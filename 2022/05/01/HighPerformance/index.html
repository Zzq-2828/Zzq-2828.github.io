<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="朱章齐的个人技术网站" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>High Performance Computer Architecture |  Keep Making Progress</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="Keep Making Progress" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-HighPerformance"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  High Performance Computer Architecture
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/05/01/HighPerformance/" class="article-date">
  <time datetime="2022-05-01T10:27:32.000Z" itemprop="datePublished">2022-05-01</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/HKU/">HKU</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">7k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">33 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <p>Hong Kong University 2022 summer semester class review —— ELEC6036 High Performance Computer Architecture.</p>
<span id="more"></span>

<h3 id="Pipelining"><a href="#Pipelining" class="headerlink" title="Pipelining"></a>Pipelining</h3><h4 id="Pipelining-Lessons"><a href="#Pipelining-Lessons" class="headerlink" title="Pipelining Lessons"></a>Pipelining Lessons</h4><ul>
<li><p>Pipelining is an implementation technique whereby <strong>multiple instructions are</strong> <strong>overlapped in execution</strong>.</p>
</li>
<li><p>Pipelining is the key implementation technique that is currently used to make high</p>
<p>performance CPUs.</p>
</li>
<li><p>Pipelining <u>doesn’t help to lower the <strong>latency</strong> of single task,</u> it helps to increase the <strong>throughput</strong>(overall system performance) of entire workload.</p>
</li>
<li><p>Pipeline rate limited by <strong>slowest</strong> (longest) pipeline stage.</p>
</li>
<li><p>The principle: <strong>Multiple</strong> tasks operating simultaneously using different resources.</p>
</li>
<li><p>Potential speedup &#x3D; <strong>Number pipe stages</strong></p>
</li>
<li><p><strong>Unbalanced</strong> lengths of pipe stages reduces speedup: that is, the key is every stage should have <strong>the same duration</strong>.</p>
</li>
<li><p>Time to “<strong>fill</strong>“ pipeline and time to “<strong>drain</strong>“ it reduces speedup.</p>
</li>
<li><p>Stall for Dependences. (stall &#x3D; delay, i.e we will have delay in the pipelined computer whenever there is contro&#x2F;data dependences between the instructions)</p>
</li>
</ul>
<h4 id="The-Five-Stages-of-Load"><a href="#The-Five-Stages-of-Load" class="headerlink" title="The Five Stages of Load"></a>The Five Stages of Load</h4><img src="https://pic.imgdb.cn/item/626e714f239250f7c5ad139b.jpg" style="zoom:80%;" />

<ul>
<li><strong>Ifetch</strong>: Instruction Fetch, fetch the instruction <u>from the instruction memory</u>.</li>
<li><strong>Reg&#x2F;Dec</strong>: Registers Fetch and Instruction Decode <u>from register file’s Read ports</u></li>
<li><strong>Exec</strong>: Calculate the memory address <u>from ALU</u></li>
<li><strong>Mem</strong>: Read the data <u>from the Data Memory</u></li>
<li><strong>Wr</strong>: Write the data back to the register file <u>from register file’s Write port</u></li>
</ul>
<img src="https://pic.imgdb.cn/item/626e756b239250f7c5b713f8.jpg" style="zoom:80%;" />

<p>As the instruction execution cycle uses different hardware components for different steps, it is possible to set up a <strong>pipeline</strong>.</p>
<p><img src="https://pic.imgdb.cn/item/626e77d2239250f7c5bce44c.jpg"></p>
<p>Suppose each stage takes 1 nsec(nano-second). Then each instruction still takes 5 nsec. But once the pipeline has been filled, a complete instruction rolls out every 1 nsec. Thus, the <strong>speedup</strong> is 5.</p>
<h4 id="Pipelining-in-the-CPU"><a href="#Pipelining-in-the-CPU" class="headerlink" title="Pipelining in the CPU"></a>Pipelining in the CPU</h4><p>(instruction-level parallelism)</p>
<ul>
<li>Pipelining is an implementation technique that exploits <strong>parallelism</strong> among instructions in a sequential instruction stream.</li>
<li>A major advantage of pipelining over “<strong>parallel processing</strong>” is that <strong>it is not visible to the programmer</strong> (whereas in parallel processing, the program usually needs to specify what kinds of tasks to be executed in parallel).</li>
<li>In a computer system, each pipeline stage completes a part of the instruction being executed. </li>
<li>The time required between <u>moving an instruction one step down the pipeline is a machine cycle</u> (<strong>the clock cycle</strong>). The length of a machine cycle is determined by the time required for <u>the slowest stage to proceed</u>.</li>
<li>The computer engineer should try to balance the length of each pipeline stage so as to achieve the ideal speedup. In practice, however, the pipeline stages will not be perfectly the same, and there are additional <strong>overheads</strong>. But we can get close to the <strong>ideal case</strong> (i.e. CPI &#x3D; 1, Cycle Per Instruction).</li>
</ul>
<p><strong>Design Issues</strong></p>
<ul>
<li>We have to make sure that <u>the same resource (e.g., ALU) is not used in more than one pipeline stage</u>.</li>
<li>If the resources used in the same pipelining stage are different, then <strong>overlapping</strong> is possible.</li>
<li>However, we must note that to retain the <strong>intermediate values</strong> produced by an individual instruction for all its pipeline stages, we must include <strong>temporary registers</strong> between the pipeline stages.</li>
</ul>
<img src="https://pic.imgdb.cn/item/626e8d05239250f7c5f37bbf.jpg" style="zoom: 67%;" />

<p>($1, $2 or $3 - represent Register #1, #2 and #3)</p>
<ul>
<li>Pipelining increases the processor <strong>instruction throughput</strong> — the <u>number of instructions completed per unit time</u>.</li>
<li>Remember: pipelining does not reduce the execution time of a single instruction.</li>
<li>The increase in instruction throughput means that <u>the program runs faster</u>, even though no single instruction runs faster.</li>
<li>Imbalance among the pipeline stages reduces performance since the <strong>clock</strong> cannot run faster than the time needed for the slowest pipeline stage.</li>
<li>Pipelining overhead can arise from the combination of <strong>pipeline register delay</strong> (propagation delay of the register to transfer the values between the pipeline stages) and other factors.</li>
</ul>
<h4 id="Graphically-Representing-Pipelines"><a href="#Graphically-Representing-Pipelines" class="headerlink" title="Graphically Representing Pipelines"></a>Graphically Representing Pipelines</h4><p><strong>Conventional Pipelined Execution Representation</strong></p>
<img src="https://pic.imgdb.cn/item/626e8f04239250f7c5fa5f47.jpg" style="zoom:80%;" />

<p><strong>Single Cycle, Multiple Cycle, vs. Pipeline</strong></p>
<img src="https://pic.imgdb.cn/item/626e8f3a239250f7c5fb2a2c.jpg" style="zoom:80%;" />

<p>Suppose we execute 100 instructions:</p>
<ul>
<li><p><strong>Single Cycle Machine</strong></p>
<p>- 45 ns&#x2F;cycle x 1 CPI x 100 instructions &#x3D; 4500ns</p>
</li>
<li><p><strong>Multi-Cycle Machine</strong></p>
<p>- 10 ns&#x2F;cycle x 4.6 CPI (due to instruction mix) x 100 instructions &#x3D; 4600ns</p>
</li>
<li><p><strong>Ideal pipelined machine</strong></p>
</li>
</ul>
<p>  - 10 ns&#x2F;cycle x (1 CPI x 100 instructions + 4 cycles drain) &#x3D; 1040ns!!</p>
<p>Ans: pipelining is much faster, i.e. in the above example, the total duration is around 1&#x2F;4 of the total time required for single-sysle machine!</p>
<p><strong>Why Pipeline? Because We Can!</strong></p>
<img src="https://pic.imgdb.cn/item/626e9041239250f7c5fecac6.jpg" style="zoom:80%;" />

<h4 id="Pipeline-Hazards"><a href="#Pipeline-Hazards" class="headerlink" title="Pipeline Hazards"></a>Pipeline Hazards</h4><h5 id="Structural-Hazards"><a href="#Structural-Hazards" class="headerlink" title="Structural Hazards:"></a><strong>Structural Hazards</strong>:</h5><p>attempt to use the same resource in two different ways (e.g., by two different instructions) at the same time.</p>
<p>- e.g., combined washer&#x2F;dryer would be a structural hazard or “folder” busy doing something else (e.g., watching TV ;-)</p>
<img src="https://pic.imgdb.cn/item/626e9224239250f7c5055a4b.jpg" style="zoom:80%;" />



<h5 id="Control-Hazards"><a href="#Control-Hazards" class="headerlink" title="Control Hazards:"></a><strong>Control Hazards</strong>:</h5><p><u>attempt to make a decision <strong>before</strong> condition is evaluated</u></p>
<p>- e.g., washing football uniforms and need to get proper detergent level; need to see after dryer before next load in</p>
<p>- <u>branch instructions</u></p>
<ul>
<li><p><strong>Control Hazard Solution #1: Stall</strong></p>
<img src="https://pic.imgdb.cn/item/626e952d239250f7c50f6c42.jpg" style="zoom:80%;" />

<p><u>Stall</u>: wait until decision is clear</p>
<p><u>Impact</u>: 2 lost cycles (i.e. 3 clock cycles per branch instruction) &#x3D;&gt; slow</p>
<p><u>Move decision to the end of decode</u>. (earlier to the decoder stage) —— save 1 cycle per branch.</p>
</li>
<li><p><strong>Control Hazard Solution #2: Predict</strong></p>
<img src="https://pic.imgdb.cn/item/626e95fa239250f7c5128041.jpg" style="zoom:80%;" />

<p><u>Predict</u>: guess one direction then back up if wrong</p>
<p><u>Impact</u>: 0 lost cycles per branch instruction if right, 1 if wrong (right - 50% of time)</p>
<ul>
<li>Need to “Squash” and restart following instruction if wrong</li>
<li>Produce CPI on branch of (1 * 0.5 + 2 * 0.5 &#x3D; 1.5) （the CPI of the branch instructions）</li>
<li>Total CPI might then be: 1.5 * 0.2 + 1 * 0.8 &#x3D; 1.1 (20% branch)</li>
</ul>
<p><u>More dynamic scheme</u>: history of 1 branch ( - 90%) , e.g. if there is 30% branch, then the total CPI &#x3D; 1.5 * 0.3 + 1 * 0.7</p>
<img src="https://pic.imgdb.cn/item/626e9b00239250f7c52578d9.jpg" style="zoom:80%;" />

<p>Delayed Branch: Redefine branch behavior (takes place after next instruction)</p>
<p>Impact: 0 clock cycles per branch instruction if can find instruction to put in “slot” ( - 50% of time)</p>
<p>As launch more instruction per clock syscle, less useful</p>
</li>
</ul>
<h5 id="Data-Hazards"><a href="#Data-Hazards" class="headerlink" title="Data Hazards:"></a><strong>Data Hazards</strong>:</h5><p>attempt to use item before it is ready ( an instruction depends on the result of a previous instruction still in the pipeline.)</p>
<p>- e.g., one sock of pair in dryer and one in washer; can’t fold until get sock from washer through dryer</p>
<p>- <u>instruction depends on result of prior instruction still in the pipeline</u></p>
<p><strong>Data Hazard on r1: Read After Write (RAW)</strong></p>
<img src="https://pic.imgdb.cn/item/626e9c70239250f7c52ae07d.jpg" style="zoom:80%;" />

<img src="https://pic.imgdb.cn/item/626ea026239250f7c539334f.jpg" style="zoom:80%;" />

<p><strong>Data Hazard Solution: Forwarding</strong></p>
<img src="https://pic.imgdb.cn/item/626e9d7c239250f7c52ea8e7.jpg" style="zoom:80%;" />

<p><strong>Forwarding (or Bypassing): What About Loads?</strong></p>
<img src="https://pic.imgdb.cn/item/626f6cdc239250f7c5971695.jpg" style="zoom:80%;" />

<img src="C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20220502133433952.png" alt="image-20220502133433952" style="zoom:80%;" />

<p><strong>Can always resolve these hazards by waiting(pipeline stall)</strong></p>
<p>- pipeline control must detect the hazard</p>
<p>- take action (or delay action) to resolve hazards</p>
<img src="https://pic.imgdb.cn/item/62790e490947543129ab86b8.jpg" style="zoom:80%;" />



<h4 id="Summary-of-Concepts"><a href="#Summary-of-Concepts" class="headerlink" title="Summary of Concepts"></a>Summary of Concepts</h4><ul>
<li>Reduce CPI by overlapping many instructions<ul>
<li>average throughput of approximately 1 CPI with fast clock</li>
</ul>
</li>
<li>Utilize capabilities of the datapath<ul>
<li>start next instruction while working on the current one</li>
<li>limited by length of longest stage (plus fill&#x2F;flush)</li>
<li>detect and resolve hazards</li>
</ul>
</li>
<li>What makes it easy</li>
<li><u>all instructions are of the same length</u> (very import for the pipeline design)</li>
<li>just a few instruction formats</li>
<li>memory operands appear only in loads(LW) and store(SW)</li>
<li>What makes it hard?<ul>
<li>structural hazards: suppose we had only one memory</li>
<li>control hazards: need to worry about branch instructions</li>
<li>data hazards: an instruction depends on a previous instruction (whenever two instructions have data dependence, there will be data hazards)</li>
</ul>
</li>
</ul>
<h4 id="Issues-in-Pipelined-Design"><a href="#Issues-in-Pipelined-Design" class="headerlink" title="Issues in Pipelined Design"></a>Issues in Pipelined Design</h4><img src="https://pic.imgdb.cn/item/626f7439239250f7c5a839d6.jpg" style="zoom:80%;" />

<h3 id="High-Performance-Techniques"><a href="#High-Performance-Techniques" class="headerlink" title="High Performance Techniques"></a>High Performance Techniques</h3><ul>
<li>How to Optimize the Pipeline? Extract More Parallelism! (<strong>multiple execution-stage PL</strong> computers e.g. ADD - EX1 and EX2, etc)</li>
<li><strong>Compiler-Directed (Static)</strong> Approaches<ul>
<li>VLIW (Very Long Instruction Word)</li>
<li>EPIC (Explicit Parallel Instruction Computer)</li>
<li>Superscalar</li>
<li>Software Pipelining</li>
</ul>
</li>
<li>A Dynamic Approach—Scoreboard</li>
</ul>
<p><strong>Pipelining: Can we somehow make CPI closer to 1?</strong></p>
<ul>
<li><p>Let’s assume FP ( full pipelining):</p>
</li>
<li><p>If we have a 4-cycle instruction (an instruction requiring 4 execution cycles), then we need 3 instructions between a producing instruction and its use:</p>
<img src="https://pic.imgdb.cn/item/626fb289239250f7c53ab10f.jpg" style="zoom:80%;" />
</li>
<li><p>Getting CPI &lt;1 : Processing Multiple Instructions&#x2F;Cycles</p>
<ul>
<li>Use parallel processing!!</li>
<li>Two main variations: superscalar and VLIW</li>
<li>Superscalar: varying number of instructions&#x2F;cycle (1 to 6)<ul>
<li>parallelism and dependencies determined&#x2F;resolved by HW(hardware)</li>
<li>IBM PowerPC 604, Sun UltraSPARC, DEC Alpha 21164, HP 7100</li>
</ul>
</li>
<li>Very Long Instruction Words (VLIW): fixed number of instructions (16) determined by compiler<ul>
<li>pipeline is exposed; compiler must schedule delays to get right results</li>
</ul>
</li>
<li>Explicit Parallel Instruction Computer (EPIC)&#x2F;Intel<ul>
<li>128 bit packets containing 3 instructions (can execute sequentially)</li>
<li>can link 128 bit packets together to allow more parallelism</li>
<li><strong>compiler determines parallelism</strong>, HW checks dependencies and <strong>forwards&#x2F;stalls</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>Parallelism: Overt vs. Covert</p>
<img src="https://pic.imgdb.cn/item/626fc41e239250f7c56323bd.jpg" style="zoom:80%;" />

<img src="https://pic.imgdb.cn/item/626fc453239250f7c563973e.jpg" style="zoom:80%;" /></li>
</ul>
<h4 id="Compliation-and-ISA-Instruction-Set-Architecture"><a href="#Compliation-and-ISA-Instruction-Set-Architecture" class="headerlink" title="Compliation and ISA (Instruction Set Architecture)"></a>Compliation and ISA (Instruction Set Architecture)</h4><ul>
<li><p>Efficient compilation requires knowledge of the pipeline structure</p>
<ul>
<li><strong>latency</strong> and <strong>bandwidth</strong> of each operation type</li>
</ul>
</li>
<li><p>But a good ISA transcends several implementations with different pipelines</p>
<ul>
<li>should things like a delayed branch be in an ISA?</li>
<li>should a compiler use the properties of one implementation when compiling for an ISA?</li>
<li>do we need a new interface?</li>
</ul>
<img src="https://pic.imgdb.cn/item/626fca4d239250f7c571fcca.jpg" style="zoom:80%;" /></li>
</ul>
<h4 id="Very-Long-Instruction-Word-VLIW-Computers"><a href="#Very-Long-Instruction-Word-VLIW-Computers" class="headerlink" title="Very Long Instruction Word (VLIW) Computers"></a>Very Long Instruction Word (VLIW) Computers</h4><img src="https://pic.imgdb.cn/item/626fcd40239250f7c5794c31.jpg" style="zoom:80%;" />

<p><strong>Pros</strong>(Strength)</p>
<ul>
<li>Very simple hardware<ul>
<li>no dependency detection</li>
<li>simple issue logic</li>
<li>just ALUs and register files</li>
</ul>
</li>
<li>Potentially exploits large amounts of ILP</li>
</ul>
<p><strong>Cons</strong>(Weakness)</p>
<ul>
<li>Lockstep execution (static schedule)<ul>
<li>very sensitive to long latency operations(cache misses)</li>
</ul>
</li>
<li>Global register file hard to build</li>
<li>Lots of NO-OPs<ul>
<li>poor “code density”</li>
<li>I-cache capacity and bandwidth compromised</li>
</ul>
</li>
<li>Must recompile sources to deliver potential</li>
<li>Implementation visible through ISA</li>
</ul>
<h4 id="EPIC-Explicit-Parallel-Instruction-Computer"><a href="#EPIC-Explicit-Parallel-Instruction-Computer" class="headerlink" title="EPIC: Explicit Parallel Instruction Computer"></a>EPIC: Explicit Parallel Instruction Computer</h4><p><strong>128-bit instructions</strong>:</p>
<ul>
<li><p>three 3-address operations</p>
</li>
<li><p>a template that encodes dependencies</p>
</li>
<li><p>128 general registers</p>
</li>
<li><p>predication (branch prediction)</p>
</li>
<li><p>speculative load (load prediction)</p>
</li>
<li><p>Example: IA-64 of Intel&#x2F;HP</p>
<img src="C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20220502204711061.png" alt="image-20220502204711061" style="zoom:80%;" /></li>
</ul>
<h4 id="Superscalar"><a href="#Superscalar" class="headerlink" title="Superscalar"></a>Superscalar</h4><p>Superscalar DLX: 2 instructions, 1 FP &amp; 1 anything else (int &#x2F; LW &#x2F; SW)</p>
<ul>
<li><p>fetch 64 bits&#x2F;clock cycle; integer on left, FP on right</p>
</li>
<li><p>can only issue 2nd instruction if 1st instruction issues</p>
</li>
<li><p>more ports for FP registers to do FP load &amp; FP op in a pair</p>
<img src="https://pic.imgdb.cn/item/626fd33f239250f7c588b92f.jpg" style="zoom: 67%;" />
</li>
<li><p>1 cycle load delay expands to 3 instructions in SS (super-scalar)</p>
<ul>
<li>instruction in right half can’t use it, nor instructions in next slot</li>
</ul>
</li>
</ul>
<p>Limits of Superscalar:</p>
<ul>
<li><p>While integer&#x2F;FP split is simple for the HW, get CPI of 0.5 only for programs with:</p>
<ul>
<li>exactly 50% FP operations</li>
<li>no hazards</li>
</ul>
</li>
<li><p>If more instructions issue at same time, greater difficulty of decode and issue</p>
<ul>
<li><p>even 2-scalar &#x3D;&gt; examine 2 opcodes, 6 register specifiers, &amp; decide if 1 or 2 instructions</p>
<p>can issue</p>
</li>
</ul>
</li>
<li><p>VLIW: tradeoff instruction space for simple decoding</p>
<ul>
<li>the long instruction word has room for many operations</li>
<li>by definition, all the operations the compiler puts in the long instruction word can execut in parallel</li>
<li>e.g., 2 integer operations, 2 FP ops, 2 memory references, 1 branch; 16 to 24 bits for each of these fields &#x3D;&#x3D;&gt; 7 x 16 or 112 bits to 7 x 24 or 168 bits wide</li>
<li>need compiling technique that schedules across several branches</li>
</ul>
</li>
</ul>
<h4 id="Software-Pipelining"><a href="#Software-Pipelining" class="headerlink" title="Software Pipelining"></a>Software Pipelining</h4><ul>
<li><p>Observation: if iterations from loops are independent, then can get more ILP (instruction level parallelism) by taking instructions from different iterations</p>
</li>
<li><p>Software pipelining: reorganizes loops so that each iteration is made from instructions chosen from different iterations of the original loop (i.e., Tomasulo algorithms in SW)</p>
<img src="https://pic.imgdb.cn/item/626fd999239250f7c599aa88.jpg" style="zoom: 67%;" /></li>
</ul>
<p><strong>Example:</strong></p>
<img src="https://pic.imgdb.cn/item/626fd9f5239250f7c59aa218.jpg" style="zoom:80%;" />

<h4 id="Multiple-Issue-as-compared-with-VLIW"><a href="#Multiple-Issue-as-compared-with-VLIW" class="headerlink" title="Multiple Issue as compared with VLIW"></a>Multiple Issue as compared with VLIW</h4><p><strong>Multiple Issue:</strong></p>
<ul>
<li>more complex issue logic<ul>
<li>check dependencies</li>
<li>check structural hazards</li>
<li>issue variable number of instructions (0-N)</li>
<li>shift unissued instructions over</li>
</ul>
</li>
<li>Able to run existing binaries<ul>
<li>recompile for performance, not correctness</li>
</ul>
</li>
<li>Data paths identical<ul>
<li>but bypass requires detection</li>
</ul>
</li>
<li>Neither VLIW or multiple-issue can schedule around run-time variation in instruction latency<ul>
<li>cache misses</li>
</ul>
</li>
<li>Dealing with run-time variation requires run-time or dynamic scheduling</li>
</ul>
<h4 id="The-problem-with-Static-Scheduling-Compile-Time"><a href="#The-problem-with-Static-Scheduling-Compile-Time" class="headerlink" title="The problem with Static Scheduling (Compile-Time)"></a>The problem with Static Scheduling (Compile-Time)</h4><p><strong>In-Order Execution</strong>:</p>
<ul>
<li>an unexpected long latency blocks <u>ready instructions</u> from executing (scheduled code cannot be changed at run-time)</li>
<li>binaries need to be <u>rescheduled (recompiled)</u> for each new processor implementation</li>
<li>small number of named registers becomes a bottleneck.</li>
</ul>
<p><strong>动态调度：</strong></p>
<ul>
<li><p>通过硬件在程序执行时重新安排代码的执行序列来减少竞争引起的流水线停顿时间</p>
</li>
<li><p>动态调度流水线具备以下功能：</p>
<ul>
<li>允许按序取多条指令和发射多条指令—-取指(IF)流水级允许按顺序取多条指令进入单口暂存器(single-entry latch)或队列(queue), 指令然后从latch或queue取出，进入ID节拍。</li>
<li>能检查并消除hazards—-将ID流水级分为独立的两级：Issue（ID1）级和Read operand（ID2）级：<ul>
<li>Issue级功能 —-指令译码，检查是否存在结构竞争(即在这一流水级解决结构竞争问题）；</li>
<li>Read operands级功能 —-等到无数据竞争(RAW)后，读出操作数，即在这一流水级解决数据竞争问题</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Scoreboard-a-bookkeeping-technique"><a href="#Scoreboard-a-bookkeeping-technique" class="headerlink" title="Scoreboard: a bookkeeping technique"></a>Scoreboard: a bookkeeping technique</h3><ul>
<li>Out-of-order execution divides <strong>ID stage</strong>:<ul>
<li><strong>Issue</strong>——decode instructions, check for <strong>structural hazards</strong></li>
<li><strong>Read operands</strong>——<strong>wait until no data hazards</strong>, then read operands</li>
</ul>
</li>
<li>Scoreboards date to CDC6600 designed in 1963</li>
<li>Instructions execute whenever not dependent on previous instructions and no hazards</li>
<li>CDC6600: <strong>in-order issue, out-of-order execution, out-of-order commit</strong> (or completion) (out-of-order or dynamic order&#x2F;scheduling, means that it DOES NOT have to follow the original order of the program code)<ul>
<li>no forwarding</li>
<li>imprecise interrupt&#x2F;exception model for now</li>
</ul>
</li>
</ul>
<h4 id="Scoreboard-Implications"><a href="#Scoreboard-Implications" class="headerlink" title="Scoreboard Implications"></a>Scoreboard Implications</h4><p><strong>算法设计</strong></p>
<ul>
<li>动态调度技术需要将ID译码段分成两个阶段：1是发射，2是读取操作数。<ul>
<li>发射阶段对指令进行译码，检查<strong>结构冒险</strong>（例如有四个运算器：整数运算、加法器、乘法器、除法器，检查该指令需要使用的运算器是否正在被占用）读取操作数阶段检查数据冒险（读之前检查寄存器的值是否已经写回，或者是否会覆盖了之前的值）。</li>
<li><strong>数据冒险</strong>的解决方法：<ul>
<li>读写冒险(RAW)：将指令和操作数保存起来，然后只能在读操作数阶段进行读取；</li>
<li>写写冒险(WAW)：检测是否有其它指令会写回到相同的寄存器（检测到冒险），有则等待，直到其它的完成</li>
</ul>
</li>
<li>发射阶段：假如检测到没有结构冒险和数据冒险，那么记分板将会将指令发射到相关的运算器，假如结构冒险或者写写冒险发生了，那么该指令将会等待，直到冒险消失为止。</li>
<li>读取操作数：没有数据相关了以后（之前的指令不会写回源寄存器或者正在写寄存器的情况时，读写冒险），读取操作数。读取操作数后将交给运算器，之后开始运算。发送到运算器的顺序可能是乱序的。</li>
</ul>
</li>
<li>之后就是执行段以及写回段了。执行段在完成计算以后会通知记分板。记分板直到计算已经完成了，那么它进行读写冒险检验（即写之前是否已经读取了寄存器的值，例如 ADD F10,F0,F8 SUB F8,F8,F14，这里SUB指令写回时要检查ADD指令的F8是否已经读取了，仅此而已）假如检测到冒险，则等待，不然就可以写寄存器了。</li>
</ul>
<p>Out-of-order completion &#x3D;&#x3D;&gt; WAR, WAW hazards?</p>
<ul>
<li>Solutions for WAR:<ul>
<li><u>stall writeback until registers have been read</u></li>
<li>read registers only during Read Operands stage</li>
</ul>
</li>
<li>No register renaming!  (This is different from the Tomasulo’s computers to be discussed)</li>
<li>Need to have multiple instructions in execution phase &#x3D;&#x3D;&gt;multiple execution units or pipelined execution units</li>
<li>Scoreboard keeps track of dependencies between instructions that have already issued</li>
<li>Scoreboard replaces ID, EX, WB with 4 stages (ID1(Issue), ID2(Read Operand), EX, WB(or completion))</li>
</ul>
<h4 id="Four-Stages-of-Scoreboard-Control"><a href="#Four-Stages-of-Scoreboard-Control" class="headerlink" title="Four Stages of Scoreboard Control"></a>Four Stages of Scoreboard Control</h4><ul>
<li><p>Issue—decode instructions &amp; check for structural hazards (ID1)</p>
<ul>
<li>instructions issued in program order (for hazard checking)</li>
<li>don’t issue if structural hazard</li>
<li>don’t issue if instruction is output dependent on any previously issued but uncompleted instruction (no WAW hazards)</li>
</ul>
</li>
<li><p>Read operands—wait until no data hazards, then read operands (ID2)</p>
<ul>
<li>all real dependencies (RAW hazards) resolved in this stage, since we wait for instructions to write back data</li>
<li>no forwarding of data in this model</li>
</ul>
</li>
<li><p>Execution—operate on operands (EX)</p>
<ul>
<li>the functional unit begins execution upon receiving operands; when the result is ready, it notifies the scoreboard that it has completed execution</li>
<li>note that different instructions will require different number of clock cycles for the execution stage!</li>
</ul>
</li>
<li><p>Write result—finish execution (WB)</p>
<ul>
<li><strong>stall until no WAR hazards</strong> with previous instructions:</li>
</ul>
<img src="https://pic.imgdb.cn/item/626fe9da239250f7c5db2acb.jpg" style="zoom:80%;" /></li>
</ul>
<h4 id="Three-Parts-of-the-Scoreboard"><a href="#Three-Parts-of-the-Scoreboard" class="headerlink" title="Three Parts of the Scoreboard"></a>Three Parts of the Scoreboard</h4><ul>
<li><p><strong>Instruction status</strong>:</p>
<p>Which of 4 steps the instruction is in</p>
</li>
<li><p><strong>Functional unit status</strong>:</p>
<p>Indicates the state of the functional unit (FU). 9 fields <u>for each functional unit</u>:</p>
<img src="https://pic.imgdb.cn/item/626fea7f239250f7c5dcf4fc.jpg" style="zoom:80%;" />
</li>
<li><p><strong>Register result status</strong>:</p>
<p>Indicates which <u>functional unit will write each register</u>, if one exists; <u>blank</u> when no pending instructions will write that register</p>
</li>
</ul>
<p><strong>Scoreboard Example:</strong></p>
<img src="https://pic.imgdb.cn/item/626feb92239250f7c5e041c4.jpg" style="zoom:80%;" />

<h4 id="Summary-of-Concepts-1"><a href="#Summary-of-Concepts-1" class="headerlink" title="Summary of Concepts"></a>Summary of Concepts</h4><ul>
<li>Compiler scheduling</li>
<li>HW exploiting ILP<ul>
<li>works when we can’t possibly know dependencies at compile time</li>
<li>code for one machine runs well on another</li>
</ul>
</li>
<li>Key idea of scoreboard: allow instructions behind stall to proceed (decode &#x3D;&gt; issue instructions and read operands)<ul>
<li>enables out-of-order execution &#x3D;&#x3D;&gt; out-of-order completion</li>
<li>ID stage checked both for structural and data dependencies</li>
<li>original version didn’t handle forwarding</li>
<li>no automatic register renaming (Tomasulo’s computer)</li>
</ul>
</li>
</ul>
<h4 id="要点总结和补充（重点）"><a href="#要点总结和补充（重点）" class="headerlink" title="要点总结和补充（重点）"></a>要点总结和补充（重点）</h4><p>总结和补充一下记分牌工作流程中的要点：</p>
<ul>
<li>一条指令能否发射，一看是否有功能部件空闲可用，这个信息包含在功能状态中；二看指令要写的寄存器是否正要被别的指令写，这个信息包含在寄存器状态中，观察这个信息是为了解决WAW冒险。</li>
<li>一条指令能否读数，要看记分牌是否提示源寄存器不可读，如果不可读，就说明该寄存器将要被别的前序指令改写，现在的指令要等待前序指令写回，观察这个信息是为了解决RAW冒险。</li>
<li>一条指令一旦读数完成，就必然可以进行运算，运算可以是多周期的，在第一个周期结束时应该改写功能状态，表明自己不再需要读寄存器。</li>
<li>一条指令能否写回，要看是否有指令需要读即将被改写的这个寄存器，具体一点来说，就是要观察标记Yes的Rj、Rk对应的寄存器里是否有当前指令的目的寄存器，如果有，就说明有指令需要读取寄存器的旧值，这样一来我们就要等指令读完旧值之后再写回，观察这个信息是为了解决WAR冒险。</li>
</ul>
<h3 id="Tomasulo-Algorithm"><a href="#Tomasulo-Algorithm" class="headerlink" title="Tomasulo Algorithm"></a>Tomasulo Algorithm</h3><p>Improved Dynamic Instruction Scheduling: Tomasulo Algorithm</p>
<p>由于<strong>记分牌算法只能检测竞争(WAR,WAW)并不能消除这两种竞争</strong>，所以将记分牌算法改进为Tomasulo算法。</p>
<p>Tomasulo算法的基本思想：</p>
<ul>
<li>Tomasulo算法采用寄存器重命名（Renaming）方法，将记分牌中的寄存器用一大组虚拟寄存器名来代替，即用虚拟寄存器集来代替真实的FP寄存器组，由于虚拟寄存器集合所含有的寄存器数目远大于真是的寄存器组，所以可以用虚拟寄存器集来实现寄存器重命名。</li>
<li>虚拟寄存器组由三部分组成：<ul>
<li>每个功能单元（FU）都带有的保留站（Reservation station）</li>
<li>取数缓冲区（Load buffers）—-保存被访问的存储单元的数据和地址</li>
<li>存数缓冲区（Store buffers）</li>
</ul>
</li>
</ul>
<h4 id="Recall-Compiler-Techniques-for-Parallelism"><a href="#Recall-Compiler-Techniques-for-Parallelism" class="headerlink" title="Recall: Compiler Techniques for Parallelism"></a>Recall: Compiler Techniques for Parallelism</h4><ul>
<li><strong>Loop unrolling</strong> &#x3D;&gt; multiple iterations of loop in software:<ul>
<li>amortizes loop overhead over several iterations</li>
<li>gives more opportunity for scheduling around stalls</li>
</ul>
</li>
<li><strong>Software Pipelining</strong> &#x3D;&gt; take one instruction from each of several iterations of the loop<ul>
<li>software overlapping of loop iterations</li>
</ul>
</li>
<li><strong>Very Long Instruction Word machines</strong> (VLIW) &#x3D;&gt;multiple operations coded in single, long instruction<ul>
<li>requires sophisticated compiler to decide which operations can be done in parallel</li>
<li>trace scheduling &#x3D;&gt; find common path and schedule code as if branches didn’t exist (add “fixup code”)</li>
</ul>
</li>
<li><u>ALL OF THE ABOVE require additional registers</u>!</li>
</ul>
<h4 id="Recall-How-are-WAR-and-WAW-hazard-handled-in-scoreboard"><a href="#Recall-How-are-WAR-and-WAW-hazard-handled-in-scoreboard" class="headerlink" title="Recall: How are WAR and WAW hazard handled in scoreboard?"></a>Recall: How are WAR and WAW hazard handled in scoreboard?</h4><ul>
<li><p><strong>WAR</strong> hazards handled by <u>stalling in WriteBack stage</u></p>
</li>
<li><p><strong>WAW</strong> hazards handled by <u>stalling in Issue stage</u></p>
</li>
<li><p>Are either of these <em>real</em> hazards???</p>
<img src="https://pic.imgdb.cn/item/627011fc239250f7c546a61c.jpg" style="zoom:80%;" /></li>
</ul>
<h4 id="Tomasulo-Algorithm-vs-Scoreboard"><a href="#Tomasulo-Algorithm-vs-Scoreboard" class="headerlink" title="Tomasulo Algorithm vs. Scoreboard"></a>Tomasulo Algorithm vs. Scoreboard</h4><ul>
<li>Control and buffers <u>distributed</u> with Function Units (FU) vs. <u>centralized</u> in scoreboard:<ul>
<li>FU buffers called “<u>reservation stations</u>“(A Buffer to a specific FU), have pending operands</li>
</ul>
</li>
<li>Registers in instructions replaced by values or pointers to reservation stations(RS); called <strong>Register Renaming</strong>. (i.e. pointing to a specific RS to wait for its register result)<ul>
<li><u>avoids WAR, WAW hazards</u></li>
<li><u>more reservation stations than registers</u>, so can do optimizations that compilers can’t do</li>
</ul>
</li>
<li>Results to FU <u>from RS</u>, not through registers, over <strong>Common Data Bus</strong> that broadcasts results to all FUs.</li>
<li>Load and Store treated as FUs with RSs as well</li>
<li>Integer instructions can go past branches, allowing FP ops beyond basic block in FP queue.</li>
</ul>
<img src="https://pic.imgdb.cn/item/6270bfa2239250f7c55636f2.jpg" style="zoom:80%;" />

<h4 id="Organization"><a href="#Organization" class="headerlink" title="Organization"></a>Organization</h4><img src="https://pic.imgdb.cn/item/6270b8af239250f7c5461af3.jpg" style="zoom:80%;" />

<ul>
<li>浮点寄存器（FP）通过一对总线与每一个功能单元（FU）相连接，这一对总线分别对应两个操作数，并通过一条总线与存数缓冲区（Load buffer）相连接。这里是浮点指令队列，指令在这里等待发射；</li>
<li>功能单元（FU）的输出和存数缓冲区（Load Buffer）的输出汇总在CDB与浮点寄存器（FP）的输入相连接。在这个算法中存储指令在执行前会先计算好存储地址；</li>
<li>公共数据总线（Common data bus）CDB：CDB与FP，Reservation station，store buffer等输入相连接，唯一无连接关系的是Load Buffer的输入。它可以直达寄存器堆（用来更新通用寄存器）、加法乘法存储单元的保留站（输送保留站中指令需要的数据）</li>
<li>由于保留站和Buffer都有对应的标识符，所以这里实现了重命名。保留站保留已经发射的指令的信息和缓冲下来的数据，指令一旦离开保留站就意味着指令开始执行</li>
</ul>
<h4 id="RS-Components"><a href="#RS-Components" class="headerlink" title="RS Components"></a>RS Components</h4><ul>
<li>Op: operation to perform in the unit(e.g., add or sub)</li>
<li>Vj, Vk, Value of source operands<ul>
<li>store buffers has V field, result to be stored</li>
</ul>
</li>
<li>Qj, Qk: reservation stations producing source registers (value to be written)<ul>
<li>note: no ready flags as in scoreboard; Qj, Qk &#x3D; 0 &#x3D;&#x3D;&gt; ready</li>
<li>store buffers only have Qi for RS producing result</li>
</ul>
</li>
<li>Busy: indicates reservation station or FU is busy</li>
<li>Register result status — indicates which functional unit will write each register, if one exists; blank when no pending instructions that will write that register.</li>
</ul>
<img src="https://pic.imgdb.cn/item/6277e6510947543129bf7d99.jpg" style="zoom:80%;" />

<ul>
<li><p>保留站的结构有点像cache，可能有多行数据，每一行都对应一条被发射到保留站的指令。</p>
<ul>
<li>保留站每一行都有Busy位，指示这一行是否现存有指令；</li>
<li>Vj和Vk与记分牌不同，记分牌的Vj和Vk会记录源寄存器的编号，<strong>而保留站则直接把能读取的数据直接拷贝到保留站中</strong>，可想而知，一旦数据进入保留站，那对应的寄存器就和这条指令没瓜葛了；</li>
<li>Qj和Qk的信息和记分牌一样，记录尚不能读取的数据将由哪条指令算出；</li>
<li>A是存储指令的地址，用于存放立即数和计算得到的地址数据。</li>
</ul>
</li>
<li><p>看上去保留站和记分牌非常相似，但是两者其实有很大的不同。</p>
<ul>
<li>以Add为例，保留站中有三行Add信息，这三行数据对应的是同一个加法单元，而在记分牌中这代表着三个加法单元。</li>
<li>记分牌那样的一条通路只对应一条信息的做法容易造成指令堵塞、无法发射，<strong>而保留站则为每条通路预留了缓冲区，指令可以在加法单元忙碌的时候发射到保留站的缓冲区待命</strong>。</li>
</ul>
</li>
<li><p>其次，保留站会直接把读取的数据缓冲下来，而不像记分牌一样只记录一个寄存器编号，只记录编号的话会造成读后写阻塞，因为一条指令在正式执行前一直在监控着它的源寄存器，源寄存器的值是不能改变的，因此后续指令无法写回，只能阻塞流水，<strong>而保留站则贯彻了“数据一旦准备完毕，就立马执行指令”的思想</strong>，指令一旦发现有数据可读，就立马读下来，读下来之后，那个源寄存器的写与不写就不关己事了。</p>
</li>
<li><p>记分牌和保留站相同的地方是都记录了Qj和Qk，即一旦需要的数据被算出来，就通过Qj和Qk捕捉广播数据，<strong>这样的做法其实就是重命名，即用保留站的编号而不是寄存器编号来标记数据源</strong>。</p>
</li>
</ul>
<img src="https://pic.imgdb.cn/item/6277e7030947543129c268cd.jpg" style="zoom:80%;" />

<ul>
<li>除了保留站数据结构之外，Tomasulo同样要记录寄存器结果状态，记录信息和记分牌一样，Tomasulo也会记录寄存器将被哪条指令更新，这个信息在指令寻找源数据时被使用。</li>
</ul>
<h4 id="Three-Stages"><a href="#Three-Stages" class="headerlink" title="Three Stages"></a>Three Stages</h4><ul>
<li>发射级（Issue）<ul>
<li>若是一条FP操作指令，如果<strong>保留站有空</strong>（判断能否发射的唯一标准），则将其送至保留站，如果该指令的操作数已在FP寄存器，将操作数的值送往保留站。</li>
<li>若是一条Load或者Store指令，如果Buffer有空，将其送往相应的Buffer</li>
<li>如果保留站或者Buffer没有空，则存在结构竞争，停顿该指令，直到对应的保留站或者Buffer有空为止。</li>
<li>这一级完成了重命名，因为在保留站中的操作数不再使用寄存器号。</li>
</ul>
</li>
<li>执行级（Execute）<ul>
<li>若有一个或几个操作数未就绪，等待该操作数，并同时监控CDB。一旦操作数就绪，立即存入相应的保留站，若两个操作数均已就绪，则执行该操作，此级检查了是否存在RAW竞争。</li>
</ul>
</li>
<li>写回级（Write Back）<ul>
<li>当结果计算出来之后，将其写入CDB，并从CDB写入目的寄存器以及等待此结果的保留站，当连续写同一寄存器时，只有最后一次才能写入，消除了WAW竞争。</li>
</ul>
</li>
</ul>
<p><strong>1. Issue</strong>:</p>
<ul>
<li>Get instruction from FP Op Queue<ul>
<li>if reservation station free (no structural hazard), control issues instructions and sends operands (renames registers);</li>
</ul>
</li>
</ul>
<p><strong>2. Execution</strong>:</p>
<ul>
<li>Operate on operands (EX)<ul>
<li>when both operands ready then execute; if not ready, watch Common Data Bus for result</li>
</ul>
</li>
</ul>
<p><strong>3. Write Result</strong>:</p>
<ul>
<li>Finish execution (WB)<ul>
<li>write on Common Data Bus to all awaiting units(all the FU that are waiting for its broadcasted result); mark reservation station available</li>
</ul>
</li>
</ul>
<p><strong>Remarks</strong>:</p>
<ul>
<li>Normal data bus: data + destination (“go to” bus) (i.e. destination-oriented data bus in the conventional computers)</li>
<li>Common Data Bus: data + source (“come from” bus) (i.e. a NEW source-oriented data bus trying to broadcast result FROM a specific FU as the data source)<ul>
<li>64 bits of data + 4 bits of Functional Unit source address</li>
<li>write if matches expected Functional Unit (produces result); does the broadcast</li>
</ul>
</li>
</ul>
<h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><p><strong>Tomasulo Example Cycle 57</strong></p>
<img src="https://pic.imgdb.cn/item/6270bf24239250f7c5551ddc.jpg" style="zoom:80%;" />

<p><strong>Compare to Scoreboard Cycle 62</strong></p>
<img src="https://pic.imgdb.cn/item/6270bffa239250f7c55700ed.jpg" style="zoom:80%;" />



<p><strong>Tomuasulo调度流程中的要点</strong>：</p>
<ul>
<li>一条指令能否发射，要看对应配置通路的保留站是否有空余，<strong>只要有空余，就可以发射到保留站中等待执行；发射的同时会被能读取的数据直接拷贝到保留站</strong>，这样做就不用考虑读后写冒险，后续的指令只要完成就可以写回，不用顾虑是否会有前序指令需要读取寄存器，换句话说，每一条被发射到保留站中的指令都不再需要读取寄存器堆。</li>
<li>指令在发射的时候会更新寄存器状态表，如果后序指令和前序指令的目的寄存器重合了，就用后序指令的写信息标志寄存器，<strong>表示只会把后序指令的计算结果写进寄存器</strong>，这样可以解决写后写冒险；</li>
<li>如果执行单元中有指令正在执行，其他指令就在保留站中等待；<strong>如果指令缺少源数据，就留在保留站中，时刻监听CDB总线</strong>，如果CDB总线广播了需要的数据，就立马拷贝下来，然后准备执行。</li>
<li>一条指令在源数据全部准备好之后就可以执行，执行可能是多周期的。</li>
<li>一条指令只要完成计算，就可以写回，<strong>写回的数据通过CDB总线直通寄存器堆和各个保留站</strong>。<strong>但是要注意的一点是指令的结果未必会写进寄存器堆</strong>，因为寄存器结果状态表中总是存有最新的状态，即如果发生写后写冒险，Tomasulo算法会记录下最新的写指令，而抛弃前序的写指令结果，前序写指令的结果不会写回到寄存器堆，这样的做法很符合数据流思维。</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>Tomasulo成功地解决了三种冒险，实现了指令的乱序执行，<strong>且性能比记分牌更好，具体优化的地方有三</strong>：</p>
<ul>
<li>记分牌每条通路只能存一条指令，导致经常有指令因为结构冒险而不能发射，<strong>而Tomasulo引入保留站之后每条通路可以缓冲下多条指令，这样的做法平缓了指令发射的速度</strong>；</li>
<li>写后写冒险时，记分牌过度纠结寄存器名字，会把所有指令的结果都写进寄存器堆，会因为写后写冒险阻塞指令发射，而Tomasulo只保存最新的写入值，这样即保证了正确的结果，又减少了无谓的工作；</li>
<li>读后写冒险时，记分牌过度纠结寄存器名字，指令在执行之前一直检测的是寄存器堆，一旦数据准备好，就会从寄存器堆中取数，这样的后果就是后序指令即使计算完结果也可能不能立刻写回寄存器堆，而Tomasulo则在发射时就拷贝数据，贯彻数据流的思想——“<strong>寄存器名字不重要，寄存器里的数据才重要</strong>”。</li>
</ul>
<p>在写后读冒险中两者都用CDB总线实现了逻辑上的正确，都解决了写后读冒险。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>但是Tomasulo也不是完美的，它也存在一些问题，图7的PPT显示了Tomasulo算法的一系列问题。</p>
<p>Tomasulo算法中每一个执行单元对应一个保留站，保留站中缓冲多条指令，所以有可能在同一周期有多条指令准备好数据，但是执行单元同时只能执行一条指令，所以就需要从中选择一条指令，简单的解决办法是为保留站的每一行增加一个年龄位，每次出现冲突，就选择最老的指令送到执行单元。</p>
<p>在前文的举例中，电路里的CDB总线只有一组，<strong>这意味着每一个周期只能写回一条指令</strong>，如果同时有多条指令完成，那就只能选择一条指令进行广播，别的指令等待；第二种办法是增加CDB总线，支持多指令广播，但是这会让电路面积大增，包括增加寄存器堆写口、增加保留站tag和CDB总线的比较电路、增加保留站写口。</p>
<h4 id="Drawbacks"><a href="#Drawbacks" class="headerlink" title="Drawbacks"></a>Drawbacks</h4><ul>
<li>Complexity<ul>
<li>delays of 360&#x2F;91, MIPS 10000, IBM 620?</li>
</ul>
</li>
<li>Many associative stores(CDB) at high speed</li>
<li>Performance limited by Common Data Bus<ul>
<li>multiple CDBs &#x3D;&#x3D;&gt; more FU logic for parallel associative stores</li>
</ul>
</li>
</ul>
<h4 id="Why-issue-in-order"><a href="#Why-issue-in-order" class="headerlink" title="Why issue in-order?"></a>Why issue in-order?</h4><ul>
<li>In-order issue permits us to analyze dataflow of program</li>
<li>This way , we know exactly which results should flow to which subsequent instructions<ul>
<li>if we issued out-of-order, we <strong>would confuse RAW and WAR hazards</strong></li>
<li>the most advanced machines ALL issue in-order ;-)</li>
</ul>
</li>
<li>This idea works perfectly well “in principle” with multiple instructions issued per clock:<ul>
<li>need to multi-port “rename table” and be able to re name a sequence of instructions together</li>
<li>need to be able to issue to multiple reservation stations in a single cycle</li>
<li>need to have 2x number of read ports and 1x number of write ports in register file</li>
</ul>
</li>
<li>In-order issue can be serious bottleneck when issuing multiple instructions per clock-cycle</li>
</ul>
<h3 id="The-5-tips-to-develop-an-effective-cloud-architecture-application"><a href="#The-5-tips-to-develop-an-effective-cloud-architecture-application" class="headerlink" title="The 5 tips to develop an effective cloud architecture application"></a>The 5 tips to develop an effective cloud architecture application</h3><ul>
<li>Ensure that your application is scalable by designing each component to be scalable on its own. If every component implements a service interface, responsible for its own scalability in all appropriate dimensions, the overall system will have a scalable base. </li>
<li>For better manageability and high-availability, make sure that your components are loosely coupled. The key is to build components without having tight dependencies between each other, so that if one component were to die (fail), sleep (not respond) or remain busy (slow to respond) for some reason, the other components in the system are built so as to continue to work as if no failure is happening.</li>
<li>Implement parallelization for better use of the infrastructure and for performance. Distributing the tasks on multiple machines, multithreading your requests and effective aggregation of results obtained in parallel are some of the techniques that help exploit the infrastructure. </li>
<li>After designing the basic functionality, use techniques and approaches that will ensure resilience. If any component fails (and failures happen all the time), the system should automatically alert, failover, and re-sync back to the ―last known state as if nothing had failed. </li>
<li>Don’t forget the cost factor. The key to building a cost-effective application is using on demand resources in your design. It’s wasteful to pay for infrastructure that is sitting idle.</li>
</ul>
<p><strong>There are numerous examples of cloud architectures including:</strong> </p>
<ul>
<li><strong>Processing pipelines</strong><ul>
<li>Document processing pipelines to convert hundreds of thousands of documents from one format to another, e.g. from MS Word to PDF; </li>
<li>Image processing piplelines – say resizing millions of images; </li>
<li>Video transcoding piplelines – transcoding AVI to MPEG movies; </li>
<li>Indexing – creating an index of web crawled documents; </li>
<li>Data mining – performing search over millions of records.</li>
</ul>
</li>
<li><strong>Batch processing systems</strong>: back-office applications in finance, insurance or retail sectors, log analysis, nightly builds or automated unit testing and deployment, etc</li>
</ul>
<h3 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h3><h4 id="MIPS-instructions"><a href="#MIPS-instructions" class="headerlink" title="MIPS instructions"></a>MIPS instructions</h4><ul>
<li><strong>Arithmetic Instructions</strong></li>
</ul>
<img src="https://pic.imgdb.cn/item/626fb4a1239250f7c53f9ffc.jpg" style="zoom:80%;" />

<ul>
<li><strong>Logical</strong></li>
</ul>
<img src="https://pic.imgdb.cn/item/626fb4d6239250f7c5400ed9.jpg" style="zoom:80%;" />

<ul>
<li><strong>Data Transfer</strong></li>
</ul>
<img src="https://pic.imgdb.cn/item/626fb4fa239250f7c5405a43.jpg" style="zoom:80%;" />

<img src="https://pic.imgdb.cn/item/626fb51a239250f7c5409d42.jpg" style="zoom:80%;" />

<ul>
<li><strong>Conditional Branch</strong></li>
</ul>
<img src="https://pic.imgdb.cn/item/626fb542239250f7c540f7f1.jpg" style="zoom:80%;" />

<ul>
<li><strong>Comparison</strong></li>
</ul>
<img src="https://pic.imgdb.cn/item/626fb566239250f7c54148d6.jpg" style="zoom:80%;" />

<ul>
<li><strong>Unconditional Jump</strong></li>
</ul>
<img src="https://pic.imgdb.cn/item/626fb586239250f7c54184f4.jpg" style="zoom:80%;" />

<ul>
<li><strong>Registers</strong></li>
</ul>
<img src="https://pic.imgdb.cn/item/626fb5c7239250f7c5420cd1.jpg" style="zoom:80%;" />
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://www.zzzzzq.com/2022/05/01/HighPerformance/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HKU/" rel="tag">HKU</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2022/05/03/objectName/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            ObjectName
          
        </div>
      </a>
    
    
      <a href="/2022/04/29/applicationLayers/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">applicationLayers</div>
      </a>
    
  </nav>

   
<!-- valine评论 -->
<div id="vcomments-box">
  <div id="vcomments"></div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdn.staticfile.org/valine/1.4.16/Valine.min.js"></script>
<script>
  new Valine({
    el: "#vcomments",
    app_id: "5J2nSr5DoqBGRRnpdFfTvawi-gzGzoHsz",
    app_key: "24GWRfKBASGr6cA5FSBF4NY4",
    path: window.location.pathname,
    avatar: "monsterid",
    placeholder: "给我的文章加点评论吧~",
    recordIP: true,
  });
  const infoEle = document.querySelector("#vcomments .info");
  if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
    infoEle.childNodes.forEach(function (item) {
      item.parentNode.removeChild(item);
    });
  }
</script>
<style>
  #vcomments-box {
    padding: 5px 30px;
  }

  @media screen and (max-width: 800px) {
    #vcomments-box {
      padding: 5px 0px;
    }
  }

  #vcomments-box #vcomments {
    background-color: #fff;
  }

  .v .vlist .vcard .vh {
    padding-right: 20px;
  }

  .v .vlist .vcard {
    padding-left: 10px;
  }
</style>

 
   
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022
        <i class="ri-heart-fill heart_icon"></i> ZHU
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Keep Making Progress"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>