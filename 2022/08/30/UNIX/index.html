<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="朱章齐的个人技术网站" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>UNIX/Linux学习记录 |  Keep Making Progress</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="Keep Making Progress" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-UNIX"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  UNIX/Linux学习记录
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/08/30/UNIX/" class="article-date">
  <time datetime="2022-08-29T18:33:50.000Z" itemprop="datePublished">2022-08-30</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">14.3k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">59 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <p>本文主要记录了阅读《UNIX&#x2F;Linux编程实践教程》过程中的学习笔记</p>
<span id="more"></span>

<h2 id="环境配置相关问题"><a href="#环境配置相关问题" class="headerlink" title="环境配置相关问题"></a>环境配置相关问题</h2><p><strong>centos7更换镜像源：</strong></p>
<ol>
<li><p>安装wget<br><code>yum install -y wget</code></p>
</li>
<li><p>备份服务器原有的yum源文件<br><code>mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</code></p>
</li>
<li><p>下载阿里云镜像文件<br><code>wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</code></p>
</li>
<li><p>清理缓存<br><code>yum clean all</code></p>
</li>
<li><p>生成缓存<br><code>yum makecache</code></p>
</li>
<li><p>更新最新源设置<br><code>yum update -y</code></p>
</li>
</ol>
<p><strong>vim插件的使用</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.linuxidc.com/Linux/2016-06/132262.htm">参考文档</a></p>
<p><strong>安装管理vim插件的插件pathogen</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> -p ~/.vim/autoload ~/.vim/bundle &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">curl -LSso ~/.vim/autoload/pathogen.vim https://tpo.pe/pathogen.vim</span></span><br></pre></td></tr></table></figure>

<p>创建该插件所需要的目录， 把 pathogen.vim 安装在 ~&#x2F;.vim&#x2F;autoload 目录，vim 会自动载入这个目录下的 pathogen 插件（目录名 autoload 顾名思义），将插件交给 pathogen 管理。创建 ~&#x2F;.vim&#x2F;bundle 目录是用来存放管理以后要安装插件。</p>
<p>在 .vimrc 里配置，加上下面这句话，意思是执行这个函数 infect()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">execute pathogen#infect()</span><br><span class="line"></span><br><span class="line"># 如果没有 .vimrc 文件， 则 vim ~/.vimrc ，然后黏贴下面这几句话</span><br><span class="line"></span><br><span class="line">execute pathogen#infect()</span><br><span class="line">syntax on</span><br><span class="line">filetype plugin indent on</span><br></pre></td></tr></table></figure>

<p>以后直接把插件安装到<code>~/.vim/bundle</code>目录下即可</p>
<p><strong>auto-pairs自动补齐括号、引号插件</strong></p>
<p>在 <code>~/.vim/bundle</code>目录下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> git@github.com:jiangmiao/auto-pairs.git</span></span><br></pre></td></tr></table></figure>



<p><strong>NERDTree树状文件列表</strong></p>
<p>安装：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> git@github.com:preservim/nerdtree.git</span></span><br></pre></td></tr></table></figure>



<ul>
<li>打开NERDTree： shift + : 然后输入 NERDTree 可看到结果</li>
<li>ctrl + w + h 光标切换到左侧树形目录</li>
<li>ctrl + w  + l 光标切换到右侧文件显示窗口</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.programminghunter.com/article/7761796988/">更多使用方式</a></p>
<p><strong>安装 MiniBufExplorer 的改进版</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@github.com:fholgado/minibufexpl.vim.git ~/.vim/bundle/minibufexpl</span><br></pre></td></tr></table></figure>

<p>测试, 可以打开多个 buffer, :vsp 加文件名</p>
<p><strong>taglist</strong></p>
<p>taglist 依赖 ctags ，默认自带， 没有就自己安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install ctags</span><br></pre></td></tr></table></figure>

<p>下载 taglist 到 bundle 目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:vim-scripts/taglist.vim.git</span><br></pre></td></tr></table></figure>

<p>测试， 用 vim 打开一个文件，然后输入 TlistToggle </p>
<p>注意修改完文件后要保存重新进以后才能更新tag</p>
<p><strong>C++自动补齐插件OmniCppComplete</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:vim-scripts/OmniCppComplete.git</span><br></pre></td></tr></table></figure>

<p>在 test 目录，生成 tags 文件，这样才能自动补全：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctags -R --<span class="built_in">sort</span>=<span class="built_in">yes</span> --c++-kinds=+p --fields=+iaS --extra=+q --language-force=C++</span><br></pre></td></tr></table></figure>

<p>自动补全快捷键 ctr+x ctr+o ， 上下选择快捷键 ctr+n ctr+p。</p>
<h2 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h2><p>注意所有命令几乎都是人为编写的程序（大多都是C语言写的）</p>
<p>在Unix系统下增加新的命令只需要把程序的可执行文件放到以下任意目录即可：</p>
<ul>
<li><code>/bin</code></li>
<li><code>/usr/bin</code></li>
<li><code>/usr/local/bin</code></li>
</ul>
<p>目录树样例：</p>
<img src="https://pic.imgdb.cn/item/630dda6d16f2c2beb100702a.jpg" style="zoom:80%;" />

<p><strong>程序运行和注销</strong></p>
<ul>
<li><code>exit</code>用于注销已运行的程序</li>
<li></li>
</ul>
<p><strong>目录操作</strong></p>
<ul>
<li><code>ls</code>：列出目录内容<ul>
<li><code>ls /</code>：列出根目录内容</li>
</ul>
</li>
<li><code>cd</code>：改变当前目录<ul>
<li><code>cd ..</code>：回退到上一层目录</li>
</ul>
</li>
<li><code>pwd</code>：显示当前目录路径</li>
<li><code>mkdir</code> <code>rmdir</code>：新建、删除目录</li>
</ul>
<p><strong>文件操作</strong></p>
<p>注意文件名不能包含根目录符号 <code>/</code></p>
<ul>
<li><code>cat</code> <code>more</code> <code>less</code> <code>pg</code> 查看文件内容</li>
<li><code>cp</code>：文件赋值</li>
<li><code>rm</code>：文件删除（注意Unix不提供恢复被删除文件的功能，其中一个原因是由于Unix是一个多用户系统，文件被删掉以后存储空间可能立即被分配给其他用户的文件）</li>
<li><code>mv</code>：重命名或移动文件</li>
<li><code>lpr</code>：打印文件</li>
<li><code>ls -l</code>：查看文件详细信息，可以看到文件权限<ul>
<li>共三组rwx，表示user group other是否可以read write excute</li>
</ul>
</li>
</ul>
<p><strong>bc： Unix计算器</strong></p>
<p>输入bc即可启动计算器，使用Ctrl + D退出</p>
<p>bc还是可编程的，语法与C语言类似</p>
<p><strong>其他</strong></p>
<ul>
<li><p><code>ps</code>：列出系统中运行的所有进程</p>
</li>
<li><p><code>man</code>：查看帮助</p>
<ul>
<li>使用 <code>man -k</code>可以根据关键字搜索联机帮助</li>
</ul>
</li>
<li><p><code>who</code>：列出当前系统中活动的用户</p>
</li>
</ul>
<h2 id="设计自己的who命令"><a href="#设计自己的who命令" class="headerlink" title="设计自己的who命令"></a>设计自己的who命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">man <span class="built_in">who</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">根据描述可以发现<span class="built_in">who</span>是用于查询所有登录用户的信息的，放在文件/var/run/utmp中</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">man -k utmp</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">man 5 utmp</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">可以找到utmp的数据结构</span></span><br></pre></td></tr></table></figure>

<p><strong>问题：如何从文件中读取数据结构</strong></p>
<p>可以在帮助中寻找答案，寻找与file和read相关的帮助。</p>
<p>由于man命令选项-k(根据关键字查找)只支持一个关键字的查找，可以借助grep命令查找（使用正则表达式搜索文本，并打印匹配的行）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">man -k file | grep <span class="built_in">read</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">man 2 <span class="built_in">read</span></span></span><br></pre></td></tr></table></figure>

<p>查看read系统调用的说明</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">       read - read from a file descriptor</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       #include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">       ssize_t read(int fd, void *buf, size_t count);</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       read()  attempts to read up to count bytes from file descriptor fd into</span><br><span class="line">       the buffer starting at buf.</span><br><span class="line"></span><br><span class="line">       On files that support seeking, the read operation commences at the cur‐</span><br><span class="line">       rent  file  offset, and the file offset is incremented by the number of</span><br><span class="line">       bytes read.  If the current file offset is at or past the end of  file,</span><br><span class="line">       no bytes are read, and read() returns zero.</span><br><span class="line"></span><br><span class="line">       If count is zero, read() may detect the errors described below.  In the</span><br><span class="line">       absence of any errors, or if read() does not check for errors, a read()</span><br><span class="line">       with a count of 0 returns zero and has no other effects.</span><br><span class="line">       </span><br><span class="line">       If count is greater than SSIZE_MAX, the result is unspecified.</span><br><span class="line">       </span><br><span class="line"> ......</span><br><span class="line"> </span><br><span class="line"> SEE ALSO</span><br><span class="line">       close(2), fcntl(2), ioctl(2), lseek(2), open(2), pread(2),  readdir(2),</span><br><span class="line">       readlink(2), readv(2), select(2), write(2), fread(3)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这个系统调用可以将一定数目的字节读入一个缓冲区。</p>
</li>
<li><p>因为每次都要读入一个数据结构，所以要用<code>sizeof(struct utmp)</code>来指定每次读入的字节数</p>
</li>
<li><p>read()需要一个文件描述符作为输入参数，文件描述符通过open()获取</p>
</li>
</ul>
<p><strong>答案：使用open、read和close</strong></p>
<ol>
<li>打开一个文件：<code>int open(const char *pathname, int flags);</code><ul>
<li>这个系统调用在进程和文件之间建立一条连接，这个连接被称为文件描述符，它就像一条由进程通向内核的管道。</li>
<li>如果文件被顺利打开，内核就会返回一个正整数的值，即文件描述符，用来唯一标识这个连接。（打开不同的文件或者同一文件打开多次得到的文件描述符是不同的）</li>
<li>The argument flags must include one  of  the  following  access  modes: O_RDONLY,  O_WRONLY,  or  O_RDWR.  These request opening the file read-only, write-only, or read&#x2F;write, respectively.</li>
</ul>
</li>
<li>从文件读取数据：<code>ssize_t read(int fd, void *buf, size_t count);</code><ul>
<li>这个系统调用请求内核从fd指定的文件中读取count字节的数据，存放到buf所指定的内存空间中，如果成功读取了数据，就返回读取的字节数目，否则返回-1.</li>
</ul>
</li>
<li>关闭文件：<code>int close(int fd);</code><ul>
<li>当不需要对文件进行读写操作时，就把文件关闭</li>
<li>这个系统调用会关闭进程和文件fd之间的连接，如果关闭的过程中出现错误，close返回-1，如：fd所指的文件不存在等</li>
</ul>
</li>
</ol>
<p><strong>编写who1.c</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;utmp.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHOWHOST</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">utmp</span>  <span class="title">current_record</span>;</span> </span><br><span class="line">    <span class="type">int</span>     utmpfd; <span class="comment">//存储utmp文件的文件描述符</span></span><br><span class="line">    <span class="type">int</span>     reclen = <span class="keyword">sizeof</span>(current_record);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//UTMP_FILE定义在/usr/include/utmp.h中， O_RDONLY表示只读模式打开文件</span></span><br><span class="line">    <span class="keyword">if</span>((utmpfd = open(UTMP_FILE, O_RDONLY)) == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(UTMP_FILE);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一次读取一个数据结构，重复到读完为之</span></span><br><span class="line">    <span class="keyword">while</span>(read(utmpfd, &amp;current_record,reclen) == reclen)&#123;</span><br><span class="line">        show_info(&amp;current_record);</span><br><span class="line">    &#125;</span><br><span class="line">    close(utmpfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示登录信息</span></span><br><span class="line">show_info(<span class="keyword">struct</span> utmp *utbufp)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;% - 8.8s&quot;</span>,utbufp-&gt;ut_name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;% - 8.8s&quot;</span>,utbufp-&gt;ut_line);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%10ld&quot;</span>,utbufp-&gt;ut_time);<span class="comment">//以long int格式输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHOWHOST</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,utbufp-&gt;ut_line);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将上述代码编译、运行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cc who1.c -o who1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./who1</span></span><br></pre></td></tr></table></figure>

<p>与系统的who命令输出对比</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[zhangqi@localhost test]$ who</span><br><span class="line">zhangqi  :0           2022-08-30 06:58 (:0)</span><br><span class="line">zhangqi  pts/0        2022-08-31 01:59 (:0)</span><br><span class="line"></span><br><span class="line">[zhangqi@localhost test]$ ./who1</span><br><span class="line">reboot   ~        1661813849 ~</span><br><span class="line">runlevel ~        1661813884 ~</span><br><span class="line">zhangqi  :0       1661813911 :0</span><br><span class="line">zhangqi  pts/0    1661882367 pts/0</span><br></pre></td></tr></table></figure>

<p>存在问题：</p>
<ol>
<li>需要消除空白记录</li>
<li>登陆时间没有正确显示</li>
</ol>
<p><strong>编写who2.c</strong></p>
<ul>
<li><p>如何消除空白记录：</p>
<ul>
<li><p>空白记录产生的原因是utmp包含所有终端的信息，包括那些尚未被用到的终端信息。</p>
</li>
<li><p>因此要做到能够区分出哪些终端对应活动的用户：</p>
<ul>
<li><p>在utmp.h中定义了如下内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* Values for ut_type field, below */</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define EMPTY         0 /* Record does not contain valid info (formerly known as UT_UNKNOWN on Linux) */</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define RUN_LVL       1 /* Change <span class="keyword">in</span> system run-level (see init(8)) */</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define BOOT_TIME     2 /* Time of system boot (<span class="keyword">in</span> ut_tv) */</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define NEW_TIME      3 /* Time after system clock change (<span class="keyword">in</span> ut_tv) */</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define OLD_TIME      4 /* Time before system clock change (<span class="keyword">in</span> ut_tv) */</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define INIT_PROCESS  5 /* Process spawned by init(8) */</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define LOGIN_PROCESS 6 /* Session leader process <span class="keyword">for</span> user login */</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define USER_PROCESS  7 /* Normal process */</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define DEAD_PROCESS  8 /* Terminated process */</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define ACCOUNTING    9 /* Not implemented */</span></span><br></pre></td></tr></table></figure>

<p>可知utmp结构中的ut_type成员，当其值为7（USER_PROCESS）时，表示这是一个已经登录的用户</p>
</li>
<li><p>因此对原程序进行修改（我的方式是在while循环中增加判断，不走show_info，书中是在show_info中进行判断的）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(read(utmpfd, &amp;current_record,reclen) == reclen)&#123;</span><br><span class="line">    <span class="keyword">if</span>((&amp;current_record)-&gt;ut_type != USER_PROCESS) <span class="keyword">continue</span>;</span><br><span class="line">    show_info(&amp;current_record);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>以可读的方式显示登录时间</p>
<ul>
<li><p>可在联机帮助中搜索关于时间的主题：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">man -k time</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">man -k time | grep transform</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">man -k time | grep -i convert</span></span><br></pre></td></tr></table></figure>

<p>可以发现很多记录都涉及到time.h</p>
</li>
<li><p>了解可的值Unix储存时间的方式是 time_t数据类型 time.h中有<code>typedef lont int time_t</code>，表示从1970年1月1日0时开始所经过的秒数</p>
</li>
<li><p>将time_t显示出来用到ctime，将整数值转换为常用的时间形式：</p>
<p><code>char *ctime(const time_t *timep);</code></p>
</li>
<li><p>注意不是所有的字符串内容都需要（去掉周几和年份，只返回ctime返回字符串从第4个字符串开始的12个字符）</p>
<p><code>printf(&quot;%12.12s&quot;,ctime(&amp;t) + 4);</code></p>
</li>
</ul>
</li>
</ul>
<p>整体代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;utmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHOWHOST</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">display_time</span><span class="params">(<span class="type">long</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">show_info</span><span class="params">(<span class="keyword">struct</span> utmp*)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">utmp</span> <span class="title">current_record</span>;</span></span><br><span class="line">        <span class="type">int</span>     utmpfd;</span><br><span class="line">        <span class="type">int</span>     reclen = <span class="keyword">sizeof</span>(current_record);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((utmpfd = open(UTMP_FILE, O_RDONLY)) == <span class="number">-1</span>)&#123;</span><br><span class="line">                perror(UTMP_FILE);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(read(utmpfd, &amp;current_record,reclen) == reclen)&#123;</span><br><span class="line">                <span class="keyword">if</span>((&amp;current_record)-&gt;ut_type != USER_PROCESS) <span class="keyword">continue</span>;</span><br><span class="line">                show_info(&amp;current_record);</span><br><span class="line">        &#125;</span><br><span class="line">        close(utmpfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_info</span><span class="params">(<span class="keyword">struct</span> utmp *utbufp)</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;% - 8.8s&quot;</span>,utbufp-&gt;ut_name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;% - 8.8s&quot;</span>,utbufp-&gt;ut_line);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        display_time(utbufp-&gt;ut_time);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHOWHOST</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,utbufp-&gt;ut_line);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">display_time</span><span class="params">(<span class="type">long</span> timeval)</span>&#123;</span><br><span class="line">        <span class="type">char</span>* cp;</span><br><span class="line">        cp = ctime(&amp;timeval);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%12.12s&quot;</span>,cp + <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编写cp（读和写）"><a href="#编写cp（读和写）" class="headerlink" title="编写cp（读和写）"></a>编写cp（读和写）</h3><p><strong>cp命令的典型用法：</strong></p>
<p><code>cp source-file target-file</code></p>
<p>如果target-file所指定的文件不存在，cp就创建这个文件，如果已经存在就覆盖，target-file的内容与source-file相同</p>
<p><strong>cp命令是如何创建&#x2F;重写文件的</strong></p>
<ul>
<li><p>其中一种方法是使用系统调用函数creat：</p>
<p><code>int creat(const char *pathname, mode_t mode);</code></p>
<ul>
<li><p>creat告诉内核创建一个名为pathname的文件，如果这个文件不存在，就创建它，如果已经存在，就把它的内容清空，把文件长度设为0</p>
</li>
<li><p>如果内核成功创建了文件，那么文件的许可位（permission bits）被设置为由第2个参数mode所指定的值，如：</p>
<p><code>fd = creat(&quot;addressbook&quot;, 0644);</code></p>
<p>创建一个名为addressbook的文件，如果文件不存在，那么文件的许可位被设为rw-r-r–</p>
<p>返回值是指向addressbook的文件描述符</p>
</li>
</ul>
</li>
<li><p>用write系统调用向已打开的文件中写入数据：</p>
<p><code>ssize_t write(int fd, const void *buf, size_t count);</code></p>
<ul>
<li>fd文件描述符，buf内存数据，count要写的字节数</li>
<li>写入失败返回-1，写入成功返回写入的字节数</li>
<li>注意实际写入的字节数可能少于count（有的系统对文件最大尺寸有限制或磁盘空间接近满了）</li>
<li>因此调用write后必须检查返回值是否与要写入的相同，若不同作出相应的处理</li>
</ul>
</li>
</ul>
<p>完整代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFERSIZE 4096</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COPYMODE 0644</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">oops</span><span class="params">(<span class="type">char</span> *, <span class="type">char</span> *)</span>;</span><br><span class="line"></span><br><span class="line">main(<span class="type">int</span> ac, <span class="type">char</span> *av[])&#123;</span><br><span class="line">        <span class="type">int</span>     in_fd, out_fd, n_chars;</span><br><span class="line">        <span class="type">char</span>    buf[BUFFERSIZE];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ac!=<span class="number">3</span>)&#123; </span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s source destination\n&quot;</span>, *av);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((in_fd = open(av[<span class="number">1</span>],O_RDONLY)) == <span class="number">-1</span>)<span class="comment">//判断能否打开</span></span><br><span class="line">                oops(<span class="string">&quot;Cannot open &quot;</span>, av[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>((out_fd = creat(av[<span class="number">2</span>],COPYMODE)) == <span class="number">-1</span>)<span class="comment">//判断能否创建</span></span><br><span class="line">                oops(<span class="string">&quot;Cannot creat &quot;</span>, av[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>((n_chars = read(in_fd, buf, BUFFERSIZE)) &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span>(write(out_fd,buf,n_chars) != n_chars)</span><br><span class="line">                        oops(<span class="string">&quot;Write error to &quot;</span>,av[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">if</span>(n_chars == <span class="number">-1</span>)</span><br><span class="line">                oops(<span class="string">&quot;Read error from &quot;</span>,av[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(close(in_fd) == <span class="number">-1</span> || close(out_fd) == <span class="number">-1</span>)</span><br><span class="line">                oops(<span class="string">&quot;Error closing files&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">oops</span><span class="params">(<span class="type">char</span> *s1, <span class="type">char</span> *s2)</span>&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Error: %s&quot;</span>,s1);</span><br><span class="line">        perror(s2);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译并测试：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cc cp1.c -o cp1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./cp1 cp1 copy.of.cp1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmp cp1 copy.of.cp1 <span class="comment">#Unix自带的文件比较工具cmp，无任何提示则说明内容完全相同</span></span></span><br></pre></td></tr></table></figure>

<h3 id="提高文件I-x2F-O效率的方法：使用缓冲"><a href="#提高文件I-x2F-O效率的方法：使用缓冲" class="headerlink" title="提高文件I&#x2F;O效率的方法：使用缓冲"></a>提高文件I&#x2F;O效率的方法：使用缓冲</h3><p>注意cp1中定义了BUFFERSIZE这个常量，用于标识每次读&#x2F;写操作的数据长度，这里的值是4096。</p>
<p>要注意缓冲区大小对性能有很大的影响，使用大的缓冲区可以减少系统调用的次数（在cp1中就是减少read()和write()的次数）</p>
<p><strong>为什么系统调用耗时很长：</strong></p>
<ul>
<li>用户进程位于用户空间，内核位于系统空间，磁盘只能被内核直接访问</li>
<li>当系统调用发生时，执行权会从用户代码转移到内核代码，执行内核代码是需要时间的</li>
<li>由于运行内核代码时，CPU工作在管理员（supervisor）模式，这对应于一些特殊的对战和内存环境，必须在系统调用发生时建立好。</li>
<li>系统调用结束后，CPU要切换到用户模式，必须把堆栈和内存环境恢复成用户程序运行时的状态，这种运行环境的切换要消耗很多时间。（上下文切换）</li>
</ul>
<p><strong>在who2.c中运用缓冲技术</strong></p>
<img src="https://pic.imgdb.cn/item/630e936716f2c2beb15cdf06.jpg" style="zoom:80%;" />

<p>使用一个能容纳16个utmp结构的数组作为缓冲区，标识为buffer。</p>
<p>我们需要编写utmp_next函数来从缓冲区中取得下一个utmp结构的数据</p>
<p>在utmplib.c中进行实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NRECS 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULLUT ((struct utmp *)NULL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UTSIZE (sizeof(struct utmp))</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> utmpbuf[NRECS * UTSIZE];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> num_recs;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> cur_rec;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> fd_utmp = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">utmp_open</span><span class="params">(<span class="type">char</span>* filename)</span>&#123;</span><br><span class="line">        fd_utmp = open(filename, O_RDONLY);</span><br><span class="line">        cur_rec = num_recs = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> fd_utmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> utmp* <span class="title function_">utmp_next</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">utmp</span> *<span class="title">recp</span>;</span></span><br><span class="line">        <span class="keyword">if</span>(fd_utmp == <span class="number">-1</span>) <span class="keyword">return</span> NULLUT;</span><br><span class="line">    	<span class="comment">//如果缓冲记录读到头并且文件记录也读完了，返回空指针</span></span><br><span class="line">        <span class="keyword">if</span>(cur_rec == num_recs &amp;&amp; utmp_reload()==<span class="number">0</span>) <span class="keyword">return</span> NULLUT;</span><br><span class="line">        recp = (<span class="keyword">struct</span> utmp*)&amp;utmpbuf[cur_rec * UTSIZE];</span><br><span class="line">        ++cur_rec;</span><br><span class="line">        <span class="keyword">return</span> recp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">utmp_reload</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> amt_read;</span><br><span class="line">        amt_read = read(fd_utmp, utmpbuf, NRECS*UTSIZE);</span><br><span class="line">        num_recs = amt_read/UTSIZE;</span><br><span class="line">        cur_rec = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> num_recs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">utmp_close</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(fd_utmp!=<span class="number">-1</span>) close(fd_utmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主函数流程修改如下：</p>
<p>修改后的主函数没有直接对open、read和close进行调用，而是调用与之等价的具有缓冲模式的函数接口。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utmplib.c&quot;</span>  <span class="comment">//注意包含.c文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">utmp</span> *<span class="title">utbufp</span>, *<span class="title">utmp_next</span>();</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(utmp_open(UTMP_FILE) == <span class="number">-1</span>)&#123;</span><br><span class="line">                perror(UTMP_FILE);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>((utbufp = utmp_next())!= ((<span class="keyword">struct</span> utmp*)<span class="literal">NULL</span>))&#123;</span><br><span class="line">                show_info(utbufp);</span><br><span class="line">        &#125;</span><br><span class="line">        utmp_close();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内核缓冲技术"><a href="#内核缓冲技术" class="headerlink" title="内核缓冲技术"></a>内核缓冲技术</h3><p>主要思想是一次读入大量数据放入缓冲区，需要的时候从缓冲区取得数据。</p>
<p>用户态和内核态之间的切换需要消耗时间，相比之下，磁盘的I&#x2F;O操作消耗的时间更多，为了提高效率，内核也是用缓冲技术来提高对磁盘的访问速度。</p>
<ul>
<li>正如utmp文件是用户登录记录的集合，磁盘是数据块的集合，内核会对磁盘上的数据块作缓冲，就像who程序缓冲utmp记录一样。</li>
<li>内核将磁盘上的数据块复制到内核缓冲区中，当一个用户空间中的进程要从磁盘上读数据时，内核一般不直接读磁盘，而是将内核缓冲区中的数据复制到进程的缓冲区中。</li>
<li>当进程所要求的数据块不在内核缓冲区中时，内核会把相应的数据块加入到请求数据列表中，然后将该进程挂起，接着为其他进程服务</li>
<li>等把相应的数据块从磁盘读到内核缓冲区后，再把数据复制到进程的缓冲区中，最后环形被挂起的进程。</li>
<li>注意read就是把数据从内核缓冲区复制到进程缓冲区，write把数据从进程缓冲区复制到内核缓冲区，它们不等价于数据在内核缓冲和磁盘之间的交换。内核在积累一定数量的写数据后再一次写入磁盘中。</li>
</ul>
<p>该应用的结果：</p>
<ul>
<li>提高磁盘I&#x2F;O效率</li>
<li>优化磁盘写操作</li>
<li>需要及时将缓冲数据写入磁盘（这是个缺点，比如当发生意外状况如断电时，内核来不及写入数据到磁盘，则更新的数据会丢失）</li>
</ul>
<p><strong>标准C函数的实现</strong></p>
<p>标准C函数如fopen getc fclose fgets的实现都包含内核级缓冲，它们用到了一个结构FILE，并以此为基础构造了类似utmplib的中间层</p>
<p>FILE的结构定义在<code>/usr/include/libio.h</code>中</p>
<h3 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h3><p><strong>注销过程是如何工作的：</strong>（utmp记录的改变）</p>
<ul>
<li>打开文件utmp<ul>
<li><code>fd = open(UTMP_FILE, O_RDWR);</code></li>
</ul>
</li>
<li>从utmp中找到包含你所在终端的登录记录<ul>
<li>在while循环中读取一条utmp记录，将它的ut_line字段跟终端名字做比较，若相等则调用修改函数</li>
</ul>
</li>
<li>对当前记录作修改<ul>
<li>负责注销的程序修改当前记录，再把它写回到文件utmp中</li>
<li>即要把ut_type的值从USER_PROCESS改成DEAD_PROCESS，把ut_time字段的值改为注销时间，也就是当前时间</li>
<li>把修改过的记录写会文件不能用write（write只会更新下一条记录而不会修改）</li>
<li><u>使用系统调用lseek进行修改</u> <code>off_t lseek(int fd, off_t offset, int whence);</code></li>
</ul>
</li>
<li>关闭文件<ul>
<li>close(fd)</li>
</ul>
</li>
</ul>
<p><strong>改变文件的当前位置</strong></p>
<p>我们知道Unix每次打开一个文件都会保存一个指针来记录文件的当前位置</p>
<img src="https://pic.imgdb.cn/item/630f49f216f2c2beb1c6aea5.jpg" style="zoom:80%;" />

<p><u>当从文件读数据时，内核从指针标明的地方开始，读取指定的字节，然后移动位置指针，指向下一个未被读取的字节</u>，写文件的操作也是类似的。</p>
<p>指针是与文件描述符相关联的，而不是与文件关联，所以如果两个程序同时打开一个文件，这时会有两个指针，两个程序对文件的读操作不会相互干扰。</p>
<p>系统调用lseek的用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>fd：文件描述符</li>
<li>offset：从基准位置开始的偏移量（可以是负值）</li>
<li>whence：<ul>
<li>SEEK_SET：文件的开始</li>
<li>SEEK_CUR：当前位置</li>
<li>SEEK_END：文件结尾</li>
</ul>
</li>
<li>遇到错误返回-1，否则返回指针变化前的位置</li>
</ul>
<p>如：</p>
<ul>
<li><code>lseek(fd, -sizeof(struct utmp),SEEK_CUR);</code> 把指针往前移一个utmp结构</li>
<li><code>lseek(fd, 10*sizeof(struct utmp), SEEK_SET);</code>把指针移到第11个记录的开始位置</li>
<li><code>lseek(fd, 0, SEEK_END);write(fd, &quot;hello&quot;, strlen(&quot;hello&quot;));</code>使指针移到文件末尾，然后写一个字符串到文件中</li>
</ul>
<p><strong>编写终端注销的代码</strong></p>
<p>可以编写一个函数对注销的用户修改utmp中相应的记录</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">logout_tty</span><span class="params">(<span class="type">char</span> * line)</span>&#123;</span><br><span class="line">    <span class="type">int</span>	fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">utmp</span> <span class="title">rec</span>;</span></span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> utmp);</span><br><span class="line">    <span class="type">int</span> retval = <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>((fd = open(UTMP_FILE,O_RDWR)) == <span class="number">-1</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//寻找并修改</span></span><br><span class="line">    <span class="keyword">while</span>(read(fd,&amp;rec,len) == len)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strncmp</span>(rec.ut_line, line))&#123;</span><br><span class="line">            rec.ut_type = DEAD_PROCESS;</span><br><span class="line">            <span class="keyword">if</span>(time(&amp;rec.ut_time != <span class="number">-1</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span>(lseek(fd, -len, SEEK_CUR) != <span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(write(fd,&amp;rec,len) == len)</span><br><span class="line">                        retval = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭文件</span></span><br><span class="line">    <span class="keyword">if</span>(close(fd) == <span class="number">-1</span>)&#123;</span><br><span class="line">    	retval = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="处理系统调用中的错误"><a href="#处理系统调用中的错误" class="headerlink" title="处理系统调用中的错误"></a>处理系统调用中的错误</h3><p>很多系统调用遇到错误会返回-1，表示出了某些问题，因此调用者每次都必须检查返回值，一旦检测到错误，必须做出相应的处理。</p>
<p><strong>确定错误的种类errno</strong></p>
<p>内核通过全局变量errno来指明错误的类型，每个程序都可以访问到这个变量</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">       errno - number of last error</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       #include &lt;errno.h&gt;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">		A common mistake is to do</span><br><span class="line">           if (somecall() == -1) &#123;</span><br><span class="line">               printf(&quot;somecall() failed\n&quot;);</span><br><span class="line">               if (errno == ...) &#123; ... &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       where errno no longer needs to have the value it had upon  return  from</span><br><span class="line">       somecall()  (i.e.,  it may have been changed by the printf(3)).  If the</span><br><span class="line">       value of errno should be preserved across a library call,  it  must  be</span><br><span class="line">       saved:</span><br><span class="line"></span><br><span class="line">           if (somecall() == -1) &#123;</span><br><span class="line">               int errsv = errno;</span><br><span class="line">               printf(&quot;somecall() failed\n&quot;);</span><br><span class="line">               if (errsv == ...) &#123; ... &#125;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>



<p><strong>显示错误信息：perror(3)</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">perror</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *sys_errlist[];</span><br><span class="line"><span class="type">int</span> sys_nerr;</span><br><span class="line"><span class="type">int</span> errno;</span><br></pre></td></tr></table></figure>

<p>perror(string)这个函数会自己查找错误代码，在标准错误输出中显示出相应的错误信息，参数string是要同时显示出的描述信息</p>
<h2 id="目录与文件属性：编写ls"><a href="#目录与文件属性：编写ls" class="headerlink" title="目录与文件属性：编写ls"></a>目录与文件属性：编写ls</h2><ul>
<li><code>ls</code>默认动作是找出当前目录中所有文件的文件名，字典序排序后输出</li>
<li><code>ls -l</code>（ls的长格式）会列出每个文件的详细信息，每一行代表一个文件和它的多个属性</li>
<li><code>ls *.c</code>显示与*.c匹配的文件</li>
<li><code>ls -a</code>列出的内容包含以”.”开头的文件</li>
<li><code>ls -lu</code> 显示最后访问时间</li>
<li><code>ls -s</code> 显示以块为单位的文件大小</li>
<li><code>ls -t</code>输出时按时间排序</li>
<li><code>ls -F</code>显示文件类型</li>
</ul>
<h3 id="Unix是如何组织磁盘上的文件的"><a href="#Unix是如何组织磁盘上的文件的" class="headerlink" title="Unix是如何组织磁盘上的文件的"></a>Unix是如何组织磁盘上的文件的</h3><p>磁盘上的文件和目录被组成一棵目录树，每个节点都是目录或文件</p>
<img src="https://pic.imgdb.cn/item/630f617a16f2c2beb1d71e55.jpg" style="zoom:80%;" />

<p>图中的大方框表示目录，大方框内的小方框表示文件，目录之间的连线表示目录之间的组织关系</p>
<p>Unix系统中，每个文件都位于某个目录中，在逻辑上是没有驱动器或卷的，当然在物理上一个系统可以有多个驱动器或分区，每个驱动器上都可以有分区，位于不同驱动器和分区上的目录通过文件树无缝地连接在一起。</p>
<p>软盘、光盘这些移动存储介质也被挂到文件树的某一个子目录来处理。</p>
<p>因此ls的实现只需考虑文件和目录两种情况，无需考虑驱动或分区</p>
<p><strong>什么是目录</strong></p>
<p>目录是一种特殊的文件，它的内容是文件和目录的名字。与utmp文件类似，目录文件包含很多记录，每个记录的格式由统一的标准定义。每条记录的内容代表一个文件或目录</p>
<p>与普通文件不同，目录文件永远不会空，每个目录都至少包含两个特殊的项：</p>
<ul>
<li><code>.</code> 表示当前目录</li>
<li><code>..</code> 表示上一级目录</li>
</ul>
<p>可以发现cat more od命令在centos7系统下都无法读取目录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[zhangqi@localhost test]$ cat /</span><br><span class="line">cat: /: Is a directory</span><br><span class="line">[zhangqi@localhost test]$ more /tmp</span><br><span class="line"></span><br><span class="line">*** /tmp: directory ***</span><br><span class="line"></span><br><span class="line">[zhangqi@localhost test]$ od -c /dev</span><br><span class="line">od: /dev: read error: Is a directory</span><br><span class="line">0000000</span><br></pre></td></tr></table></figure>

<p>那么如何读取呢？</p>
<p>通过 <code>man -k direct | grep read</code>可以找到readdir命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">man 3 readdir</span></span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">       readdir, readdir_r - read a directory</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       #include &lt;dirent.h&gt;</span><br><span class="line"></span><br><span class="line">       struct dirent *readdir(DIR *dirp);</span><br><span class="line"></span><br><span class="line">       int readdir_r(DIR *dirp, struct dirent *entry, struct dirent **result);</span><br><span class="line"></span><br><span class="line">   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):</span><br><span class="line"></span><br><span class="line">       readdir_r():</span><br><span class="line">           _POSIX_C_SOURCE &gt;= 1 || _XOPEN_SOURCE || _BSD_SOURCE || _SVID_SOURCE || _POSIX_SOURCE</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       The readdir() function returns a pointer to a dirent structure representing the next directory</span><br><span class="line">       entry in the directory stream pointed to by dirp.  It returns NULL on reaching the end of  the</span><br><span class="line">       directory stream or if an error occurred.</span><br><span class="line"></span><br><span class="line">       On Linux, the dirent structure is defined as follows:</span><br><span class="line"></span><br><span class="line">           struct dirent &#123;</span><br><span class="line">               ino_t          d_ino;       /* inode number */</span><br><span class="line">               off_t          d_off;       /* not an offset; see NOTES */</span><br><span class="line">               unsigned short d_reclen;    /* length of this record */</span><br><span class="line">               unsigned char  d_type;      /* type of file; not supported</span><br><span class="line">                                              by all file system types */</span><br><span class="line">               char           d_name[256]; /* filename */</span><br><span class="line">           &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>编写简单的ls：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">do_ls</span><span class="params">(<span class="type">char</span> *dirname)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (argc == <span class="number">1</span>) &#123;<span class="comment">//如果没有任何参数，则显示当前目录下所有文件</span></span><br><span class="line">    do_ls(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123; <span class="comment">//否则，显示指定的目录下的文件，可以加多个参数</span></span><br><span class="line">    <span class="keyword">while</span> (--argc) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s:\n&quot;</span>, *++argv);</span><br><span class="line">      do_ls(*argv);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">do_ls</span><span class="params">(<span class="type">char</span> *dirname)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dirent_p</span>;</span></span><br><span class="line">  DIR *dir_p = opendir(dirname);</span><br><span class="line">  <span class="keyword">if</span> (dir_p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    perror(dirname);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ((dirent_p = readdir(dir_p)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, dirent_p-&gt;d_name);</span><br><span class="line">  &#125;</span><br><span class="line">  closedir(dir_p);</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个简单的版本基本实现了查看目录功能，但还需要加进去一些功能：</p>
<ul>
<li>排序：ls1的输出没有进过排序。<ul>
<li>解决办法：把所有文件名读入一个数组，用qsort函数把数组排序</li>
</ul>
</li>
<li>分栏：标准的ls输出是分栏排列的，有些以行排序输出，有些以列排序输出<ul>
<li>解决办法：把文件名读入数组，然后计算出列的宽度和行数</li>
</ul>
</li>
<li>“.”文件：ls1列出了“.”文件，而标准的ls只有在给出-a选项时才会列出这些文件<ul>
<li>解决办法：ls1能够接收选项-a，并在没有-a的时候不显示隐藏文件</li>
</ul>
</li>
<li>选项 -l ：如果选项里有-l，标准的ls会列出文件的详细信息，而ls1不会。<ul>
<li>解决办法：由于dirent结构中没有所需信息，如文件大小、文件所有者等，要找到存储这些信息的地方（使用stat系统调用）</li>
</ul>
</li>
</ul>
<h3 id="用stat得到文件信息"><a href="#用stat得到文件信息" class="headerlink" title="用stat得到文件信息"></a>用stat得到文件信息</h3><p>用法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">       stat, fstat, lstat, fstatat - get file status</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *buf)</span>;</span><br><span class="line">       <span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat *buf)</span>;</span><br><span class="line">       <span class="type">int</span> <span class="title function_">lstat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *buf)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>stat把文件pathname的信息复制到指针buf所指的结构中</li>
<li>入参：文件名，指向stat结构buffer的指针</li>
<li>返回值：-1（遇到错误） 0（成功返回）</li>
</ul>
<p>stat结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">    <span class="type">dev_t</span>     st_dev;         <span class="comment">/* ID of device containing file */</span></span><br><span class="line">    <span class="type">ino_t</span>     st_ino;         <span class="comment">/* inode number */</span></span><br><span class="line">    <span class="type">mode_t</span>    st_mode;        <span class="comment">/* file type and mode */</span></span><br><span class="line">    <span class="type">nlink_t</span>   st_nlink;       <span class="comment">/* number of hard links */</span></span><br><span class="line">    <span class="type">uid_t</span>     st_uid;         <span class="comment">/* user ID of owner */</span></span><br><span class="line">    <span class="type">gid_t</span>     st_gid;         <span class="comment">/* group ID of owner */</span></span><br><span class="line">    <span class="type">dev_t</span>     st_rdev;        <span class="comment">/* device ID (if special file) */</span></span><br><span class="line">    <span class="type">off_t</span>     st_size;        <span class="comment">/* total size, in bytes */</span></span><br><span class="line">    <span class="type">blksize_t</span> st_blksize;     <span class="comment">/* blocksize for filesystem I/O */</span></span><br><span class="line">    <span class="type">blkcnt_t</span>  st_blocks;      <span class="comment">/* number of 512B blocks allocated */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Since Linux 2.6, the kernel supports nanosecond</span></span><br><span class="line"><span class="comment">                  precision for the following timestamp fields.</span></span><br><span class="line"><span class="comment">                  For the details before Linux 2.6, see NOTES. */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_atim</span>;</span>  <span class="comment">/* time of last access */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_mtim</span>;</span>  <span class="comment">/* time of last modification */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_ctim</span>;</span>  <span class="comment">/* time of last status change */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> st_atime st_atim.tv_sec      <span class="comment">/* Backward compatibility */</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> st_mtime st_mtim.tv_sec</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> st_ctime st_ctim.tv_sec</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//filesize.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">infobuf</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(stat(<span class="string">&quot;/etc/passwd&quot;</span>, &amp;infobuf) == <span class="number">-1</span>)</span><br><span class="line">        perror(<span class="string">&quot;/etc/passwd&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//用stat来获取文件大小</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The size of /etc/passwd is %d\n&quot;</span>, infobuf.st_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>编写fileinfo.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fileinfo.c - use stat() to obtain and print file properties</span></span><br><span class="line"><span class="comment">//            - some menbers are just numbers</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">show_stat_info</span><span class="params">(<span class="type">char</span> *filename, <span class="keyword">struct</span> stat *stat_buf)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stat_buf</span>;</span></span><br><span class="line">  <span class="keyword">while</span> (--argc &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (stat(*++argv, &amp;stat_buf) == <span class="number">-1</span>) &#123;</span><br><span class="line">      perror(*argv);</span><br><span class="line">      <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    show_stat_info(*argv, &amp;stat_buf);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">show_stat_info</span><span class="params">(<span class="type">char</span> *filename, <span class="keyword">struct</span> stat *stat_buf_p)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  mode: %o\n&quot;</span>, stat_buf_p-&gt;st_mode);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot; links: %d\n&quot;</span>, stat_buf_p-&gt;st_nlink);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  user: %d\n&quot;</span>, stat_buf_p-&gt;st_uid);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot; group: %d\n&quot;</span>, stat_buf_p-&gt;st_gid);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  size: %d\n&quot;</span>, stat_buf_p-&gt;st_size);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot; mtime: %d\n&quot;</span>, stat_buf_p-&gt;st_mtime);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  name: %s\n&quot;</span>, filename);</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译，运行，并与ls -l作对比</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[zhangqi@localhost chap3]$ ./fileinfo fileinfo.c </span><br><span class="line">  mode: 100664</span><br><span class="line"> links: 1</span><br><span class="line">  user: 1000</span><br><span class="line"> group: 1000</span><br><span class="line">  size: 777</span><br><span class="line"> mtime: 1662418390</span><br><span class="line">  name: fileinfo.c</span><br><span class="line">[zhangqi@localhost chap3]$ <span class="built_in">ls</span> -l fileinfo.c </span><br><span class="line">-rw-rw-r--. 1 zhangqi zhangqi 777 Sep  6 06:53 fileinfo.c</span><br><span class="line">[zhangqi@localhost chap3]$ </span><br></pre></td></tr></table></figure>

<p>可以发现链接数（links，即文件被引用的次数，即别名的数量）、文件大小（size，即实际所占用的存储空间的字节数）的显示都没有问题，时间是可以用ctime转化成字符串的，也没有问题。</p>
<p>然而fileinfo将模式（mode）字段以数字形式输出，然而需要的是 <code>-rw-rw-r--</code>这种形式。</p>
<p>另外结构中的user和group字段都是数值，显示出来的应该是用户名（需要通过getpwuid()来获取）和组名（通过getgrgid()来获取组列表）。</p>
<p>因此要进一步处理这些问题</p>
<p><code>st_mode</code>是一个16位的二进制数，文件类型和权限被编码在这个数中：</p>
<img src="https://pic.imgdb.cn/item/631681e216f2c2beb1280d65.jpg" style="zoom:80%;" />

<ul>
<li><p>前四位用作文件类型，最多标识16种类型，目前已使用其中的7个</p>
</li>
<li><p>接下来3位是文件的特殊属性，1代表具有某个属性，0代表没有。</p>
<ul>
<li><code>set-user-ID</code>位：SUID位告诉内核，运行这个程序的时候认为是由文件所有者在运行这个程序</li>
<li><code>set-group-ID</code>位：用来设置程序运行时所属组</li>
<li><code>sticky</code>位：对于文件来说，告诉内核即使没有人在使用程序，也要把它放在交换空间中（早期类似虚拟内存的实现技术）；对于目录来说，sticky位使目录里的文件只能被创建者删除</li>
</ul>
</li>
<li><p>最后9位是许可权限，分为三组，对应文件所有者、同组用户和其他用户。每组三位，分别是读、写和执行的权限。相应位置如果是1说明有权限，0代表没有</p>
<ul>
<li><p>文件所有者：就是创建文件的用户，当用户通过creat建立文件时，内核把文件所有者设为运行程序的用户，如果程序具有set-user-ID位，那么新文件的文件所有者就是程序的文件所有者</p>
</li>
<li><p>组：通常新文件的组被设为执行创建动作的用户所在的组</p>
</li>
<li><p>修改文件所有者和组：通过系统调用<code>chown</code>来修改文件所有者和组：</p>
<p><code>chown(&quot;file1&quot;,200,40);</code>将文件file1的用户ID改为200，组ID改为40，如果后两个参数都为-1，则文件所有者和组都不会改变。</p>
<p>shell命令chown和chgrp可以用来修改文件所有者和组，它们可以一次修改多个文件</p>
</li>
</ul>
</li>
</ul>
<p><strong>如何读取被编码的值</strong>：</p>
<p>“掩码”技术——为了比较，把不需要的地方置0，需要的字段值不发生改变</p>
<p>实现：与0作位与（&amp;）操作可以将相应的bit置为0</p>
<p>在&lt;sys&#x2F;stat.h&gt;中定义了一系列掩码，用于过滤出不同的信息</p>
<h3 id="综合实现"><a href="#综合实现" class="headerlink" title="综合实现"></a>综合实现</h3><p>ls2.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_ls</span><span class="params">(<span class="type">char</span>[])</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dostat</span><span class="params">(<span class="type">char</span>*)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">show_file_info</span><span class="params">(<span class="type">char</span>*, <span class="keyword">struct</span> stat *)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mode_to_letters</span><span class="params">(<span class="type">int</span>, <span class="type">char</span>[])</span>;</span><br><span class="line"><span class="type">char</span> * <span class="title function_">uid_to_name</span><span class="params">(<span class="type">uid_t</span>)</span>;</span><br><span class="line"><span class="type">char</span> * <span class="title function_">gid_to_name</span><span class="params">(<span class="type">gid_t</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main(<span class="type">int</span> argc, <span class="type">char</span> *argv[]) &#123;</span><br><span class="line">	<span class="keyword">if</span>(argc == <span class="number">1</span>)</span><br><span class="line">		do_ls(<span class="string">&quot;.&quot;</span>); <span class="comment">//如果没有指定参数，则列出该目录下所有文件信息</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">while</span>(--argc)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s:\n&quot;</span>,*++argv);</span><br><span class="line">			do_ls(*argv);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_ls</span><span class="params">(<span class="type">char</span> dirname[])</span>&#123;</span><br><span class="line">	<span class="comment">//list files in directory called dirname</span></span><br><span class="line">	DIR	*dir_ptr;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span>	 <span class="title">dirent</span> * <span class="title">direntp</span>;</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>((dir_ptr = opendir(dirname)) == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;ls2: cannot open %s\n&quot;</span>, dirname);</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">while</span>((direntp = readdir(dir_ptr)) != <span class="literal">NULL</span>)</span><br><span class="line">			dostat(direntp-&gt;d_name);</span><br><span class="line">		closedir(dir_ptr);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dostat</span><span class="params">(<span class="type">char</span> * filename)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span>	<span class="title">stat</span>	<span class="title">info</span>;</span></span><br><span class="line">	<span class="keyword">if</span>(stat(filename, &amp;info)==<span class="number">-1</span>)</span><br><span class="line">		perror(filename);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		show_file_info(filename,&amp;info);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">show_file_info</span><span class="params">(<span class="type">char</span> *filename, <span class="keyword">struct</span> stat *info_p)</span> &#123;</span><br><span class="line">	<span class="type">char</span> *<span class="title function_">uid_to_name</span><span class="params">()</span>, *<span class="title function_">ctime</span><span class="params">()</span>, *<span class="title function_">gid_to_name</span><span class="params">()</span>, *<span class="title function_">filemode</span><span class="params">()</span>;</span><br><span class="line">	<span class="type">void</span> <span class="title function_">mode_to_letters</span><span class="params">()</span>;</span><br><span class="line">	<span class="type">char</span> modestr[<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line">	mode_to_letters(info_p-&gt;st_mode, modestr);</span><br><span class="line"></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>, modestr);</span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">&quot;%4d &quot;</span>,(<span class="type">int</span>)info_p-&gt;st_nlink);</span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">&quot;%-8s &quot;</span>, uid_to_name(info_p-&gt;st_uid));</span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">&quot;%-8s &quot;</span>, gid_to_name(info_p-&gt;st_gid));</span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">&quot;%8ld &quot;</span>, (<span class="type">long</span>)info_p-&gt;st_size);</span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">&quot;%.12s &quot;</span>, <span class="number">4</span>+ctime(&amp;info_p-&gt;st_mtime));</span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, filename);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mode_to_letters</span><span class="params">(<span class="type">int</span> mode, <span class="type">char</span> str[])</span>&#123;</span><br><span class="line">	<span class="built_in">strcpy</span>(str,<span class="string">&quot;----------&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(S_ISDIR(mode)) str[<span class="number">0</span>] = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">	<span class="keyword">if</span>(S_ISCHR(mode)) str[<span class="number">0</span>] = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">	<span class="keyword">if</span>(S_ISBLK(mode)) str[<span class="number">0</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(mode &amp; S_IRUSR) str[<span class="number">1</span>] = <span class="string">&#x27;r&#x27;</span>;</span><br><span class="line">	<span class="keyword">if</span>(mode &amp; S_IWUSR) str[<span class="number">2</span>] = <span class="string">&#x27;w&#x27;</span>;</span><br><span class="line">	<span class="keyword">if</span>(mode &amp; S_IXUSR) str[<span class="number">3</span>] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(mode &amp; S_IRGRP) str[<span class="number">4</span>] = <span class="string">&#x27;r&#x27;</span>;</span><br><span class="line">	<span class="keyword">if</span>(mode &amp; S_IWGRP) str[<span class="number">5</span>] = <span class="string">&#x27;w&#x27;</span>;</span><br><span class="line">	<span class="keyword">if</span>(mode &amp; S_IXGRP) str[<span class="number">6</span>] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(mode &amp; S_IROTH) str[<span class="number">7</span>] = <span class="string">&#x27;r&#x27;</span>;</span><br><span class="line">	<span class="keyword">if</span>(mode &amp; S_IWOTH) str[<span class="number">8</span>] = <span class="string">&#x27;w&#x27;</span>;</span><br><span class="line">	<span class="keyword">if</span>(mode &amp; S_IXOTH) str[<span class="number">9</span>] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pwd.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">uid_to_name</span><span class="params">(<span class="type">uid_t</span> uid)</span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> passwd * <span class="title function_">getpwuid</span><span class="params">()</span>, *pw_ptr;</span><br><span class="line">	<span class="type">static</span> <span class="type">char</span> numstr[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((pw_ptr = getpwuid(uid))== <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">sprintf</span>(numstr,<span class="string">&quot;%d&quot;</span>,uid);</span><br><span class="line">		<span class="keyword">return</span> numstr;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> pw_ptr-&gt;pw_name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;grp.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">gid_to_name</span><span class="params">(<span class="type">gid_t</span> gid)</span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> group * <span class="title function_">getgrgid</span><span class="params">()</span>, *grp_ptr;</span><br><span class="line">	<span class="type">static</span> <span class="type">char</span> numstr[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">if</span>((grp_ptr = getgrgid(gid)) == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">sprintf</span>(numstr,<span class="string">&quot;%d&quot;</span>,gid);</span><br><span class="line">		<span class="keyword">return</span> numstr;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> grp_ptr-&gt;gr_name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="设置和修改文件的属性"><a href="#设置和修改文件的属性" class="headerlink" title="设置和修改文件的属性"></a>设置和修改文件的属性</h3><p>ls2.c的属性</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zhangqi@localhost chap3]$ <span class="built_in">ls</span> -l ls2.c</span><br><span class="line">-rw-rw-r--. 1 zhangqi zhangqi 2336 Sep  7 01:11 ls2.c</span><br></pre></td></tr></table></figure>

<p><strong>文件类型</strong></p>
<p>有普通文件、目录文件、设备文件、socket文件、符号链接文件、命名管道文件等</p>
<ul>
<li>文件类型的建立：是在创建文件的时候建立的，如用系统调用creat建立一个普通文件。其他类型的文件如目录（mkdir()系统调用）等，可使用不同的函数创建。</li>
<li>修改文件类型：文件一经创建，类型就无法修改</li>
</ul>
<p><strong>许可位与特殊属性位</strong></p>
<p>每个文件都有9位许可权限和3位特殊属性，是在文件创建的时候建立的，创建后，它们可以被chmod系统调用修改</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">chmod</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>建立文件的模式：creat的第二个参数制定了要创建文件的许可位</p>
<p><code>fd = creat(&quot;newfile&quot;,0744)</code>指定新创建文件的许可位为rwxr–r–</p>
</li>
<li><p>改变文件的模式：</p>
<ul>
<li><p>程序可以通过系统调用<code>chmod</code>来改变文件的模式：</p>
<p><code>chmod(&quot;/tmp/myfile&quot;, 04764);</code></p>
<p><code>chomod(&quot;/tmp/myfile,S_ISUID|S_IRWXU|S_IRWXU|S_IRGRP|S_IWGRP|S_IROTH&quot;);</code></p>
</li>
<li><p>以上两条指令的作用相同，第一条是八进制表示，第二条是用&lt;sys&#x2F;stat.h&gt;中定义的符号来表示。后者有明显的优点，当系统定义的许可位的值改变时，无需修改程序。即系统调用chmod不受“新建文件掩码”的影响</p>
</li>
<li><p>返回-1即错误，0则是成功</p>
</li>
<li><p>shell命令chmod也可以用来完成上述操作。它可以通过八进制模式（如04764）和符号模式（如u&#x3D;rws g&#x3D;rw o&#x3D;r）来指定权限和属性</p>
</li>
</ul>
</li>
</ul>
<h2 id="文件系统：编写pwd"><a href="#文件系统：编写pwd" class="headerlink" title="文件系统：编写pwd"></a>文件系统：编写pwd</h2><p>文件包含数据，而目录是文件的列表。不同的目录互相连接构成树状的结构。目录还可以包含其他的目录。</p>
<p>pwd命令显示你在目录树中的位置。从树根到你所处位置所经过的目录的序列被称作路径（path）。</p>
<p><strong>用户角度看文件系统</strong></p>
<p>Unix系统中一盘上的文件组成一棵目录树</p>
<p>针对目录树的命令：</p>
<ul>
<li><code>ls -R</code>可以查看以当前节点为根节点的整个树结构。-R要求列出指定目录及其子目录的所有内容</li>
<li><code>chmod -R</code> 可以改变子目录中所有文件的许可权</li>
<li><code>du</code> 是disk usage的缩写，该命令给出指定目录及其子目录下所有文件占用硬盘中数据块的总数</li>
<li><code>find</code> 将在一个目录及其所有子目录中检索符合要求的文件和目录</li>
</ul>
<p>目录树的深度几乎没有限制</p>
<h3 id="Unix文件系统的内部结构"><a href="#Unix文件系统的内部结构" class="headerlink" title="Unix文件系统的内部结构"></a>Unix文件系统的内部结构</h3><p>硬盘实际上是由一些磁性盘片组成的计算机系统的一个设备。文件系统其实是对该设备的一种多层次的抽象</p>
<p><strong>第一层抽象：从磁盘到分区</strong></p>
<ul>
<li>一个磁盘可被划分为若干个分区，以便在一个大的实体内创建独立的区域。每个分区都可以看做是一个独立的磁盘</li>
</ul>
<p><strong>第二层抽象：从磁盘到块序列</strong></p>
<ul>
<li><p>一个磁盘由一些磁性盘片组成。每个盘片的表面都被划分为很多同心圆，这些同心圆被称作磁道，每个磁道又进一步被划分为扇区。</p>
</li>
<li><p>每个扇区可以存储一定字节数的数据（512字节）</p>
</li>
<li><p>扇区是磁盘上的基本存储单元</p>
</li>
<li><p>为磁盘块编号：</p>
<img src="https://pic.imgdb.cn/item/631a294316f2c2beb1c84330.jpg" style="zoom:80%;" />

<ul>
<li>给每个磁盘块分配连续的编号使得系统能够计算磁盘上的每个块。</li>
<li>可以一个磁盘接一个磁盘从上到下给所有块编号，还可以一个磁道接一个磁道地从外向里给所有的块编号。</li>
<li>一个将磁盘扇区编号的系统使得我们可以把磁盘视为一系列块的组合</li>
</ul>
</li>
</ul>
<p><strong>第三层抽象：从块序列到三个区域的划分</strong></p>
<ul>
<li><p>文件系统被分为三个区域来存储不同类型的数据（文件内容、文件属性（所有者、日期等）和目录）</p>
<img src="https://pic.imgdb.cn/item/631a2c3116f2c2beb1cb613a.jpg" style="zoom:80%;" />

<ul>
<li><strong>超级块</strong>：存放文件系统本身的信息（如每个区域的大小、未被使用的磁盘块信息）</li>
<li><strong>i-节点表</strong>：存放文件属性（如大小、文件所有者和最近修改时间）<ul>
<li>这些性质被记录在一个称为 “i-节点”的结构中，所有inode有相同的大小，这是一个inode的列表。</li>
<li>文件系统中的每个文件在该表中都有一个inode</li>
<li>如果有root权限，可以像操作文件一样将分区打开、阅读并显示i-节点表。</li>
<li>注意：表中的每个inode都通过位置来标识。例如，标识为2的inode（inode 2）位于文件系统i-节点表中的第3个位置</li>
</ul>
</li>
<li><strong>数据区</strong>：用来存放文件内容。一个较大的文件可能分布在上千个独立的磁盘块中</li>
</ul>
</li>
<li><p>文件系统由这三部分组合而成，其中任一部分都是由很多有序磁盘块组成的</p>
</li>
</ul>
<h3 id="文件系统的实现："><a href="#文件系统的实现：" class="headerlink" title="文件系统的实现："></a>文件系统的实现：</h3><p><strong>创建一个文件的过程</strong></p>
<p>考虑如下命令： who &gt; userlist，创建了一个存放命令who输出内容的新文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[zhangqi@localhost chap4]$ <span class="built_in">who</span> &gt; userlist</span><br><span class="line">[zhangqi@localhost chap4]$ <span class="built_in">ls</span></span><br><span class="line">demodir  userlist</span><br><span class="line">[zhangqi@localhost chap4]$ <span class="built_in">cat</span> userlist</span><br><span class="line">zhangqi  :0           2022-09-06 06:39 (:0)</span><br><span class="line">zhangqi  pts/0        2022-09-06 06:46 (:0)</span><br><span class="line">zhangqi  pts/1        2022-09-08 08:13 (:0)</span><br></pre></td></tr></table></figure>

<p>文件有内容和属性，内核将文件内容存放在数据区，文件属性存放在inode节点，文件名存在目录</p>
<img src="https://pic.imgdb.cn/item/631a307d16f2c2beb1cfcfcf.jpg" style="zoom:80%;" />

<p>创建一个新文件的四个操作：</p>
<ul>
<li>存储属性：<ul>
<li>文件属性的存储：内核先找到一个空的 inode。如图中，内核找到 inode 47。内核把文件的信息记录其中</li>
</ul>
</li>
<li>存储数据<ul>
<li>文件内容的存储：由于该新文件需要3个存储磁盘块，因此内核从自由块的列表中找出3个自由块。如图中，找到块627、200和992。内核将第一块数据复制到块627， 下一块数据复制到块200，最后一块数据复制到块992。</li>
</ul>
</li>
<li>记录分配情况：<ul>
<li>内核在inode的磁盘分布区记录了上述的块序列。</li>
<li>磁盘分布区是一个磁盘块序号的列表，这3个编号放在最开始的3个位置</li>
</ul>
</li>
<li>添加文件名到目录<ul>
<li>新文件的名字是userlist。Unix内核将入口（47，userlist）添加到目录文件。</li>
<li>文件名和i-节点号之间的对应关系将文件名和文件内容及属性连接了起来</li>
</ul>
</li>
</ul>
<p><strong>目录的工作过程</strong></p>
<p>目录是一种包含了文件名字列表的特殊文件。不同版本的Unix目录的内部结构不同，但是抽象模型总是一致的——一个包含i-节点号和文件名的表</p>
<p>可通过 <code>ls -1ia</code> （选项第一位是数字1）来看目录的内容：</p>
<ul>
<li>输出的是文件名和对应的 i-节点号，如文件名x对应于 i-节点号37405777</li>
<li>当前目录用 <code>.</code>表示，有关大小、文件所有者、组等各项关于当前目录的信息存放在i-节点表中的编号为37405773中</li>
<li><code>-i</code>告诉ls在列表中包含 i-节点号</li>
<li><code>-1</code>要求每行列出一个文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[zhangqi@localhost chap4]$ <span class="built_in">ls</span> -1ia</span><br><span class="line">17507719 .</span><br><span class="line">36866887 ..</span><br><span class="line">37405773 demodir</span><br><span class="line">17507727 userlist</span><br><span class="line">[zhangqi@localhost chap4]$ <span class="built_in">ls</span> -1ia demodir</span><br><span class="line">37405773 .</span><br><span class="line">17507719 ..</span><br><span class="line">51681516 a</span><br><span class="line">51681478 c</span><br><span class="line">37405778 copy.of.x</span><br><span class="line">37405777 x</span><br></pre></td></tr></table></figure>

<p>可以用 <code>ls -i</code>查看系统上任何一个文件的 i-节点号。</p>
<p>如查看系统根目录中各文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[zhangqi@localhost chap4]$ <span class="built_in">ls</span> -ia /</span><br><span class="line">      64 .            3 dev         83 lib64         1 proc    551128 snap  33593488 usr</span><br><span class="line">      64 ..    16777281 etc         84 media  33574977 root  50332836 srv   50331713 var</span><br><span class="line">   74275 bin   50332835 home  16777863 mnt        8868 run          1 sys</span><br><span class="line">      64 boot        81 lib   33593545 opt       74279 sbin  16777288 tmp</span><br></pre></td></tr></table></figure>

<p>这个列表有两个重要的注意点：</p>
<ul>
<li><code>proc</code>和 <code>sys</code>文件的节点号相同都为1，这说明他们是同一个文件的两个不同名字</li>
<li>根目录的<code>.</code>和 <code>..</code>都指向同一个目录。根目录比较特别，当Unix命令mkfs创建一个文件系统，mkfs将根目录的父目录指向自己</li>
</ul>
<p><strong>cat命令的工作原理</strong></p>
<p><code>cat userlist</code> 从目录文件到找到数据：</p>
<img src="https://pic.imgdb.cn/item/631a57c016f2c2beb1eddab8.jpg" style="zoom:80%;" />

<ol>
<li><p>在目录寻找文件名：</p>
<ul>
<li>内核在目录文件中寻找包含字符串userlist的记录。从而找到编号为47的i-节点号</li>
</ul>
</li>
<li><p>定位 i-节点 47 并读取其内容：</p>
<ul>
<li>内核在文件系统中的i-节点区域找到节点 inode 47。（由于所有inode大小相同，每个磁盘块包含相同数量的inode，因此可通过简单的计算进行定位）。</li>
<li>为了提高访问效率，内核有可能将inode置于缓冲区中。inode包含数据块编号的列表</li>
</ul>
</li>
<li><p>访问存储文件内容的数据块</p>
<ul>
<li>通过以上过程，内核已经可以知道文件内容存放在哪些数据块上，以及它们的顺序。由于cat不断地调用read函数，使得内核不断将字节从磁盘复制到内核缓冲区，进而到达用户空间</li>
<li>所有从文件读取数据的命令，例如cat、cp、more、who等，都是将文件名传给open来访问文件内容。对open的每次调用都是先在目录中寻找文件名，然后根据目录中的i-节点号获得文件的属性，最终找到文件的内容</li>
</ul>
</li>
</ol>
<p>如果open一个没有读或写权限的文件：</p>
<ul>
<li>内核首先完成1 2两步</li>
<li>然后在inode中内核可以读取文件权限相关的信息（权限位和拥有者的用户ID）</li>
<li>如果权限位设置你的用户ID对文件没有访问权限，则open返回-1并且将全局变量errno的值设为EPERM</li>
</ul>
<p><strong>如何跟踪大文件</strong></p>
<p>我们知道一个大的文件需要多个磁盘块，而inode中存放有磁盘块分配列表。那么一个固定大小的inode如何存储较长的分配列表呢？</p>
<img src="https://pic.imgdb.cn/item/631a5c7216f2c2beb1f0f560.jpg" style="zoom:80%;" />

<p>如图所示，这个文件需要14个数据块存储它的内容，因此，分配链表包含14个块的编号。但是文件的inode只包含一个含有13个项的分配链表。那么应该如何存放呢？</p>
<p>解决方案：将分配链表的前10个编号放到inode中，将最后4个编号放到一个数据块中：</p>
<ul>
<li>具体来说，就是该inode的链表包含分配13个块编号的空间，链表里的前10个项中的块编号指向的是文件的实际数据。</li>
<li>如果分配链表有多余10个的项，则剩下的块编号不是存储在inode，而是存储在数据区。</li>
<li>链表的第11项存储了存放多余编号的数据块的编号</li>
<li>如果仍然不够，链表的第12项（二级间接块）存放那个存储着第2、3、4及后继额外块的编号的块的编号</li>
<li>还是不够，使用第13项（三级间接块），加深一层递归</li>
<li>此时文件大小达到了极限，还要更大的空间就需要一个拥有更大的磁盘块构成的文件系统了。</li>
</ul>
<p><strong>Unix文件系统的改进</strong></p>
<p>不同版本的Unix使用前述文件系统模型的不同版本。这种方法很简洁，但存在一些问题：</p>
<ul>
<li>超级块如果损坏了，则整个文件系统的结构信息就没有了。因此新版本的Unix在文件系统中备份了这个块的副本</li>
<li>分块问题。由于文件的创建和删除，自由块将遍布磁盘。一种方案是在文件系统中创建被称为柱面组（cylinder group）的微文件系统</li>
</ul>
<h3 id="理解目录"><a href="#理解目录" class="headerlink" title="理解目录"></a>理解目录</h3><p><u>“x文件在目录a中”</u>的含义：</p>
<p>从系统角度看，目录a中有一个指向 文件x对应的i-节点号的链接（xLink），这个链接附加的文件名为x</p>
<p><u>“目录demodir包含子目录a”</u>的含义：</p>
<p>demodir包含一个指向子目录a对应的inode的链接</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[zhangqi@localhost chap4]$ <span class="built_in">ls</span> -iaR demodir/</span><br><span class="line">demodir/:</span><br><span class="line">37405773 .  17507719 ..  51681516 a  51681478 c  37405778 copy.of.x  37405777 x</span><br><span class="line"></span><br><span class="line">demodir/a:</span><br><span class="line">51681516 .  37405773 ..  51681517 x  51681518 y</span><br><span class="line"></span><br><span class="line">demodir/c:</span><br><span class="line">51681478 .  37405773 ..  17507718 d1  37405776 d2</span><br><span class="line"></span><br><span class="line">demodir/c/d1:</span><br><span class="line">17507718 .  51681478 ..  51681517 xlink</span><br><span class="line"></span><br><span class="line">demodir/c/d2:</span><br><span class="line">37405776 .  51681478 ..  37405775 xcopy</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><u>“目录a有一个父目录demodir”</u>的含义：</p>
<p>目录a中有一个 <code>..</code>的名字，为父目录的保留名字</p>
<p><u>多重链接及链接数</u></p>
<p>在demodir目录树中，inode 51681517有两个链接，一个在目录a中，称为x，另一个在目录d1中，称为xlink。那么哪个是原始文件，那个是指向它的链接呢？</p>
<p>在Unix的目录结构中，这两个链接的状态完全相同；它们被称为指向文件的硬链接。</p>
<p>文件是一个inode和一些数据块的结合；链接是对inode的引用。可以对一个文件创建任意多的链接</p>
<p>内核记录了一个文件的链接数，就inode 51681517来说，链接数至少是2。因为在文件系统的其他部分或许还存在着这个文件的其他链接。</p>
<p>链接数被记录在inode中，同时也是系统调用stat返回值stat结构中的一个成员</p>
<h4 id="与目录树相关的命令和系统调用"><a href="#与目录树相关的命令和系统调用" class="headerlink" title="与目录树相关的命令和系统调用"></a>与目录树相关的命令和系统调用</h4><p><strong>mkdir</strong></p>
<p>用于创建新的目录。它接受命令行上的一个或多个目录名，使用mkdir(2)系统调用.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure>

<p>实际上mkdir创建了一个新的目录节点并把它链接至文件系统树：</p>
<ul>
<li>mkdir创建了这个目录的inode</li>
<li>分配了一个磁盘块用以存储它的内容</li>
<li>在目录中设置了两个入口： <code>.</code>和 <code>..</code>并正确配置了它们的 i-节点号</li>
<li>在它的父目录中增加一个该节点的链接</li>
</ul>
<p><strong>rmdir</strong></p>
<p>用于删除一个目录，使用rmdir(2)系统调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rmdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure>

<p>rmdir从目录树中删除一个目录节点。这个目录必须是空的。即除了 <code>.</code>和 <code>..</code>的入口，这个目录不能包含其他任何的文件和子目录。同时在父目录中删除这个目录的链接，如果这个目录本身并未被其他进程占用，它的inode和数据块将被释放</p>
<p><strong>rm</strong></p>
<p>用来从一个目录文件中删除一条记录，接受命令行上一个或多个文件名，使用unlink(2)系统调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure>

<p>unlink用于删除目录文件中的一个记录，减少相应inode的链接数。如果该inode的链接数减为0，数据块和inode将被释放（和C++中shared_ptr的设计思想很像，妙）。unlink不能用于删除目录</p>
<p><strong>ln</strong></p>
<p>用来创建一个文件的链接，使用系统调用link(2)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">link</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *oldpath, <span class="type">const</span> <span class="type">char</span> *newpath)</span>;</span><br></pre></td></tr></table></figure>

<p>link不能用来生成目录的新链接</p>
<p><strong>mv</strong></p>
<p>用来改变文件和目录的名字或位置。很多情况下mv仅仅使用系统调用rename</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rename</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *oldpath, <span class="type">const</span> <span class="type">char</span> *newpath)</span>;</span><br></pre></td></tr></table></figure>

<p>当入参位于同一个目录时，即实现了重命名</p>
<p>当入参位于不同的目录时，即实现了移动，由于实际上目录中存放的是链接，因此就是把链接从一个目录移动到另一个目录：</p>
<ul>
<li>复制链接至新的名字&#x2F;位置（调用link()）</li>
<li>删除原来的链接（调用unlink()）</li>
</ul>
<p>实际上过去没有rename这个系统调用，而是结合link和unlink使用，新增的目的是：</p>
<ul>
<li>rename使重命名或重定位一个目录变得更加安全</li>
<li>可以支持非Unix系统。将通用方法rename添加至内核隐藏了实现的细节，使相同的代码能够在各种文件系统上运行</li>
</ul>
<p><strong>cd</strong></p>
<p>用来改变进程的当前目录。cd对进程产生影响，但是并不影响目录。</p>
<p>cd使用系统调用chdir()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span>;</span><br></pre></td></tr></table></figure>

<p>Unix上的每个运行程序都有一个当前目录，chdir系统调用改变进程的当前目录。在系统内部，进程有一个存放当前目录 i-节点号的变量。从一个目录进入另一个目录只是改变那个变量的值</p>
<h3 id="编写pwd"><a href="#编写pwd" class="headerlink" title="编写pwd"></a>编写pwd</h3><p>命令pwd用来显式到达当前目录的路径</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zhangqi@localhost chap4]$ <span class="built_in">pwd</span></span><br><span class="line">/home/zhangqi/ZZQ/test/chap4</span><br></pre></td></tr></table></figure>

<p>这个路径并不位于当前的目录中，当前目录称呼其本身为<code>.</code>  ，并且有一个 i-节点号。</p>
<p>因此要获得完整的路径名，要追踪链接，读取目录，一个目录接着一个目录地沿着树向上追踪，每步查看 <code>.</code>的节点号（自身的节点号），然后<u>在父目录中查找该 inode的名字</u>，直到到达树的顶端。</p>
<p>伪代码：</p>
<p>while(没有到达树的顶端){</p>
<p>​        得到 <code>.</code>的i-节点号，称其为n（使用stat）</p>
<p>​        chdir.. （使用chdir）</p>
<p>​        找到 i-节点号 n链接的名字（使用opendir、readdir 、closedir）</p>
<p>}</p>
<p>如何判断是否达到树的顶端：判断直到一个目录的 <code>.</code>和 <code>..</code>的 i-节点号相同时</p>
<p>如何以证券顺序显示目录名字：建立一个循环，使用strcat或sprintf建立目录名字的字符串序列。通过一个递归的程序逐步到达树的顶端来一个接一个地显示目录名，从而避免了字符串的管理</p>
<p><strong>pwd的实现</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// spwd.c: a simplified version of pwd</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// starts in current directory and recursively</span></span><br><span class="line"><span class="comment">// climbs up to root of filesystem, prints top part</span></span><br><span class="line"><span class="comment">// then prints current part</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// uses readdir() to get info about each thing</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">ino_t</span> <span class="title function_">get_ino</span><span class="params">(<span class="type">char</span> *dir)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">printpath</span><span class="params">(<span class="type">ino_t</span> this_inode)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">inode_num_to_name</span><span class="params">(<span class="type">ino_t</span> this_ino, <span class="type">char</span> this_inode_name[BUFSIZ])</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">int</span> ino = get_ino(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (ino == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;/\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">  &#125;</span><br><span class="line">  printpath(ino);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// prints path leadin down to an object with this inode</span></span><br><span class="line"><span class="comment">// kindof recursive</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">printpath</span><span class="params">(<span class="type">ino_t</span> this_ino)</span> &#123;</span><br><span class="line">  <span class="type">char</span> this_inode_name[BUFSIZ];</span><br><span class="line">  <span class="type">ino_t</span> father_inode_num = get_ino(<span class="string">&quot;..&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (father_inode_num != this_ino) &#123;</span><br><span class="line">    inode_num_to_name(this_ino, this_inode_name);</span><br><span class="line">    chdir(<span class="string">&quot;..&quot;</span>);</span><br><span class="line">    printpath(father_inode_num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;/%s&quot;</span>, this_inode_name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// returns inode number of the file</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">ino_t</span> <span class="title function_">get_ino</span><span class="params">(<span class="type">char</span> *dir)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">info</span>;</span></span><br><span class="line">  <span class="keyword">if</span> (stat(dir, &amp;info) == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Cannot stat &quot;</span>);</span><br><span class="line">    perror(dir);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> info.st_ino;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// looks through current directory for a file with this inode</span></span><br><span class="line"><span class="comment">// number and copies its name into namebuf</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">inode_num_to_name</span><span class="params">(<span class="type">ino_t</span> this_ino, <span class="type">char</span> this_inode_name[])</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dirent_p</span>;</span></span><br><span class="line">  DIR *dir_p = opendir(<span class="string">&quot;..&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (dir_p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;..&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// search directory for a file with specified inum</span></span><br><span class="line">  <span class="keyword">while</span> ((dirent_p = readdir(dir_p)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dirent_p-&gt;d_ino == this_ino) &#123;</span><br><span class="line">      <span class="built_in">strcpy</span>(this_inode_name, dirent_p-&gt;d_name);</span><br><span class="line">      closedir(dir_p);</span><br><span class="line">      <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;error looking from inum %ld\n&quot;</span>, this_ino);</span><br><span class="line">  <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="连接控制：学习stty"><a href="#连接控制：学习stty" class="headerlink" title="连接控制：学习stty"></a>连接控制：学习stty</h2><p>计算机除了文件和目录相关的程序，还有其他的数据来源，如调制解调器、打印机、扫描仪、鼠标、扬声器、照相机和终端等这样的设备。</p>
<p>设备的读写方法：对Unix来说，声卡，终端，鼠标和磁盘文件是同一种对象。在Unix系统中，每个设备都被当做一个文件。每个设备都有一个文件名，一个i-节点号、一个文件所有者、一个权限位的集合和最近修改时间。</p>
<p>和文件有关的所有内容都将被运用于终端和其他设备</p>
<p><strong>设备具有文件名</strong></p>
<p>通常表示设备的文件存放在目录&#x2F;dev中（devices），但是可以在任何目录中创建设备文件。</p>
<p>查看我的机器上的&#x2F;dev目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -C /dev | <span class="built_in">head</span> -5</span><br><span class="line">agpgart		 kmsg		     rtc       tty2   tty44  ttyS2</span><br><span class="line">autofs		 <span class="built_in">log</span>		     rtc0      tty20  tty45  ttyS3</span><br><span class="line">block		 loop0		     sda       tty21  tty46  uhid</span><br><span class="line">bsg		 loop1		     sda1      tty22  tty47  uinput</span><br><span class="line">btrfs-control	 loop2		     sda2      tty23  tty48  urandom</span><br></pre></td></tr></table></figure>

<p><strong>相关系统调用</strong></p>
<p>设备不仅具有文件名，还支持所有与文件相关的系统调用：open、read、write、lseek、close和stat</p>
<p>实际上Unix没有其他的方法用来和设备通信。</p>
<p><strong>设备文件的属性</strong></p>
<p>（这部分没有太理解，暂时简单记录并略过）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -li /dev/pts/1</span><br><span class="line">4 crw--w----. 1 zhangqi <span class="built_in">tty</span> 136, 1 Sep 10  2022 /dev/pts/1</span><br></pre></td></tr></table></figure>

<p>设备文件具有磁盘文件的大部分属性。如上面ls的输出内容表明&#x2F;dev&#x2F;pts&#x2F;1 拥有inode 4，权限位为rw–w—-，1个链接，文件所有者zhangqi和组tty，最近修改时间为Sep 10 2022。文件类型为“c”，表示这个文件实际上是以字符为单位进行传送的设备</p>
<p>常用的磁盘文件中的字节数就是文件的大小。但设备文件是链接而不是容器。键盘和鼠标不存储击键数和点击数。</p>
<p>设备文件的inode存储的是指向内核子程序的指针，而不是文件的大小和存储列表。</p>
<p>内核中传输设备数据的子程序被称为设备驱动程序。</p>
<p>在&#x2F;dev&#x2F;pts&#x2F;1中，参数是1。136和1这两个数被称为设备的主设备号和从设备号：</p>
<ul>
<li>主设备号确定处理该设备实际的子程序</li>
<li>从设备号被作为参数传输到该子程序</li>
</ul>
<p><u>设备文件的读写执行权限：</u></p>
<p>当文件实际上表示设备时</p>
<ul>
<li>向文件写入数据就是把数据发送到设备，权限写意味着允许发送数据</li>
<li>读文件就是从文件获得数据</li>
</ul>
<p><strong>Unix文件系统的inode和数据块是如何支持设备文件的概念的：</strong></p>
<img src="https://pic.imgdb.cn/item/631b7f3416f2c2beb1389f1d.jpg" style="zoom:80%;" />

<ul>
<li>目录并不能区分哪些文件名代表磁盘文件，哪些文件名代表设备</li>
<li>文件类型的区别体现在inode上：<ul>
<li>每个inode的类型被记录在结构stat的成员变量st_mode的类型区域中</li>
<li>磁盘文件的inode包含指向数据块的指针。设备文件的inode包含指向内核子程序表的指针</li>
<li>主设备号用于告知从设备读取数据的那部分代码的位置</li>
</ul>
</li>
<li>考虑read的工作流程（其他如open、write、lseek和close等都是类似的）：<ul>
<li>内核首先找到文件描述符fd的inode，该inode用于告诉内核文件的类型</li>
<li>如果文件是磁盘文件，那么内核通过访问块分配表来读取数据</li>
<li>如果文件是设备文件，那么内核通过调用该设备驱动程序的read部分来读取数据</li>
</ul>
</li>
</ul>
<p><strong>设备和文件的不同之处</strong></p>
<img src="https://pic.imgdb.cn/item/631b812616f2c2beb13aa6ff.jpg" style="zoom:80%;" />

<p>系统通过调用open创建文件和设备与进程的连接，但是他们有着不同的性质。<br><strong>磁盘连接</strong>的两个主要属性：</p>
<ul>
<li>缓冲：磁盘文件有缓冲区，可以通过fcntl()关闭</li>
<li>自动添加模式：即当文件描述符的O_APPEND打开后，每个对write的调用自动调用lseek将内容添加到文件末尾。</li>
</ul>
<p><strong>终端连接</strong>：<br>具有回显，波特率， 编辑和换行会话。</p>
<p><strong>相关系统调用</strong><br>fcntl：控制文件描述符<br>ioctl：控制一个设备<br>tcsetattr:设置tty驱动程序的属性<br>tcgetattr:读取tty驱动程序的属性</p>
<p><strong>终端</strong><br>终端是人们用来和unix进程进行通信的设备。终端拥有一个可以让进程读取字符的键盘和可让进程发送字符的显示器。<br>进程与终端间的数据传输和数据处理由<u>终端驱动程序</u>负责，终端驱动程序是内核的一部分，该部分代码提供缓冲，编辑和数据转换</p>
<img src="https://pic.imgdb.cn/item/631b843116f2c2beb13d11fd.jpg" style="zoom:80%;" />

<p><strong>stty命令</strong></p>
<p>stty命令让用户读取和修改终端驱动程序的设置</p>
<p>使用stty显示驱动程序设置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">stty</span></span><br><span class="line">speed 38400 baud; line = 0;</span><br><span class="line">eol = M-^?; eol2 = M-^?; swtch = M-^?;</span><br><span class="line">ixany iutf8</span><br></pre></td></tr></table></figure>

<p><strong>使用stty改变驱动程序属性</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">stty</span> erase X     <span class="comment">#将删除键改为X</span></span><br><span class="line">$ <span class="built_in">stty</span> - <span class="built_in">echo</span>      <span class="comment">#关闭按键显示，即输入的字符不显示在屏幕上</span></span><br><span class="line">$ <span class="built_in">stty</span> erase @ <span class="built_in">echo</span> <span class="comment">#复合命令：将删除键改为@，并打开按键显示</span></span><br></pre></td></tr></table></figure>

<p><strong>编写终端驱动程序</strong></p>
<p>tty驱动程序包含很多对传入的数据所进行的操作。这些操作分为4种：</p>
<ul>
<li>输入：如何处理从终端来的字符。包括将小写转换为大写，去除最高位及将回车符转换为换行符</li>
<li>输出：如何处理流向终端的字符。用若干个空格符代替制表符，将换行符转换为回车符及将小写字母转换为大写字母</li>
<li>控制：字符如何被表示——位的个数、位的奇偶性、停止位等</li>
<li>本地：如何处理来自驱动程序内部的字符。包括回显字符给用户及缓冲输入直到用户按回车键</li>
</ul>
<h2 id="为用户编程：终端控制和信号"><a href="#为用户编程：终端控制和信号" class="headerlink" title="为用户编程：终端控制和信号"></a>为用户编程：终端控制和信号</h2><p><strong>软件工具与针对特定设备编写的程序</strong></p>
<p>软件工具：对磁盘文件和设备文件不加以区分的程序（Unix中有好几百个，如who、ls、sort等）</p>
<ul>
<li>从标准输入stdin或文件读取字节，进行一些处理，然后将包含结果的字节流写到标准输出stdout</li>
<li>工具发送错误消息到标准错误输出，它们也被当作简单的字节流来处理。</li>
<li>这些文件描述符能够连接到文件、终端、鼠标、光电管、打印机等</li>
<li>工具对所处理的数据的源和目的地不做任何假设</li>
<li>其他很多程序也能从命令行所指定的文件中读取数据</li>
</ul>
<img src="https://pic.imgdb.cn/item/631b932c16f2c2beb1479ce0.jpg" style="zoom:80%;" />
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://www.zzzzzq.com/2022/08/30/UNIX/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
    
      <a href="/2022/08/30/Interview-muduo/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">muduo高性能网络服务器库学习笔记</div>
      </a>
    
  </nav>

   
<!-- valine评论 -->
<div id="vcomments-box">
  <div id="vcomments"></div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdn.staticfile.org/valine/1.4.16/Valine.min.js"></script>
<script>
  new Valine({
    el: "#vcomments",
    app_id: "5J2nSr5DoqBGRRnpdFfTvawi-gzGzoHsz",
    app_key: "24GWRfKBASGr6cA5FSBF4NY4",
    path: window.location.pathname,
    avatar: "monsterid",
    placeholder: "给我的文章加点评论吧~",
    recordIP: true,
  });
  const infoEle = document.querySelector("#vcomments .info");
  if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
    infoEle.childNodes.forEach(function (item) {
      item.parentNode.removeChild(item);
    });
  }
</script>
<style>
  #vcomments-box {
    padding: 5px 30px;
  }

  @media screen and (max-width: 800px) {
    #vcomments-box {
      padding: 5px 0px;
    }
  }

  #vcomments-box #vcomments {
    background-color: #fff;
  }

  .v .vlist .vcard .vh {
    padding-right: 20px;
  }

  .v .vlist .vcard {
    padding-left: 10px;
  }
</style>

 
   
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022
        <i class="ri-heart-fill heart_icon"></i> ZHU
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Keep Making Progress"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>