<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="朱章齐的个人技术网站" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>UNIX/Linux学习记录 |  Keep Making Progress</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="Keep Making Progress" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-UNIX"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  UNIX/Linux学习记录
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/08/30/UNIX/" class="article-date">
  <time datetime="2022-08-29T18:33:50.000Z" itemprop="datePublished">2022-08-30</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">57.7k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">248 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <p>本文主要记录了阅读《UNIX&#x2F;Linux编程实践教程》过程中的学习笔记</p>
<span id="more"></span>

<h2 id="环境配置相关问题"><a href="#环境配置相关问题" class="headerlink" title="环境配置相关问题"></a>环境配置相关问题</h2><p><strong>centos7更换镜像源：</strong></p>
<ol>
<li><p>安装wget<br><code>yum install -y wget</code></p>
</li>
<li><p>备份服务器原有的yum源文件<br><code>mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</code></p>
</li>
<li><p>下载阿里云镜像文件<br><code>wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</code></p>
</li>
<li><p>清理缓存<br><code>yum clean all</code></p>
</li>
<li><p>生成缓存<br><code>yum makecache</code></p>
</li>
<li><p>更新最新源设置<br><code>yum update -y</code></p>
</li>
</ol>
<p><strong>vim插件的使用</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.linuxidc.com/Linux/2016-06/132262.htm">参考文档</a></p>
<p><strong>安装管理vim插件的插件pathogen</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> -p ~/.vim/autoload ~/.vim/bundle &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">curl -LSso ~/.vim/autoload/pathogen.vim https://tpo.pe/pathogen.vim</span></span><br></pre></td></tr></table></figure>

<p>创建该插件所需要的目录， 把 pathogen.vim 安装在 ~&#x2F;.vim&#x2F;autoload 目录，vim 会自动载入这个目录下的 pathogen 插件（目录名 autoload 顾名思义），将插件交给 pathogen 管理。创建 ~&#x2F;.vim&#x2F;bundle 目录是用来存放管理以后要安装插件。</p>
<p>在 .vimrc 里配置，加上下面这句话，意思是执行这个函数 infect()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">execute pathogen#infect()</span><br><span class="line"></span><br><span class="line"># 如果没有 .vimrc 文件， 则 vim ~/.vimrc ，然后黏贴下面这几句话</span><br><span class="line"></span><br><span class="line">execute pathogen#infect()</span><br><span class="line">syntax on</span><br><span class="line">filetype plugin indent on</span><br></pre></td></tr></table></figure>

<p>以后直接把插件安装到<code>~/.vim/bundle</code>目录下即可</p>
<p><strong>auto-pairs自动补齐括号、引号插件</strong></p>
<p>在 <code>~/.vim/bundle</code>目录下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> git@github.com:jiangmiao/auto-pairs.git</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>NERDTree树状文件列表</strong></p>
<p>安装：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> git@github.com:preservim/nerdtree.git</span></span><br></pre></td></tr></table></figure>



<ul>
<li>打开NERDTree： shift + : 然后输入 NERDTree 可看到结果</li>
<li>ctrl + w + h 光标切换到左侧树形目录</li>
<li>ctrl + w  + l 光标切换到右侧文件显示窗口</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.programminghunter.com/article/7761796988/">更多使用方式</a></p>
<p><strong>安装 MiniBufExplorer 的改进版</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@github.com:fholgado/minibufexpl.vim.git ~/.vim/bundle/minibufexpl</span><br></pre></td></tr></table></figure>

<p>测试, 可以打开多个 buffer, :vsp 加文件名</p>
<p><strong>taglist</strong></p>
<p>taglist 依赖 ctags ，默认自带， 没有就自己安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install ctags</span><br></pre></td></tr></table></figure>

<p>下载 taglist 到 bundle 目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:vim-scripts/taglist.vim.git</span><br></pre></td></tr></table></figure>

<p>测试， 用 vim 打开一个文件，然后输入 TlistToggle </p>
<p>注意修改完文件后要保存重新进以后才能更新tag</p>
<p><strong>C++自动补齐插件OmniCppComplete</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:vim-scripts/OmniCppComplete.git</span><br></pre></td></tr></table></figure>

<p>在 test 目录，生成 tags 文件，这样才能自动补全：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctags -R --<span class="built_in">sort</span>=<span class="built_in">yes</span> --c++-kinds=+p --fields=+iaS --extra=+q --language-force=C++</span><br><span class="line"><span class="comment">#ctags -R --c++-kinds=+p --fields=+iaS --extra=+q ./</span></span><br></pre></td></tr></table></figure>

<p>自动补全快捷键 ctr+x ctr+o ， 上下选择快捷键 ctr+n ctr+p。</p>
<p>全部配置完成后的.vimrc</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">execute pathogen#infect()</span><br><span class="line">syntax on</span><br><span class="line">filetype plugin indent on</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">&quot; Tag List (ctags)</span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">&quot;set mouse=a  &quot; always use mouse</span><br><span class="line">let Tlist_Ctags_Cmd = &#x27;/usr/bin/ctags&#x27;</span><br><span class="line">let Tlist_Show_One_File = 1        &quot;不同时显示多个文件的tag，只显示当前文件的</span><br><span class="line">let Tlist_Exit_OnlyWindow = 1      &quot;如果taglist窗口是最后一个窗口，则退出vim</span><br><span class="line">let Tlist_Use_Right_Wiset = 1</span><br><span class="line">let Tlist_Sort_Type=&quot;name&quot;   &quot; tag按名字排序</span><br><span class="line"></span><br><span class="line">set tags+=~/.vim/tags/cpp_src/tags</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">&quot; omnicppcomplete</span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">filetype plugin indent on</span><br><span class="line">set completeopt=longest,menu</span><br><span class="line">let OmniCpp_NamespaceSearch = 2     &quot; search namespaces in the current buffer   and in included files</span><br><span class="line">let OmniCpp_ShowPrototypeInAbbr = 1 &quot; 显示函数参数列表</span><br><span class="line">let OmniCpp_MayCompleteScope = 1    &quot; 输入 :: 后自动补全</span><br><span class="line">let OmniCpp_DefaultNamespaces = [&quot;std&quot;, &quot;_GLIBCXX_STD&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h2><p>注意所有命令几乎都是人为编写的程序（大多都是C语言写的）</p>
<p>在Unix系统下增加新的命令只需要把程序的可执行文件放到以下任意目录即可：</p>
<ul>
<li><code>/bin</code></li>
<li><code>/usr/bin</code></li>
<li><code>/usr/local/bin</code></li>
</ul>
<p>目录树样例：</p>
<img src="https://pic.imgdb.cn/item/630dda6d16f2c2beb100702a.jpg" style="zoom:80%;" />

<p><strong>程序运行和注销</strong></p>
<ul>
<li><code>exit</code>用于注销已运行的程序</li>
<li></li>
</ul>
<p><strong>目录操作</strong></p>
<ul>
<li><code>ls</code>：列出目录内容<ul>
<li><code>ls /</code>：列出根目录内容</li>
</ul>
</li>
<li><code>cd</code>：改变当前目录<ul>
<li><code>cd ..</code>：回退到上一层目录</li>
</ul>
</li>
<li><code>pwd</code>：显示当前目录路径</li>
<li><code>mkdir</code> <code>rmdir</code>：新建、删除目录</li>
</ul>
<p><strong>文件操作</strong></p>
<p>注意文件名不能包含根目录符号 <code>/</code></p>
<ul>
<li><code>cat</code> <code>more</code> <code>less</code> <code>pg</code> 查看文件内容</li>
<li><code>cp</code>：文件赋值</li>
<li><code>rm</code>：文件删除（注意Unix不提供恢复被删除文件的功能，其中一个原因是由于Unix是一个多用户系统，文件被删掉以后存储空间可能立即被分配给其他用户的文件）</li>
<li><code>mv</code>：重命名或移动文件</li>
<li><code>lpr</code>：打印文件</li>
<li><code>ls -l</code>：查看文件详细信息，可以看到文件权限<ul>
<li>共三组rwx，表示user group other是否可以read write excute</li>
</ul>
</li>
</ul>
<p><strong>bc： Unix计算器</strong></p>
<p>输入bc即可启动计算器，使用Ctrl + D退出</p>
<p>bc还是可编程的，语法与C语言类似</p>
<p><strong>其他</strong></p>
<ul>
<li><p><code>ps</code>：列出系统中运行的所有进程</p>
</li>
<li><p><code>man</code>：查看帮助</p>
<ul>
<li>使用 <code>man -k</code>可以根据关键字搜索联机帮助</li>
</ul>
</li>
<li><p><code>who</code>：列出当前系统中活动的用户</p>
</li>
</ul>
<h2 id="设计自己的who命令"><a href="#设计自己的who命令" class="headerlink" title="设计自己的who命令"></a>设计自己的who命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">man <span class="built_in">who</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">根据描述可以发现<span class="built_in">who</span>是用于查询所有登录用户的信息的，放在文件/var/run/utmp中</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">man -k utmp</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">man 5 utmp</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">可以找到utmp的数据结构</span></span><br></pre></td></tr></table></figure>

<p><strong>问题：如何从文件中读取数据结构</strong></p>
<p>可以在帮助中寻找答案，寻找与file和read相关的帮助。</p>
<p>由于man命令选项-k(根据关键字查找)只支持一个关键字的查找，可以借助grep命令查找（使用正则表达式搜索文本，并打印匹配的行）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">man -k file | grep <span class="built_in">read</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">man 2 <span class="built_in">read</span></span></span><br></pre></td></tr></table></figure>

<p>查看read系统调用的说明</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">       read - read from a file descriptor</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       #include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">       ssize_t read(int fd, void *buf, size_t count);</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       read()  attempts to read up to count bytes from file descriptor fd into</span><br><span class="line">       the buffer starting at buf.</span><br><span class="line"></span><br><span class="line">       On files that support seeking, the read operation commences at the cur‐</span><br><span class="line">       rent  file  offset, and the file offset is incremented by the number of</span><br><span class="line">       bytes read.  If the current file offset is at or past the end of  file,</span><br><span class="line">       no bytes are read, and read() returns zero.</span><br><span class="line"></span><br><span class="line">       If count is zero, read() may detect the errors described below.  In the</span><br><span class="line">       absence of any errors, or if read() does not check for errors, a read()</span><br><span class="line">       with a count of 0 returns zero and has no other effects.</span><br><span class="line">       </span><br><span class="line">       If count is greater than SSIZE_MAX, the result is unspecified.</span><br><span class="line">       </span><br><span class="line"> ......</span><br><span class="line"> </span><br><span class="line"> SEE ALSO</span><br><span class="line">       close(2), fcntl(2), ioctl(2), lseek(2), open(2), pread(2),  readdir(2),</span><br><span class="line">       readlink(2), readv(2), select(2), write(2), fread(3)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这个系统调用可以将一定数目的字节读入一个缓冲区。</p>
</li>
<li><p>因为每次都要读入一个数据结构，所以要用<code>sizeof(struct utmp)</code>来指定每次读入的字节数</p>
</li>
<li><p>read()需要一个文件描述符作为输入参数，文件描述符通过open()获取</p>
</li>
</ul>
<p><strong>答案：使用open、read和close</strong></p>
<ol>
<li>打开一个文件：<code>int open(const char *pathname, int flags);</code><ul>
<li>这个系统调用在进程和文件之间建立一条连接，这个连接被称为文件描述符，它就像一条由进程通向内核的管道。</li>
<li>如果文件被顺利打开，内核就会返回一个正整数的值，即文件描述符，用来唯一标识这个连接。（打开不同的文件或者同一文件打开多次得到的文件描述符是不同的）</li>
<li>The argument flags must include one  of  the  following  access  modes: O_RDONLY,  O_WRONLY,  or  O_RDWR.  These request opening the file read-only, write-only, or read&#x2F;write, respectively.</li>
</ul>
</li>
<li>从文件读取数据：<code>ssize_t read(int fd, void *buf, size_t count);</code><ul>
<li>这个系统调用请求内核从fd指定的文件中读取count字节的数据，存放到buf所指定的内存空间中，如果成功读取了数据，就返回读取的字节数目，否则返回-1.</li>
</ul>
</li>
<li>关闭文件：<code>int close(int fd);</code><ul>
<li>当不需要对文件进行读写操作时，就把文件关闭</li>
<li>这个系统调用会关闭进程和文件fd之间的连接，如果关闭的过程中出现错误，close返回-1，如：fd所指的文件不存在等</li>
</ul>
</li>
</ol>
<p><strong>编写who1.c</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;utmp.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHOWHOST</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">utmp</span>  <span class="title">current_record</span>;</span> </span><br><span class="line">    <span class="type">int</span>     utmpfd; <span class="comment">//存储utmp文件的文件描述符</span></span><br><span class="line">    <span class="type">int</span>     reclen = <span class="keyword">sizeof</span>(current_record);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//UTMP_FILE定义在/usr/include/utmp.h中， O_RDONLY表示只读模式打开文件</span></span><br><span class="line">    <span class="keyword">if</span>((utmpfd = open(UTMP_FILE, O_RDONLY)) == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(UTMP_FILE);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一次读取一个数据结构，重复到读完为之</span></span><br><span class="line">    <span class="keyword">while</span>(read(utmpfd, &amp;current_record,reclen) == reclen)&#123;</span><br><span class="line">        show_info(&amp;current_record);</span><br><span class="line">    &#125;</span><br><span class="line">    close(utmpfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示登录信息</span></span><br><span class="line">show_info(<span class="keyword">struct</span> utmp *utbufp)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;% - 8.8s&quot;</span>,utbufp-&gt;ut_name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;% - 8.8s&quot;</span>,utbufp-&gt;ut_line);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%10ld&quot;</span>,utbufp-&gt;ut_time);<span class="comment">//以long int格式输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHOWHOST</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,utbufp-&gt;ut_line);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将上述代码编译、运行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cc who1.c -o who1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./who1</span></span><br></pre></td></tr></table></figure>

<p>与系统的who命令输出对比</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[zhangqi@localhost test]$ who</span><br><span class="line">zhangqi  :0           2022-08-30 06:58 (:0)</span><br><span class="line">zhangqi  pts/0        2022-08-31 01:59 (:0)</span><br><span class="line"></span><br><span class="line">[zhangqi@localhost test]$ ./who1</span><br><span class="line">reboot   ~        1661813849 ~</span><br><span class="line">runlevel ~        1661813884 ~</span><br><span class="line">zhangqi  :0       1661813911 :0</span><br><span class="line">zhangqi  pts/0    1661882367 pts/0</span><br></pre></td></tr></table></figure>

<p>存在问题：</p>
<ol>
<li>需要消除空白记录</li>
<li>登陆时间没有正确显示</li>
</ol>
<p><strong>编写who2.c</strong></p>
<ul>
<li><p>如何消除空白记录：</p>
<ul>
<li><p>空白记录产生的原因是utmp包含所有终端的信息，包括那些尚未被用到的终端信息。</p>
</li>
<li><p>因此要做到能够区分出哪些终端对应活动的用户：</p>
<ul>
<li><p>在utmp.h中定义了如下内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* Values for ut_type field, below */</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define EMPTY         0 /* Record does not contain valid info (formerly known as UT_UNKNOWN on Linux) */</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define RUN_LVL       1 /* Change <span class="keyword">in</span> system run-level (see init(8)) */</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define BOOT_TIME     2 /* Time of system boot (<span class="keyword">in</span> ut_tv) */</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define NEW_TIME      3 /* Time after system clock change (<span class="keyword">in</span> ut_tv) */</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define OLD_TIME      4 /* Time before system clock change (<span class="keyword">in</span> ut_tv) */</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define INIT_PROCESS  5 /* Process spawned by init(8) */</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define LOGIN_PROCESS 6 /* Session leader process <span class="keyword">for</span> user login */</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define USER_PROCESS  7 /* Normal process */</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define DEAD_PROCESS  8 /* Terminated process */</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define ACCOUNTING    9 /* Not implemented */</span></span><br></pre></td></tr></table></figure>

<p>可知utmp结构中的ut_type成员，当其值为7（USER_PROCESS）时，表示这是一个已经登录的用户</p>
</li>
<li><p>因此对原程序进行修改（我的方式是在while循环中增加判断，不走show_info，书中是在show_info中进行判断的）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(read(utmpfd, &amp;current_record,reclen) == reclen)&#123;</span><br><span class="line">    <span class="keyword">if</span>((&amp;current_record)-&gt;ut_type != USER_PROCESS) <span class="keyword">continue</span>;</span><br><span class="line">    show_info(&amp;current_record);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>以可读的方式显示登录时间</p>
<ul>
<li><p>可在联机帮助中搜索关于时间的主题：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">man -k time</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">man -k time | grep transform</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">man -k time | grep -i convert</span></span><br></pre></td></tr></table></figure>

<p>可以发现很多记录都涉及到time.h</p>
</li>
<li><p>了解可的值Unix储存时间的方式是 time_t数据类型 time.h中有<code>typedef lont int time_t</code>，表示从1970年1月1日0时开始所经过的秒数</p>
</li>
<li><p>将time_t显示出来用到ctime，将整数值转换为常用的时间形式：</p>
<p><code>char *ctime(const time_t *timep);</code></p>
</li>
<li><p>注意不是所有的字符串内容都需要（去掉周几和年份，只返回ctime返回字符串从第4个字符串开始的12个字符）</p>
<p><code>printf(&quot;%12.12s&quot;,ctime(&amp;t) + 4);</code></p>
</li>
</ul>
</li>
</ul>
<p>整体代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;utmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHOWHOST</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">display_time</span><span class="params">(<span class="type">long</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">show_info</span><span class="params">(<span class="keyword">struct</span> utmp*)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">utmp</span> <span class="title">current_record</span>;</span></span><br><span class="line">        <span class="type">int</span>     utmpfd;</span><br><span class="line">        <span class="type">int</span>     reclen = <span class="keyword">sizeof</span>(current_record);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((utmpfd = open(UTMP_FILE, O_RDONLY)) == <span class="number">-1</span>)&#123;</span><br><span class="line">                perror(UTMP_FILE);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(read(utmpfd, &amp;current_record,reclen) == reclen)&#123;</span><br><span class="line">                <span class="keyword">if</span>((&amp;current_record)-&gt;ut_type != USER_PROCESS) <span class="keyword">continue</span>;</span><br><span class="line">                show_info(&amp;current_record);</span><br><span class="line">        &#125;</span><br><span class="line">        close(utmpfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_info</span><span class="params">(<span class="keyword">struct</span> utmp *utbufp)</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;% - 8.8s&quot;</span>,utbufp-&gt;ut_name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;% - 8.8s&quot;</span>,utbufp-&gt;ut_line);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        display_time(utbufp-&gt;ut_time);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHOWHOST</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,utbufp-&gt;ut_line);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">display_time</span><span class="params">(<span class="type">long</span> timeval)</span>&#123;</span><br><span class="line">        <span class="type">char</span>* cp;</span><br><span class="line">        cp = ctime(&amp;timeval);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%12.12s&quot;</span>,cp + <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编写cp（读和写）"><a href="#编写cp（读和写）" class="headerlink" title="编写cp（读和写）"></a>编写cp（读和写）</h3><p><strong>cp命令的典型用法：</strong></p>
<p><code>cp source-file target-file</code></p>
<p>如果target-file所指定的文件不存在，cp就创建这个文件，如果已经存在就覆盖，target-file的内容与source-file相同</p>
<p><strong>cp命令是如何创建&#x2F;重写文件的</strong></p>
<ul>
<li><p>其中一种方法是使用系统调用函数creat：</p>
<p><code>int creat(const char *pathname, mode_t mode);</code></p>
<ul>
<li><p>creat告诉内核创建一个名为pathname的文件，如果这个文件不存在，就创建它，如果已经存在，就把它的内容清空，把文件长度设为0</p>
</li>
<li><p>如果内核成功创建了文件，那么文件的许可位（permission bits）被设置为由第2个参数mode所指定的值，如：</p>
<p><code>fd = creat(&quot;addressbook&quot;, 0644);</code></p>
<p>创建一个名为addressbook的文件，如果文件不存在，那么文件的许可位被设为rw-r-r–</p>
<p>返回值是指向addressbook的文件描述符</p>
</li>
</ul>
</li>
<li><p>用write系统调用向已打开的文件中写入数据：</p>
<p><code>ssize_t write(int fd, const void *buf, size_t count);</code></p>
<ul>
<li>fd文件描述符，buf内存数据，count要写的字节数</li>
<li>写入失败返回-1，写入成功返回写入的字节数</li>
<li>注意实际写入的字节数可能少于count（有的系统对文件最大尺寸有限制或磁盘空间接近满了）</li>
<li>因此调用write后必须检查返回值是否与要写入的相同，若不同作出相应的处理</li>
</ul>
</li>
</ul>
<p>完整代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFERSIZE 4096</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COPYMODE 0644</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">oops</span><span class="params">(<span class="type">char</span> *, <span class="type">char</span> *)</span>;</span><br><span class="line"></span><br><span class="line">main(<span class="type">int</span> ac, <span class="type">char</span> *av[])&#123;</span><br><span class="line">        <span class="type">int</span>     in_fd, out_fd, n_chars;</span><br><span class="line">        <span class="type">char</span>    buf[BUFFERSIZE];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ac!=<span class="number">3</span>)&#123; </span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s source destination\n&quot;</span>, *av);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((in_fd = open(av[<span class="number">1</span>],O_RDONLY)) == <span class="number">-1</span>)<span class="comment">//判断能否打开</span></span><br><span class="line">                oops(<span class="string">&quot;Cannot open &quot;</span>, av[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>((out_fd = creat(av[<span class="number">2</span>],COPYMODE)) == <span class="number">-1</span>)<span class="comment">//判断能否创建</span></span><br><span class="line">                oops(<span class="string">&quot;Cannot creat &quot;</span>, av[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>((n_chars = read(in_fd, buf, BUFFERSIZE)) &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span>(write(out_fd,buf,n_chars) != n_chars)</span><br><span class="line">                        oops(<span class="string">&quot;Write error to &quot;</span>,av[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">if</span>(n_chars == <span class="number">-1</span>)</span><br><span class="line">                oops(<span class="string">&quot;Read error from &quot;</span>,av[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(close(in_fd) == <span class="number">-1</span> || close(out_fd) == <span class="number">-1</span>)</span><br><span class="line">                oops(<span class="string">&quot;Error closing files&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">oops</span><span class="params">(<span class="type">char</span> *s1, <span class="type">char</span> *s2)</span>&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Error: %s&quot;</span>,s1);</span><br><span class="line">        perror(s2);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译并测试：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cc cp1.c -o cp1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./cp1 cp1 copy.of.cp1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmp cp1 copy.of.cp1 <span class="comment">#Unix自带的文件比较工具cmp，无任何提示则说明内容完全相同</span></span></span><br></pre></td></tr></table></figure>

<h3 id="提高文件I-x2F-O效率的方法：使用缓冲"><a href="#提高文件I-x2F-O效率的方法：使用缓冲" class="headerlink" title="提高文件I&#x2F;O效率的方法：使用缓冲"></a>提高文件I&#x2F;O效率的方法：使用缓冲</h3><p>注意cp1中定义了BUFFERSIZE这个常量，用于标识每次读&#x2F;写操作的数据长度，这里的值是4096。</p>
<p>要注意缓冲区大小对性能有很大的影响，使用大的缓冲区可以减少系统调用的次数（在cp1中就是减少read()和write()的次数）</p>
<p><strong>为什么系统调用耗时很长：</strong></p>
<ul>
<li>用户进程位于用户空间，内核位于系统空间，磁盘只能被内核直接访问</li>
<li>当系统调用发生时，执行权会从用户代码转移到内核代码，执行内核代码是需要时间的</li>
<li>由于运行内核代码时，CPU工作在管理员（supervisor）模式，这对应于一些特殊的对战和内存环境，必须在系统调用发生时建立好。</li>
<li>系统调用结束后，CPU要切换到用户模式，必须把堆栈和内存环境恢复成用户程序运行时的状态，这种运行环境的切换要消耗很多时间。（上下文切换）</li>
</ul>
<p><strong>在who2.c中运用缓冲技术</strong></p>
<img src="https://pic.imgdb.cn/item/630e936716f2c2beb15cdf06.jpg" style="zoom:80%;" />

<p>使用一个能容纳16个utmp结构的数组作为缓冲区，标识为buffer。</p>
<p>我们需要编写utmp_next函数来从缓冲区中取得下一个utmp结构的数据</p>
<p>在utmplib.c中进行实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NRECS 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULLUT ((struct utmp *)NULL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UTSIZE (sizeof(struct utmp))</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> utmpbuf[NRECS * UTSIZE];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> num_recs;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> cur_rec;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> fd_utmp = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">utmp_open</span><span class="params">(<span class="type">char</span>* filename)</span>&#123;</span><br><span class="line">        fd_utmp = open(filename, O_RDONLY);</span><br><span class="line">        cur_rec = num_recs = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> fd_utmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> utmp* <span class="title function_">utmp_next</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">utmp</span> *<span class="title">recp</span>;</span></span><br><span class="line">        <span class="keyword">if</span>(fd_utmp == <span class="number">-1</span>) <span class="keyword">return</span> NULLUT;</span><br><span class="line">    	<span class="comment">//如果缓冲记录读到头并且文件记录也读完了，返回空指针</span></span><br><span class="line">        <span class="keyword">if</span>(cur_rec == num_recs &amp;&amp; utmp_reload()==<span class="number">0</span>) <span class="keyword">return</span> NULLUT;</span><br><span class="line">        recp = (<span class="keyword">struct</span> utmp*)&amp;utmpbuf[cur_rec * UTSIZE];</span><br><span class="line">        ++cur_rec;</span><br><span class="line">        <span class="keyword">return</span> recp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">utmp_reload</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> amt_read;</span><br><span class="line">        amt_read = read(fd_utmp, utmpbuf, NRECS*UTSIZE);</span><br><span class="line">        num_recs = amt_read/UTSIZE;</span><br><span class="line">        cur_rec = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> num_recs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">utmp_close</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(fd_utmp!=<span class="number">-1</span>) close(fd_utmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主函数流程修改如下：</p>
<p>修改后的主函数没有直接对open、read和close进行调用，而是调用与之等价的具有缓冲模式的函数接口。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utmplib.c&quot;</span>  <span class="comment">//注意包含.c文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">utmp</span> *<span class="title">utbufp</span>, *<span class="title">utmp_next</span>();</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(utmp_open(UTMP_FILE) == <span class="number">-1</span>)&#123;</span><br><span class="line">                perror(UTMP_FILE);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>((utbufp = utmp_next())!= ((<span class="keyword">struct</span> utmp*)<span class="literal">NULL</span>))&#123;</span><br><span class="line">                show_info(utbufp);</span><br><span class="line">        &#125;</span><br><span class="line">        utmp_close();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内核缓冲技术"><a href="#内核缓冲技术" class="headerlink" title="内核缓冲技术"></a>内核缓冲技术</h3><p>主要思想是一次读入大量数据放入缓冲区，需要的时候从缓冲区取得数据。</p>
<p>用户态和内核态之间的切换需要消耗时间，相比之下，磁盘的I&#x2F;O操作消耗的时间更多，为了提高效率，内核也是用缓冲技术来提高对磁盘的访问速度。</p>
<ul>
<li>正如utmp文件是用户登录记录的集合，磁盘是数据块的集合，内核会对磁盘上的数据块作缓冲，就像who程序缓冲utmp记录一样。</li>
<li>内核将磁盘上的数据块复制到内核缓冲区中，当一个用户空间中的进程要从磁盘上读数据时，内核一般不直接读磁盘，而是将内核缓冲区中的数据复制到进程的缓冲区中。</li>
<li>当进程所要求的数据块不在内核缓冲区中时，内核会把相应的数据块加入到请求数据列表中，然后将该进程挂起，接着为其他进程服务</li>
<li>等把相应的数据块从磁盘读到内核缓冲区后，再把数据复制到进程的缓冲区中，最后环形被挂起的进程。</li>
<li>注意read就是把数据从内核缓冲区复制到进程缓冲区，write把数据从进程缓冲区复制到内核缓冲区，它们不等价于数据在内核缓冲和磁盘之间的交换。内核在积累一定数量的写数据后再一次写入磁盘中。</li>
</ul>
<p>该应用的结果：</p>
<ul>
<li>提高磁盘I&#x2F;O效率</li>
<li>优化磁盘写操作</li>
<li>需要及时将缓冲数据写入磁盘（这是个缺点，比如当发生意外状况如断电时，内核来不及写入数据到磁盘，则更新的数据会丢失）</li>
</ul>
<p><strong>标准C函数的实现</strong></p>
<p>标准C函数如fopen getc fclose fgets的实现都包含内核级缓冲，它们用到了一个结构FILE，并以此为基础构造了类似utmplib的中间层</p>
<p>FILE的结构定义在<code>/usr/include/libio.h</code>中</p>
<h3 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h3><p><strong>注销过程是如何工作的：</strong>（utmp记录的改变）</p>
<ul>
<li>打开文件utmp<ul>
<li><code>fd = open(UTMP_FILE, O_RDWR);</code></li>
</ul>
</li>
<li>从utmp中找到包含你所在终端的登录记录<ul>
<li>在while循环中读取一条utmp记录，将它的ut_line字段跟终端名字做比较，若相等则调用修改函数</li>
</ul>
</li>
<li>对当前记录作修改<ul>
<li>负责注销的程序修改当前记录，再把它写回到文件utmp中</li>
<li>即要把ut_type的值从USER_PROCESS改成DEAD_PROCESS，把ut_time字段的值改为注销时间，也就是当前时间</li>
<li>把修改过的记录写会文件不能用write（write只会更新下一条记录而不会修改）</li>
<li><u>使用系统调用lseek进行修改</u> <code>off_t lseek(int fd, off_t offset, int whence);</code></li>
</ul>
</li>
<li>关闭文件<ul>
<li>close(fd)</li>
</ul>
</li>
</ul>
<p><strong>改变文件的当前位置</strong></p>
<p>我们知道Unix每次打开一个文件都会保存一个指针来记录文件的当前位置</p>
<img src="https://pic.imgdb.cn/item/630f49f216f2c2beb1c6aea5.jpg" style="zoom:80%;" />

<p><u>当从文件读数据时，内核从指针标明的地方开始，读取指定的字节，然后移动位置指针，指向下一个未被读取的字节</u>，写文件的操作也是类似的。</p>
<p>指针是与文件描述符相关联的，而不是与文件关联，所以如果两个程序同时打开一个文件，这时会有两个指针，两个程序对文件的读操作不会相互干扰。</p>
<p>系统调用lseek的用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>fd：文件描述符</li>
<li>offset：从基准位置开始的偏移量（可以是负值）</li>
<li>whence：<ul>
<li>SEEK_SET：文件的开始</li>
<li>SEEK_CUR：当前位置</li>
<li>SEEK_END：文件结尾</li>
</ul>
</li>
<li>遇到错误返回-1，否则返回指针变化前的位置</li>
</ul>
<p>如：</p>
<ul>
<li><code>lseek(fd, -sizeof(struct utmp),SEEK_CUR);</code> 把指针往前移一个utmp结构</li>
<li><code>lseek(fd, 10*sizeof(struct utmp), SEEK_SET);</code>把指针移到第11个记录的开始位置</li>
<li><code>lseek(fd, 0, SEEK_END);write(fd, &quot;hello&quot;, strlen(&quot;hello&quot;));</code>使指针移到文件末尾，然后写一个字符串到文件中</li>
</ul>
<p><strong>编写终端注销的代码</strong></p>
<p>可以编写一个函数对注销的用户修改utmp中相应的记录</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">logout_tty</span><span class="params">(<span class="type">char</span> * line)</span>&#123;</span><br><span class="line">    <span class="type">int</span>	fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">utmp</span> <span class="title">rec</span>;</span></span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> utmp);</span><br><span class="line">    <span class="type">int</span> retval = <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>((fd = open(UTMP_FILE,O_RDWR)) == <span class="number">-1</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//寻找并修改</span></span><br><span class="line">    <span class="keyword">while</span>(read(fd,&amp;rec,len) == len)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strncmp</span>(rec.ut_line, line))&#123;</span><br><span class="line">            rec.ut_type = DEAD_PROCESS;</span><br><span class="line">            <span class="keyword">if</span>(time(&amp;rec.ut_time != <span class="number">-1</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span>(lseek(fd, -len, SEEK_CUR) != <span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(write(fd,&amp;rec,len) == len)</span><br><span class="line">                        retval = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭文件</span></span><br><span class="line">    <span class="keyword">if</span>(close(fd) == <span class="number">-1</span>)&#123;</span><br><span class="line">    	retval = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="处理系统调用中的错误"><a href="#处理系统调用中的错误" class="headerlink" title="处理系统调用中的错误"></a>处理系统调用中的错误</h3><p>很多系统调用遇到错误会返回-1，表示出了某些问题，因此调用者每次都必须检查返回值，一旦检测到错误，必须做出相应的处理。</p>
<p><strong>确定错误的种类errno</strong></p>
<p>内核通过全局变量errno来指明错误的类型，每个程序都可以访问到这个变量</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">       errno - number of last error</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       #include &lt;errno.h&gt;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">		A common mistake is to do</span><br><span class="line">           if (somecall() == -1) &#123;</span><br><span class="line">               printf(&quot;somecall() failed\n&quot;);</span><br><span class="line">               if (errno == ...) &#123; ... &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       where errno no longer needs to have the value it had upon  return  from</span><br><span class="line">       somecall()  (i.e.,  it may have been changed by the printf(3)).  If the</span><br><span class="line">       value of errno should be preserved across a library call,  it  must  be</span><br><span class="line">       saved:</span><br><span class="line"></span><br><span class="line">           if (somecall() == -1) &#123;</span><br><span class="line">               int errsv = errno;</span><br><span class="line">               printf(&quot;somecall() failed\n&quot;);</span><br><span class="line">               if (errsv == ...) &#123; ... &#125;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>



<p><strong>显示错误信息：perror(3)</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">perror</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *sys_errlist[];</span><br><span class="line"><span class="type">int</span> sys_nerr;</span><br><span class="line"><span class="type">int</span> errno;</span><br></pre></td></tr></table></figure>

<p>perror(string)这个函数会自己查找错误代码，在标准错误输出中显示出相应的错误信息，参数string是要同时显示出的描述信息</p>
<h2 id="目录与文件属性：编写ls"><a href="#目录与文件属性：编写ls" class="headerlink" title="目录与文件属性：编写ls"></a>目录与文件属性：编写ls</h2><ul>
<li><code>ls</code>默认动作是找出当前目录中所有文件的文件名，字典序排序后输出</li>
<li><code>ls -l</code>（ls的长格式）会列出每个文件的详细信息，每一行代表一个文件和它的多个属性</li>
<li><code>ls *.c</code>显示与*.c匹配的文件</li>
<li><code>ls -a</code>列出的内容包含以”.”开头的文件</li>
<li><code>ls -lu</code> 显示最后访问时间</li>
<li><code>ls -s</code> 显示以块为单位的文件大小</li>
<li><code>ls -t</code>输出时按时间排序</li>
<li><code>ls -F</code>显示文件类型</li>
</ul>
<h3 id="Unix是如何组织磁盘上的文件的"><a href="#Unix是如何组织磁盘上的文件的" class="headerlink" title="Unix是如何组织磁盘上的文件的"></a>Unix是如何组织磁盘上的文件的</h3><p>磁盘上的文件和目录被组成一棵目录树，每个节点都是目录或文件</p>
<img src="https://pic.imgdb.cn/item/630f617a16f2c2beb1d71e55.jpg" style="zoom:80%;" />

<p>图中的大方框表示目录，大方框内的小方框表示文件，目录之间的连线表示目录之间的组织关系</p>
<p>Unix系统中，每个文件都位于某个目录中，在逻辑上是没有驱动器或卷的，当然在物理上一个系统可以有多个驱动器或分区，每个驱动器上都可以有分区，位于不同驱动器和分区上的目录通过文件树无缝地连接在一起。</p>
<p>软盘、光盘这些移动存储介质也被挂到文件树的某一个子目录来处理。</p>
<p>因此ls的实现只需考虑文件和目录两种情况，无需考虑驱动或分区</p>
<p><strong>什么是目录</strong></p>
<p>目录是一种特殊的文件，它的内容是文件和目录的名字。与utmp文件类似，目录文件包含很多记录，每个记录的格式由统一的标准定义。每条记录的内容代表一个文件或目录</p>
<p>与普通文件不同，目录文件永远不会空，每个目录都至少包含两个特殊的项：</p>
<ul>
<li><code>.</code> 表示当前目录</li>
<li><code>..</code> 表示上一级目录</li>
</ul>
<p>可以发现cat more od命令在centos7系统下都无法读取目录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[zhangqi@localhost test]$ cat /</span><br><span class="line">cat: /: Is a directory</span><br><span class="line">[zhangqi@localhost test]$ more /tmp</span><br><span class="line"></span><br><span class="line">*** /tmp: directory ***</span><br><span class="line"></span><br><span class="line">[zhangqi@localhost test]$ od -c /dev</span><br><span class="line">od: /dev: read error: Is a directory</span><br><span class="line">0000000</span><br></pre></td></tr></table></figure>

<p>那么如何读取呢？</p>
<p>通过 <code>man -k direct | grep read</code>可以找到readdir命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">man 3 readdir</span></span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">       readdir, readdir_r - read a directory</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       #include &lt;dirent.h&gt;</span><br><span class="line"></span><br><span class="line">       struct dirent *readdir(DIR *dirp);</span><br><span class="line"></span><br><span class="line">       int readdir_r(DIR *dirp, struct dirent *entry, struct dirent **result);</span><br><span class="line"></span><br><span class="line">   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):</span><br><span class="line"></span><br><span class="line">       readdir_r():</span><br><span class="line">           _POSIX_C_SOURCE &gt;= 1 || _XOPEN_SOURCE || _BSD_SOURCE || _SVID_SOURCE || _POSIX_SOURCE</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       The readdir() function returns a pointer to a dirent structure representing the next directory</span><br><span class="line">       entry in the directory stream pointed to by dirp.  It returns NULL on reaching the end of  the</span><br><span class="line">       directory stream or if an error occurred.</span><br><span class="line"></span><br><span class="line">       On Linux, the dirent structure is defined as follows:</span><br><span class="line"></span><br><span class="line">           struct dirent &#123;</span><br><span class="line">               ino_t          d_ino;       /* inode number */</span><br><span class="line">               off_t          d_off;       /* not an offset; see NOTES */</span><br><span class="line">               unsigned short d_reclen;    /* length of this record */</span><br><span class="line">               unsigned char  d_type;      /* type of file; not supported</span><br><span class="line">                                              by all file system types */</span><br><span class="line">               char           d_name[256]; /* filename */</span><br><span class="line">           &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>编写简单的ls：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">do_ls</span><span class="params">(<span class="type">char</span> *dirname)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (argc == <span class="number">1</span>) &#123;<span class="comment">//如果没有任何参数，则显示当前目录下所有文件</span></span><br><span class="line">    do_ls(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123; <span class="comment">//否则，显示指定的目录下的文件，可以加多个参数</span></span><br><span class="line">    <span class="keyword">while</span> (--argc) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s:\n&quot;</span>, *++argv);</span><br><span class="line">      do_ls(*argv);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">do_ls</span><span class="params">(<span class="type">char</span> *dirname)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dirent_p</span>;</span></span><br><span class="line">  DIR *dir_p = opendir(dirname);</span><br><span class="line">  <span class="keyword">if</span> (dir_p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    perror(dirname);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ((dirent_p = readdir(dir_p)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, dirent_p-&gt;d_name);</span><br><span class="line">  &#125;</span><br><span class="line">  closedir(dir_p);</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个简单的版本基本实现了查看目录功能，但还需要加进去一些功能：</p>
<ul>
<li>排序：ls1的输出没有进过排序。<ul>
<li>解决办法：把所有文件名读入一个数组，用qsort函数把数组排序</li>
</ul>
</li>
<li>分栏：标准的ls输出是分栏排列的，有些以行排序输出，有些以列排序输出<ul>
<li>解决办法：把文件名读入数组，然后计算出列的宽度和行数</li>
</ul>
</li>
<li>“.”文件：ls1列出了“.”文件，而标准的ls只有在给出-a选项时才会列出这些文件<ul>
<li>解决办法：ls1能够接收选项-a，并在没有-a的时候不显示隐藏文件</li>
</ul>
</li>
<li>选项 -l ：如果选项里有-l，标准的ls会列出文件的详细信息，而ls1不会。<ul>
<li>解决办法：由于dirent结构中没有所需信息，如文件大小、文件所有者等，要找到存储这些信息的地方（使用stat系统调用）</li>
</ul>
</li>
</ul>
<h3 id="用stat得到文件信息"><a href="#用stat得到文件信息" class="headerlink" title="用stat得到文件信息"></a>用stat得到文件信息</h3><p>用法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">       stat, fstat, lstat, fstatat - get file status</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *buf)</span>;</span><br><span class="line">       <span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat *buf)</span>;</span><br><span class="line">       <span class="type">int</span> <span class="title function_">lstat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *buf)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>stat把文件pathname的信息复制到指针buf所指的结构中</li>
<li>入参：文件名，指向stat结构buffer的指针</li>
<li>返回值：-1（遇到错误） 0（成功返回）</li>
</ul>
<p>stat结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">    <span class="type">dev_t</span>     st_dev;         <span class="comment">/* ID of device containing file */</span></span><br><span class="line">    <span class="type">ino_t</span>     st_ino;         <span class="comment">/* inode number */</span></span><br><span class="line">    <span class="type">mode_t</span>    st_mode;        <span class="comment">/* file type and mode */</span></span><br><span class="line">    <span class="type">nlink_t</span>   st_nlink;       <span class="comment">/* number of hard links */</span></span><br><span class="line">    <span class="type">uid_t</span>     st_uid;         <span class="comment">/* user ID of owner */</span></span><br><span class="line">    <span class="type">gid_t</span>     st_gid;         <span class="comment">/* group ID of owner */</span></span><br><span class="line">    <span class="type">dev_t</span>     st_rdev;        <span class="comment">/* device ID (if special file) */</span></span><br><span class="line">    <span class="type">off_t</span>     st_size;        <span class="comment">/* total size, in bytes */</span></span><br><span class="line">    <span class="type">blksize_t</span> st_blksize;     <span class="comment">/* blocksize for filesystem I/O */</span></span><br><span class="line">    <span class="type">blkcnt_t</span>  st_blocks;      <span class="comment">/* number of 512B blocks allocated */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Since Linux 2.6, the kernel supports nanosecond</span></span><br><span class="line"><span class="comment">                  precision for the following timestamp fields.</span></span><br><span class="line"><span class="comment">                  For the details before Linux 2.6, see NOTES. */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_atim</span>;</span>  <span class="comment">/* time of last access */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_mtim</span>;</span>  <span class="comment">/* time of last modification */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_ctim</span>;</span>  <span class="comment">/* time of last status change */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> st_atime st_atim.tv_sec      <span class="comment">/* Backward compatibility */</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> st_mtime st_mtim.tv_sec</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> st_ctime st_ctim.tv_sec</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//filesize.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">infobuf</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(stat(<span class="string">&quot;/etc/passwd&quot;</span>, &amp;infobuf) == <span class="number">-1</span>)</span><br><span class="line">        perror(<span class="string">&quot;/etc/passwd&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//用stat来获取文件大小</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The size of /etc/passwd is %d\n&quot;</span>, infobuf.st_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>编写fileinfo.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fileinfo.c - use stat() to obtain and print file properties</span></span><br><span class="line"><span class="comment">//            - some menbers are just numbers</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">show_stat_info</span><span class="params">(<span class="type">char</span> *filename, <span class="keyword">struct</span> stat *stat_buf)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stat_buf</span>;</span></span><br><span class="line">  <span class="keyword">while</span> (--argc &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (stat(*++argv, &amp;stat_buf) == <span class="number">-1</span>) &#123;</span><br><span class="line">      perror(*argv);</span><br><span class="line">      <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    show_stat_info(*argv, &amp;stat_buf);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">show_stat_info</span><span class="params">(<span class="type">char</span> *filename, <span class="keyword">struct</span> stat *stat_buf_p)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  mode: %o\n&quot;</span>, stat_buf_p-&gt;st_mode);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot; links: %d\n&quot;</span>, stat_buf_p-&gt;st_nlink);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  user: %d\n&quot;</span>, stat_buf_p-&gt;st_uid);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot; group: %d\n&quot;</span>, stat_buf_p-&gt;st_gid);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  size: %d\n&quot;</span>, stat_buf_p-&gt;st_size);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot; mtime: %d\n&quot;</span>, stat_buf_p-&gt;st_mtime);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  name: %s\n&quot;</span>, filename);</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译，运行，并与ls -l作对比</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[zhangqi@localhost chap3]$ ./fileinfo fileinfo.c </span><br><span class="line">  mode: 100664</span><br><span class="line"> links: 1</span><br><span class="line">  user: 1000</span><br><span class="line"> group: 1000</span><br><span class="line">  size: 777</span><br><span class="line"> mtime: 1662418390</span><br><span class="line">  name: fileinfo.c</span><br><span class="line">[zhangqi@localhost chap3]$ <span class="built_in">ls</span> -l fileinfo.c </span><br><span class="line">-rw-rw-r--. 1 zhangqi zhangqi 777 Sep  6 06:53 fileinfo.c</span><br><span class="line">[zhangqi@localhost chap3]$ </span><br></pre></td></tr></table></figure>

<p>可以发现链接数（links，即文件被引用的次数，即别名的数量）、文件大小（size，即实际所占用的存储空间的字节数）的显示都没有问题，时间是可以用ctime转化成字符串的，也没有问题。</p>
<p>然而fileinfo将模式（mode）字段以数字形式输出，然而需要的是 <code>-rw-rw-r--</code>这种形式。</p>
<p>另外结构中的user和group字段都是数值，显示出来的应该是用户名（需要通过getpwuid()来获取）和组名（通过getgrgid()来获取组列表）。</p>
<p>因此要进一步处理这些问题</p>
<p><code>st_mode</code>是一个16位的二进制数，文件类型和权限被编码在这个数中：</p>
<img src="https://pic.imgdb.cn/item/631681e216f2c2beb1280d65.jpg" style="zoom:80%;" />

<ul>
<li><p>前四位用作文件类型，最多标识16种类型，目前已使用其中的7个</p>
</li>
<li><p>接下来3位是文件的特殊属性，1代表具有某个属性，0代表没有。</p>
<ul>
<li><code>set-user-ID</code>位：SUID位告诉内核，运行这个程序的时候认为是由文件所有者在运行这个程序</li>
<li><code>set-group-ID</code>位：用来设置程序运行时所属组</li>
<li><code>sticky</code>位：对于文件来说，告诉内核即使没有人在使用程序，也要把它放在交换空间中（早期类似虚拟内存的实现技术）；对于目录来说，sticky位使目录里的文件只能被创建者删除</li>
</ul>
</li>
<li><p>最后9位是许可权限，分为三组，对应文件所有者、同组用户和其他用户。每组三位，分别是读、写和执行的权限。相应位置如果是1说明有权限，0代表没有</p>
<ul>
<li><p>文件所有者：就是创建文件的用户，当用户通过creat建立文件时，内核把文件所有者设为运行程序的用户，如果程序具有set-user-ID位，那么新文件的文件所有者就是程序的文件所有者</p>
</li>
<li><p>组：通常新文件的组被设为执行创建动作的用户所在的组</p>
</li>
<li><p>修改文件所有者和组：通过系统调用<code>chown</code>来修改文件所有者和组：</p>
<p><code>chown(&quot;file1&quot;,200,40);</code>将文件file1的用户ID改为200，组ID改为40，如果后两个参数都为-1，则文件所有者和组都不会改变。</p>
<p>shell命令chown和chgrp可以用来修改文件所有者和组，它们可以一次修改多个文件</p>
</li>
</ul>
</li>
</ul>
<p><strong>如何读取被编码的值</strong>：</p>
<p>“掩码”技术——为了比较，把不需要的地方置0，需要的字段值不发生改变</p>
<p>实现：与0作位与（&amp;）操作可以将相应的bit置为0</p>
<p>在&lt;sys&#x2F;stat.h&gt;中定义了一系列掩码，用于过滤出不同的信息</p>
<h3 id="综合实现"><a href="#综合实现" class="headerlink" title="综合实现"></a>综合实现</h3><p>ls2.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_ls</span><span class="params">(<span class="type">char</span>[])</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dostat</span><span class="params">(<span class="type">char</span>*)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">show_file_info</span><span class="params">(<span class="type">char</span>*, <span class="keyword">struct</span> stat *)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mode_to_letters</span><span class="params">(<span class="type">int</span>, <span class="type">char</span>[])</span>;</span><br><span class="line"><span class="type">char</span> * <span class="title function_">uid_to_name</span><span class="params">(<span class="type">uid_t</span>)</span>;</span><br><span class="line"><span class="type">char</span> * <span class="title function_">gid_to_name</span><span class="params">(<span class="type">gid_t</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main(<span class="type">int</span> argc, <span class="type">char</span> *argv[]) &#123;</span><br><span class="line">	<span class="keyword">if</span>(argc == <span class="number">1</span>)</span><br><span class="line">		do_ls(<span class="string">&quot;.&quot;</span>); <span class="comment">//如果没有指定参数，则列出该目录下所有文件信息</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">while</span>(--argc)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s:\n&quot;</span>,*++argv);</span><br><span class="line">			do_ls(*argv);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_ls</span><span class="params">(<span class="type">char</span> dirname[])</span>&#123;</span><br><span class="line">	<span class="comment">//list files in directory called dirname</span></span><br><span class="line">	DIR	*dir_ptr;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span>	 <span class="title">dirent</span> * <span class="title">direntp</span>;</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>((dir_ptr = opendir(dirname)) == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;ls2: cannot open %s\n&quot;</span>, dirname);</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">while</span>((direntp = readdir(dir_ptr)) != <span class="literal">NULL</span>)</span><br><span class="line">			dostat(direntp-&gt;d_name);</span><br><span class="line">		closedir(dir_ptr);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dostat</span><span class="params">(<span class="type">char</span> * filename)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span>	<span class="title">stat</span>	<span class="title">info</span>;</span></span><br><span class="line">	<span class="keyword">if</span>(stat(filename, &amp;info)==<span class="number">-1</span>)</span><br><span class="line">		perror(filename);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		show_file_info(filename,&amp;info);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">show_file_info</span><span class="params">(<span class="type">char</span> *filename, <span class="keyword">struct</span> stat *info_p)</span> &#123;</span><br><span class="line">	<span class="type">char</span> *<span class="title function_">uid_to_name</span><span class="params">()</span>, *<span class="title function_">ctime</span><span class="params">()</span>, *<span class="title function_">gid_to_name</span><span class="params">()</span>, *<span class="title function_">filemode</span><span class="params">()</span>;</span><br><span class="line">	<span class="type">void</span> <span class="title function_">mode_to_letters</span><span class="params">()</span>;</span><br><span class="line">	<span class="type">char</span> modestr[<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line">	mode_to_letters(info_p-&gt;st_mode, modestr);</span><br><span class="line"></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>, modestr);</span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">&quot;%4d &quot;</span>,(<span class="type">int</span>)info_p-&gt;st_nlink);</span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">&quot;%-8s &quot;</span>, uid_to_name(info_p-&gt;st_uid));</span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">&quot;%-8s &quot;</span>, gid_to_name(info_p-&gt;st_gid));</span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">&quot;%8ld &quot;</span>, (<span class="type">long</span>)info_p-&gt;st_size);</span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">&quot;%.12s &quot;</span>, <span class="number">4</span>+ctime(&amp;info_p-&gt;st_mtime));</span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, filename);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mode_to_letters</span><span class="params">(<span class="type">int</span> mode, <span class="type">char</span> str[])</span>&#123;</span><br><span class="line">	<span class="built_in">strcpy</span>(str,<span class="string">&quot;----------&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(S_ISDIR(mode)) str[<span class="number">0</span>] = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">	<span class="keyword">if</span>(S_ISCHR(mode)) str[<span class="number">0</span>] = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">	<span class="keyword">if</span>(S_ISBLK(mode)) str[<span class="number">0</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(mode &amp; S_IRUSR) str[<span class="number">1</span>] = <span class="string">&#x27;r&#x27;</span>;</span><br><span class="line">	<span class="keyword">if</span>(mode &amp; S_IWUSR) str[<span class="number">2</span>] = <span class="string">&#x27;w&#x27;</span>;</span><br><span class="line">	<span class="keyword">if</span>(mode &amp; S_IXUSR) str[<span class="number">3</span>] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(mode &amp; S_IRGRP) str[<span class="number">4</span>] = <span class="string">&#x27;r&#x27;</span>;</span><br><span class="line">	<span class="keyword">if</span>(mode &amp; S_IWGRP) str[<span class="number">5</span>] = <span class="string">&#x27;w&#x27;</span>;</span><br><span class="line">	<span class="keyword">if</span>(mode &amp; S_IXGRP) str[<span class="number">6</span>] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(mode &amp; S_IROTH) str[<span class="number">7</span>] = <span class="string">&#x27;r&#x27;</span>;</span><br><span class="line">	<span class="keyword">if</span>(mode &amp; S_IWOTH) str[<span class="number">8</span>] = <span class="string">&#x27;w&#x27;</span>;</span><br><span class="line">	<span class="keyword">if</span>(mode &amp; S_IXOTH) str[<span class="number">9</span>] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pwd.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">uid_to_name</span><span class="params">(<span class="type">uid_t</span> uid)</span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> passwd * <span class="title function_">getpwuid</span><span class="params">()</span>, *pw_ptr;</span><br><span class="line">	<span class="type">static</span> <span class="type">char</span> numstr[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((pw_ptr = getpwuid(uid))== <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">sprintf</span>(numstr,<span class="string">&quot;%d&quot;</span>,uid);</span><br><span class="line">		<span class="keyword">return</span> numstr;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> pw_ptr-&gt;pw_name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;grp.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">gid_to_name</span><span class="params">(<span class="type">gid_t</span> gid)</span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> group * <span class="title function_">getgrgid</span><span class="params">()</span>, *grp_ptr;</span><br><span class="line">	<span class="type">static</span> <span class="type">char</span> numstr[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">if</span>((grp_ptr = getgrgid(gid)) == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">sprintf</span>(numstr,<span class="string">&quot;%d&quot;</span>,gid);</span><br><span class="line">		<span class="keyword">return</span> numstr;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> grp_ptr-&gt;gr_name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="设置和修改文件的属性"><a href="#设置和修改文件的属性" class="headerlink" title="设置和修改文件的属性"></a>设置和修改文件的属性</h3><p>ls2.c的属性</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zhangqi@localhost chap3]$ <span class="built_in">ls</span> -l ls2.c</span><br><span class="line">-rw-rw-r--. 1 zhangqi zhangqi 2336 Sep  7 01:11 ls2.c</span><br></pre></td></tr></table></figure>

<p><strong>文件类型</strong></p>
<p>有普通文件、目录文件、设备文件、socket文件、符号链接文件、命名管道文件等</p>
<ul>
<li>文件类型的建立：是在创建文件的时候建立的，如用系统调用creat建立一个普通文件。其他类型的文件如目录（mkdir()系统调用）等，可使用不同的函数创建。</li>
<li>修改文件类型：文件一经创建，类型就无法修改</li>
</ul>
<p><strong>许可位与特殊属性位</strong></p>
<p>每个文件都有9位许可权限和3位特殊属性，是在文件创建的时候建立的，创建后，它们可以被chmod系统调用修改</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">chmod</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>建立文件的模式：creat的第二个参数制定了要创建文件的许可位</p>
<p><code>fd = creat(&quot;newfile&quot;,0744)</code>指定新创建文件的许可位为rwxr–r–</p>
</li>
<li><p>改变文件的模式：</p>
<ul>
<li><p>程序可以通过系统调用<code>chmod</code>来改变文件的模式：</p>
<p><code>chmod(&quot;/tmp/myfile&quot;, 04764);</code></p>
<p><code>chomod(&quot;/tmp/myfile,S_ISUID|S_IRWXU|S_IRWXU|S_IRGRP|S_IWGRP|S_IROTH&quot;);</code></p>
</li>
<li><p>以上两条指令的作用相同，第一条是八进制表示，第二条是用&lt;sys&#x2F;stat.h&gt;中定义的符号来表示。后者有明显的优点，当系统定义的许可位的值改变时，无需修改程序。即系统调用chmod不受“新建文件掩码”的影响</p>
</li>
<li><p>返回-1即错误，0则是成功</p>
</li>
<li><p>shell命令chmod也可以用来完成上述操作。它可以通过八进制模式（如04764）和符号模式（如u&#x3D;rws g&#x3D;rw o&#x3D;r）来指定权限和属性</p>
</li>
</ul>
</li>
</ul>
<h2 id="文件系统：编写pwd"><a href="#文件系统：编写pwd" class="headerlink" title="文件系统：编写pwd"></a>文件系统：编写pwd</h2><p>文件包含数据，而目录是文件的列表。不同的目录互相连接构成树状的结构。目录还可以包含其他的目录。</p>
<p>pwd命令显示你在目录树中的位置。从树根到你所处位置所经过的目录的序列被称作路径（path）。</p>
<p><strong>用户角度看文件系统</strong></p>
<p>Unix系统中一盘上的文件组成一棵目录树</p>
<p>针对目录树的命令：</p>
<ul>
<li><code>ls -R</code>可以查看以当前节点为根节点的整个树结构。-R要求列出指定目录及其子目录的所有内容</li>
<li><code>chmod -R</code> 可以改变子目录中所有文件的许可权</li>
<li><code>du</code> 是disk usage的缩写，该命令给出指定目录及其子目录下所有文件占用硬盘中数据块的总数</li>
<li><code>find</code> 将在一个目录及其所有子目录中检索符合要求的文件和目录</li>
</ul>
<p>目录树的深度几乎没有限制</p>
<h3 id="Unix文件系统的内部结构"><a href="#Unix文件系统的内部结构" class="headerlink" title="Unix文件系统的内部结构"></a>Unix文件系统的内部结构</h3><p>硬盘实际上是由一些磁性盘片组成的计算机系统的一个设备。文件系统其实是对该设备的一种多层次的抽象</p>
<p><strong>第一层抽象：从磁盘到分区</strong></p>
<ul>
<li>一个磁盘可被划分为若干个分区，以便在一个大的实体内创建独立的区域。每个分区都可以看做是一个独立的磁盘</li>
</ul>
<p><strong>第二层抽象：从磁盘到块序列</strong></p>
<ul>
<li><p>一个磁盘由一些磁性盘片组成。每个盘片的表面都被划分为很多同心圆，这些同心圆被称作磁道，每个磁道又进一步被划分为扇区。</p>
</li>
<li><p>每个扇区可以存储一定字节数的数据（512字节）</p>
</li>
<li><p>扇区是磁盘上的基本存储单元</p>
</li>
<li><p>为磁盘块编号：</p>
<img src="https://pic.imgdb.cn/item/631a294316f2c2beb1c84330.jpg" style="zoom:80%;" />

<ul>
<li>给每个磁盘块分配连续的编号使得系统能够计算磁盘上的每个块。</li>
<li>可以一个磁盘接一个磁盘从上到下给所有块编号，还可以一个磁道接一个磁道地从外向里给所有的块编号。</li>
<li>一个将磁盘扇区编号的系统使得我们可以把磁盘视为一系列块的组合</li>
</ul>
</li>
</ul>
<p><strong>第三层抽象：从块序列到三个区域的划分</strong></p>
<ul>
<li><p>文件系统被分为三个区域来存储不同类型的数据（文件内容、文件属性（所有者、日期等）和目录）</p>
<img src="https://pic.imgdb.cn/item/631a2c3116f2c2beb1cb613a.jpg" style="zoom:80%;" />

<ul>
<li><strong>超级块</strong>：存放文件系统本身的信息（如每个区域的大小、未被使用的磁盘块信息）</li>
<li><strong>i-节点表</strong>：存放文件属性（如大小、文件所有者和最近修改时间）<ul>
<li>这些性质被记录在一个称为 “i-节点”的结构中，所有inode有相同的大小，这是一个inode的列表。</li>
<li>文件系统中的每个文件在该表中都有一个inode</li>
<li>如果有root权限，可以像操作文件一样将分区打开、阅读并显示i-节点表。</li>
<li>注意：表中的每个inode都通过位置来标识。例如，标识为2的inode（inode 2）位于文件系统i-节点表中的第3个位置</li>
</ul>
</li>
<li><strong>数据区</strong>：用来存放文件内容。一个较大的文件可能分布在上千个独立的磁盘块中</li>
</ul>
</li>
<li><p>文件系统由这三部分组合而成，其中任一部分都是由很多有序磁盘块组成的</p>
</li>
</ul>
<h3 id="文件系统的实现："><a href="#文件系统的实现：" class="headerlink" title="文件系统的实现："></a>文件系统的实现：</h3><p><strong>创建一个文件的过程</strong></p>
<p>考虑如下命令： who &gt; userlist，创建了一个存放命令who输出内容的新文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[zhangqi@localhost chap4]$ <span class="built_in">who</span> &gt; userlist</span><br><span class="line">[zhangqi@localhost chap4]$ <span class="built_in">ls</span></span><br><span class="line">demodir  userlist</span><br><span class="line">[zhangqi@localhost chap4]$ <span class="built_in">cat</span> userlist</span><br><span class="line">zhangqi  :0           2022-09-06 06:39 (:0)</span><br><span class="line">zhangqi  pts/0        2022-09-06 06:46 (:0)</span><br><span class="line">zhangqi  pts/1        2022-09-08 08:13 (:0)</span><br></pre></td></tr></table></figure>

<p>文件有内容和属性，内核将文件内容存放在数据区，文件属性存放在inode节点，文件名存在目录</p>
<img src="https://pic.imgdb.cn/item/631a307d16f2c2beb1cfcfcf.jpg" style="zoom:80%;" />

<p>创建一个新文件的四个操作：</p>
<ul>
<li>存储属性：<ul>
<li>文件属性的存储：内核先找到一个空的 inode。如图中，内核找到 inode 47。内核把文件的信息记录其中</li>
</ul>
</li>
<li>存储数据<ul>
<li>文件内容的存储：由于该新文件需要3个存储磁盘块，因此内核从自由块的列表中找出3个自由块。如图中，找到块627、200和992。内核将第一块数据复制到块627， 下一块数据复制到块200，最后一块数据复制到块992。</li>
</ul>
</li>
<li>记录分配情况：<ul>
<li>内核在inode的磁盘分布区记录了上述的块序列。</li>
<li>磁盘分布区是一个磁盘块序号的列表，这3个编号放在最开始的3个位置</li>
</ul>
</li>
<li>添加文件名到目录<ul>
<li>新文件的名字是userlist。Unix内核将入口（47，userlist）添加到目录文件。</li>
<li>文件名和i-节点号之间的对应关系将文件名和文件内容及属性连接了起来</li>
</ul>
</li>
</ul>
<p><strong>目录的工作过程</strong></p>
<p>目录是一种包含了文件名字列表的特殊文件。不同版本的Unix目录的内部结构不同，但是抽象模型总是一致的——一个包含i-节点号和文件名的表</p>
<p>可通过 <code>ls -1ia</code> （选项第一位是数字1）来看目录的内容：</p>
<ul>
<li>输出的是文件名和对应的 i-节点号，如文件名x对应于 i-节点号37405777</li>
<li>当前目录用 <code>.</code>表示，有关大小、文件所有者、组等各项关于当前目录的信息存放在i-节点表中的编号为37405773中</li>
<li><code>-i</code>告诉ls在列表中包含 i-节点号</li>
<li><code>-1</code>要求每行列出一个文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[zhangqi@localhost chap4]$ <span class="built_in">ls</span> -1ia</span><br><span class="line">17507719 .</span><br><span class="line">36866887 ..</span><br><span class="line">37405773 demodir</span><br><span class="line">17507727 userlist</span><br><span class="line">[zhangqi@localhost chap4]$ <span class="built_in">ls</span> -1ia demodir</span><br><span class="line">37405773 .</span><br><span class="line">17507719 ..</span><br><span class="line">51681516 a</span><br><span class="line">51681478 c</span><br><span class="line">37405778 copy.of.x</span><br><span class="line">37405777 x</span><br></pre></td></tr></table></figure>

<p>可以用 <code>ls -i</code>查看系统上任何一个文件的 i-节点号。</p>
<p>如查看系统根目录中各文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[zhangqi@localhost chap4]$ <span class="built_in">ls</span> -ia /</span><br><span class="line">      64 .            3 dev         83 lib64         1 proc    551128 snap  33593488 usr</span><br><span class="line">      64 ..    16777281 etc         84 media  33574977 root  50332836 srv   50331713 var</span><br><span class="line">   74275 bin   50332835 home  16777863 mnt        8868 run          1 sys</span><br><span class="line">      64 boot        81 lib   33593545 opt       74279 sbin  16777288 tmp</span><br></pre></td></tr></table></figure>

<p>这个列表有两个重要的注意点：</p>
<ul>
<li><code>proc</code>和 <code>sys</code>文件的节点号相同都为1，这说明他们是同一个文件的两个不同名字</li>
<li>根目录的<code>.</code>和 <code>..</code>都指向同一个目录。根目录比较特别，当Unix命令mkfs创建一个文件系统，mkfs将根目录的父目录指向自己</li>
</ul>
<p><strong>cat命令的工作原理</strong></p>
<p><code>cat userlist</code> 从目录文件到找到数据：</p>
<img src="https://pic.imgdb.cn/item/631a57c016f2c2beb1eddab8.jpg" style="zoom:80%;" />

<ol>
<li><p>在目录寻找文件名：</p>
<ul>
<li>内核在目录文件中寻找包含字符串userlist的记录。从而找到编号为47的i-节点号</li>
</ul>
</li>
<li><p>定位 i-节点 47 并读取其内容：</p>
<ul>
<li>内核在文件系统中的i-节点区域找到节点 inode 47。（由于所有inode大小相同，每个磁盘块包含相同数量的inode，因此可通过简单的计算进行定位）。</li>
<li>为了提高访问效率，内核有可能将inode置于缓冲区中。inode包含数据块编号的列表</li>
</ul>
</li>
<li><p>访问存储文件内容的数据块</p>
<ul>
<li>通过以上过程，内核已经可以知道文件内容存放在哪些数据块上，以及它们的顺序。由于cat不断地调用read函数，使得内核不断将字节从磁盘复制到内核缓冲区，进而到达用户空间</li>
<li>所有从文件读取数据的命令，例如cat、cp、more、who等，都是将文件名传给open来访问文件内容。对open的每次调用都是先在目录中寻找文件名，然后根据目录中的i-节点号获得文件的属性，最终找到文件的内容</li>
</ul>
</li>
</ol>
<p>如果open一个没有读或写权限的文件：</p>
<ul>
<li>内核首先完成1 2两步</li>
<li>然后在inode中内核可以读取文件权限相关的信息（权限位和拥有者的用户ID）</li>
<li>如果权限位设置你的用户ID对文件没有访问权限，则open返回-1并且将全局变量errno的值设为EPERM</li>
</ul>
<p><strong>如何跟踪大文件</strong></p>
<p>我们知道一个大的文件需要多个磁盘块，而inode中存放有磁盘块分配列表。那么一个固定大小的inode如何存储较长的分配列表呢？</p>
<img src="https://pic.imgdb.cn/item/631a5c7216f2c2beb1f0f560.jpg" style="zoom:80%;" />

<p>如图所示，这个文件需要14个数据块存储它的内容，因此，分配链表包含14个块的编号。但是文件的inode只包含一个含有13个项的分配链表。那么应该如何存放呢？</p>
<p>解决方案：将分配链表的前10个编号放到inode中，将最后4个编号放到一个数据块中：</p>
<ul>
<li>具体来说，就是该inode的链表包含分配13个块编号的空间，链表里的前10个项中的块编号指向的是文件的实际数据。</li>
<li>如果分配链表有多余10个的项，则剩下的块编号不是存储在inode，而是存储在数据区。</li>
<li>链表的第11项存储了存放多余编号的数据块的编号</li>
<li>如果仍然不够，链表的第12项（二级间接块）存放那个存储着第2、3、4及后继额外块的编号的块的编号</li>
<li>还是不够，使用第13项（三级间接块），加深一层递归</li>
<li>此时文件大小达到了极限，还要更大的空间就需要一个拥有更大的磁盘块构成的文件系统了。</li>
</ul>
<p><strong>Unix文件系统的改进</strong></p>
<p>不同版本的Unix使用前述文件系统模型的不同版本。这种方法很简洁，但存在一些问题：</p>
<ul>
<li>超级块如果损坏了，则整个文件系统的结构信息就没有了。因此新版本的Unix在文件系统中备份了这个块的副本</li>
<li>分块问题。由于文件的创建和删除，自由块将遍布磁盘。一种方案是在文件系统中创建被称为柱面组（cylinder group）的微文件系统</li>
</ul>
<h3 id="理解目录"><a href="#理解目录" class="headerlink" title="理解目录"></a>理解目录</h3><p><u>“x文件在目录a中”</u>的含义：</p>
<p>从系统角度看，目录a中有一个指向 文件x对应的i-节点号的链接（xLink），这个链接附加的文件名为x</p>
<p><u>“目录demodir包含子目录a”</u>的含义：</p>
<p>demodir包含一个指向子目录a对应的inode的链接</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[zhangqi@localhost chap4]$ <span class="built_in">ls</span> -iaR demodir/</span><br><span class="line">demodir/:</span><br><span class="line">37405773 .  17507719 ..  51681516 a  51681478 c  37405778 copy.of.x  37405777 x</span><br><span class="line"></span><br><span class="line">demodir/a:</span><br><span class="line">51681516 .  37405773 ..  51681517 x  51681518 y</span><br><span class="line"></span><br><span class="line">demodir/c:</span><br><span class="line">51681478 .  37405773 ..  17507718 d1  37405776 d2</span><br><span class="line"></span><br><span class="line">demodir/c/d1:</span><br><span class="line">17507718 .  51681478 ..  51681517 xlink</span><br><span class="line"></span><br><span class="line">demodir/c/d2:</span><br><span class="line">37405776 .  51681478 ..  37405775 xcopy</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><u>“目录a有一个父目录demodir”</u>的含义：</p>
<p>目录a中有一个 <code>..</code>的名字，为父目录的保留名字</p>
<p><u>多重链接及链接数</u></p>
<p>在demodir目录树中，inode 51681517有两个链接，一个在目录a中，称为x，另一个在目录d1中，称为xlink。那么哪个是原始文件，那个是指向它的链接呢？</p>
<p>在Unix的目录结构中，这两个链接的状态完全相同；它们被称为指向文件的硬链接。</p>
<p>文件是一个inode和一些数据块的结合；链接是对inode的引用。可以对一个文件创建任意多的链接</p>
<p>内核记录了一个文件的链接数，就inode 51681517来说，链接数至少是2。因为在文件系统的其他部分或许还存在着这个文件的其他链接。</p>
<p>链接数被记录在inode中，同时也是系统调用stat返回值stat结构中的一个成员</p>
<h4 id="与目录树相关的命令和系统调用"><a href="#与目录树相关的命令和系统调用" class="headerlink" title="与目录树相关的命令和系统调用"></a>与目录树相关的命令和系统调用</h4><p><strong>mkdir</strong></p>
<p>用于创建新的目录。它接受命令行上的一个或多个目录名，使用mkdir(2)系统调用.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure>

<p>实际上mkdir创建了一个新的目录节点并把它链接至文件系统树：</p>
<ul>
<li>mkdir创建了这个目录的inode</li>
<li>分配了一个磁盘块用以存储它的内容</li>
<li>在目录中设置了两个入口： <code>.</code>和 <code>..</code>并正确配置了它们的 i-节点号</li>
<li>在它的父目录中增加一个该节点的链接</li>
</ul>
<p><strong>rmdir</strong></p>
<p>用于删除一个目录，使用rmdir(2)系统调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rmdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure>

<p>rmdir从目录树中删除一个目录节点。这个目录必须是空的。即除了 <code>.</code>和 <code>..</code>的入口，这个目录不能包含其他任何的文件和子目录。同时在父目录中删除这个目录的链接，如果这个目录本身并未被其他进程占用，它的inode和数据块将被释放</p>
<p><strong>rm</strong></p>
<p>用来从一个目录文件中删除一条记录，接受命令行上一个或多个文件名，使用unlink(2)系统调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure>

<p>unlink用于删除目录文件中的一个记录，减少相应inode的链接数。如果该inode的链接数减为0，数据块和inode将被释放（和C++中shared_ptr的设计思想很像，妙）。unlink不能用于删除目录</p>
<p><strong>ln</strong></p>
<p>用来创建一个文件的链接，使用系统调用link(2)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">link</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *oldpath, <span class="type">const</span> <span class="type">char</span> *newpath)</span>;</span><br></pre></td></tr></table></figure>

<p>link不能用来生成目录的新链接</p>
<p><strong>mv</strong></p>
<p>用来改变文件和目录的名字或位置。很多情况下mv仅仅使用系统调用rename</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rename</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *oldpath, <span class="type">const</span> <span class="type">char</span> *newpath)</span>;</span><br></pre></td></tr></table></figure>

<p>当入参位于同一个目录时，即实现了重命名</p>
<p>当入参位于不同的目录时，即实现了移动，由于实际上目录中存放的是链接，因此就是把链接从一个目录移动到另一个目录：</p>
<ul>
<li>复制链接至新的名字&#x2F;位置（调用link()）</li>
<li>删除原来的链接（调用unlink()）</li>
</ul>
<p>实际上过去没有rename这个系统调用，而是结合link和unlink使用，新增的目的是：</p>
<ul>
<li>rename使重命名或重定位一个目录变得更加安全</li>
<li>可以支持非Unix系统。将通用方法rename添加至内核隐藏了实现的细节，使相同的代码能够在各种文件系统上运行</li>
</ul>
<p><strong>cd</strong></p>
<p>用来改变进程的当前目录。cd对进程产生影响，但是并不影响目录。</p>
<p>cd使用系统调用chdir()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span>;</span><br></pre></td></tr></table></figure>

<p>Unix上的每个运行程序都有一个当前目录，chdir系统调用改变进程的当前目录。在系统内部，进程有一个存放当前目录 i-节点号的变量。从一个目录进入另一个目录只是改变那个变量的值</p>
<h3 id="编写pwd"><a href="#编写pwd" class="headerlink" title="编写pwd"></a>编写pwd</h3><p>命令pwd用来显式到达当前目录的路径</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zhangqi@localhost chap4]$ <span class="built_in">pwd</span></span><br><span class="line">/home/zhangqi/ZZQ/test/chap4</span><br></pre></td></tr></table></figure>

<p>这个路径并不位于当前的目录中，当前目录称呼其本身为<code>.</code>  ，并且有一个 i-节点号。</p>
<p>因此要获得完整的路径名，要追踪链接，读取目录，一个目录接着一个目录地沿着树向上追踪，每步查看 <code>.</code>的节点号（自身的节点号），然后<u>在父目录中查找该 inode的名字</u>，直到到达树的顶端。</p>
<p>伪代码：</p>
<p>while(没有到达树的顶端){</p>
<p>​        得到 <code>.</code>的i-节点号，称其为n（使用stat）</p>
<p>​        chdir.. （使用chdir）</p>
<p>​        找到 i-节点号 n链接的名字（使用opendir、readdir 、closedir）</p>
<p>}</p>
<p>如何判断是否达到树的顶端：判断直到一个目录的 <code>.</code>和 <code>..</code>的 i-节点号相同时</p>
<p>如何以证券顺序显示目录名字：建立一个循环，使用strcat或sprintf建立目录名字的字符串序列。通过一个递归的程序逐步到达树的顶端来一个接一个地显示目录名，从而避免了字符串的管理</p>
<p><strong>pwd的实现</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// spwd.c: a simplified version of pwd</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// starts in current directory and recursively</span></span><br><span class="line"><span class="comment">// climbs up to root of filesystem, prints top part</span></span><br><span class="line"><span class="comment">// then prints current part</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// uses readdir() to get info about each thing</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">ino_t</span> <span class="title function_">get_ino</span><span class="params">(<span class="type">char</span> *dir)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">printpath</span><span class="params">(<span class="type">ino_t</span> this_inode)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">inode_num_to_name</span><span class="params">(<span class="type">ino_t</span> this_ino, <span class="type">char</span> this_inode_name[BUFSIZ])</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">int</span> ino = get_ino(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (ino == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;/\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">  &#125;</span><br><span class="line">  printpath(ino);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// prints path leadin down to an object with this inode</span></span><br><span class="line"><span class="comment">// kindof recursive</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">printpath</span><span class="params">(<span class="type">ino_t</span> this_ino)</span> &#123;</span><br><span class="line">  <span class="type">char</span> this_inode_name[BUFSIZ];</span><br><span class="line">  <span class="type">ino_t</span> father_inode_num = get_ino(<span class="string">&quot;..&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (father_inode_num != this_ino) &#123;</span><br><span class="line">    inode_num_to_name(this_ino, this_inode_name);</span><br><span class="line">    chdir(<span class="string">&quot;..&quot;</span>);</span><br><span class="line">    printpath(father_inode_num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;/%s&quot;</span>, this_inode_name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// returns inode number of the file</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">ino_t</span> <span class="title function_">get_ino</span><span class="params">(<span class="type">char</span> *dir)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">info</span>;</span></span><br><span class="line">  <span class="keyword">if</span> (stat(dir, &amp;info) == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Cannot stat &quot;</span>);</span><br><span class="line">    perror(dir);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> info.st_ino;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// looks through current directory for a file with this inode</span></span><br><span class="line"><span class="comment">// number and copies its name into namebuf</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">inode_num_to_name</span><span class="params">(<span class="type">ino_t</span> this_ino, <span class="type">char</span> this_inode_name[])</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dirent_p</span>;</span></span><br><span class="line">  DIR *dir_p = opendir(<span class="string">&quot;..&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (dir_p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;..&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// search directory for a file with specified inum</span></span><br><span class="line">  <span class="keyword">while</span> ((dirent_p = readdir(dir_p)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dirent_p-&gt;d_ino == this_ino) &#123;</span><br><span class="line">      <span class="built_in">strcpy</span>(this_inode_name, dirent_p-&gt;d_name);</span><br><span class="line">      closedir(dir_p);</span><br><span class="line">      <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;error looking from inum %ld\n&quot;</span>, this_ino);</span><br><span class="line">  <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="连接控制：学习stty"><a href="#连接控制：学习stty" class="headerlink" title="连接控制：学习stty"></a>连接控制：学习stty</h2><p>计算机除了文件和目录相关的程序，还有其他的数据来源，如调制解调器、打印机、扫描仪、鼠标、扬声器、照相机和终端等这样的设备。</p>
<p>设备的读写方法：对Unix来说，声卡，终端，鼠标和磁盘文件是同一种对象。在Unix系统中，每个设备都被当做一个文件。每个设备都有一个文件名，一个i-节点号、一个文件所有者、一个权限位的集合和最近修改时间。</p>
<p>和文件有关的所有内容都将被运用于终端和其他设备</p>
<p><strong>设备具有文件名</strong></p>
<p>通常表示设备的文件存放在目录&#x2F;dev中（devices），但是可以在任何目录中创建设备文件。</p>
<p>查看我的机器上的&#x2F;dev目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -C /dev | <span class="built_in">head</span> -5</span><br><span class="line">agpgart		 kmsg		     rtc       tty2   tty44  ttyS2</span><br><span class="line">autofs		 <span class="built_in">log</span>		     rtc0      tty20  tty45  ttyS3</span><br><span class="line">block		 loop0		     sda       tty21  tty46  uhid</span><br><span class="line">bsg		 loop1		     sda1      tty22  tty47  uinput</span><br><span class="line">btrfs-control	 loop2		     sda2      tty23  tty48  urandom</span><br></pre></td></tr></table></figure>

<p><strong>相关系统调用</strong></p>
<p>设备不仅具有文件名，还支持所有与文件相关的系统调用：open、read、write、lseek、close和stat</p>
<p>实际上Unix没有其他的方法用来和设备通信。</p>
<p><strong>设备文件的属性</strong></p>
<p>（这部分没有太理解，暂时简单记录并略过）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -li /dev/pts/1</span><br><span class="line">4 crw--w----. 1 zhangqi <span class="built_in">tty</span> 136, 1 Sep 10  2022 /dev/pts/1</span><br></pre></td></tr></table></figure>

<p>设备文件具有磁盘文件的大部分属性。如上面ls的输出内容表明&#x2F;dev&#x2F;pts&#x2F;1 拥有inode 4，权限位为rw–w—-，1个链接，文件所有者zhangqi和组tty，最近修改时间为Sep 10 2022。文件类型为“c”，表示这个文件实际上是以字符为单位进行传送的设备</p>
<p>常用的磁盘文件中的字节数就是文件的大小。但设备文件是链接而不是容器。键盘和鼠标不存储击键数和点击数。</p>
<p>设备文件的inode存储的是指向内核子程序的指针，而不是文件的大小和存储列表。</p>
<p>内核中传输设备数据的子程序被称为设备驱动程序。</p>
<p>在&#x2F;dev&#x2F;pts&#x2F;1中，参数是1。136和1这两个数被称为设备的主设备号和从设备号：</p>
<ul>
<li>主设备号确定处理该设备实际的子程序</li>
<li>从设备号被作为参数传输到该子程序</li>
</ul>
<p><u>设备文件的读写执行权限：</u></p>
<p>当文件实际上表示设备时</p>
<ul>
<li>向文件写入数据就是把数据发送到设备，权限写意味着允许发送数据</li>
<li>读文件就是从文件获得数据</li>
</ul>
<p><strong>Unix文件系统的inode和数据块是如何支持设备文件的概念的：</strong></p>
<img src="https://pic.imgdb.cn/item/631b7f3416f2c2beb1389f1d.jpg" style="zoom:80%;" />

<ul>
<li>目录并不能区分哪些文件名代表磁盘文件，哪些文件名代表设备</li>
<li>文件类型的区别体现在inode上：<ul>
<li>每个inode的类型被记录在结构stat的成员变量st_mode的类型区域中</li>
<li>磁盘文件的inode包含指向数据块的指针。设备文件的inode包含指向内核子程序表的指针</li>
<li>主设备号用于告知从设备读取数据的那部分代码的位置</li>
</ul>
</li>
<li>考虑read的工作流程（其他如open、write、lseek和close等都是类似的）：<ul>
<li>内核首先找到文件描述符fd的inode，该inode用于告诉内核文件的类型</li>
<li>如果文件是磁盘文件，那么内核通过访问块分配表来读取数据</li>
<li>如果文件是设备文件，那么内核通过调用该设备驱动程序的read部分来读取数据</li>
</ul>
</li>
</ul>
<p><strong>设备和文件的不同之处</strong></p>
<img src="https://pic.imgdb.cn/item/631b812616f2c2beb13aa6ff.jpg" style="zoom:80%;" />

<p>系统通过调用open创建文件和设备与进程的连接，但是他们有着不同的性质。<br><strong>磁盘连接</strong>的两个主要属性：</p>
<ul>
<li>缓冲：磁盘文件有缓冲区，可以通过fcntl()关闭</li>
<li>自动添加模式：即当文件描述符的O_APPEND打开后，每个对write的调用自动调用lseek将内容添加到文件末尾。</li>
</ul>
<p><strong>终端连接</strong>：<br>具有回显，波特率， 编辑和换行会话。</p>
<p><strong>终端</strong><br>终端是人们用来和unix进程进行通信的设备。终端拥有一个可以让进程读取字符的键盘和可让进程发送字符的显示器。<br>进程与终端间的数据传输和数据处理由<u>终端驱动程序</u>负责，终端驱动程序是内核的一部分，该部分代码提供缓冲，编辑和数据转换</p>
<img src="https://pic.imgdb.cn/item/631b843116f2c2beb13d11fd.jpg" style="zoom:80%;" />

<p><strong>stty命令</strong></p>
<p>stty命令让用户读取和修改终端驱动程序的设置</p>
<p>使用stty显示驱动程序设置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">stty</span></span><br><span class="line">speed 38400 baud; line = 0;</span><br><span class="line">eol = M-^?; eol2 = M-^?; swtch = M-^?;</span><br><span class="line">ixany iutf8</span><br></pre></td></tr></table></figure>

<p><strong>使用stty改变驱动程序属性</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">stty</span> erase X     <span class="comment">#将删除键改为X</span></span><br><span class="line">$ <span class="built_in">stty</span> - <span class="built_in">echo</span>      <span class="comment">#关闭按键显示，即输入的字符不显示在屏幕上</span></span><br><span class="line">$ <span class="built_in">stty</span> erase @ <span class="built_in">echo</span> <span class="comment">#复合命令：将删除键改为@，并打开按键显示</span></span><br></pre></td></tr></table></figure>

<p><strong>编写终端驱动程序</strong></p>
<p><u>关于设置</u></p>
<p>tty驱动程序包含很多对传入的数据所进行的操作。这些操作分为4种：</p>
<ul>
<li>输入：如何处理从终端来的字符。包括将小写转换为大写，去除最高位及将回车符转换为换行符</li>
<li>输出：如何处理流向终端的字符。用若干个空格符代替制表符，将换行符转换为回车符及将小写字母转换为大写字母</li>
<li>控制：字符如何被表示——位的个数、位的奇偶性、停止位等</li>
<li>本地：如何处理来自驱动程序内部的字符。包括回显字符给用户及缓冲输入直到用户按回车键</li>
</ul>
<p><u>关于函数</u></p>
<p>改变终端驱动程序的设置就像改变磁盘文件连接的设置一样：</p>
<ul>
<li>从驱动程序获得属性</li>
<li>修改所要修改的属性</li>
<li>将修改过的属性送回驱动程序</li>
</ul>
<p>如，以下代码为一个连接开启字符回显</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">settings</span>;</span>		<span class="comment">//struct to hold attributes</span></span><br><span class="line">tcgetattr(fd,&amp;settings);		<span class="comment">//get attribs from driver</span></span><br><span class="line">settings.c_lflag | = ECHO;		<span class="comment">//turn on ECHO bit in flagset</span></span><br><span class="line">tcsetattr(fd, TCSANOW, &amp;settings); <span class="comment">//send attribs back to driver</span></span><br></pre></td></tr></table></figure>



<p><u>相关系统调用</u></p>
<ul>
<li><code>tcsetattr</code>：设置tty驱动程序的属性，遇到错误返回-1，成功返回0<ul>
<li>optional_actions参数告诉tcsetsttr在什么时候更新驱动程序</li>
<li>TCSANOW：立即更新驱动程序设置</li>
<li>TCSADRAIN：等待直到驱动程序队列中的所有输出都被传送到终端。然后更新</li>
<li>TCSAFLUSH：等待直到驱动程序队列中的所有输出都被传送出去。然后，释放所有队列中的输入数据，并进行一定的变化</li>
</ul>
</li>
<li><code>tcgetattr</code>：读取tty驱动程序的属性</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">tcgetattr</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> termios *termios_p)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">tcsetattr</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> optional_actions,</span></span><br><span class="line"><span class="params">              <span class="type">const</span> <span class="keyword">struct</span> termios *termios_p)</span>;</span><br></pre></td></tr></table></figure>

<p>termios的结构（包含若干个标志集和一个控制字符的数组）和位：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">The termios structure</span><br><span class="line">    Many  of the functions described here have a termios_p argument that is</span><br><span class="line">    a pointer to a termios structure.  This structure contains at least the</span><br><span class="line">    following members:</span><br><span class="line"></span><br><span class="line"><span class="type">tcflag_t</span> c_iflag;      <span class="comment">/* input modes */</span></span><br><span class="line"><span class="type">tcflag_t</span> c_oflag;      <span class="comment">/* output modes */</span></span><br><span class="line"><span class="type">tcflag_t</span> c_cflag;      <span class="comment">/* control modes */</span></span><br><span class="line"><span class="type">tcflag_t</span> c_lflag;      <span class="comment">/* local modes */</span></span><br><span class="line"><span class="type">cc_t</span>     c_cc[NCCS];   <span class="comment">/* special characters */</span></span><br></pre></td></tr></table></figure>

<p>每个标志集的独立位的含义：（前四个为标志集，c_cc为控制字符的数组）</p>
<img src="https://pic.imgdb.cn/item/631c9e5616f2c2beb13a8a62.jpg" style="zoom:80%;" />

<p>每个属性在标志集中都占有一位。属性的掩码定义在termios.h中。</p>
<img src="https://pic.imgdb.cn/item/631c9eea16f2c2beb13b24a2.jpg" style="zoom:80%;" />

<p><strong>其他设备编程</strong></p>
<ul>
<li><p><code>fcntl</code>：控制文件描述符</p>
</li>
<li><p><code>ioctl</code>：控制一个设备，request为需进行的操作，…为操作所需参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ioctl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> request, ...)</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="为用户编程：终端控制和信号"><a href="#为用户编程：终端控制和信号" class="headerlink" title="为用户编程：终端控制和信号"></a>为用户编程：终端控制和信号</h2><p><strong>软件工具</strong>：对磁盘文件和设备文件不加以区分的程序（Unix中有好几百个，如who、ls、sort等）</p>
<ul>
<li><p>从标准输入stdin或文件读取字节，进行一些处理，然后将包含结果的字节流写到标准输出stdout</p>
</li>
<li><p>工具发送错误消息到标准错误输出，它们也被当作简单的字节流来处理。</p>
</li>
<li><p>这些文件描述符能够连接到文件、终端、鼠标、光电管、打印机等</p>
</li>
<li><p>工具对所处理的数据的源和目的地不做任何假设</p>
</li>
<li><p>其他很多程序也能从命令行所指定的文件中读取数据</p>
</li>
<li><p>这些程序的输入和输出能够被重定向到任何类型的连接上：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sort</span> &gt; outputfile</span><br><span class="line">$ <span class="built_in">sort</span> x &gt; /dev/lp</span><br><span class="line">$ <span class="built_in">who</span> | <span class="built_in">tr</span> <span class="string">&#x27;[a - z]&#x27;</span> <span class="string">&#x27;[A - Z]&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<img src="https://pic.imgdb.cn/item/631b932c16f2c2beb1479ce0.jpg" style="zoom:80%;" />

<p><strong>特定设备程序：为特定应用控制设备</strong></p>
<p>其他程序（如终端、控制扫描仪、记录压缩盘、操作磁带驱动程序）也能同特定设备进行交互。</p>
<p><strong>用户程序：一种常见的设备相关程序</strong></p>
<p>如vi、emacs、pine、more等</p>
<p>这些程序设置终端驱动程序的击键和输出处理方式。驱动程序有很多设置，但是用户常用到的有：</p>
<ol>
<li>立即响应击键事件</li>
<li>有限的输入集</li>
<li>输入的超时</li>
<li>屏蔽Ctrl-C</li>
</ol>
<p>下面将编写一个实现所有这些特点的程序</p>
<h3 id="终端驱动程序的模式"><a href="#终端驱动程序的模式" class="headerlink" title="终端驱动程序的模式"></a>终端驱动程序的模式</h3><p><strong>规范处理</strong></p>
<p>首先看一个简短的转换程序（将输入的字符串的所有字符改为该字符的下一个）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="keyword">while</span>((c = getchar())!=EOF)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;z&#x27;</span>)  c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">islower</span>(c)) ++c;</span><br><span class="line">        <span class="built_in">putchar</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用默认设置运行这个程序（&lt;- 是退格键）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cc rotate.c -o rotate</span><br><span class="line">$ ./rotate</span><br><span class="line">abx&lt;-<span class="built_in">cd</span></span><br><span class="line">bcde</span><br><span class="line"></span><br><span class="line">efgCtrl-C</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<img src="https://pic.imgdb.cn/item/631b99af16f2c2beb14b5017.jpg" style="zoom:80%;" />

<p>上述结果揭示了标准输入处理的特征：</p>
<ul>
<li>程序未得到输入的“x”，因为退格键删除了它</li>
<li>击键的同时字符显示在屏幕上，但是直到按了回车键，程序才接收到输入</li>
<li>Ctrl-C键结束输入并终止程序</li>
</ul>
<p>程序rotate不做这些操作。缓冲、回显、编辑和控制键处理都由驱动程序完成：</p>
<img src="https://pic.imgdb.cn/item/631b9b6f16f2c2beb14caf1a.jpg" style="zoom:80%;" />

<p>缓冲和编辑包含规范处理（canonical rpocessing）。当这些特征被启动，终端连接被称为处于<strong>规范模式</strong>（cooked模式）。</p>
<p><strong>非规范处理</strong></p>
<p>命令 <code>stty -icanon</code>会关闭驱动程序的规范模式处理。非规范模式没有缓冲，因此输入一个字母就会直接显示。当试图删除一个字符，驱动程序不能做任何事情；字符早就送给程序了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[zhangqi@localhost chap6]$ <span class="built_in">stty</span> -icanon</span><br><span class="line">[zhangqi@localhost chap6]$ ./rotate</span><br><span class="line">abstdefg~~??^?^?^?^C</span><br><span class="line">[zhangqi@localhost chap6]$ <span class="built_in">stty</span> icanon</span><br></pre></td></tr></table></figure>

<p>另外也可以通过 <code>stty -icanon -echo</code>同时关闭规范模式和回显模式</p>
<p><strong>raw模式</strong></p>
<p>当所有处理都被关闭后，驱动程序将输入直接原封不动传递给程序。这种情况下驱动程序被称为处于raw模式、</p>
<h3 id="编写play-again-c"><a href="#编写play-again-c" class="headerlink" title="编写play_again.c"></a>编写play_again.c</h3><p>逻辑：</p>
<ul>
<li>对用户显示提示问题</li>
<li>接受输入</li>
<li>如果是“y”，返回0</li>
<li>如果是“n”，返回1</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// purpose: ask if user wants another transaction</span></span><br><span class="line"><span class="comment">//  method: ask a quesion, wait for yes/no anser</span></span><br><span class="line"><span class="comment">// returns: 0=&gt;yes, 1=&gt;no</span></span><br><span class="line"><span class="comment">//  better: eliminate need to press return</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUESTION <span class="string">&quot;Do you want another transaction&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">get_response</span><span class="params">(<span class="type">char</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> response;</span><br><span class="line">    response = get_response(QUESTION);</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">get_response</span><span class="params">(<span class="type">char</span> *question)</span> &#123;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s (y/n)?&quot;</span>, question);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(c = getchar()) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;y&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;Y&#x27;</span>: <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;N&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> EOF: <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// no default, ignore all other input</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序显示提问，然后循环读取输入，直到用户输入“y”、“n”、“Y”或“N”才停止。</p>
<p>有两个问题，都是由于运行时处在规范模式引起的：</p>
<ul>
<li>用户必须按回车键，play_again0才能接收到数据</li>
<li>当用户按回车键时，接收整行数据并对其进行处理</li>
</ul>
<p><strong>改进1：即时响应</strong></p>
<p>因此第一个改进就是关闭规范输入，使程序能在用户敲键的同时得到输入的字符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// play_again1.c</span></span><br><span class="line"><span class="comment">// purpose: ask if user wants another transaction</span></span><br><span class="line"><span class="comment">//  method: set tty into char-by-char mode, read char, return result</span></span><br><span class="line"><span class="comment">// returns: 0=&gt;yes, 1=&gt;no</span></span><br><span class="line"><span class="comment">//  better: do no echo inappropriate input</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUESTION <span class="string">&quot;Do you want another transaction&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">tty_mode</span><span class="params">(<span class="type">int</span> how)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">set_crmode</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">get_response</span><span class="params">(<span class="type">char</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    tty_mode(<span class="number">0</span>); <span class="comment">// save tty mode</span></span><br><span class="line">    set_crmode();</span><br><span class="line">    <span class="type">int</span> response = get_response(QUESTION);</span><br><span class="line">    tty_mode(<span class="number">1</span>); <span class="comment">// reload tty mode</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">tty_mode</span><span class="params">(<span class="type">int</span> how)</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">original_mode</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (how == <span class="number">0</span>) &#123;</span><br><span class="line">        tcgetattr(<span class="number">0</span>, &amp;original_mode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        tcsetattr(<span class="number">0</span>, TCSANOW, &amp;original_mode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">set_crmode</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">ttystate</span>;</span></span><br><span class="line">    tcgetattr(<span class="number">0</span>, &amp;ttystate);</span><br><span class="line">    ttystate.c_lflag &amp;= ~ICANON; <span class="comment">// no buffering</span></span><br><span class="line">    ttystate.c_cc[VMIN] = <span class="number">1</span>; <span class="comment">// get one char at a time</span></span><br><span class="line">    tcsetattr(<span class="number">0</span>, TCSANOW, &amp;ttystate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">get_response</span><span class="params">(<span class="type">char</span> *question)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s (y/n)?&quot;</span>, question);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">char</span> c = getchar();</span><br><span class="line">        <span class="keyword">switch</span>(c) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;y&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;Y&#x27;</span>: <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;N&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> EOF: <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\ncannot understand %c, &quot;</span>, c);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Please type y or n\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>play_again1首先将终端置于一个char-by-char模式，然后调用函数显示一个提示符，并获得一个响应，最后设置终端为原始的模式。</p>
<p>注意：最后并未将终端置于桂丹模式。取而代之的是，将原先的设置复制到一个称为original_mode的结构中，结束时恢复这些设置。</p>
<p><strong>改进2：忽略非法键</strong></p>
<p>上述实现对每个非法字符都提示错误信息。因此更好的设计时关闭回显模式，丢掉不需要的字符，直到得到可接受的字符为止。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// play_again2.c</span></span><br><span class="line"><span class="comment">// purpose: ask if user wants another transaction</span></span><br><span class="line"><span class="comment">//  method: set tty into char-by-char mode and no -echo mode</span></span><br><span class="line"><span class="comment">//          read char, return result</span></span><br><span class="line"><span class="comment">// returns: 0=&gt;yes, 1=&gt;no</span></span><br><span class="line"><span class="comment">//  better: time out if user walks away</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUESTION <span class="string">&quot;Do you want another transaction&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">tty_mode</span><span class="params">(<span class="type">int</span> how)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">set_cr_noecho_mode</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">get_response</span><span class="params">(<span class="type">char</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    tty_mode(<span class="number">0</span>); <span class="comment">// save tty mode</span></span><br><span class="line">    set_cr_noecho_mode();</span><br><span class="line">    <span class="type">int</span> response = get_response(QUESTION);</span><br><span class="line">    tty_mode(<span class="number">1</span>); <span class="comment">// reload tty mode</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">tty_mode</span><span class="params">(<span class="type">int</span> how)</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">original_mode</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (how == <span class="number">0</span>) &#123;</span><br><span class="line">        tcgetattr(<span class="number">0</span>, &amp;original_mode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        tcsetattr(<span class="number">0</span>, TCSANOW, &amp;original_mode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">set_cr_noecho_mode</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">ttystate</span>;</span></span><br><span class="line">    tcgetattr(<span class="number">0</span>, &amp;ttystate);</span><br><span class="line">    ttystate.c_lflag &amp;= ~ICANON; <span class="comment">// no buffering</span></span><br><span class="line">    ttystate.c_lflag &amp;= ~ECHO; <span class="comment">// no echo either</span></span><br><span class="line">    ttystate.c_cc[VMIN] = <span class="number">1</span>; <span class="comment">// get one char at a time</span></span><br><span class="line">    tcsetattr(<span class="number">0</span>, TCSANOW, &amp;ttystate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">get_response</span><span class="params">(<span class="type">char</span> *question)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s (y/n)?&quot;</span>, question);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">char</span> c = getchar();</span><br><span class="line">        <span class="keyword">switch</span>(c) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;y&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;Y&#x27;</span>:</span><br><span class="line">                <span class="built_in">putchar</span>(<span class="string">&#x27;y&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;N&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> EOF:</span><br><span class="line">                <span class="built_in">putchar</span>(<span class="string">&#x27;n&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>改进3：非阻塞模式实现超时响应</strong></p>
<p>要求程序含有超时特征。通过设置终端驱动程序，使之不等待输入来实现这个特征：先检查看是否有输入，如果发现没有输入，则先睡眠几秒钟，然后继续检查输入。如此尝试3次之后放弃</p>
<ul>
<li>当调用getchar或read从文件描述符读取输入时，这些调用通常会等待输入。</li>
<li>在play_again例子中，对getchar的调用使得程序一直等待用户的输入，直到用户输入一个字符。</li>
<li>程序被阻塞，直到能获得某些字符或是检测到了文件的末尾</li>
</ul>
<p>如何关闭阻塞：</p>
<ul>
<li><p>阻塞不仅仅是终端连接的属性，而是任何一个打开的文件的属性</p>
</li>
<li><p>程序可以使用fcntl或open为文件描述符启动非阻塞输入（nonblock input）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ... <span class="comment">/* arg */</span> )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fcntl() performs one of the operations described below on the open file descriptor fd.  The operation is determined by cmd.</span></span><br><span class="line"><span class="comment">// fcntl() can take an optional third argument.  Whether or not this argument  is  required is determined by cmd.  The required argument type is indicated in parentheses after  each  cmd  name  (in  most  cases,  the required type is int, and we identify the argument using the name arg),  or void is specified if the argument is not required.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">File descriptor flags</span><br><span class="line">    The following commands manipulate the flags associated with  a  file  descriptor.   Currently,</span><br><span class="line">    only  one  such flag is defined: FD_CLOEXEC, the close-on-exec flag.  If the FD_CLOEXEC bit is</span><br><span class="line">    0, the file descriptor will remain open across an execve(2), otherwise it will be closed.</span><br><span class="line">  </span><br><span class="line">    F_GETFD (void)</span><br><span class="line">           Read the file descriptor flags; arg is ignored.</span><br><span class="line">  </span><br><span class="line">    F_SETFD (int)</span><br><span class="line">           Set the file descriptor flags to the value specified by arg.</span><br><span class="line">  </span><br><span class="line">File status flags</span><br><span class="line">    Each open file description has certain associated status flags,  initialized  by  open(2)  and</span><br><span class="line">    possibly  modified by fcntl().  Duplicated file descriptors (made with dup(2), fcntl(F_DUPFD),</span><br><span class="line">    fork(2), etc.) refer to the same open file description, and thus share the  same  file  status</span><br><span class="line">    flags.</span><br><span class="line">  </span><br><span class="line">    The file status flags and their semantics are described in open(2).</span><br><span class="line">  </span><br><span class="line">    F_GETFL (void)</span><br><span class="line">           Get the file access mode and the file status flags; arg is ignored.</span><br><span class="line">  </span><br><span class="line">    F_SETFL (int)</span><br><span class="line">           Set  the  file status flags to the value specified by arg.  File access mode (O_RDONLY,</span><br><span class="line">           O_WRONLY, O_RDWR) and file creation flags (i.e., O_CREAT, O_EXCL, O_NOCTTY, O_TRUNC) in</span><br><span class="line">           arg  are  ignored.   On  Linux  this  command  can  change  only the O_APPEND, O_ASYNC,</span><br><span class="line">           O_DIRECT, O_NOATIME, and O_NONBLOCK flags.</span><br><span class="line">  </span><br></pre></td></tr></table></figure>


</li>
<li><p>可传入O_NDELAY或O_NONBLOCK开启非阻塞模式</p>
</li>
<li><p>非阻塞操作的内部实现很简单：每个文件都有一块保存未读取数据的地方。如果文件描述符置了O_NDELAY位，并且那块空间是空的，read调用返回0.可以参考O_NDELAY有关的源代码深入了解</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// play_again3.c</span></span><br><span class="line"><span class="comment">// purpose: ask if user wants another transaction</span></span><br><span class="line"><span class="comment">//  method: set tty into char-by-char mode, no -echo mdoe</span></span><br><span class="line"><span class="comment">//          set tty into no -delay mode</span></span><br><span class="line"><span class="comment">//          read char, return result</span></span><br><span class="line"><span class="comment">// returns: 0=&gt;yes, 1=&gt;no, 2=&gt;timeout</span></span><br><span class="line"><span class="comment">//  better: reset terminal mode on Interrupt</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUESTION <span class="string">&quot;Do you want another transaction&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRIES 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SLEEPTIME 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BEEP putchar(<span class="string">&#x27;\a&#x27;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">tty_mode</span><span class="params">(<span class="type">int</span> how)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">set_nodelay_mode</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">set_cr_noecho_mode</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">get_ok_char</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">get_response</span><span class="params">(<span class="type">char</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> maxtries = TRIES; <span class="comment">// 教材版源代码实际上漏掉了该变量的声明</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  tty_mode(<span class="number">0</span>); <span class="comment">// save tty mode</span></span><br><span class="line">  set_nodelay_mode();</span><br><span class="line">  set_cr_noecho_mode();</span><br><span class="line">  <span class="type">int</span> response = get_response(QUESTION);</span><br><span class="line">  tty_mode(<span class="number">1</span>); <span class="comment">// reload tty mode</span></span><br><span class="line">  <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">tty_mode</span><span class="params">(<span class="type">int</span> how)</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">original_mode</span>;</span></span><br><span class="line">  <span class="keyword">if</span> (how == <span class="number">0</span>) &#123;</span><br><span class="line">    tcgetattr(<span class="number">0</span>, &amp;original_mode);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    tcsetattr(<span class="number">0</span>, TCSANOW, &amp;original_mode);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">set_nodelay_mode</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> termflags;</span><br><span class="line">  termflags = fcntl(<span class="number">0</span>, F_GETFL);</span><br><span class="line">  termflags |= O_NDELAY;</span><br><span class="line">  fcntl(<span class="number">0</span>, F_SETFL, termflags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">set_cr_noecho_mode</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">ttystate</span>;</span></span><br><span class="line">  tcgetattr(<span class="number">0</span>, &amp;ttystate);</span><br><span class="line">  ttystate.c_lflag &amp;= ~ICANON; <span class="comment">// no buffering</span></span><br><span class="line">  ttystate.c_lflag &amp;= ~ECHO; <span class="comment">// no echo either</span></span><br><span class="line">  ttystate.c_cc[VMIN] = <span class="number">1</span>; <span class="comment">// get one char at a time</span></span><br><span class="line">  tcsetattr(<span class="number">0</span>, TCSANOW, &amp;ttystate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">get_ok_char</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> c;</span><br><span class="line">  <span class="keyword">while</span> ((c = getchar()) != EOF &amp;&amp; <span class="built_in">strchr</span>(<span class="string">&quot;yYnN&quot;</span>, c) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">get_response</span><span class="params">(<span class="type">char</span> *question)</span> &#123;</span><br><span class="line">  <span class="type">int</span> c;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s (y/n)?&quot;</span>, question);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    sleep(SLEEPTIME);</span><br><span class="line">    c = <span class="built_in">tolower</span>(get_ok_char());</span><br><span class="line">    <span class="keyword">if</span> (c != EOF)</span><br><span class="line">      <span class="built_in">putchar</span>(c);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (maxtries-- == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    BEEP;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个版本的程序使用fcntl关闭和开启非阻塞模式，其次在get_response中使用aleep和计数器maxtries</p>
<p>小问题：</p>
<ul>
<li>程序会在调用getchar给用户输入字符之前睡眠2s。就算用户在1s内完成输入，程序也要在2s后才得到字符，用户体验不好<ul>
<li>为了使程序更快响应，可以减少每次调用getchar间的睡眠时间，并相应增加循环次数来实现相同的超时设置</li>
</ul>
</li>
<li>另外注意在显示提示符之后对fflush的调用。如果没有这一行，在调用getchar之前，提示符将不能显示。原因是终端驱动程序不仅一行行地缓冲输入，还一行行地缓冲输出。驱动程序缓冲输出，直到它收到一个换行符或者程序试图从终端读取输入</li>
</ul>
<p>实现超时的其他方法：</p>
<p>Unix提供更好的方法来实现超时功能，在驱动程序中设置数组c_cc[]中的元素VTIME将超时功能的实现移至终端驱动程序。系统调用select包含一个超时参数。</p>
<p>还有一个大问题（如果不是bash等中断，可能会）：</p>
<p>当按下Ctrl-C终止程序play-again时，会导致程序无法执行重置驱动程序的代码。</p>
<img src="https://pic.imgdb.cn/item/631ccb4816f2c2beb16be72d.jpg" style="zoom:80%;" />

<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>Ctrl-C中断当前运行的程序。这个中断由一个称为信号的内核机制产生。</p>
<img src="https://pic.imgdb.cn/item/631ccb7616f2c2beb16c0fbd.jpg" style="zoom:80%;" />

<p>中断信号的击键组合不一定非是Ctrl-C，可以使用stty（或tcsetattr）将当前的VINTR控制字符替换成另一种键</p>
<p><strong>信号是什么</strong></p>
<p>信号是由单个词组成的消息。当按Ctrl-C时，内核向当前正在运行的进程发送中断信号。</p>
<p>每个信号都有一个数字编码。中断信号通常是编码2.</p>
<p>生成信号的请求来自三个地方：</p>
<ul>
<li>用户。用户通过输入Ctrl-C、Ctrl-\，或是终端驱动程序分配给信号控制字符的其他任何键来请求内核产生信号</li>
<li>内核。当进程执行出错时，内核给进程发送一个信号，例如，非法段存取、浮点数溢出，或是一个非法的机器指令。内核也利用信号通知进程特定事件的发生</li>
<li>进程。一个进程可以通过系统调用kill给另一个进程发送信号。一个进程可以和另一个进程通过信号通信。</li>
</ul>
<p>由进程的某个操作产生的信号被同步信号（Synchronous Signals），例如，被0除。</p>
<p>由用户击键这样的进程外时间引起的信号被称为异步信号（Asynchronous Aignals）。</p>
<p>信号编号以及它们的名字通常出现在 <code>/usr/include/signal.h</code>文件中</p>
<p>通过查看signal(7)：</p>
<img src="C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20220911015332382.png" alt="image-20220911015332382" style="zoom:80%;" />

<p>中断信号被称为SIGINT，退出信号被称为SIGQUIT，非法段存取信号是SIGSEGV。</p>
<p><strong>进程如何处理信号</strong></p>
<p>当接收到SIGINT时，并不一定非要消亡。进程能够通过系统调用signal告诉内核，它要如何处理信号，有三个选择：</p>
<ul>
<li><p>接受默认处理（通常是消亡）</p>
<ul>
<li>手册上列出了对每个信号的默认处理。SIGINT的默认处理是消亡。</li>
<li>进程并不一定要使用signal接受默认处理，但是能通过调用<code>signal(SIGINT, SIG_DFL);</code>来恢复默认处理</li>
</ul>
</li>
<li><p>忽略信号</p>
<ul>
<li>可通过 <code>signal(SIGINT, SIG_IGN);</code>来告诉内核，它需要忽略SIGINT信号</li>
</ul>
</li>
<li><p>调用一个函数</p>
<ul>
<li><p>是三个选择中最强大的一种</p>
</li>
<li><p>考虑play_again3的例子。当用户输入Ctrl-C，当前运行的程序会立即退出而不调用恢复驱动程序设置的函数。更好的做法是，程序在接收到SIGINT后，调用一个恢复设置的函数，然后再退出。</p>
</li>
<li><p>通过 <code>signal(signum, functionname);</code>可以在信号到来时调用信号处理函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>signum为需相应的信号，handler为如何响应</p>
</li>
<li><p>handler可以是函数名或以下两个特殊值之一：</p>
<ul>
<li>SIG_IGN，忽略信号</li>
<li>SIG_DFL，将信号恢复为默认处理</li>
</ul>
</li>
<li><p>signal返回前一个处理函数。值是指向函数的指针</p>
</li>
</ul>
</li>
</ul>
<p><strong>信号处理的例子</strong></p>
<p><u>捕捉信号</u></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    signal(SIGINT,f);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello%d\n&quot;</span>,i);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> signum)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;OUCH! \n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译并运行，在中途击键Ctrl-C</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ./sigdemo1 </span><br><span class="line">hello0</span><br><span class="line">hello1</span><br><span class="line">hello2</span><br><span class="line">^COUCH! </span><br><span class="line">hello3</span><br><span class="line">hello4</span><br></pre></td></tr></table></figure>

<p><u>忽略信号</u></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line">        <span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        signal(SIGINT,SIG_IGN);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;you can&#x27;t stop me!&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;haha%d\n&quot;</span>,i);</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译并运行，随意击键Ctrl-C不会有影响</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./sigdemo2</span><br><span class="line">you can<span class="string">&#x27;t stop me!haha0</span></span><br><span class="line"><span class="string">haha1</span></span><br><span class="line"><span class="string">^Chaha2</span></span><br><span class="line"><span class="string">^Chaha3</span></span><br><span class="line"><span class="string">haha4</span></span><br></pre></td></tr></table></figure>

<p><strong>为处理信号做准备：play_again4.c</strong></p>
<p>下面这个程序版本捕捉SIGINT，重置驱动程序，然后返回no的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// play_again4.c</span></span><br><span class="line"><span class="comment">// purpose: ask if user wants another transaction</span></span><br><span class="line"><span class="comment">//  method: set tty into char-by-char mode, no -echo mdoe</span></span><br><span class="line"><span class="comment">//          set tty into no -delay mode</span></span><br><span class="line"><span class="comment">//          read char, return result</span></span><br><span class="line"><span class="comment">//          resets terminal modes on SIGINT, ignores SIGQUIT</span></span><br><span class="line"><span class="comment">// returns: 0=&gt;yes, 1=&gt;no, 2=&gt;timeout</span></span><br><span class="line"><span class="comment">//  better: reset terminal mode on Interrupt</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUESTION <span class="string">&quot;Do you want another transaction&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRIES 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SLEEPTIME 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BEEP putchar(<span class="string">&#x27;\a&#x27;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">tty_mode</span><span class="params">(<span class="type">int</span> how)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">set_nodelay_mode</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">set_cr_noecho_mode</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">ctrl_c_handler</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">get_ok_char</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">get_response</span><span class="params">(<span class="type">char</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> maxtries = TRIES; <span class="comment">// 教材版源代码实际上漏掉了该变量的声明</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  tty_mode(<span class="number">0</span>); <span class="comment">// save tty mode</span></span><br><span class="line">  set_nodelay_mode();</span><br><span class="line">  set_cr_noecho_mode();</span><br><span class="line">  signal(SIGINT, ctrl_c_handler);</span><br><span class="line">  signal(SIGQUIT, SIG_IGN);</span><br><span class="line">  <span class="type">int</span> response = get_response(QUESTION);</span><br><span class="line">  tty_mode(<span class="number">1</span>); <span class="comment">// reload tty mode</span></span><br><span class="line">  <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">tty_mode</span><span class="params">(<span class="type">int</span> how)</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">original_mode</span>;</span></span><br><span class="line">  <span class="keyword">if</span> (how == <span class="number">0</span>) &#123;</span><br><span class="line">    tcgetattr(<span class="number">0</span>, &amp;original_mode);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    tcsetattr(<span class="number">0</span>, TCSANOW, &amp;original_mode);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">set_nodelay_mode</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> termflags;</span><br><span class="line">  termflags = fcntl(<span class="number">0</span>, F_GETFL);</span><br><span class="line">  termflags |= O_NDELAY;</span><br><span class="line">  fcntl(<span class="number">0</span>, F_SETFL, termflags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">set_cr_noecho_mode</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">ttystate</span>;</span></span><br><span class="line">  tcgetattr(<span class="number">0</span>, &amp;ttystate);</span><br><span class="line">  ttystate.c_lflag &amp;= ~ICANON; <span class="comment">// no buffering</span></span><br><span class="line">  ttystate.c_lflag &amp;= ~ECHO; <span class="comment">// no echo either</span></span><br><span class="line">  ttystate.c_cc[VMIN] = <span class="number">1</span>; <span class="comment">// get one char at a time</span></span><br><span class="line">  tcsetattr(<span class="number">0</span>, TCSANOW, &amp;ttystate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">ctrl_c_handler</span><span class="params">(<span class="type">int</span> signum)</span> &#123;</span><br><span class="line">  tty_mode(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">get_ok_char</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> c;</span><br><span class="line">  <span class="keyword">while</span> ((c = getchar()) != EOF &amp;&amp; <span class="built_in">strchr</span>(<span class="string">&quot;yYnN&quot;</span>, c) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">get_response</span><span class="params">(<span class="type">char</span> *question)</span> &#123;</span><br><span class="line">  <span class="type">int</span> c;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s (y/n)?&quot;</span>, question);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    sleep(SLEEPTIME);</span><br><span class="line">    c = <span class="built_in">tolower</span>(get_ok_char());</span><br><span class="line">    <span class="keyword">if</span> (c != EOF)</span><br><span class="line">      <span class="built_in">putchar</span>(c);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (maxtries-- == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    BEEP;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="事件驱动编程：编写一个视频游戏"><a href="#事件驱动编程：编写一个视频游戏" class="headerlink" title="事件驱动编程：编写一个视频游戏"></a>事件驱动编程：编写一个视频游戏</h2><p><strong>视频游戏做什么：</strong></p>
<p>考虑一个有两个人参与的星际旅行视频游戏：</p>
<ul>
<li>程序创立行星、流星、飞船和其他物体的影像，并使它们移动。</li>
<li>每一个物体有自己的移动速度、方向、动力和其他一些属性。</li>
<li>物体之间相互作用。一个流星可能撞上飞船或其他流星。</li>
</ul>
<p>游戏同时要相应用户输入：</p>
<ul>
<li>游戏玩家们通过按钮、鼠标和轨迹球在任何时刻都有可能生成输入，程序必须在很短的时间里作出相应。</li>
<li>这些输入事件会影响游戏中物体的属性。通过按下按钮，用户可以增加飞船速度或是减小飞船质量。</li>
<li>飞船的变化会影响它与其他物体的作用方式</li>
</ul>
<p><strong>如何做</strong></p>
<p>一个视频游戏综合了一些基本的概念和原则：</p>
<ul>
<li>空间<ul>
<li>游戏必须在计算机屏幕的特定位置画影像。（程序如何控制视频显示？）</li>
</ul>
</li>
<li>时间<ul>
<li>影像以不同的速度在屏幕上移动。以一个特定的时间间隔改变位置。（程序是如何获知时间并且在特定的时间安排事情的发生？）</li>
</ul>
</li>
<li>中断<ul>
<li>程序在屏幕上平滑地移动物体，用户可在任意时刻产生输入。（程序是如何响应中断的？）</li>
</ul>
</li>
<li>同时做几件事<ul>
<li>游戏必须在保持几个物体移动的同时还要响应中断。</li>
</ul>
</li>
</ul>
<p><strong>操作系统面临类似的问题</strong></p>
<p>操作系统也要面对以上四个问题：</p>
<ul>
<li>内核将程序载入内存空间并维护每个程序在内存中所处的位置</li>
<li>在内核的调度下，程序以时间片间隔的方式运行，同时，内核也在特定的时刻运行特定的内部人物。</li>
<li>内核必须在很短的时间内响应用户和外设在任何时刻的输入。</li>
<li>内核在同时做几件事的同时还需要保证数据的有序和规整</li>
</ul>
<p><u>本章将通过编写一个基于字符终端的动画游戏来学习屏幕管理、时间、信号、和共享资源是如何安全地同时做几件事情的。</u></p>
<p><strong>任务：单人弹球游戏（Pong）</strong></p>
<p>概要描述：</p>
<ul>
<li>球以一定的速度移动</li>
<li>求碰到墙壁或挡板会被弹回</li>
<li>用户按按钮来控制挡板上下移动</li>
</ul>
<h3 id="屏幕编程：curses库"><a href="#屏幕编程：curses库" class="headerlink" title="屏幕编程：curses库"></a>屏幕编程：curses库</h3><p>curses库是一组函数，程序员可以用它们来设置光标的位置和终端屏幕上显示的字符样式。</p>
<p>curses将终端屏幕看成是由字符单元组成的网格，每一个单元由（行、列）坐标对标示。坐标系的原点是屏幕的左上角，行坐标自上而下递增，列坐标自左向右递增。</p>
<img src="https://pic.imgdb.cn/item/631ceb8216f2c2beb1828b22.jpg" style="zoom:80%;" />

<p>curses具有的函数包括可以将光标移动到屏幕上任何行、列单元，添加字符到屏幕或者从屏幕上删除字符，设置字符的可视属性（如颜色、亮度），建立和控制窗口以及其他文本区域。我们会用到其中的9个</p>
<img src="https://pic.imgdb.cn/item/631ceba716f2c2beb1829ce0.jpg" style="zoom:80%;" />

<p>小deno展示curses程序基本逻辑：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;curses.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  initscr();</span><br><span class="line"></span><br><span class="line">  clear();</span><br><span class="line">  move(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">  addstr(<span class="string">&quot;Hello, world&quot;</span>);</span><br><span class="line">  move(LINES - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  refresh();				</span><br><span class="line">  getch();					<span class="comment">//等待用户输入</span></span><br><span class="line">  endwin();					</span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译和运行：（<code>-l</code>指定连接库的名字）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zhangqi@localhost demo]$ cc hello1.c -l curses -o hello1</span><br><span class="line">[zhangqi@localhost demo]$ ./hello1</span><br></pre></td></tr></table></figure>

<img src="https://pic.imgdb.cn/item/631cef6816f2c2beb186be71.jpg" style="zoom:80%;" />

<p>例2：hello2.c</p>
<p>将curses函数与循环、变量和其他函数组合在一起会产生更复杂的显示效果</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;curses.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    initscr();</span><br><span class="line">    clear();</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;LINES;++i)&#123;</span><br><span class="line">        move(i,i+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">1</span>) standout();</span><br><span class="line">        addstr(<span class="string">&quot;Hello, world&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">1</span>) standend();</span><br><span class="line">    &#125;</span><br><span class="line">    refresh();</span><br><span class="line">    getch();</span><br><span class="line">    endwin();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<img src="https://pic.imgdb.cn/item/631cf10216f2c2beb18799e0.jpg" style="zoom:80%;" />

<p><strong>curses内部：虚拟和实际屏幕</strong></p>
<p>我们可以发现注释掉refresh函数会导致屏幕上什么也不显示。</p>
<p>curses设计成能够在不阻塞通信线路的情况下更新文本屏幕。surse通过虚拟屏幕来最小化数据流量</p>
<img src="https://pic.imgdb.cn/item/631cf16d16f2c2beb187d047.jpg" style="zoom:80%;" />

<ul>
<li>真实屏幕是眼前的一个字符数组。</li>
<li>curses保留了屏幕的两个内部版本。一个内部屏幕是真实屏幕的复制。另一个是工作屏幕，其上记录了对屏幕的改动。</li>
<li>每个函数，如move、addstr等都只在工作屏幕上进行修改。</li>
<li>工作屏幕就像磁盘缓存，curses中的大部分的函数都只对它进行修改</li>
</ul>
<p>refresh函数比较工作屏幕和真实屏幕的差异。然后refresh通过终端驱动送出那些能使真实屏幕与工作屏幕一直的字符和控制码。（替换有差异的部分）</p>
<h3 id="时钟编程：sleep"><a href="#时钟编程：sleep" class="headerlink" title="时钟编程：sleep"></a>时钟编程：sleep</h3><p>为了写一个视频游戏，需要把影像在特定的时间置于特定的位置。用curses把影像置于特定的位置。然后在程序中添加时间响应。</p>
<p>第一步使用系统函数sleep</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;curses.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    initscr();</span><br><span class="line">    clear();</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;LINES;++i)&#123;</span><br><span class="line">        move(i,i+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">1</span>) standout();</span><br><span class="line">        addstr(<span class="string">&quot;Hello, world&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">1</span>) standend();</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        refresh();</span><br><span class="line">    &#125;</span><br><span class="line">    endwin();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当编译并运行这个程序的时候，可以看到hello字符串在屏幕自上而下逐行显示，每秒增加一行，反色和正常显示交替出现。注意必须每次循环调用refresh</p>
<p>动画例子2：hello4.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;curses.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    initscr();</span><br><span class="line">    clear();</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;LINES;++i)&#123;</span><br><span class="line">        move(i,i+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">1</span>) standout();</span><br><span class="line">        addstr(<span class="string">&quot;Hello, world&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">1</span>) standend();</span><br><span class="line"></span><br><span class="line">        refresh();</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        move(i,i+<span class="number">1</span>);</span><br><span class="line">        addstr(<span class="string">&quot;              &quot;</span>);<span class="comment">//erase line</span></span><br><span class="line">    &#125;</span><br><span class="line">    endwin();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hello4创造移动的假象。字符串沿着对角线缓慢向下移动。方法是先在一个地方画字符串，睡眠一秒钟，然后在原来的地方画空字符串以删除原有影像，最后将输出位置推进。</p>
<p>注意在两次请求之后通过调用refresh来保证每次循环后旧的影像消失，新的影像显示</p>
<p>hello5将字符串在屏幕左右壁弹来弹去</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;curses.h&gt;</span> <span class="comment">// initscr(), clear(), standout(), standend(), refresh(),</span></span></span><br><span class="line"><span class="comment">// addstr(), move(), endwin()</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span> <span class="comment">// true</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> <span class="comment">// sleep()</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEFTEDGE 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RIGHTEDGE 30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROW 10</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">char</span> message[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="type">char</span> blank[] = <span class="string">&quot;     &quot;</span>;</span><br><span class="line"></span><br><span class="line">    initscr();</span><br><span class="line">    clear();</span><br><span class="line">    <span class="type">int</span> dir = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> pos = LEFTEDGE;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        move(ROW, pos);</span><br><span class="line">        addstr(message);</span><br><span class="line">        move(LINES - <span class="number">1</span>, COLS - <span class="number">1</span>);</span><br><span class="line">        refresh();</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        move(ROW, pos);</span><br><span class="line">        addstr(blank);</span><br><span class="line">        pos += dir;</span><br><span class="line">        <span class="keyword">if</span> (pos &gt;= RIGHTEDGE)</span><br><span class="line">            dir = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt;= LEFTEDGE)</span><br><span class="line">            dir = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目前距离写出一个简单的动作类游戏：</p>
<ul>
<li>一秒钟时延太长，需要更精确的计时器</li>
<li>需要增加用户输入</li>
</ul>
<p>从而引出新话题：时钟和高级信号编程</p>
<h3 id="时钟编程1：Alarms"><a href="#时钟编程1：Alarms" class="headerlink" title="时钟编程1：Alarms"></a>时钟编程1：Alarms</h3><p>程序可以以不同的方式使用时钟。可以用来在执行流中加入时延。</p>
<p>sleep(n)将当前进程挂起n秒或者在此期间被一个不能忽略的信号的到达所唤醒</p>
<p><strong>sleep()是如何工作的：使用Unix中的Alarms</strong></p>
<p>系统中的每个进程都有一个私有的闹钟（alarm clock）。这个闹钟很像一个计时器，可以设置在一定秒数后闹铃。</p>
<p>时间一到，时钟就发送一个信号SIGALRM到进程。</p>
<p>除非进程为SIGALRM设置了处理函数（handler），否则信号将杀死这个进程。</p>
<p>sleep函数由三个步骤组成：</p>
<ol>
<li>为SIGALRM设置一个处理函数</li>
<li>调用alarm(num_seconds);</li>
<li>调用pause</li>
</ol>
<img src="C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20220911070235187.png" alt="image-20220911070235187" style="zoom:80%;" />

<p>系统调用pause挂起进程直到信号到达。任何信号都可以唤醒进程，而非仅仅等待SIGALRM。</p>
<p>因此可以写出sleep1.c：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">wakeup</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//调用signal设置SIGALRM处理函数，然后调用alarm设置一个4秒的计时器，最后调用pause等待</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;about to sleep for 4 seconds\n&quot;</span>);</span><br><span class="line">    signal(SIGALRM,wakeup);</span><br><span class="line">    alarm(<span class="number">4</span>);</span><br><span class="line">    pause();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Morning so soon? \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">wakeup</span><span class="params">(<span class="type">int</span> signum)</span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHHHH</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Alarm received from kernel\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里调用pause的目的是挂起进程直到有一个信号被处理。当计时器计时4秒钟以后，内核送出SIGALRM给进程，导致控制从pause跳转到信号处理函数。</p>
<p>在信号处理程序中的代码被执行，然后控制返回。</p>
<p>当信号被处理完后，pause返回，进程继续</p>
<img src="https://pic.imgdb.cn/item/631d1a1416f2c2beb19b2c72.jpg" style="zoom:80%;" />

<p><u>alarm的细节：</u></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>入参：seconds 等待的时间（秒）</li>
<li>如果出错，返回-1；否则返回计时器剩余时间</li>
</ul>
<p>alarm设置本进程的计时器到seconds秒后激发信号。当设定的时间过去之后，内核发送SIGALRM到这个进程。如果计时器已经被设置，alarm返回剩余秒数</p>
<p>注意：调用alarm(0)意味着关掉闹钟</p>
<p><u>pause的细节</u></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pause</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>pause挂起调用进程直到一个信号到达</p>
<ul>
<li>如果调用进程被这个信号终止，pause没有返回。</li>
<li>如果调用进程用一个处理函数捕获，在控制从处理函数处返回后pause返回。这种情况下errno被设置为EINTR</li>
</ul>
<p>计时器的另一个用途是调度一个在将来的某个时刻发生的动作同时做些其他事情：通过调用alarm来设置计时器，然后继续做别的事情。当计时器计时到0，信号发送，处理函数被调用。</p>
<h3 id="时钟编程2：间隔计时器"><a href="#时钟编程2：间隔计时器" class="headerlink" title="时钟编程2：间隔计时器"></a>时钟编程2：间隔计时器</h3><p>sleep和alarm提供的时钟精度为秒，对很多应用来说精度不能让人满意。</p>
<p>后来添加进一个更强大的计时器系统：间隔计时器（interval timer），有更高的精度。并且每个进程都有3个独立的计时器而不是原来的一个。</p>
<p>每个计时器都有两个设置：初始间隔（it_value，要把两个都关掉，设为0）和重复间隔（it_interval，如果不想要重复，则设置为0）设置。</p>
<img src="https://pic.imgdb.cn/item/631d1da016f2c2beb19d3252.jpg" style="zoom:80%;" />

<p>使用usleep(n)可以添加精度更高的时延，将当前进程挂起n微秒或者知道有一个不能被忽略的信号到达</p>
<p><strong>三种计时器：真实、进程和实用</strong></p>
<p>进程可以以3种方式来计时。考虑一个程序在运行了30s后结束。在一个分时系统中，这个程序不是一直在运行得，其他的程序与它共享处理器，下图显示了一种可能性：</p>
<img src="https://pic.imgdb.cn/item/631d1f1a16f2c2beb19e0b6f.jpg" style="zoom:80%;" />

<p>显示了从0到5s进程在用户模式运行，从5s到15s睡眠，然后在核心态运行到20s睡眠……</p>
<p>因此从开始到结束，程序使用了10s用户时间、5s系统时间，并显示了3种时间：真实时间、用户时间和用户时间+系统时间</p>
<p>3类计时器名字和功能如下：</p>
<ul>
<li>ITIMER_REAL<ul>
<li>计量真实时间。当这个计时器用尽，发送SIGALRM消息</li>
</ul>
</li>
<li>ITIMER_VIRTUAL<ul>
<li>计量进程在用户态运行的时间。当虚拟计时器用尽，发送SIGVTALRM消息</li>
</ul>
</li>
<li>ITIMER_PROF<ul>
<li>该计时器在进程运行于用户态或由该进程调用而陷入核心态时计时。当这个计时器用尽，发送SIGPROF消息</li>
</ul>
</li>
</ul>
<p><strong>用间隔计时器编程</strong></p>
<ul>
<li>选择计时器类型</li>
<li>选择初始间隔和重复间隔</li>
<li>设置在结构体struct itimerval中的值</li>
<li>通过getitimer读取计时器设置</li>
</ul>
<p>间隔计时器例子：ticker_demo.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span> <span class="comment">// setitimer()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span> <span class="comment">// signal()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> <span class="comment">// pause()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">countdown</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">set_ticker</span><span class="params">(<span class="type">int</span> n_msecs)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">//使用signal设置函数countdown来处理SIGALRM信号</span></span><br><span class="line">    signal(SIGALRM, countdown);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过set_ticker来设置微秒数</span></span><br><span class="line">    <span class="keyword">if</span> (set_ticker(<span class="number">500</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;set_ticker&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            pause();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">countdown</span><span class="params">(<span class="type">int</span> signum)</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d..\n&quot;</span>, num);</span><br><span class="line">    num--;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Done!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">set_ticker</span><span class="params">(<span class="type">int</span> n_msecs)</span> &#123;</span><br><span class="line">    <span class="comment">//通过装载初始间隔和重复间隔设置间隔计时器</span></span><br><span class="line">    <span class="comment">//每个间隔由秒数和微秒数组成</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">new_timeset</span>;</span></span><br><span class="line">    <span class="type">long</span> n_sec, n_usecs;</span><br><span class="line"></span><br><span class="line">    n_sec = n_msecs / <span class="number">1000</span>;</span><br><span class="line">    n_usecs = (n_msecs % <span class="number">1000</span>) * <span class="number">1000L</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//设置初始间隔</span></span><br><span class="line">    new_timeset.it_value.tv_sec = n_sec;</span><br><span class="line">    new_timeset.it_value.tv_usec = n_usecs;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//设置重复间隔</span></span><br><span class="line">    new_timeset.it_interval.tv_sec = n_sec;</span><br><span class="line">    new_timeset.it_interval.tv_usec = n_usecs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> setitimer(ITIMER_REAL, &amp;new_timeset, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相关系统调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getitimer</span><span class="params">(<span class="type">int</span> which, <span class="keyword">struct</span> itimerval *curr_value)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setitimer</span><span class="params">(<span class="type">int</span> which, <span class="type">const</span> <span class="keyword">struct</span> itimerval *new_value,</span></span><br><span class="line"><span class="params">              <span class="keyword">struct</span> itimerval *old_value)</span>;</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li>which：获取或设置的计时器</li>
<li>val：指向当前设置值的指针</li>
<li>newval：指向要被设置值的指针</li>
<li>oldval：指向要被替换的设置值的指针</li>
</ul>
<p>返回值：</p>
<ul>
<li>-1 出错</li>
<li>0 成功</li>
</ul>
<p><strong>计算机有几个时钟</strong></p>
<p>有些系统同时又几百个进程在运行。但计算机里没有几百个独立的时钟，一个系统只需要一个时钟来设置节拍。</p>
<p>一个硬件时钟的脉冲是计算机里唯一需要的时钟。</p>
<p>如何只用一个时钟在设置一个进程的私有计时器为5s的同时又设置另一个进程的私有计时器为12s？</p>
<ul>
<li><p>每个进程设置自己的计数时间，操作系统在每过一个时间片后为所有的计数器的数值做递减</p>
<img src="https://pic.imgdb.cn/item/631d29d616f2c2beb1a62d48.jpg" style="zoom:80%;" /></li>
</ul>
<h3 id="信号处理1：使用signal"><a href="#信号处理1：使用signal" class="headerlink" title="信号处理1：使用signal"></a>信号处理1：使用signal</h3><p>要实现视频游戏还需要<u>管理中断</u>的技术</p>
<p>中断处理是操作系统和系统软件的关键部分。Unix中的软件终端被称为信号（signals）。</p>
<p><strong>早期的信号处理机制</strong></p>
<p>各种事件（包括用户的击键、进程的非法操作和计时器到时）促使内核向进程发送信号。</p>
<p>早期信号处理模型，一个进程调用signal在以下三种处理信号的方法之中选择：</p>
<ul>
<li>默认操作（一般是终止进程），比如，signal(SIGALRM, SIG_DFL)</li>
<li>忽略信号，比如，signal(SIGALRM, SIG_IGN)</li>
<li>调用一个函数，比如，signal(SIGALRM, handler)</li>
</ul>
<p><strong>处理多个信号</strong></p>
<p>如果只有一个信号要处理，原始的信号处理模型足以应付，但如果有多个信号到达会发生什么？</p>
<p>如果相应定义为终止（termination）或是忽略（ignore），那结果很清楚，但是如果是调用（invoke）一个函数来相应，那么结果就不那么明显了</p>
<p><u>捕鼠器问题</u></p>
<p>信号处理函数有点像捕鼠器。一个信号意味着什么具有破坏性的事情发生，并被捕获。当信号或老师被捕获，信号处理函数或捕鼠器就失效了。</p>
<p>在早期的版本中，信号处理函数在另一个方面也很像捕鼠器：在每次捕获之后，都必须重新设置它们。</p>
<p>如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> s)</span>&#123;</span><br><span class="line">    signal(SIGINT, handler);<span class="comment">//reset handler</span></span><br><span class="line">    ... 					<span class="comment">//do work here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就算设置的速度非常快，它还是需要时间的，这一个间隙使得原有的信号处理不可靠。</p>
<p><u>进程的多个信号</u></p>
<p>想象一个进程在内存里工作，用户可能通过按下Ctrl-C来产生一个SIGINT信号，或者是Ctrl-\产生SIGQUIT信号，或者计时器到时产生一个SIGQLRM信号。</p>
<p>这些信号可能同时到达，那么进程要如何响应？</p>
<img src="https://pic.imgdb.cn/item/631d30a416f2c2beb1ab42fa.jpg" style="zoom:80%;" />

<p><strong>测试多个信号</strong></p>
<p>编译并运行如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INPUTLEN 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">int_handler</span><span class="params">(<span class="type">int</span> )</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">quit_handler</span><span class="params">(<span class="type">int</span> )</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    signal(SIGINT, int_handler);</span><br><span class="line">    signal(SIGQUIT, quit_handler);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> nchars;</span><br><span class="line">    <span class="type">char</span> input[INPUTLEN];</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nType a message\n&quot;</span>);</span><br><span class="line">        nchars = read(<span class="number">0</span>, input, (INPUTLEN - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (nchars == <span class="number">-1</span>)</span><br><span class="line">            perror(<span class="string">&quot;read returned an error&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            input[nchars] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;You typed: %s\n&quot;</span>, input);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">strncmp</span>(input, <span class="string">&quot;quit&quot;</span>, <span class="number">4</span>) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">int_handler</span><span class="params">(<span class="type">int</span> signum)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Received signal %d .. wating\n&quot;</span>, signum);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Leaving int_handler\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">quit_handler</span><span class="params">(<span class="type">int</span> signum)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Received signal %d .. waiting\n&quot;</span>, signum);</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Leaving quit_handler\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用不同的方式常规输入和两个信号生成键Ctrl-C和Ctrl-\ （分别对应SIGINT和SIGQUIT）。</p>
<ul>
<li>SIGY打断SIGX的处理函数：当接连按下Ctrl-C和Ctrl-\时，会看到程序先跳到int_handler，接着调到quit_handler，然后再回到int_handler，最后回到主循环</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">^CReceived signal 2 .. waiting</span><br><span class="line">^\Received signal 3 .. waiting</span><br><span class="line">Leaving quithandler </span><br><span class="line">Leaving inthandler</span><br></pre></td></tr></table></figure>

<ul>
<li>SIGX打断SIGX的处理函数：我这的实验结果是会阻塞第二个信号直到第一个处理完毕</li>
<li>被中断的系统调用：例如程序经常在等待输入的时候接收到信号</li>
</ul>
<p><strong>信号机制其他的弱点</strong></p>
<p>早期信号系统还有两个弱点：</p>
<ol>
<li><p>不知道信号被发送的原因</p>
<ul>
<li>信号处理函数是一个在信号到达的时候被调用的函数。内核传给处理函数一个信号数字编号。因此早期的模型只告诉了处理函数它被调用是由什么类型的信号而引起的，但是没有告知为什么会生成信号。</li>
<li>例如几种算术错误（除数为0，整数溢出和浮点下溢）会引起浮点异常（floating - point exception）。处理函数需要指导问题的原因</li>
</ul>
</li>
<li><p>处理函数中不能安全地阻塞其他消息</p>
<ul>
<li><p>假设想让程序在相应SIGINT时忽略SIGQUIT，使用经典信号机制修改int_handler：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">int_handler</span><span class="params">(<span class="type">int</span> s)</span>&#123;</span><br><span class="line">    <span class="type">int</span> rv;</span><br><span class="line">    <span class="type">void</span>(*prev_qhandler)();</span><br><span class="line">    prev_qhandler = signal(SIGQUIT, SIG_IGN);</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    signal(SIGQUIT, prev_qhandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这样，在进入中断处理函数时禁用退出处理函数，在结束时再重新使能它。</p>
</li>
<li><p>这个方案有两个问题：</p>
<ul>
<li>在调用int_handler和调用signal之间是它的软肋所在。这里只是希望调用int_handler和忽略SIGQUIT同时进行</li>
<li>这里并不想忽略SIGQUIT，而只是想阻塞它直到int_handler处理完成。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="信号处理2：sigaction"><a href="#信号处理2：sigaction" class="headerlink" title="信号处理2：sigaction"></a>信号处理2：sigaction</h3><p>针对原有模型产生的问题，有不同的解决方案，这里介绍POSIX模型和相关的系统调用。</p>
<p>注意经典的信号系统依旧被支持，而且在一些应用中这些就够了</p>
<p><strong>处理多个信号：sigaction</strong></p>
<p>在POSIX中用sigaction替代signal。参数非常相似。指定什么信号将被如何处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act,</span></span><br><span class="line"><span class="params">              <span class="keyword">struct</span> sigaction *oldact)</span>;</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li>signum指明想要处理的消息</li>
<li>act 指向描述如何响应信号的结构体</li>
<li>oldact 如果不是null的话，就是指向描述被替换的处理设置的结构体</li>
</ul>
<p>返回：</p>
<ul>
<li>如果新的操作设置成功则返回0</li>
<li>设置错误返回-1</li>
</ul>
<p><strong>定制信号处理：struct sigaction</strong></p>
<p>过去面对信号的处理只有三种选择：SIG_DFL、SIG_IGN、函数处理</p>
<p>这些选项在新的系统中作为结构体sigaction的部分定义依然提供。</p>
<p>结构体sigaction定义了如何处理一个信号，结构体完整定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">    <span class="type">void</span>     (*sa_handler)(<span class="type">int</span>);</span><br><span class="line">    <span class="type">void</span>     (*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *);</span><br><span class="line">    <span class="type">sigset_t</span>   sa_mask;</span><br><span class="line">    <span class="type">int</span>        sa_flags;</span><br><span class="line">    <span class="type">void</span>     (*sa_restorer)(<span class="type">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>sa_handler</code>：信号处理器函数的地址，亦或是常量<code>SIG_IGN</code>、<code>SIG_DFL</code>之一。仅当<code>sa_handler</code>是信号处理程序的地址时，亦即sa_handler的取值在<code>SIG_IGN</code>和<code>SIG_DFL</code>之外，才会对<code>sa_mask</code>和<code>sa_flags</code>字段加以处理。</p>
<p><code>sa_sigaction</code>：如果设置了<code>SA_SIGINFO</code>标志位，则会使用<code>sa_sigaction</code>处理函数，否则使用<code>sa_handler</code>处理函数。</p>
<p><code>sa_mask</code>：定义一组信号，在调用由<code>sa_handler</code>所定义的处理器程序时将阻塞该组信号，不允许它们中断此处理器程序的执行。</p>
<p><code>sa_flags</code>：位掩码，指定用于控制信号处理过程的各种选项。</p>
<ul>
<li><code>SA_NODEFER</code>：捕获该信号时，不会在执行处理器程序时将该信号自动添加到进程掩码中。</li>
<li><code>SA_ONSTACK</code>：针对此信号调用处理器函数时，使用了由<code>sigaltstack()</code>安装的备选栈。</li>
<li><code>SA_RESETHAND</code>：当捕获该信号时，会在调用处理器函数之前将信号处置重置为默认值(即<code>SIG_IGN</code>)。</li>
<li><code>SA_SIGINFO</code>：调用信号处理器程序时携带了额外参数，其中提供了关于信号的深入信息</li>
</ul>
<p>选择sa_handler还是sa_sigaction？</p>
<ul>
<li>如果老的处理方式就够用了，可以设置sa_handler为其中之一。当然，如果指定为旧的信号处理方式，那么只能得到信号编号</li>
<li>如果设定sa_sigaction为一个处理函数，那么哪个处理函数被调用的时候，不但可以得到信号编号而且可以获悉被调用的原因以及产生问题的上下文的相关信息。</li>
<li>为了告诉内核使用的是新的信号处理方式，只需设置sa_flags的SA_SIGINFO位</li>
</ul>
<p><strong>sa_flags</strong></p>
<p>用一些位来控制处理函数，可以解决前面提出的问题：</p>
<img src="https://pic.imgdb.cn/item/631defdf16f2c2beb16eca0e.jpg" style="zoom:80%;" />



<p><strong>sa_mask</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sa_mask specifies a mask of signals  which  should  be  blocked  (i.e., added  to  the signal mask of the thread in which the signal handler is invoked) during execution of the signal handler.  In addition, the signal  which triggered the handler will be blocked, unless the SA_NODEFER flag is used.</span><br></pre></td></tr></table></figure>

<p>sa_mask决定在处理一个消息时是否要阻塞其他信号。</p>
<p>sa_mask中的位指定哪些信号要被阻塞。</p>
<p><u>sa_mask的值包括要被阻塞的信号集</u></p>
<p><strong>例子：使用sigaction</strong></p>
<p>演示了如何使用sigaction，注意程序做到了在处理SIGINT时阻塞SIGQUIT</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INPUTLEN 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">sig_handler</span><span class="params">(<span class="type">int</span> )</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">newhandler</span>;</span></span><br><span class="line">    <span class="type">sigset_t</span> block;</span><br><span class="line">    <span class="type">char</span> input[INPUTLEN];</span><br><span class="line">    newhandler.sa_handler = sig_handler;</span><br><span class="line">    newhandler.sa_flags = SA_RESETHAND | SA_RESTART;</span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;block);</span><br><span class="line">    sigaddset(&amp;block, SIGQUIT);</span><br><span class="line">    newhandler.sa_mask = block;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGINT, &amp;newhandler, <span class="literal">NULL</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            fgets(input, INPUTLEN, <span class="built_in">stdin</span>);<span class="comment">//从输入流中读取INPUTLEN长度的字符存到input中</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;input: %s\n&quot;</span>, input);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">sig_handler</span><span class="params">(<span class="type">int</span> signum)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Called with signal %d\n&quot;</span>, signum);</span><br><span class="line">    sleep(signum);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;done handling signal %d\n&quot;</span>, signum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行这个程序，如果以很快的速度连续按Ctrl-C和Ctrl-\，退出信号将被阻塞直到中断信号处理完毕。</p>
<p>如果连续按两下Ctrl-C，进程就将被第二个信号杀死</p>
<p>如果想要捕获所有的Ctrl-C，将SA_RESETHAND掩码从sa_flags中去掉</p>
<h3 id="防止数据损毁（Data-Corruption）"><a href="#防止数据损毁（Data-Corruption）" class="headerlink" title="防止数据损毁（Data Corruption）"></a>防止数据损毁（Data Corruption）</h3><p>程序在由于中断转到别的地方执行的情况可能会导致数据损毁</p>
<p>因此在一些情况下一个操作不应该被其他操作打断。在对一个数据结构（这里是列表）改动结束之前，其它函数不能读或写这个数据结构。</p>
<p><strong>临界区（Critical Sections）</strong></p>
<p>一段修改一个数据结构的代码如果在运行时被打断将导致数据的不完整或损毁，则称这段代码为临界区。</p>
<p>当程序处理信号时，必须决定哪一段代码为临界区，然后设法保护这段代码。临界区不一定就在信号处理函数中，很多出现在常规的程序流中。</p>
<p>保护临界区的最简单的办法就是阻塞或忽略那些处理函数将要使用或修改特定数据的信号。</p>
<p><strong>阻塞信号：sigprocmask和sigsetops</strong></p>
<ol>
<li><p>在信号处理者一级阻塞信号</p>
<p>为了在处理一个信号的时候阻塞另一个信号，要设置struct sigaction结构中的sa_mask成员位，它在设置处理函数时被传递给sigaction。sa_mask是sigset_t类型，它定义了一个信号集。</p>
</li>
<li><p>在进程一级阻塞信号</p>
<p>在任何时候一个进程都有一些信号被阻塞（注意是阻塞而不是忽略）。这个信号集就称为signal mask。通过sigprocmask可以修改这个被阻塞的信号集，sigprocmask作为一个原子操作根据所给的信号集来修改当前被阻塞的信号集</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>;</span><br><span class="line"><span class="comment">/* sigprocmask 修改当前的signal mask设置。</span></span><br><span class="line"><span class="comment">how的值分别为SIG_BLOCK、SIG_UNBLOCK或SIG_SET时，</span></span><br><span class="line"><span class="comment">*set所指定的信号将被添加、删除或替换</span></span><br><span class="line"><span class="comment">如果oldset不为NULL，那么之前的设置将被复制到oldset中</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>用sigsetops构造信号集</p>
<p>一个sigset_t是一个抽象的信号集，可以通过一些函数来添加或删除信号。基本的函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//清除由set指向的列表中的所有信号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加所有的信号到set指向的列表</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加signum到set指向的列表</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从set指向的列表中删除signum所标识的信号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>例子：暂时阻塞用户信号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sigset_t</span> sigs, prevsigs;</span><br><span class="line">sigemptyset(&amp;sigs);				<span class="comment">//turn off all bits</span></span><br><span class="line">sigaddset(&amp;sigs, SIGINT);		<span class="comment">//turn on SIGINT bit</span></span><br><span class="line">sigaddset(&amp;sigs, SIGQUIT);		<span class="comment">//turn on SIGQUIT bit</span></span><br><span class="line">sigprocmask(SIG_BLOCK, &amp;sigs, &amp;prevsigs);	<span class="comment">//add that to proc mask</span></span><br><span class="line"><span class="comment">//..modify data structure here</span></span><br><span class="line">sigprocmask(SIG_SET, *prevsigs, <span class="literal">NULL</span>);		<span class="comment">//restore previous mask</span></span><br></pre></td></tr></table></figure>



<p><strong>重入代码（Reetrant Code）：递归调用的风险</strong></p>
<p>一个信号处理者或者一个函数，如果在激活状态下能被调用而不引起任何问题就称之为可重入的。</p>
<p>在通过sigaction设置时，可以通过设置SA_NODEFER位来允许处理函数的递归调用。反之，可以通过清除此位来阻塞信号。如何选择：</p>
<ul>
<li>如果处理者是不可重入的，必须阻塞信号。但是如果阻塞信号，就有可能丢失信号</li>
</ul>
<p>如何权衡丢掉信号还是弄乱数据是需要认真考虑的</p>
<p><strong>kill：从另一个进程发送的信号</strong></p>
<p>信号来自间隔计时器、终端驱动、内核或者进程。一个进程可以通过kill系统调用向另一个进程发送信号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br></pre></td></tr></table></figure>

<p>入参：</p>
<ul>
<li>pid 目标进程id</li>
<li>sig要被发送的信号</li>
</ul>
<p>返回值：</p>
<ul>
<li>-1 失败</li>
<li>0 成功</li>
</ul>
<p>kill向一个进程发送一个信号。发送信号的进程的用户ID必须和目标进程的用户ID相同，或者发送信号的进程的拥有者是一个超级用户。一个进程可以向自己发送信号。</p>
<p>一个进程可以向其他进程发送任何信息，包括一般来自键盘、间隔计时器或者内核的信号。</p>
<p>比如一个进程可以向另一个进程发送SIGSEGV信号，就好像目标进程执行了非法内存读取</p>
<p>Unix命令kill使用kill系统调用</p>
<img src="https://pic.imgdb.cn/item/631e319916f2c2beb1acee80.jpg" style="zoom:80%;" />

<p><strong>进程间通信的含义</strong></p>
<p>接受信号的进程几乎可以设置任何信号的处理者。</p>
<p>考虑在收到SIGINT时就打印OUCH！的程序。如果其他进程向OUCH！程序发送SIGINT又该如何呢？——OUCH！程序会捕获信号，跳转到处理者，打印OUCH！</p>
<img src="https://pic.imgdb.cn/item/631e321416f2c2beb1ad3bc1.jpg" style="zoom:80%;" />

<p>更进一步。如果第一个程序设置一个间隔计时器，计时器的信号处理函数向OUCH！程序发送SIGINT信号。这样相应的处理函数就被调用。从而一个进程的计时器控制了另一个进程的函数调用。</p>
<p><u>IPC信号设计：SIGUSR1、SIGUSR2</u></p>
<p>Unix有两个信号可以被用户程序使用。它们是SIGUSR1和SIGUSR2。这两个信号没有预定义任务。可以使用它们避免使用已经有预定义语义的信号。</p>
<p>编程时有很多方法组合使用kill和sigaction</p>
<p><strong>视频游戏中的临界区</strong></p>
<p>球匀速在屏幕上移动，碰到墙或挡板就弹回。用户通过按键上下移动挡板。间隔计数器控制球的运动。用户控制挡板的输入就如信号那样看上去是无法预料的事件。</p>
<p>因此要考虑：需要在某个时刻阻塞用户输入吗？有没有什么临界区，其间挡板不应该移动吗？</p>
<h3 id="使用计时器和信号：视频游戏"><a href="#使用计时器和信号：视频游戏" class="headerlink" title="使用计时器和信号：视频游戏"></a>使用计时器和信号：视频游戏</h3><p>回到视频游戏。游戏有两个主要元素：动画和用户输入。动画要平滑，用户输入会改变运动状态。</p>
<p>先设计一个可以让用户可以将字符串在屏幕上弹来弹去的程序：</p>
<img src="https://pic.imgdb.cn/item/631e36e816f2c2beb1aff3fd.jpg" style="zoom:80%;" />

<p>程序将一个单词平滑地在屏幕上移动：</p>
<ul>
<li>当用户按下空格键，单词就向反方向移动</li>
<li>s键和f键分别增加和减少单词的移送速度</li>
<li>按“Q”键退出程序</li>
</ul>
<p>动画的实现是在一个地方画一个字符串，等待几毫秒，然后擦去旧的影像并在原来位置的左边或右边一个单位距离重新画同一个字符串</p>
<ul>
<li>这里希望擦去和重画动作以相同的间隔连续的进行，因此使用间隔计时器来调用相应的处理函数</li>
<li>两个变量分别记录移动的方向和速度：设置方向变量的值+1和-1分别表示向左和向右移动。</li>
<li>延时变量记录间隔计时器的间隔长度：较长的延时意味着较慢的速度</li>
<li>向程序添加方向和速度控制：根据用户的键盘输入修改方向和速度变量</li>
</ul>
<p>如下图，体现了程序的逻辑</p>
<img src="https://pic.imgdb.cn/item/631e382e16f2c2beb1b0a443.jpg" style="zoom:80%;" />

<p>该设计体现了两个重要的技术：状态变量和事件处理：</p>
<ul>
<li>记录位置、方向和延时的变量定义了动画的状态</li>
<li>用户输入和计时器信号是改变这些状态的事件</li>
<li>每次计时器到达信号就调用改变位置的处理函数</li>
<li>每次得到用户键盘输入信号就调用改变方向和速度变量的代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// crmode() 已改爲 cbreak(), 此外別忘了自己定義 set_ticker</span></span><br><span class="line"><span class="comment">// 此外 row, col, direction, delay, new_delay, c 等变量要声明为全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;curses.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MESSAGE <span class="string">&quot;hello&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLANK   <span class="string">&quot;     &quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> row = <span class="number">10</span>, col = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> direction = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> delay = <span class="number">200</span>, new_delay = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">set_ticker</span><span class="params">(<span class="type">int</span> )</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">move_msg</span><span class="params">(<span class="type">int</span> )</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    initscr();</span><br><span class="line">    cbreak();</span><br><span class="line">    noecho();</span><br><span class="line"></span><br><span class="line">    move(row, col);</span><br><span class="line">    addstr(MESSAGE);</span><br><span class="line">    signal(SIGALRM, move_msg); <span class="comment">//当收到时钟信号时，执行move_msg</span></span><br><span class="line">    set_ticker(delay);	<span class="comment">//设置间隔计时器的初始状态</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        new_delay = <span class="number">0</span>;</span><br><span class="line">        c = getch();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27; &#x27;</span>) direction *= <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;f&#x27;</span> &amp;&amp; delay &gt; <span class="number">2</span>)</span><br><span class="line">            new_delay = delay / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">            new_delay = delay * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (new_delay &gt; <span class="number">0</span>)</span><br><span class="line">            set_ticker(delay = new_delay);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    endwin();</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">set_ticker</span><span class="params">(<span class="type">int</span> n_msecs)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">new_timeset</span>;</span></span><br><span class="line">    <span class="type">long</span> n_sec, n_usecs;</span><br><span class="line"></span><br><span class="line">    n_sec = n_msecs / <span class="number">1000</span>;</span><br><span class="line">    n_usecs = (n_msecs % <span class="number">1000</span>) * <span class="number">1000L</span>;</span><br><span class="line"></span><br><span class="line">    new_timeset.it_value.tv_sec = n_sec;</span><br><span class="line">    new_timeset.it_value.tv_usec = n_usecs;</span><br><span class="line"></span><br><span class="line">    new_timeset.it_interval.tv_sec = n_sec;</span><br><span class="line">    new_timeset.it_interval.tv_usec = n_usecs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> setitimer(ITIMER_REAL, &amp;new_timeset, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">move_msg</span><span class="params">(<span class="type">int</span> signum)</span> &#123;</span><br><span class="line">    signal(SIGALRM, move_msg);</span><br><span class="line"></span><br><span class="line">    move(row, col);</span><br><span class="line">    addstr(BLANK);</span><br><span class="line">    col += direction;</span><br><span class="line">    move(row, col);</span><br><span class="line">    addstr(MESSAGE);</span><br><span class="line">    refresh();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (direction == <span class="number">-1</span> &amp;&amp; col &lt;= <span class="number">0</span>)</span><br><span class="line">        direction = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (direction == <span class="number">1</span> &amp;&amp; col + <span class="built_in">strlen</span>(MESSAGE) &gt;= COLS)</span><br><span class="line">        direction = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>bounce2d.c：二维动画</strong></p>
<p>改进，用户可以控制水平速度和垂直速度<br>为了能同时在两个方向移动，要用两个计数器来充当计时器</p>
<p>bounce.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// some settings for the game</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLANK <span class="string">&#x27; &#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BALL_SYMBOL <span class="string">&#x27;O&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOP_EDGE 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOTTOM_EDGE 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEFT_EDGE 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RIGHT_EDGE 70</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TICKS_PER_SEC 50</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X_INIT_POS 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Y_INIT_POS 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X_TIM 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Y_TIM 8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinball</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> x_pos, y_pos,</span><br><span class="line">      x_ttm, y_ttm,</span><br><span class="line">      x_ttg, y_ttg,</span><br><span class="line">      x_dir, y_dir;</span><br><span class="line">  <span class="type">char</span> symbol;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>bounce2d.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;curses.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bounce.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinball</span> <span class="title">the_ball</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">set_up</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">ball_move</span><span class="params">(<span class="type">int</span> )</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">bounce_or_lose</span><span class="params">(<span class="keyword">struct</span> pinball *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">end_down</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">set_ticker</span><span class="params">(<span class="type">int</span> )</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    set_up();<span class="comment">//初始设置</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="keyword">while</span> ((c = getch()) != <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;f&#x27;</span>) the_ball.x_ttm--;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;s&#x27;</span>) the_ball.x_ttm++;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;F&#x27;</span>) the_ball.y_ttm--;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;S&#x27;</span>) the_ball.y_ttm++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    end_down();</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">set_up</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//设置初始位置</span></span><br><span class="line">    the_ball.x_pos = X_INIT_POS;</span><br><span class="line">    the_ball.y_pos = Y_INIT_POS;</span><br><span class="line">    <span class="comment">//设置x和y方向计数器的间隔和当前值（离下次重画还要多少个时钟信号）</span></span><br><span class="line">    the_ball.x_ttm = the_ball.x_ttg = X_TIM;</span><br><span class="line">    the_ball.y_ttm = the_ball.y_ttg = Y_TIM;</span><br><span class="line">    <span class="comment">//设置初始方向</span></span><br><span class="line">    the_ball.x_dir = <span class="number">1</span>;</span><br><span class="line">    the_ball.y_dir = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//设置移动的字符</span></span><br><span class="line">    the_ball.symbol = DFL_SYMBOL;</span><br><span class="line"></span><br><span class="line">    initscr();</span><br><span class="line">    noecho();<span class="comment">//用户的输入不显示</span></span><br><span class="line">    cbreak();<span class="comment">//不缓存输入，直接单个字符读入</span></span><br><span class="line"></span><br><span class="line">    signal(SIGALRM, SIG_IGN);<span class="comment">//忽略计时器信号</span></span><br><span class="line">    mvaddch(the_ball.y_pos, the_ball.x_pos, the_ball.symbol);</span><br><span class="line">    refresh();<span class="comment">//刷新屏幕 进行显示</span></span><br><span class="line"></span><br><span class="line">    signal(SIGALRM, ball_move);<span class="comment">//重新启动处理计时器信号</span></span><br><span class="line">    set_ticker(<span class="number">1000</span> / TICKS_PER_SEC);	<span class="comment">//设置间隔计时器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">ball_move</span><span class="params">(<span class="type">int</span> signum)</span> &#123;</span><br><span class="line">    signal(SIGALRM, SIG_IGN);</span><br><span class="line">    <span class="type">int</span> x_org_pos = the_ball.x_pos,</span><br><span class="line">    y_org_pos = the_ball.y_pos;</span><br><span class="line">    <span class="type">bool</span> moved = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (the_ball.x_ttm &gt; <span class="number">0</span> &amp;&amp; the_ball.x_ttg-- == <span class="number">1</span>) &#123;</span><br><span class="line">        the_ball.x_pos += the_ball.x_dir;</span><br><span class="line">        the_ball.x_ttg = the_ball.x_ttm;</span><br><span class="line">        moved = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (the_ball.y_ttm &gt; <span class="number">0</span> &amp;&amp; the_ball.y_ttg-- == <span class="number">1</span>) &#123;</span><br><span class="line">        the_ball.y_pos += the_ball.y_dir;</span><br><span class="line">        the_ball.y_ttg = the_ball.y_ttm;</span><br><span class="line">        moved = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (moved == <span class="literal">true</span>) &#123;</span><br><span class="line">        mvaddch(y_org_pos, x_org_pos, BLANK);</span><br><span class="line">        mvaddch(the_ball.y_pos, the_ball.x_pos, the_ball.symbol);</span><br><span class="line">        bounce_or_lose(&amp;the_ball);</span><br><span class="line">        move(LINES - <span class="number">1</span>, COLS - <span class="number">1</span>);<span class="comment">//光标移到右下角</span></span><br><span class="line">        refresh();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    signal(SIGALRM, ball_move);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">bounce_or_lose</span><span class="params">(<span class="keyword">struct</span> pinball *the_ball_p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (the_ball_p-&gt;y_pos == TOP_EDGE)</span><br><span class="line">        the_ball_p-&gt;y_dir = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (the_ball_p-&gt;y_pos == BOTTOM_EDGE)</span><br><span class="line">        the_ball_p-&gt;y_dir = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (the_ball_p-&gt;x_pos == LEFT_EDGE)</span><br><span class="line">        the_ball_p-&gt;x_dir = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (the_ball_p-&gt;x_pos == RIGHT_EDGE)</span><br><span class="line">        the_ball_p-&gt;x_dir = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">end_down</span><span class="params">()</span> &#123;</span><br><span class="line">    set_ticker(<span class="number">0</span>);<span class="comment">//关闭计时器，不再发送时钟信号</span></span><br><span class="line">    endwin();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">set_ticker</span><span class="params">(<span class="type">int</span> n_msecs)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">new_timeset</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> n_sec = n_msecs / <span class="number">1000</span>;</span><br><span class="line">    <span class="type">long</span> n_usecs = (n_msecs % <span class="number">1000</span>) * <span class="number">1000L</span>;</span><br><span class="line"></span><br><span class="line">    new_timeset.it_value.tv_sec = n_sec;</span><br><span class="line">    new_timeset.it_value.tv_usec = n_usecs;</span><br><span class="line"></span><br><span class="line">    new_timeset.it_interval.tv_sec = n_sec;</span><br><span class="line">    new_timeset.it_interval.tv_usec = n_usecs;</span><br><span class="line"></span><br><span class="line">    setitimer(ITIMER_REAL, &amp;new_timeset, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="输入信号：异步I-x2F-O"><a href="#输入信号：异步I-x2F-O" class="headerlink" title="输入信号：异步I&#x2F;O"></a>输入信号：异步I&#x2F;O</h3><p>前面的程序通过调用getch()阻塞程序以等待键盘输入。</p>
<p>除了阻塞，程序还可以要求内核在得到输入时发送信号，这样就可以不用一直等待着。</p>
<p>Unix有两个异步输入（asynchronous input）系统：</p>
<ul>
<li>一种是当输入就绪时发送信号。UCB中通过设置文件描述符（file descriptor）的O_ASYNC来实现</li>
<li>另一个是当输入被读入时发送信号。是POSIX标准，它调用aio_read</li>
</ul>
<p>新版本的反弹程序如图所示，需要两种信号：SIGIO和SIGALRM，所以要建立两个处理函数：</p>
<ul>
<li>SIGIO处理函数读入击键并根据读入的数据采取行动</li>
<li>SIGALRM处理函数驱动动画并检测碰撞。（为了简单起见去掉了速度控制）</li>
</ul>
<img src="https://pic.imgdb.cn/item/631f313016f2c2beb18fe534.jpg" style="zoom:90%;" />

<p><strong>方法1：使用O_ASYNC</strong></p>
<p>使用O_ASYNC需要对原来的弹球程序做4处改动：</p>
<ul>
<li><p>要建立和设置在键盘输入时被调用的处理函数</p>
</li>
<li><p>使用fcntl的F_SETOWN命令告诉内核发送输入通知信号给进程。其他进程可能也连接到键盘，这里不想让这些进程发送信号</p>
<ul>
<li><p>补充fcntl相关函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ... <span class="comment">/* arg */</span> )</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>通过调用fcntl来设置文件描述符0中的O_ASYNC位来打开输入信号</p>
</li>
<li><p>最后循环调用pause等待来自计时器或键盘的信号</p>
</li>
</ul>
<p>当有一个键盘来的字符到达，内核向进程发送SIGIO信号。SIGIO的处理函数使用标准的curses函数getch来读入这个字符。当计时器间隔超时，内核发送以前已经处理的SIGALRM信号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;curses.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MESSAGE <span class="string">&quot;hello&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLANK <span class="string">&quot;     &quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> row =<span class="number">10</span>, col =<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> dir = <span class="number">1</span>, delay =<span class="number">200</span>;</span><br><span class="line"><span class="type">int</span> done = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">on_alarm</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">on_input</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">enable_kbd_signals</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">set_ticker</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">sigset_t</span> * <span class="built_in">set</span>;</span><br><span class="line">    <span class="built_in">set</span> = (<span class="type">sigset_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="built_in">set</span>));</span><br><span class="line">    sigemptyset(<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(<span class="built_in">set</span>,SIGIO);</span><br><span class="line">    sigprocmask(SIG_UNBLOCK,<span class="built_in">set</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    initscr();</span><br><span class="line">    crmode();</span><br><span class="line">    noecho();</span><br><span class="line">    clear();</span><br><span class="line"></span><br><span class="line">    enable_kbd_signals();</span><br><span class="line">    signal(SIGIO,on_input);</span><br><span class="line">    enable_kbd_signals();</span><br><span class="line">    signal(SIGALRM,on_alarm);</span><br><span class="line">    set_ticker(delay);</span><br><span class="line"></span><br><span class="line">    move(row,col);</span><br><span class="line">    addstr(MESSAGE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!done) pause();</span><br><span class="line"></span><br><span class="line">    endwin();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">on_input</span><span class="params">(<span class="type">int</span> signum)</span>&#123;</span><br><span class="line">    <span class="type">char</span> c = getch();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">&#x27;Q&#x27;</span> || c ==EOF)&#123;</span><br><span class="line">        done = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//the rest 3 lines not included will cause cannot quit</span></span><br><span class="line">        move(LINES<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">        endwin();</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27; &#x27;</span>) dir = -dir; <span class="comment">//change direction when the space is input</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">on_alarm</span><span class="params">(<span class="type">int</span> signum)</span>&#123;</span><br><span class="line">    signal(SIGALRM, on_alarm); <span class="comment">//reset, to ensure the setting is right</span></span><br><span class="line">    mvaddstr(row, col, BLANK);</span><br><span class="line">    col+=dir;</span><br><span class="line">    mvaddstr(row,col,MESSAGE);</span><br><span class="line">    refresh();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dir == <span class="number">-1</span> &amp;&amp; col &lt;= <span class="number">0</span>) dir = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(dir == <span class="number">1</span> &amp;&amp; col+<span class="built_in">strlen</span>(MESSAGE)&gt;=COLS)</span><br><span class="line">        dir = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">enable_kbd_signals</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd_flags;</span><br><span class="line">    fcntl(<span class="number">0</span>, F_SETOWN,getpid());</span><br><span class="line">    fd_flags = fcntl(<span class="number">0</span>,F_GETFL);</span><br><span class="line">    fcntl(<span class="number">0</span>,F_SETFL,(fd_flags|O_ASYNC));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">set_ticker</span><span class="params">(<span class="type">int</span> n_msecs)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">new_timeset</span>;</span></span><br><span class="line">    <span class="type">long</span> n_sec, n_usecs;</span><br><span class="line"></span><br><span class="line">    n_sec = n_msecs/<span class="number">1000</span>;</span><br><span class="line">    n_usecs = (n_msecs % <span class="number">1000</span>) *<span class="number">1000L</span>;</span><br><span class="line"></span><br><span class="line">    new_timeset.it_interval.tv_sec = n_sec;</span><br><span class="line">    new_timeset.it_interval.tv_usec = n_usecs;</span><br><span class="line"></span><br><span class="line">    new_timeset.it_value.tv_sec = n_sec;</span><br><span class="line">    new_timeset.it_value.tv_usec = n_usecs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> setitimer(ITIMER_REAL, &amp;new_timeset, <span class="literal">NULL</span>);                                               </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>方法2：使用aio_read</strong></p>
<p> 相比值文件描述符的O_ASYNC位，使用aio_read更加灵活，当然也更加复杂一点</p>
<p>对原来的弹球程序做4处改动：</p>
<ol>
<li>设置输入被读入时调用的处理函数on_inpuut</li>
<li>设置struct kbcbuf中的变量来指明等待什么类型的输入，当输入发生时产生什么信号<ul>
<li>在这个程序中，需要从文件描述符0中读入一个字符，当字符被读入时希望收到SIGIO信号。</li>
<li>实际上能指定任何信号，甚至是SIGARLM或SIGINT</li>
</ul>
</li>
<li>通过将以上定义的结构体传给aio_read来递交读入请求。和调用一般的read不同，aio_read不会阻塞进程。相反，aio_read会在完成时发送信号</li>
<li>最后，实现处理函数，函数通过调用aio_return来得到输入的字符。然后处理这个字符</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> <span class="comment">// pause()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span> <span class="comment">// fcntl()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span> <span class="comment">// signal()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span> <span class="comment">// set_ticker()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;aio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;curses.h&quot;</span> <span class="comment">// initscr(), cbreak(), getch(), move(), addstr(), mvaddch(), refresh(), endwin()</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MESSAGE <span class="string">&quot;hello&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLANK <span class="string">&quot;     &quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">aiocb</span> <span class="title">kbcbuf</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> row = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> col = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> dir = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> delay = <span class="number">200</span>;</span><br><span class="line"><span class="type">bool</span> done = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">set_ticker</span><span class="params">(<span class="type">int</span> n_msecs)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">on_input</span><span class="params">(<span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">setup_aio_buffer</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">on_alarm</span><span class="params">(<span class="type">int</span> signum)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    initscr();</span><br><span class="line">    cbreak();</span><br><span class="line">    noecho();</span><br><span class="line">    refresh();</span><br><span class="line"></span><br><span class="line">    signal(SIGIO, on_input);</span><br><span class="line">    setup_aio_buffer();</span><br><span class="line">    aio_read(&amp;kbcbuf);</span><br><span class="line"></span><br><span class="line">    signal(SIGALRM, on_alarm);</span><br><span class="line">    set_ticker(delay);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (done == <span class="literal">false</span>)</span><br><span class="line">        pause();</span><br><span class="line"></span><br><span class="line">    endwin();</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">set_ticker</span><span class="params">(<span class="type">int</span> n_msecs)</span> &#123;</span><br><span class="line">    <span class="type">long</span> n_secs = n_msecs / <span class="number">1000L</span>;</span><br><span class="line">    <span class="type">long</span> n_usecs = (n_msecs % <span class="number">1000L</span>) * <span class="number">1000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">new_timeset</span>;</span></span><br><span class="line"></span><br><span class="line">    new_timeset.it_value.tv_sec = n_secs;</span><br><span class="line">    new_timeset.it_value.tv_usec = n_usecs;</span><br><span class="line"></span><br><span class="line">    new_timeset.it_interval.tv_sec = n_secs;</span><br><span class="line">    new_timeset.it_interval.tv_usec = n_usecs;</span><br><span class="line"></span><br><span class="line">    setitimer(ITIMER_REAL, &amp;new_timeset, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">on_input</span><span class="params">(<span class="type">int</span> signum)</span> &#123;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="type">char</span> *cp = (<span class="type">char</span> *)kbcbuf.aio_buf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (aio_error(&amp;kbcbuf) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;reading failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (aio_return(&amp;kbcbuf) == <span class="number">1</span>) &#123;</span><br><span class="line">            c = *cp;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;Q&#x27;</span> || c == EOF)</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                dir = -dir;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    aio_read(&amp;kbcbuf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">setup_aio_buffer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> input[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    kbcbuf.aio_fildes = <span class="number">0</span>;</span><br><span class="line">    kbcbuf.aio_buf = input;</span><br><span class="line">    kbcbuf.aio_nbytes = <span class="number">1</span>;</span><br><span class="line">    kbcbuf.aio_offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    kbcbuf.aio_sigevent.sigev_notify = SIGEV_SIGNAL;</span><br><span class="line">    kbcbuf.aio_sigevent.sigev_signo = SIGIO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">on_alarm</span><span class="params">(<span class="type">int</span> signum)</span> &#123;</span><br><span class="line">    signal(SIGALRM, on_alarm);</span><br><span class="line">    mvaddstr(row, col, BLANK);</span><br><span class="line">    col += dir;</span><br><span class="line">    mvaddstr(row, col, MESSAGE);</span><br><span class="line">    refresh();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dir == <span class="number">-1</span> &amp;&amp; col &lt;= <span class="number">0</span>)</span><br><span class="line">        dir = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (dir == <span class="number">1</span> &amp;&amp; col + <span class="built_in">strlen</span>(MESSAGE) &gt;= COLS)</span><br><span class="line">        dir = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cc bounce_aio.c -lcurses -lrt  -o bounce_aio</span><br></pre></td></tr></table></figure>



<p><strong>弹球程序中需要异步读入吗</strong></p>
<p>不。</p>
<p>用户输入阻塞程序，间隔计时器驱动球移动的模式工作的很好。要注意异步读入的优势在于程序不用被输入阻塞而可以做些其他什么。</p>
<p>但是操作系统需要异步输入：</p>
<ul>
<li>内核要运行程序而不能把时间浪费在等待用户输入上</li>
<li>内核设置当键盘、串口或网卡得到输入时被调用的处理函数</li>
<li>内核从一个运行中的程序跳转到处理函数，处理输入，再跳回运行中的程序。</li>
<li>在临界区，内核阻塞信号</li>
</ul>
<p>内核的异步输入是由硬件实现的，而进程的异步输入是由软件实现的。</p>
<p>内核的设备驱动代码从输入端口读入字符，然后将读入的字符通过终端驱动进行处理。如果驱动的文件描述符被设置为异步输入，内核向进程发送信号。当进程继续运行时，控制转移到进程内的信号处理函数。</p>
<h2 id="进程和程序：编写命令解释器sh"><a href="#进程和程序：编写命令解释器sh" class="headerlink" title="进程和程序：编写命令解释器sh"></a>进程和程序：编写命令解释器sh</h2><p>Unix是如何运行程序的？</p>
<p>首先登录，然后shell打印提示符，输入命令并按回车键。程序立即就开始运行了。</p>
<p>当程序结束后，shell打印一个新的提示符。</p>
<p><strong>程序是什么</strong></p>
<p>一个程序是存储在文件中的机器指令序列。一般它是由编译器将源代码编译成二进制格式的代码。</p>
<p>运行一个程序意味着将这个机器指令序列载入内存然后让处理器（CPU）逐条执行这些指令。</p>
<p>在Unix术语中，一个可执行程序是一个机器指令及其数据的序列。一个进程是程序运行时的内存空间和设置。</p>
<img src="https://pic.imgdb.cn/item/631fa61d16f2c2beb1ef123d.jpg" style="zoom:80%;" />

<p>数据和程序存储在磁盘文件中，程序在进程中运行。</p>
<h3 id="通过命令ps学习进程"><a href="#通过命令ps学习进程" class="headerlink" title="通过命令ps学习进程"></a>通过命令ps学习进程</h3><p>进程存在于用户空间。</p>
<p>用户空间是存放运行的程序和它们的数据的一部分内存空间。可以通过ps（process status，进程状态）命令来查看用户空间的内容。这个命令会列出当前的进程。</p>
<img src="https://pic.imgdb.cn/item/631fa6bf16f2c2beb1ef50f2.jpg" style="zoom:80%;" />

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ps</span><br><span class="line">   PID TTY          TIME CMD</span><br><span class="line">  3042 pts/0    00:00:04 bash</span><br><span class="line">122547 pts/0    00:00:01 ps</span><br></pre></td></tr></table></figure>

<p>这里有两个进程正在运行：bash（shell）和ps命令。</p>
<p>每个进程都：</p>
<ul>
<li>有一个可以唯一标识它的数字。称为进程ID（PID）。</li>
<li>与一个终端相连，这里是dev&#x2F;pts&#x2F;0。</li>
<li>有一个已运行时间。注意ps对已运行时间通缉并不是非常的精确</li>
</ul>
<p>和ls一样，ps支持-a，-a选项列出所有进程，包括在其他终端由其他用户运行的程序。但是带选项-a的输出并不包括shell</p>
<p>ps也有一个-l选项来打印更多细节</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[zhangqi@localhost chap8]$ ps -l</span><br><span class="line">F S   UID    PID   PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line">0 S  1000   3042   3033  0  80   0 - 29246 do_wai pts/0    00:00:04 bash</span><br><span class="line">0 R  1000 123930   3042  0  80   0 - 38331 -      pts/0    00:00:00 ps</span><br></pre></td></tr></table></figure>

<ul>
<li>名为S的列表示各个进程的状态，为R说明ps对应的进程正在运行，其他说明处于睡眠状态</li>
<li>UID列指明用户ID</li>
<li>每个进程都有一个进程ID（PID），同时也有一个父进程ID（PPID）</li>
<li>标记为PRI和NI的列分别是进程的优先级和niceness级别。内核根据这些值来决定什么时候运行进程<ul>
<li>一个进程可以增加niceness级别（就像让位）</li>
<li>超级用户可以减少他的niceness级别（就像插队）</li>
</ul>
</li>
<li>SZ列表示进程的大小。这列的数据表示这个进程占用的内存大小。程序在运行的时候占用的内存数量可能会动态的改变。如果程序在运行时分配内存，那么它占用的内存就会增加</li>
<li>WCHAN列显示进程睡眠的原因</li>
</ul>
<p>和文件管理类似：</p>
<ul>
<li>文件包含数据，进程包含可执行代码</li>
<li>文件和进程都有一些属性</li>
<li>内核建立和销毁文件，进程类似</li>
<li>就像管理磁盘的多个文件，内核管理内存中的多个进程，为它们分配空间，并记录内存分配情况</li>
</ul>
<p><strong>系统进程</strong></p>
<p>除了用户运行的进程外，其他一些是Unix系统用来完成系统任务的进程，可通过 <code>ps -ax</code>查看</p>
<p>系统进程中的很大一部分是没有终端与之相连的。它们在系统启动时启动，而不是由用户在命令行输入。</p>
<p>这些系统进程的功能包括内核缓冲、虚存页面、管理系统日志、调度批任务、让一般的用户登录（sshd、getty）等</p>
<p><strong>内存和程序</strong></p>
<img src="https://pic.imgdb.cn/item/631fb15e16f2c2beb1f3df07.jpg" style="zoom:80%;" />

<p>Unix系统中的内存分为系统空间和用户空间。</p>
<p>进程存在于用户空间。</p>
<p>内存实际上就是一个字节序列，或是一个很大的数组</p>
<ul>
<li>如果机器有64MB的内存，那意味着这个数组有大约6700万个内存位置。</li>
<li>其中的一些用来存放组成内核的机器指令和数据。</li>
<li>还有一些存放组成进程的机器指令和数据</li>
<li>一个进程不一定必须要占一段连续的内存。就像文件在磁盘上被分成小块，进程在内存也被分成小块。</li>
<li>同样和文件有记录分配了的磁盘块的列表相似，进程也有保存分配到的内存页面（memory pages）的数据结构</li>
</ul>
<p>建立一个进程有点像建立一个磁盘文件：内核要找到一些用来存放程序指令和数据的空闲内存也。内核还要建立数据结构来存放相应的内存分配情况和进程属性</p>
<h3 id="shell：进程控制和程序控制的工具"><a href="#shell：进程控制和程序控制的工具" class="headerlink" title="shell：进程控制和程序控制的工具"></a>shell：进程控制和程序控制的工具</h3><p>shell是一个管理进程和运行程序的程序。</p>
<p>就像存在很多编程语言，Unix系统有很多种可用的shell，所有常用的shell都有三个主要功能：</p>
<ul>
<li>运行程序<ul>
<li>如grep、date、ls、echo和mail都是一些普通的程序，用C编写，并被编译成机器语言。shell将它们载入内存并运行它们。很多人把shell看成一个程序启动器（program launcher）</li>
</ul>
</li>
<li>管理输入和输出<ul>
<li>shell不仅仅是运行程序。使用&lt; 、&gt;和 | 符号可以将输入、输出重定向。这样就可以告诉shell将进程的输入和输出连接到一个文件或是其他的进程</li>
</ul>
</li>
<li>可编程<ul>
<li>shell同时也是带有变量和流程控制的编程语言。</li>
</ul>
</li>
</ul>
<p><strong>shell是如何运行程序的</strong></p>
<p>shell打印提示符，输入命令，shell就运行这个命令，然后shell再次打印提示符——如此循环。</p>
<p>这些现象可以反映一个shell的主循环：</p>
<ul>
<li>用户键入a.out;</li>
<li>shell建立一个新的进程来运行这个程序</li>
<li>shell将程序从磁盘载入</li>
<li>程序在它的进程中运行直到结束</li>
</ul>
<p>即：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while( !end_of_input)</span><br><span class="line">	get command</span><br><span class="line">	execute command</span><br><span class="line">	wait for command to finish</span><br></pre></td></tr></table></figure>

<p>考虑在终端先后执行ls 和  ps命令，时间轴如下：</p>
<img src="https://pic.imgdb.cn/item/631fb4b716f2c2beb1f56448.jpg" style="zoom:80%;" />

<p>需要三个技术：</p>
<ul>
<li>如何建立进程 fork</li>
<li>如何运行一个程序 execvp</li>
<li>如何让父进程等待子进程结束 wait</li>
</ul>
<p><strong>问题1：一个程序如何运行另一个程序</strong></p>
<p>答案：程序调用execvp</p>
<img src="https://pic.imgdb.cn/item/631fb70616f2c2beb1f677a5.jpg" style="zoom:80%;" />

<p>比如为了运行 <code>ls -la</code>，一个程序调用execvp(“ls”,arglist)。这里arglist是命令行的字符串数组。内核从磁盘将程序载入内存。命令参数ls和-la被传给程序，然后程序开始运行：</p>
<ul>
<li>程序调用execvp</li>
<li>内核从磁盘将程序载入</li>
<li>内核将arglist复制到进程</li>
<li>内核调用main(argc,argv)</li>
</ul>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">    <span class="type">char</span> * arglist[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    arglist[<span class="number">0</span>] = <span class="string">&quot;ls&quot;</span>;</span><br><span class="line">    arglist[<span class="number">1</span>] = <span class="string">&quot;-l&quot;</span>;</span><br><span class="line">    arglist[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*** About toexec ls -l\n&quot;</span>);</span><br><span class="line">    execvp(<span class="string">&quot;ls&quot;</span>,arglist);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*** ls is done. bye\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译并运行后：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[zhangqi@localhost chap8]$ ./exec1</span><br><span class="line">*** About toexec <span class="built_in">ls</span> -l</span><br><span class="line">total 16</span><br><span class="line">-rwxrwxr-x. 1 zhangqi zhangqi 8408 Sep 13 07:45 exec1</span><br><span class="line">-rw-rw-r--. 1 zhangqi zhangqi  182 Sep 13 07:45 exec1.c</span><br></pre></td></tr></table></figure>

<p>可以发现第二条打印的消息并没有出现。</p>
<p>一个程序在一个进程中运行——也就是一些内存和内核中相应的数据结构。这样，execvp将程序从磁盘载入进程以便它可以被运行。</p>
<p>核心：内核将新程序载入到当前进程，替代当前进程的代码和数据</p>
<p>exec系统调用（execvp是一组基于execve系统调用函数中的一个，统称为exec）从当前进程中把当前程序的机器指令清除，然后在空的进程中载入调用时指定的程序代码，最后运行这个新的程序。exec调整进程的内存分配使之适应新的程序对内存的要求。</p>
<p>execvp()总结如下：</p>
<ul>
<li>参数： file，要执行的文件名，argv，字符串数组</li>
<li>如果出错，返回-1，如果执行成功，execvp没有返回值，当前程序从进程中清楚，新的程序在当前进程中运行。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg,</span></span><br><span class="line"><span class="params">           ..., <span class="type">char</span> * <span class="type">const</span> envp[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvpe</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[],</span></span><br><span class="line"><span class="params">            <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br></pre></td></tr></table></figure>

<p>execvp载入又file指定的程序到当前进程，然后试图运行它。execvp将以NULL结尾的字符串列表传给程序。execvp在环境变量PATH所指定的路径中查找file文件。</p>
<p><strong>带提示符的shell实现</strong></p>
<p>psh1.c  (带提示符的shell，prompting shell)</p>
<p>该程序要求每个字符串单独的输入，第一个是程序名，然后依次是程序参数，程序包括两步：</p>
<ul>
<li>一个字符串一个字符串地构造参数列表arglist，最后在数组末尾加上NULL</li>
<li>将arglist[0]和arglist数组传给execvp</li>
</ul>
<img src="https://pic.imgdb.cn/item/631ffce616f2c2beb12c4c33.jpg" style="zoom:80%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 教材版 psh1.c 有内存泄漏……</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXARGS 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARGLEN  100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> *<span class="title function_">makestring</span><span class="params">(<span class="type">char</span> argbuf[])</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">execute</span><span class="params">(<span class="type">char</span> *arglist[])</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *arglist[MAXARGS + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> numargs = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> argbuf[ARGLEN];</span><br><span class="line">    <span class="keyword">while</span> (numargs &lt; MAXARGS) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Arg[%d]?&quot;</span>, numargs);</span><br><span class="line">        <span class="keyword">if</span> (fgets(argbuf, ARGLEN, <span class="built_in">stdin</span>) &amp;&amp; *argbuf != <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">            arglist[numargs] = makestring(argbuf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (numargs &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                arglist[numargs] = <span class="literal">NULL</span>;</span><br><span class="line">                execute(arglist);</span><br><span class="line">                <span class="keyword">while</span> (--numargs)</span><br><span class="line">                    <span class="built_in">free</span>(arglist[numargs]);</span><br><span class="line">                numargs = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        numargs++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> *<span class="title function_">makestring</span><span class="params">(<span class="type">char</span> argbuf[])</span> &#123;</span><br><span class="line">    argbuf[<span class="built_in">strlen</span>(argbuf) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="type">char</span> *cp = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(argbuf) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (cp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;no memory\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(cp, argbuf);</span><br><span class="line">    <span class="keyword">return</span> cp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">execute</span><span class="params">(<span class="type">char</span> *arglist[])</span> &#123;</span><br><span class="line">    execvp(arglist[<span class="number">0</span>], arglist);</span><br><span class="line">    perror(<span class="string">&quot;execvp failed&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译并运行，结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[zhangqi@localhost chap8]$ ./psh1</span><br><span class="line">Arg[0]?<span class="built_in">ls</span></span><br><span class="line">Arg[1]?-l</span><br><span class="line">Arg[2]?.</span><br><span class="line">Arg[3]?</span><br><span class="line">total 32</span><br><span class="line">-rwxrwxr-x. 1 zhangqi zhangqi 8408 Sep 13 07:45 exec1</span><br><span class="line">-rw-rw-r--. 1 zhangqi zhangqi  182 Sep 13 08:28 exec1.c</span><br><span class="line">-rwxrwxr-x. 1 zhangqi zhangqi 8928 Sep 13 11:46 psh1</span><br><span class="line">-rw-rw-r--. 1 zhangqi zhangqi  781 Sep 13 11:46 psh1.c</span><br></pre></td></tr></table></figure>

<p>问题：这里在执行指定的程序结束之后就退出了，shell不能再次接受新的命令，为了运行新的命令，用户不得不再次运行shell</p>
<p>为了shell做到在运行程序的同时还能等待下一个命令，需要启动一个新进程</p>
<p><strong>问题2：如何建立新的进程？</strong></p>
<p>答案：一个进程调用fork来复制自己</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<img src="https://pic.imgdb.cn/item/6320005716f2c2beb12f7aa1.jpg" style="zoom:80%;" />

<p>进程调用fork，当控制转移到内核中的fork代码后，内核做：</p>
<ul>
<li>分配新的内存块和内核数据结构</li>
<li>复制原来的进程到新的进程</li>
<li>向运行进程集添加新的进程</li>
<li>将控制返回给两个进程</li>
</ul>
<p>测试fork：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//forkdemo1.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line">    <span class="type">int</span> ret_from_fork, mypid;</span><br><span class="line"></span><br><span class="line">    mypid = getpid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Before: my pid is %d\n&quot;</span>,mypid);</span><br><span class="line"></span><br><span class="line">    ret_from_fork = fork();</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After: my pid is %d, fork() said %d\n&quot;</span>, getpid(), ret_from_fork);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译并运行：(注意三行输出，可知新的进程3359是从fork返回的地方开始运行的，相当于分出一个岔路)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[zhangqi@localhost chap8]$ ./forkdemo1</span><br><span class="line">Before: my pid is 3358</span><br><span class="line">After: my pid is 3358, fork() said 3359</span><br><span class="line">After: my pid is 3359, fork() said 0</span><br></pre></td></tr></table></figure>

<img src="https://pic.imgdb.cn/item/6320b1aa16f2c2beb1fd0d31.jpg" style="zoom:80%;" />

<p><strong>分辨父进程和子进程</strong></p>
<p>根据不同的进程：fork的返回值是不同的。在子进程中fork返回0，在父进程中fork返回3359。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line">    <span class="type">int</span> fork_rv;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Before: my pid is %d\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">    fork_rv = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fork_rv == <span class="number">-1</span>) perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(fork_rv == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am child. my pid = %d\n&quot;</span>,getpid());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am the parent. my child is %d\n&quot;</span>, fork_rv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译并运行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[zhangqi@localhost chap8]$ ./forkdemo3</span><br><span class="line">Before: my pid is 3921</span><br><span class="line">I am the parent. my child is 3922</span><br><span class="line">I am child. my pid = 3922</span><br></pre></td></tr></table></figure>

<p><strong>问题3：父进程如何等待子进程的退出</strong></p>
<p>答案：进程调用wait等待子进程结束</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *status)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *status, <span class="type">int</span> options)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>系统调用wait()做两件事：</p>
<ul>
<li>wait暂停调用它的进程直到子进程结束。</li>
<li>wait取得子进程结束时传给exit的值</li>
</ul>
<img src="https://pic.imgdb.cn/item/6320b65516f2c2beb101a832.jpg" style="zoom:80%;" />

<p>最终子进程会结束任务并调用exit(n)，n是0-255的一个数字</p>
<p>当子进程调用exit，内核唤醒父进程同时将子进程传给exit的参数。唤醒和传递退出（exit）值的动作由exit的括号到父进程的箭头表示。</p>
<p>这样wait执行两个操作：通知和通信</p>
<p>waitdemo1.c显示了子进程调用exit是如何出发wait返回父进程的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELAY 2</span></span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line">    <span class="type">int</span> newpid;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">child_code</span><span class="params">()</span>, <span class="title function_">parent_code</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;before:mypid is %d\n&quot;</span>,getpid());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((newpid = fork())== <span class="number">-1</span>)</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(newpid == <span class="number">0</span>)</span><br><span class="line">        child_code(DELAY);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        parent_code(newpid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">child_code</span><span class="params">(<span class="type">int</span> delay)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child %d here, will sleep for %d seconds\n&quot;</span>,getpid(), delay);</span><br><span class="line">    sleep(delay);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child done, about to exit\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">17</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">parent_code</span><span class="params">(<span class="type">int</span> childpid)</span>&#123;</span><br><span class="line">    <span class="type">int</span> wait_rv;</span><br><span class="line">    wait_rv = wait(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;done waiting for %d. Wait returned:%d\n&quot;</span>,childpid, wait_rv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>编译并运行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[zhangqi@localhost chap8]$ ./waitdemo1 </span><br><span class="line">before:mypid is <span class="number">6212</span></span><br><span class="line">child <span class="number">6213</span> here, will sleep <span class="keyword">for</span> <span class="number">2</span> seconds</span><br><span class="line">child done, about to <span class="built_in">exit</span></span><br><span class="line">done waiting <span class="keyword">for</span> <span class="number">6213.</span> Wait returned:<span class="number">6213</span></span><br></pre></td></tr></table></figure>

<p>运行程序、调整时间，可以发现父进程总会等到子进程调用exit。</p>
<p>在父进程，控制流始于程序的开始，在wait的地方阻塞。在子进程，控制流始于main函数的中部，然后运行child_code函数，最后调用exit结束。</p>
<p>子进程调用exit就像发送一个信号给父进程以唤醒它</p>
<img src="https://pic.imgdb.cn/item/6320bcca16f2c2beb108037c.jpg" style="zoom:80%;" />

<p>这个程序体现了wait的两个重要特征：</p>
<ul>
<li>wait阻塞调用它的程序直到子进程结束。这使两个进程能够同步它们的行为</li>
<li>wait返回结束进程的PID</li>
</ul>
<p>wait还可以告诉父进程子进程是如何结束的（通过wait的入参，该整型变量地址所对应的int会保存子进程的退出状态）。这个整数由三个部分组成：</p>
<ul>
<li>高八位是记录退出值</li>
<li>低七位记录信号序号</li>
<li>第七位用来指明发生错误并产生了内核映像（core dump）</li>
</ul>
<img src="https://pic.imgdb.cn/item/6320c1ad16f2c2beb10c6c18.jpg" style="zoom:80%;" />

<p>基于waitdemo1增加DELAY并修改parent_code()函数体部分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">parent_code</span><span class="params">(<span class="type">int</span> childpid)</span>&#123;</span><br><span class="line">    <span class="type">int</span> wait_rv;</span><br><span class="line">    <span class="type">int</span> child_status;</span><br><span class="line">    <span class="type">int</span> high_8, low_7, bit_7;</span><br><span class="line"></span><br><span class="line">    wait_rv = wait(&amp;child_status);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;done waiting for %d. Wait returned:%d\n&quot;</span>,childpid, wait_rv);</span><br><span class="line"></span><br><span class="line">    high_8 = child_status &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    low_7 = child_status &amp; <span class="number">0x7F</span>;</span><br><span class="line">    bit_7 = <span class="number">0x80</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;status: exit = %d, sig = %d, core = %d\n&quot;</span>,high_8,low_7,bit_7);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行waitdemo2并正常退出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[zhangqi@localhost chap8]$ ./waitdemo2</span><br><span class="line">before:mypid is 9820</span><br><span class="line">child 9821 here, will <span class="built_in">sleep</span> <span class="keyword">for</span> 5 seconds</span><br><span class="line">child <span class="keyword">done</span>, about to <span class="built_in">exit</span></span><br><span class="line"><span class="keyword">done</span> waiting <span class="keyword">for</span> 9821. Wait returned:9821</span><br><span class="line">status: <span class="built_in">exit</span> = 17, sig = 0, core = 0</span><br></pre></td></tr></table></figure>

<p>运行另一个进程向子进程发送SIGTERM信号（使用kill）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[zhangqi@localhost chap8]$ ./waitdemo2</span><br><span class="line">before:mypid is 9848</span><br><span class="line">child 9849 here, will <span class="built_in">sleep</span> <span class="keyword">for</span> 5 seconds</span><br><span class="line"><span class="keyword">done</span> waiting <span class="keyword">for</span> 9849. Wait returned:9849</span><br><span class="line">status: <span class="built_in">exit</span> = 0, sig = 15, core = 0</span><br></pre></td></tr></table></figure>

<p><strong>小结：shell如何运行程序</strong></p>
<ul>
<li>用fork建立新进程</li>
<li>用exec在新进程中运行用户指定的程序</li>
<li>用wai等待新进程结束。wait系统调用同时从内核取得退出状态或信号序号以告知子进程是如何结束的</li>
</ul>
<img src="https://pic.imgdb.cn/item/6320c99116f2c2beb112e759.jpg" style="zoom:80%;" />

<h3 id="实现一个shell：psh2-c"><a href="#实现一个shell：psh2-c" class="headerlink" title="实现一个shell：psh2.c"></a>实现一个shell：psh2.c</h3><img src="https://pic.imgdb.cn/item/6320c9b816f2c2beb113071f.jpg" style="zoom:80%;" />

<p>使用这个简化的流程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXARGS 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARGLEN  100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> *<span class="title function_">makestring</span><span class="params">(<span class="type">char</span> argbuf[])</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">execute</span><span class="params">(<span class="type">char</span> *arglist[])</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *arglist[MAXARGS + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> numargs = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> argbuf[ARGLEN];</span><br><span class="line">    <span class="keyword">while</span> (numargs &lt; MAXARGS) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Arg[%d]?&quot;</span>, numargs);</span><br><span class="line">        <span class="keyword">if</span> (fgets(argbuf, ARGLEN, <span class="built_in">stdin</span>) &amp;&amp; *argbuf != <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">            arglist[numargs++] = makestring(argbuf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (numargs &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                arglist[numargs] = <span class="literal">NULL</span>;</span><br><span class="line">                execute(arglist);</span><br><span class="line">                <span class="keyword">while</span> (--numargs)</span><br><span class="line">                    <span class="built_in">free</span>(arglist[numargs]);</span><br><span class="line">                numargs = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> *<span class="title function_">makestring</span><span class="params">(<span class="type">char</span> argbuf[])</span> &#123;</span><br><span class="line">    argbuf[<span class="built_in">strlen</span>(argbuf) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="type">char</span> *cp = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(argbuf) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (cp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;no memory\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(cp, argbuf);</span><br><span class="line">    <span class="keyword">return</span> cp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">execute</span><span class="params">(<span class="type">char</span> *arglist[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> pid, exitstatus;</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">switch</span>(pid) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">            perror(<span class="string">&quot;fork failed&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            execvp(arglist[<span class="number">0</span>], arglist);</span><br><span class="line">            perror(<span class="string">&quot;execvp failed&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">while</span> (wait(&amp;exitstatus) != pid)</span><br><span class="line">                ;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child exited with status %d, %d\n&quot;</span>,</span><br><span class="line">                   exitstatus &gt;&gt; <span class="number">8</span>, exitstatus &amp; <span class="number">0377</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以继续改进：</p>
<ul>
<li>让用户可以通过按下Ctrl-D或输入exit退出程序</li>
<li>让用户能够在一行中输入所有参数</li>
</ul>
<h3 id="用进程编程"><a href="#用进程编程" class="headerlink" title="用进程编程"></a>用进程编程</h3><p>考虑函数和进程之间的相似性</p>
<p><strong>execvp&#x2F;exit就像call&#x2F;return</strong></p>
<img src="https://pic.imgdb.cn/item/6320d87416f2c2beb11d4da8.jpg" style="zoom:80%;" />

<ul>
<li>call&#x2F;return<ul>
<li>一个C程序由很多函数组成，一个函数可以调用另一个函数，同时传给它一些参数。被调用的函数执行一定的操作，然后返回一个值。每个函数都有它的局部变量，不同的函数通过call&#x2F;return系统进行通信</li>
<li>这种通过参数和返回值在拥有私有数据的函数间通信的模式是结构化程序设计的基础。Unix鼓励将这种应用于程序之内的模式扩展到程序之间</li>
</ul>
</li>
<li>exec&#x2F;exit<ul>
<li>一个C程序可以fork&#x2F;exec另一个程序，并传给它一些参数。这个被调用的程序执行一定的操作，然后通过exit(n)来返回值。</li>
<li>调用它的进程可以通过wait(&amp;result)来获取exit的返回值。</li>
<li>子程序的exit返回值可以在result的8-15位之间找到</li>
<li>由exec传递的参数必须是字符串。由于进程间通信的参数类型为字符串，这样就强迫了子程序的通信也必须使用文本作为参数类型。</li>
</ul>
</li>
<li>全局变量和fork&#x2F;exec<ul>
<li>全局变量是有害的，它破坏了封装原则，但有时又无法去掉全局变量。</li>
<li>Unix提供方法来建立全局变量。环境（environment）是一些传递给进程的字符串型变量几个。不会有副作用，它对fork&#x2F;exec和exit&#x2F;wait机制是一个有用的补充</li>
</ul>
</li>
</ul>
<h3 id="exit和exec的其他细节"><a href="#exit和exec的其他细节" class="headerlink" title="exit和exec的其他细节"></a>exit和exec的其他细节</h3><p><strong>进程死亡：exit和_exit</strong></p>
<ul>
<li>exit是fork的逆操作，进程通过调用exit来停止运行。fork创建一个进程，exit删除进程</li>
<li>exit刷新所有的流，调用由atexit和on_exit注册的函数，执行当前系统定义的其他与exit相关的操作。然后调用_exit。</li>
<li>系统函数_exit是一个内核操作，这个操作处理所有分配给这个进程的内存，关闭所有这个进程打开的文件，释放所有内核用来管理和维护这个进程的数据结构。</li>
<li>子进程传给exit的参数被存放在内核直到这个进程的父进程通过wait系统调用取回这个值。</li>
<li>那些已经死亡但还没有给exit赋值的子进程被称为僵尸（zombie）进程。很多版本的ps将这些进程标记为defunct。<ul>
<li>任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。这是每个子进程在结束时都要经过的阶段。如果子进程在exit()之后，父进程没有来得及处理，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将导致没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。</li>
</ul>
</li>
</ul>
<p>_exit()小结：</p>
<p>系统调用_exit终止当前进程并执行所有必须的清理工作，包括：</p>
<ul>
<li>关闭所有文件描述符和目录描述符</li>
<li>将该进程的PID置为init进程的PID</li>
<li>如果父进程调用wait或waitpid来等待子进程结束，则通知父进程</li>
<li>向父进程发送SIGCHLD</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _exit(<span class="type">int</span> status);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _Exit(<span class="type">int</span> status);</span><br></pre></td></tr></table></figure>

<p>如果父进程在子进程之前退出，子进程会成为孤儿进程，为避免孤儿进程退出时无法释放所占用的资源而僵死，进程号为1的init进程将会接受这些孤儿进程，这一过程也被称为“收养”（re-parenting）</p>
<p>注意，就算父进程没有调用wait，内核也会向他发送SIGCHLD消息。尽管对SIGCHLD消息的默认处理方法是忽略。但如果想响应这个消息，可以设置一个处理函数</p>
<p><strong>exec家族</strong></p>
<p>注意execvp不是一个系统调用，是一个库函数，这个函数通过系统调用execve来调用内核服务。</p>
<p>另外还有其他一些调用execve的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...)</span>;<span class="comment">//第一参数为完整路径</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ...)</span>;<span class="comment">//不以数组形式传参</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg,</span></span><br><span class="line"><span class="params">           ..., <span class="type">char</span> * <span class="type">const</span> envp[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvpe</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[],</span></span><br><span class="line"><span class="params">            <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br></pre></td></tr></table></figure>



<h2 id="可编程的shell、shell变量和环境"><a href="#可编程的shell、shell变量和环境" class="headerlink" title="可编程的shell、shell变量和环境"></a>可编程的shell、shell变量和环境</h2><p>在shell中可以运行程序，而shell本身就是一种编程语言。shell程序，一般称之为shell脚本，是Unix的重要部分，Unix的引导程序和很多管理程序都是用shell脚本。</p>
<p>shell是一个编程语言解释器，这个解释器解释从键盘输入的命令，也解释存储在脚本中的命令序列。</p>
<p><strong>shell脚本包含一系列命令</strong></p>
<p>运行一个脚本就是运行这个文件中的每个命令</p>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#---this is  comments----</span><br><span class="line">ls</span><br><span class="line">echo the current date/time is</span><br><span class="line">date</span><br><span class="line">echo my name is</span><br><span class="line">whoami</span><br></pre></td></tr></table></figure>

<p>可以把脚本文件名作为参数传给shell来执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[zhangqi@localhost chap9]$ sh script0 </span><br><span class="line">script0</span><br><span class="line">the current <span class="built_in">date</span>/time is</span><br><span class="line">Wed Sep 14 04:26:54 CST 2022</span><br><span class="line">my name is</span><br><span class="line">zhangqi</span><br></pre></td></tr></table></figure>

<p>还可以通过设置文件的执行权限，然后输入文件名来执行脚本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[zhangqi@localhost chap9]$ <span class="built_in">chmod</span> +x script0 </span><br><span class="line">[zhangqi@localhost chap9]$ ./script0 </span><br><span class="line">script0</span><br><span class="line">the current <span class="built_in">date</span>/time is</span><br><span class="line">Wed Sep 14 04:36:18 CST 2022</span><br><span class="line">my name is</span><br><span class="line">zhangqi</span><br></pre></td></tr></table></figure>

<p>对于一个脚本只需要执行一次chmod，可执行位将保持不变直到下一次再改变它，这种方法来启动脚本会更加方便。</p>
<h3 id="sh编程"><a href="#sh编程" class="headerlink" title="sh编程"></a>sh编程</h3><p><strong>sh的编程特征：变量、I&#x2F;O和if..then</strong></p>
<p>以这个script2程序为例</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/sh</span></span><br><span class="line"><span class="comment"># script2: areal program with variables, input and control flow</span></span><br><span class="line"></span><br><span class="line">BOOK = <span class="variable">$HOME</span>/phonebook.data</span><br><span class="line"><span class="built_in">echo</span> find what name <span class="keyword">in</span> phonebook</span><br><span class="line"><span class="built_in">read</span> NAME</span><br><span class="line"><span class="keyword">if</span> grep $ NAME $ BOOK &gt; /tmp/pb.tmp</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> Entries <span class="keyword">for</span> $ NAME</span><br><span class="line">        <span class="built_in">cat</span> /tmp/pb.tmp</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> No entriess <span class="keyword">for</span> $ NAME</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">rm</span> /tmp/pb.tmp</span><br></pre></td></tr></table></figure>

<p>脚本中除了命令之外还包括以下元素：</p>
<ul>
<li>变量：脚本中可以定义变量。如在script2中定义了名为BOOK和NAME两个变量，并在定义之后使用了它们，用前缀$来取得变量的值。变量名习惯上大写</li>
<li>用户输入：read命令告诉shell要从标准输入中读入一个字符串。可以使用read来创建交互的脚本，也可以从文件或管道中读入数据</li>
<li>控制：这个脚本包括了 <code>if... then ... else ... fi</code>控制语句。其他脚本控制语句还有 <code>while</code> <code>case</code>和 <code>for</code></li>
<li>环境：脚本使用一个名为HOME的变量。HOME的值是主目录的路径。HOME变量是由login程序设置的，可以被login进程的所有子进程使用。<ul>
<li>HOME变量是多个环境变量（environment variables）中的一个。这些环境变量记录了个性化设置。而这些设置能影响很多程序的行为。</li>
<li>比如TZ变量记录了当前的时区。将TZ设置为“EST5EDT”是那些使用ctime的程序，比如date或ls -l，应该显示美国东部时间</li>
</ul>
</li>
</ul>
<h3 id="smsh1——命令行解析"><a href="#smsh1——命令行解析" class="headerlink" title="smsh1——命令行解析"></a>smsh1——命令行解析</h3><p>对上一章的自编shell进行改进：加入命令行解析的功能，从而可以在一行中输入命令，然后由解析器将命令行拆成字符串数组，以便传给execvp。</p>
<img src="https://pic.imgdb.cn/item/6320f34b16f2c2beb12d3579.jpg" style="zoom:80%;" />

<p>shell的主函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> *cmdline, *prompt, * *arglist;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    prompt = DFL_PROMPT;</span><br><span class="line">    setup();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从输入流中读取一行进行处理</span></span><br><span class="line">    <span class="keyword">while</span>((cmdline = next_cmd(prompt, <span class="built_in">stdin</span>))!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>((arglist = splitline(cmdline))!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            result = execute(arglist);</span><br><span class="line">            freelist(arglist);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中有三个函数：</p>
<ul>
<li><p>next_cmd</p>
<p>从输入流中读入下一条命令。它调用malloc来分配内存以接受任意长度的命令行。碰到文件结束符，返回NULL</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">next_cmd</span><span class="params">(<span class="type">char</span> *prompt, FILE *fp)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *buf;</span><br><span class="line">    <span class="type">int</span> bufspace = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, prompt);</span><br><span class="line">    <span class="keyword">while</span> ((c = getc(fp)) != EOF) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos + <span class="number">1</span> &gt; bufspace) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bufspace == <span class="number">0</span>)</span><br><span class="line">                buf = (<span class="type">char</span> *)emalloc(BUFSIZ);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                buf = (<span class="type">char</span> *)erealloc(buf, bufspace + BUFSIZ);</span><br><span class="line">            bufspace += BUFSIZ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        buf[pos++] = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == EOF &amp;&amp; pos == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    buf[pos] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>splitline</p>
<p>splitline将一个字符串分解为字符串数组，并返回这个数组。它调用malloc来分配内存以接受任意参数个数的命令行。这个数组由NULL标记结束</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> is_delim(x) ((x) == <span class="string">&#x27; &#x27;</span> || (x) == <span class="string">&#x27;\t&#x27;</span>)</span></span><br><span class="line"><span class="type">char</span> **<span class="title function_">splitline</span><span class="params">(<span class="type">char</span> *line)</span> &#123;</span><br><span class="line">    <span class="type">char</span> **arglist;</span><br><span class="line">    <span class="type">int</span> spots = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> bufspace = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> argnum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> *cp = line;</span><br><span class="line">    <span class="type">char</span> *start;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (line == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    arglist = (<span class="type">char</span> **)emalloc(BUFSIZ);</span><br><span class="line">    bufspace = BUFSIZ;</span><br><span class="line">    spots = BUFSIZ/<span class="keyword">sizeof</span>(<span class="type">char</span> *);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*cp != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (is_delim(*cp))</span><br><span class="line">            cp++;</span><br><span class="line">        <span class="keyword">if</span> (*cp == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (argnum + <span class="number">1</span> &gt;= spots) &#123;</span><br><span class="line">            arglist = (<span class="type">char</span> **)erealloc(arglist, bufspace + BUFSIZ);</span><br><span class="line">            bufspace += BUFSIZ;</span><br><span class="line">            spots += BUFSIZ/<span class="keyword">sizeof</span>(<span class="type">char</span> *);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        start = cp;</span><br><span class="line">        len = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (*++cp != <span class="string">&#x27;\0&#x27;</span> &amp;&amp; !(is_delim(*cp)))</span><br><span class="line">            len++;</span><br><span class="line">        arglist[argnum++] = newstr(start, len);</span><br><span class="line">    &#125;</span><br><span class="line">    arglist[argnum] = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> arglist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">freelist</span><span class="params">(<span class="type">char</span> **arglist)</span> &#123;</span><br><span class="line">    <span class="type">char</span> **cp = arglist;</span><br><span class="line">    <span class="keyword">while</span> (*cp)</span><br><span class="line">        <span class="built_in">free</span>(*cp++);</span><br><span class="line">    <span class="built_in">free</span>(arglist);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *<span class="title function_">newstr</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *rv = (<span class="type">char</span> *)emalloc(len + <span class="number">1</span>);</span><br><span class="line">    rv[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">strncpy</span>(rv, s, len);</span><br><span class="line">    <span class="keyword">return</span> rv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">emalloc</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="type">void</span> *rv;</span><br><span class="line">    <span class="keyword">if</span> ((rv = <span class="built_in">malloc</span>(size)) == <span class="literal">NULL</span>)</span><br><span class="line">        fatal(<span class="string">&quot;out of memory&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> rv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">erealloc</span><span class="params">(<span class="type">void</span> *rv, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="type">void</span> *new_rv;</span><br><span class="line">    <span class="keyword">if</span> ((new_rv = <span class="built_in">realloc</span>(rv, size)) == <span class="literal">NULL</span>)</span><br><span class="line">        fatal(<span class="string">&quot;realloc failed&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> new_rv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>execute</p>
<p>execute使用fork、execvp和wait来运行一个命令。execute返回命令的结束状态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">execute</span><span class="params">(<span class="type">char</span> **arglist)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arglist[<span class="number">0</span>] == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="type">int</span> child_status = <span class="number">-1</span>; <span class="comment">// The return value, default set to -1 which show error.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> child_status;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        signal(SIGINT, SIG_DFL);</span><br><span class="line">        signal(SIGQUIT, SIG_DFL);</span><br><span class="line">        execvp(arglist[<span class="number">0</span>], arglist);</span><br><span class="line">        perror(<span class="string">&quot;cannot execute command&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        signal(SIGINT, SIG_IGN);</span><br><span class="line">        signal(SIGQUIT, SIG_IGN);</span><br><span class="line">        <span class="keyword">if</span> (wait(&amp;child_status) == <span class="number">-1</span>)</span><br><span class="line">            perror(<span class="string">&quot;wait&quot;</span>);</span><br><span class="line">        signal(SIGINT, SIG_DFL);</span><br><span class="line">        signal(SIGQUIT, SIG_DFL);</span><br><span class="line">        <span class="keyword">return</span> child_status;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="shell中的流程控制"><a href="#shell中的流程控制" class="headerlink" title="shell中的流程控制"></a>shell中的流程控制</h3><p><strong>if语句做些什么</strong></p>
<p>考虑以下例子，假设考虑每周五做磁盘备份：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[zhangqi@localhost chap9]$ <span class="keyword">if</span> <span class="built_in">date</span>|grep Fri</span><br><span class="line">&gt; <span class="keyword">then</span></span><br><span class="line">&gt; <span class="built_in">echo</span> time <span class="keyword">for</span> backup, Insert tape and press enter</span><br><span class="line">&gt; <span class="built_in">read</span> x</span><br><span class="line">&gt; tar cvf dev/tape/home</span><br><span class="line">&gt; <span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>shell中的if语句的作用与其他语言一致：做条件检测</p>
<p>程序是如何表示成功的：</p>
<ul>
<li>exit(0)代表成功<ul>
<li>grep程序调用函数exit(0)来表明成功。所有的Unix程序都遵从以0退出表明成功这一惯例。比如diff命令用来比较两个文本文件。如果两个文件相同，diff返回0表明成功。类似的，mv、cp和rm都以相同的方式表明成功</li>
</ul>
</li>
<li>带有else的if语句<ul>
<li>else部分就像then部分一样，可以包含任意数量的命令，包括其他的if then语句</li>
</ul>
</li>
</ul>
<p>if语句还有另一个特征，如果if后的条件是一系列命令，那么最后一个命令的exit值被用作这个语句块的条件值，并由此来决定条件是否成立</p>
<p>if的工作流程：</p>
<ul>
<li>shell运行if后的命令（调用execute）</li>
<li>shell检查命令的exit状态（从wait函数中得到）</li>
<li>exit的状态为0意味着成功，非0意味着事变</li>
<li>如果成功，shell执行then部分的代码</li>
<li>如果失败，shell执行else部分的代码</li>
<li>关键字fi表示if块的结束</li>
</ul>
<p><strong>在smsh中增加if</strong></p>
<p>增加流程控制后的流程图：</p>
<img src="https://pic.imgdb.cn/item/6322006316f2c2beb1362eba.jpg" style="zoom:80%;" />

<p>需要增加一层process：通过寻找关键字，比如if then和fi来管理脚本流程，在适当的时候调用fork和exec。process必须记录条件命令的结果以便能够处理then和else块</p>
<p>process如何工作：</p>
<ul>
<li><p>process将脚本看作一个接一个的代码区域：第一个区域是then代码块，第二个是else代码块，第三个是在if语句之外的代码块。对于不同的区域，shell的处理方法不同</p>
</li>
<li><p>if语句之外的区域称为中立区，对于这类区域的代码，简单地读一条，分析一条，执行一条</p>
</li>
<li><p>if和then之间的区域，这个区域中shell每执行一套命令就记录下它的退出状态。</p>
</li>
<li><p>shell记录当前区域类型，还必须记录在WANT_THEN区域中所执行命令的结果。</p>
<img src="https://pic.imgdb.cn/item/6322094c16f2c2beb13dacc2.jpg" style="zoom:80%;" /></li>
</ul>
<p>process通过3个函数来处理区域问题：</p>
<ul>
<li>is_control_command：返回一个boolean变量告诉process这条命令是脚本语言的一部分还是一条可执行的命令</li>
<li>do_control_command：处理关键字if、then和fi。每个关键字都是区域的界标。这个函数更新状态变量并执行必要的操作</li>
<li>ok_to_execute：根据当前的状态和条件命令的结果返回一个boolean值，说明能否执行当前命令</li>
</ul>
<p>smsh2.c （基于smsh1.c，只在调用execute的地方换成调用process</p>
<p>process.c：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;smsh.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">is_control_command</span><span class="params">(<span class="type">char</span>*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">do_control_command</span><span class="params">(<span class="type">char</span>**)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">ok_to_execute</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">char</span>** args)</span>&#123;</span><br><span class="line">    <span class="type">int</span> rv = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(args[<span class="number">0</span>] == <span class="literal">NULL</span>) rv = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(is_control_command(args[<span class="number">0</span>]))</span><br><span class="line">        rv = do_control_command(args);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ok_to_execute())</span><br><span class="line">        rv = execute(args);</span><br><span class="line">    <span class="keyword">return</span> rv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>controlflow.c：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意 syn_err 会重置 if_state, 也就是说遇到语法错误，前面的条件句就全无效。</span></span><br><span class="line"><span class="comment">// 同时还会忽略 then, fi 之后的命令。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;smsh.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">states</span> &#123;</span>NEUTRAL, WANT_THEN, THEN_BLOCK&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">results</span> &#123;</span>SUCCESS, FAIL&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> if_state = NEUTRAL;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> if_result = SUCCESS;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> last_stat = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">syn_err</span><span class="params">(<span class="type">char</span>*)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ok_to_execute</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//determin the shell should execute a command</span></span><br><span class="line">    <span class="comment">//returns: 1 for yes, 0 for no</span></span><br><span class="line">    <span class="type">int</span> rv = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(if_state == WANT_THEN)&#123;</span><br><span class="line">        syn_err(<span class="string">&quot;then expected&quot;</span>);</span><br><span class="line">        rv = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(if_state == THEN_BLOCK &amp;&amp;if_result == SUCCESS)</span><br><span class="line">        rv = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(if_state == THEN_BLOCK &amp;&amp; if_result == FAIL)</span><br><span class="line">        rv = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> rv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">is_control_command</span><span class="params">(<span class="type">char</span>* s)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">strcmp</span>(s,<span class="string">&quot;if&quot;</span>)==<span class="number">0</span> || <span class="built_in">strcmp</span>(s,<span class="string">&quot;then&quot;</span>)==<span class="number">0</span>||</span><br><span class="line">            <span class="built_in">strcmp</span>(s,<span class="string">&quot;fi&quot;</span>) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">do_control_command</span><span class="params">(<span class="type">char</span> ** args)</span>&#123;</span><br><span class="line">    <span class="type">char</span> *cmd = args[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> rv = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(cmd,<span class="string">&quot;if&quot;</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(if_state != NEUTRAL)</span><br><span class="line">            rv = syn_err(<span class="string">&quot;if unexpected&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            last_stat = process(args+<span class="number">1</span>);</span><br><span class="line">            if_result = (last_stat == <span class="number">0</span>? SUCCESS : FAIL);</span><br><span class="line">            if_state = WANT_THEN;</span><br><span class="line">            rv = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(cmd,<span class="string">&quot;then&quot;</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(if_state != WANT_THEN)</span><br><span class="line">            rv = syn_err(<span class="string">&quot;then unexpected&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            if_state = THEN_BLOCK;</span><br><span class="line">            rv = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(cmd,<span class="string">&quot;fi&quot;</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(if_state!=THEN_BLOCK)</span><br><span class="line">            rv = syn_err(<span class="string">&quot;fi unexpected&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            if_state = NEUTRAL;</span><br><span class="line">            rv = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fatal(<span class="string">&quot;internal error processing:&quot;</span>,cmd,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> rv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">syn_err</span><span class="params">(<span class="type">char</span> * msg)</span>&#123;</span><br><span class="line">    if_state = NEUTRAL;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;syntax error:%s\n&quot;</span>,msg);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译并运行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ cc -o smsh2 smsh2.c splitline.c execute.c process.c controlflow.c </span><br><span class="line">$ ./smsh2</span><br><span class="line">&gt;grep lp /etc/passwd</span><br><span class="line">lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin</span><br><span class="line">&gt;<span class="keyword">if</span> grep lp /etc/passwd</span><br><span class="line">lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin</span><br><span class="line">&gt;<span class="keyword">then</span></span><br><span class="line">&gt;<span class="built_in">echo</span> ok</span><br><span class="line">ok</span><br><span class="line">&gt;<span class="keyword">fi</span></span><br><span class="line">&gt;<span class="keyword">if</span> grep pati /etc/passwd</span><br><span class="line">&gt;<span class="keyword">then</span></span><br><span class="line">&gt;<span class="built_in">echo</span> ok</span><br><span class="line">&gt;<span class="keyword">fi</span></span><br><span class="line">&gt;<span class="built_in">echo</span> ok</span><br><span class="line">ok</span><br><span class="line">&gt;<span class="keyword">then</span></span><br><span class="line">syntax error:<span class="keyword">then</span> unexpected</span><br></pre></td></tr></table></figure>

<p>这个shell已经可以处理if语句了，但是无法处理嵌套的if语句。</p>
<h3 id="shell变量：局部和全局"><a href="#shell变量：局部和全局" class="headerlink" title="shell变量：局部和全局"></a>shell变量：局部和全局</h3><p>shell也有变量，可以对其赋值取值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[zhangqi@localhost chap9]$ age=7</span><br><span class="line">[zhangqi@localhost chap9]$ <span class="built_in">echo</span> <span class="variable">$age</span></span><br><span class="line">7</span><br><span class="line">[zhangqi@localhost chap9]$ <span class="built_in">echo</span> age</span><br><span class="line">age</span><br><span class="line">[zhangqi@localhost chap9]$ <span class="built_in">echo</span> <span class="variable">$age</span> + <span class="variable">$age</span></span><br><span class="line">7 + 7</span><br><span class="line">[zhangqi@localhost chap9]$ <span class="built_in">read</span> name</span><br><span class="line">fido</span><br><span class="line">[zhangqi@localhost chap9]$ <span class="built_in">echo</span> hello, <span class="variable">$name</span>, how are you</span><br><span class="line">hello, fido, how are you</span><br><span class="line">[zhangqi@localhost chap9]$ <span class="built_in">ls</span> &gt; <span class="variable">$name</span>.<span class="variable">$age</span></span><br><span class="line">[zhangqi@localhost chap9]$ food = muffins</span><br><span class="line">bash: food: <span class="built_in">command</span> not found...</span><br></pre></td></tr></table></figure>

<p>shell包括两类变量：局部变量和环境变量（HOME、TZ等）。环境变量可以被所有shell的子进程存取</p>
<p><strong>使用shell变量</strong></p>
<img src="https://pic.imgdb.cn/item/632234dc16f2c2beb159483e.jpg" style="zoom:80%;" />

<p>注意变量的值是字符串，没有数值类型的变量。所有的操作都是字符串操作</p>
<p>可以使用set命令列出当前shell定义的所有变量：</p>
<p><strong>变量的存储</strong></p>
<p>要在shell里增加变量，必须有个地方能存放这些变量的名称和值，而且这个变量存储系统必须能够分辨局部和全局变量</p>
<p>下面是这个系统的抽象模型：</p>
<img src="https://pic.imgdb.cn/item/6322364916f2c2beb15a2aed.jpg" style="zoom:80%;" />

<p>接口：</p>
<h2 id="I-x2F-O重定向和管道"><a href="#I-x2F-O重定向和管道" class="headerlink" title="I&#x2F;O重定向和管道"></a>I&#x2F;O重定向和管道</h2><p>考虑这组命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[zhangqi@localhost chap10]$ <span class="built_in">ls</span> &gt; my.files</span><br><span class="line">[zhangqi@localhost chap10]$ <span class="built_in">who</span> | <span class="built_in">sort</span> &gt; userlist</span><br><span class="line">[zhangqi@localhost chap10]$ <span class="built_in">ls</span></span><br><span class="line">my.files  userlist</span><br></pre></td></tr></table></figure>

<p>shell是如何告诉程序将结果输出到文件而不是屏幕的？又是如何将一个进程的输出流连接到另一个进程的输入流的？标准输入（standard imput）这个术语是什么意思？</p>
<p>本章涉及进程间通信的一种特殊形式：输入&#x2F;输出重定向和管道（I&#x2F;O redirection and pipes）</p>
<h3 id="监控系统用户的shell程序"><a href="#监控系统用户的shell程序" class="headerlink" title="监控系统用户的shell程序"></a>监控系统用户的shell程序</h3><p>考虑一个情景：希望编写一个程序，当其他用户登录系统或注销时通知你。</p>
<p>一种思路：可以使用utmp文件和建个计数器的C程序来完成任务。程序打开utmp文件，记录下用户列表，休眠一段时间后再重新扫描此文件，并将变化报告出来</p>
<p>更简单的办法：写一个shell脚本。Unix中通过who命令列出当前用户</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">whos.sh</span></span><br><span class="line"></span><br><span class="line">who | sort&gt;prev</span><br><span class="line">while true; </span><br><span class="line">do</span><br><span class="line">	sleep 60</span><br><span class="line">	who | sort&gt;curr</span><br><span class="line">	echo &quot;logged out&quot;</span><br><span class="line">	comm -23 prev curr  #删除第二列和第三列=》仅显示prev中的内容</span><br><span class="line">	echo &quot;logged in&quot;</span><br><span class="line">	comm -13 prev curr  #删除第一列和第二列=》仅显示curr中的内容</span><br><span class="line">	mv curr prev</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>此脚本使用了Unix提供的7个工具、一个while循环和I&#x2F;O重定向：</p>
<ul>
<li><p>第一行建立了一个在此脚本运行时已登录用户的列表，并按用户名进行排序。who命令输出用户列表，sort命令将列表作为输入读进，然后输出一个排好序的列表</p>
<ul>
<li><p>这个命令告诉shell同时执行who和sort，将who的输出直接送到sort的输入</p>
<img src="https://pic.imgdb.cn/item/6323968b16f2c2beb13c5085.jpg" style="zoom:80%;" />
</li>
<li><p>who命令并不一定要在sort命令开始读取和排序之前完成对utmp文件的分析。这两个进程以很小的时间间隔为单位来调度，他们和系统中的其他进程一起分享CPU时间。</p>
</li>
</ul>
</li>
<li><p>休眠一分钟后，脚本在文件curr中创建了一个新的用户列表。使用comm工具可以找出两个文件中共有的行。比较两个文件可以得到三个子集：</p>
<ul>
<li>仅文件1有的行</li>
<li>仅文件2有的行</li>
<li>两者共有的行</li>
<li>comm命令比较了两个排过序的列表，并将此三列打印出来，这里的每一列代表一个子集的内容</li>
</ul>
</li>
</ul>
<p>这个脚本体现了三个重要思路：</p>
<ul>
<li>shell脚本的功能——与C相比简单易用</li>
<li>软件工具的灵活性——每一个工具完成一项特定的、通用的功能</li>
<li>I&#x2F;O重定向和管道的使用和作用</li>
</ul>
<p>使用<code>&gt;</code>操作符可以把文件看成任意大小和结构的变量，比如C的调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = func_a(func_b(y));</span><br></pre></td></tr></table></figure>

<p>用shell写就是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prog_b | prog_a &gt; x #将prog_b的结果作为prog_a的输入并将最终结果放入x</span><br></pre></td></tr></table></figure>

<h3 id="标准I-x2F-O与重定向的若干概念"><a href="#标准I-x2F-O与重定向的若干概念" class="headerlink" title="标准I&#x2F;O与重定向的若干概念"></a>标准I&#x2F;O与重定向的若干概念</h3><p>所有的Unix I&#x2F;O重定向都基于标准数据流的原理。考虑sort工具是如何工作的。</p>
<p>sort从一个数据流中读取字节，再将结果输出到另一个流中，同时若有错误发生，则将错误报告给第三个流。如果忽略这些标准流的去向问题，sort工具的基本原型就如图所示：</p>
<img src="https://pic.imgdb.cn/item/63239c8716f2c2beb143e1b9.jpg" style="zoom:80%;" />

<p>三个数据流分别如下：</p>
<ul>
<li>标准输入——需要处理的数据流</li>
<li>标准输出——结果数据流</li>
<li>标准错误输出——错误消息流</li>
</ul>
<p><strong>概念1: 3个标准文件描述符</strong></p>
<p>三种流的每一种都是一个特别的文件描述符：</p>
<ul>
<li>stdin：0</li>
<li>stdout：1</li>
<li>stderr：2</li>
</ul>
<img src="https://pic.imgdb.cn/item/63239cde16f2c2beb1446261.jpg" style="zoom:80%;" />

<p><strong>默认的连接：tty</strong></p>
<p>通常<u>通过shell命令行运行Unix系统工具时，stdin、stdout和stderr连接在终端上</u>。因此，工具从键盘读取数据并且把输出和错误消息写到屏幕。</p>
<p>举例来说：如果输入sort并按下回车键，终端将会被连接到sort工具上。随便输入几行文字，当按Ctrl-D键来结束文字输入的时候，sort程序对输入进行排序，并将结果写到stdout。</p>
<p>大部分的Unix工具处理从文件或标准输入读入的数据。如果在命令行上给出了文件名，工具将从文件读取数据。若无文件名，程序则从标准输入读取数据</p>
<p><strong>程序都输出到stdout</strong></p>
<p>另一方面说，大多数程序并不接收输出文件名；他们总将结果写到文件描述符1，并将错误消息写到文件描述符2。如果希望将进程的输出写到文件或另一个进程的输入去，就必须重定向相应的文件描述符。</p>
<p><strong>重定向I&#x2F;O的是shell而不是程序</strong></p>
<p>通过使用输出重定向标志，命令cmd&gt;filename告诉shell将文件描述符1定位到文件，于是shell就将文件描述符与指定的文件连接起来。</p>
<p>程序则持续不断地将数据写到文件描述符1中，没有意识到数据的目的地已经改变了</p>
<p>如下面的程序甚至没有看到命令行中的重定向符号：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">main(<span class="type">int</span> ac, <span class="type">char</span> * av[])&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Number of args: %d, Args are: \n&quot;</span>,ac);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; ac; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;args[%d] %s\n&quot;</span>,i, av[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This message is sent to stderr.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序将命令行参数打印到标准输出。注意它并没有打印出重定向符号和文件名</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[zhangqi@localhost chap10]$ ./listargs</span><br><span class="line">Number of args: 1, Args are: </span><br><span class="line">args[0] ./listargs</span><br><span class="line">This message is sent to stderr.</span><br><span class="line">[zhangqi@localhost chap10]$ ./listargs testing one two</span><br><span class="line">Number of args: 4, Args are: </span><br><span class="line">args[0] ./listargs</span><br><span class="line">args[1] testing</span><br><span class="line">args[2] one</span><br><span class="line">args[3] two</span><br><span class="line">This message is sent to stderr.</span><br><span class="line">[zhangqi@localhost chap10]$ ./listargs testing one two &gt; xyz</span><br><span class="line">This message is sent to stderr.</span><br><span class="line">[zhangqi@localhost chap10]$ <span class="built_in">cat</span> xyz</span><br><span class="line">Number of args: 4, Args are: </span><br><span class="line">args[0] ./listargs</span><br><span class="line">args[1] testing</span><br><span class="line">args[2] one</span><br><span class="line">args[3] two</span><br><span class="line">[zhangqi@localhost chap10]$ ./listargs testing one two &gt; xyz one two 2&gt;oops</span><br><span class="line">[zhangqi@localhost chap10]$ <span class="built_in">cat</span> xyz</span><br><span class="line">Number of args: 6, Args are: </span><br><span class="line">args[0] ./listargs</span><br><span class="line">args[1] testing</span><br><span class="line">args[2] one</span><br><span class="line">args[3] two</span><br><span class="line">args[4] one</span><br><span class="line">args[5] two</span><br><span class="line">[zhangqi@localhost chap10]$ <span class="built_in">cat</span> oops</span><br><span class="line">This message is sent to stderr.</span><br></pre></td></tr></table></figure>

<p>这些例子验证了关于shell输出重定向的一些概念：</p>
<ul>
<li>最重要的一点是shell不将重定向标记和文件名传递给程序</li>
<li>第二点是重定向可以出现在命令行中的任何地方，并且在重定向标识符周围并不需要空格来区分。<ul>
<li>类似 <code>&gt;listing ls</code>这样的命令也是可以接受的，这里的 <code>&gt;</code>符号并不能终止命令和参数，它只不过是一个附加的请求而已。</li>
</ul>
</li>
<li>另外许多版本的shell都提供对重定向其他文件描述符的支持。如 <code>2&gt;filename</code>即重定向文件描述符2，也就是将标准错误输出到给定的文件中</li>
</ul>
<p>三个基本的重定向操作程序：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">who</span>&gt;userlist   	<span class="comment">#将stdout连接到一个文件</span></span><br><span class="line"><span class="built_in">sort</span>&lt;data		<span class="comment">#将stdin连接到一个文件</span></span><br><span class="line"><span class="built_in">who</span>|<span class="built_in">sort</span>		<span class="comment">#将stdout连接到stdin</span></span><br></pre></td></tr></table></figure>

<p><strong>文件描述符</strong></p>
<p>文件描述符是一个数组的索引号。每个进程都有其打开的一组文件。这些打开的文件被保持在一个数组中。文件描述符即为某文件再次数组中的索引。</p>
<p>下图展示了“最低可用文件描述符（Lowest-Available-fd”）原则</p>
<img src="https://pic.imgdb.cn/item/6323b20216f2c2beb16bc44d.jpg" style="zoom:80%;" />

<p>概念：当打开文件时，为此文件安排的描述符总是次数组中最低可用位置的索引</p>
<h3 id="程序如何将stdin定向到文件"><a href="#程序如何将stdin定向到文件" class="headerlink" title="程序如何将stdin定向到文件"></a>程序如何将stdin定向到文件</h3><p>精确的说，进程并不是从文件读数据，而是从文件描述符读数据，如果将文件描述符0定位到一个文件，那么此文件就成为标准输入的源</p>
<p>以下是三种将标准输入定位到文件的方法：</p>
<ol>
<li><p><strong>close then open：</strong></p>
<ul>
<li><p>初始情况，系统中三种标准流分别连接到文件描述符0,1,2</p>
</li>
<li><p>第一步close(0)，将标准输入的连接挂断</p>
<img src="C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20220916071733439.png" alt="image-20220916071733439" style="zoom:80%;" />
</li>
<li><p>此时文件描述符数组中的第一个元素现在处于空闲状态</p>
</li>
<li><p>最后使用 <code>open(filename, O_RDONLY)</code>打开一个想连接到stdin上的文件。由于当前最低可用文件描述符是0，因此打开的文件将被连接到标准输入</p>
<img src="https://pic.imgdb.cn/item/6323b33d16f2c2beb16dc7f7.jpg" style="zoom:80%;" />
</li>
<li><p>代码实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> line[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//read and print 3 lines</span></span><br><span class="line">    fgets(line,<span class="number">100</span>,<span class="built_in">stdin</span>);<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,line);</span><br><span class="line">    fgets(line,<span class="number">100</span>,<span class="built_in">stdin</span>);<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,line);</span><br><span class="line">    fgets(line,<span class="number">100</span>,<span class="built_in">stdin</span>);<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,line);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//redirect input</span></span><br><span class="line">    close(<span class="number">0</span>);</span><br><span class="line">    fd = open(<span class="string">&quot;/etc/passwd&quot;</span>,O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not open data as fd 0\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//read and print 3 lines</span></span><br><span class="line">    fgets(line,<span class="number">100</span>,<span class="built_in">stdin</span>);<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,line);</span><br><span class="line">    fgets(line,<span class="number">100</span>,<span class="built_in">stdin</span>);<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,line);</span><br><span class="line">    fgets(line,<span class="number">100</span>,<span class="built_in">stdin</span>);<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,line);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序从标准输入读取并打印了三行字符串，然后重定向标准输入，之后又从标准输入中读取并打印了三行字符串（后三行字符串是从passwd中读出的）。</p>
</li>
</ul>
</li>
<li><p><strong>open.. close.. dup.. close</strong></p>
<p>Unix系统调用dup建立指向已经存在的文件描述符的第二个连接，这个方法需要4个步骤：</p>
<ul>
<li>open(file)：先打开stdin要重定向的文件，这个调用会返回一个文件描述符（非0）</li>
<li>close(0)：文件描述符0现在空闲</li>
<li>duo(fd)：将文件描述符fd做一个复制，此次复制使用最低可用文件描述符号，因此获得的文件描述符为0。</li>
<li>close(fd)：关闭文件的原始连接，只留下文件描述符0的连接</li>
</ul>
<p>代码实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">int</span> newfd;</span><br><span class="line">    <span class="type">char</span> line[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//read and print 3 lines</span></span><br><span class="line">    fgets(line,<span class="number">100</span>,<span class="built_in">stdin</span>);<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,line);</span><br><span class="line">    fgets(line,<span class="number">100</span>,<span class="built_in">stdin</span>);<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,line);</span><br><span class="line">    fgets(line,<span class="number">100</span>,<span class="built_in">stdin</span>);<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,line);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//redirect input</span></span><br><span class="line">    fd = open(<span class="string">&quot;/etc/passwd&quot;</span>,O_RDONLY);</span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> CLOSE_DUP</span></span><br><span class="line">    close(<span class="number">0</span>);</span><br><span class="line">    newfd = dup(fd);</span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    newfd = dup2(fd,<span class="number">0</span>);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span>(newfd!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not open data as fd 0\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//read and print 3 lines</span></span><br><span class="line">    fgets(line,<span class="number">100</span>,<span class="built_in">stdin</span>);<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,line);</span><br><span class="line">    fgets(line,<span class="number">100</span>,<span class="built_in">stdin</span>);<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,line);</span><br><span class="line">    fgets(line,<span class="number">100</span>,<span class="built_in">stdin</span>);<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,line);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dup系统调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>; <span class="comment">//oldfd为需要复制的文件描述符</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;  <span class="comment">//newfd为复制oldfd后得到的文件描述符</span></span><br><span class="line"><span class="comment">//发生错误，返回-1。成功，返回newfd</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>open..dup2..close</strong></p>
<p>已包含在上面代码中</p>
</li>
</ol>
<p>这些例子显示了程序如何将标准输入重定向到文件。但事实上，如果程序希望读取文件，它直接打开文件就可以了。这些例子的意义在与说明一个程序如何将标准输入重定向到别的程序。</p>
<h3 id="为其他程序重定向I-x2F-O-who-gt-userlist"><a href="#为其他程序重定向I-x2F-O-who-gt-userlist" class="headerlink" title="为其他程序重定向I&#x2F;O: who &gt; userlist"></a>为其他程序重定向I&#x2F;O: who &gt; userlist</h3><p>当某用户输入 <code>who&gt;userlist</code>，shell运行who程序，并将who的标准输出重定向到名为userlist的文件上。这是如何完成的呢？</p>
<p>关键就在与fork和exec之间的时间间隙。在fork执行之后，子进程仍然在运行shell程序，并准备执行exec。exec将替换进程中运行的程序，但它不会改变进程的属性和进程中所有的连接。</p>
<p>也就是说，在运行过exec之后，进程的用户ID不会改变，其优先级不会改变，并且其文件描述符也和运行exec之前一样。注意，程序得到的是载入它的进程所打开的文件。</p>
<img src="https://pic.imgdb.cn/item/6323bce916f2c2beb179969a.jpg" style="zoom:80%;" />

<ol>
<li><p>初始情况</p>
<p>如图所示，进程运行在用户空间中。文件描述符1连接在打开的文件f上。</p>
<img src="https://pic.imgdb.cn/item/6323c9b316f2c2beb1899639.jpg" style="zoom:80%;" />
</li>
<li><p>父进程调用fork之后</p>
<p>新进程出现，与原始进程运行相同的代码。但它知道自己是子进程。然后子进程会调用close(1)</p>
<img src="https://pic.imgdb.cn/item/6323c9f916f2c2beb189ebe3.jpg" style="zoom:80%;" />
</li>
<li><p>子进程调用close(1)之后</p>
<p>由于父进程没有调用close(1)，因此父进程的文件描述符1仍然指向f。子进程调用close(1)后，文件描述符1变成了最低未用文件描述符</p>
<img src="https://pic.imgdb.cn/item/6323cae516f2c2beb18ba179.jpg" style="zoom:80%;" />
</li>
<li><p>在子进程调用 <code>creat(&quot;g&quot;,m)</code>之后</p>
<p>文件描述符1被连接到文件g、子进程的标准输出被重定向到g。子进程然后调用exec来运行who</p>
</li>
<li><p>子进程使用exec执行新程序之后</p>
<p>子进程执行who程序，于是子进程中的代码和数据都被who程序的代码和数据替代了，然而文件描述符被保留下来。打开的文件并非是程序的代码也不是数据，它们属于进程的属性，因此exec调用并不改变它们。</p>
<img src="https://pic.imgdb.cn/item/6323cc4f16f2c2beb18df694.jpg" style="zoom:80%;" /></li>
</ol>
<p>who命令将当前用户列表送至文件描述符1。其实这组字节已经被写到文件g中去了，而who命令毫不知情</p>
<p>下面程序实现了上面说的方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;About to run who into a file\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//create a new process or quit</span></span><br><span class="line">    <span class="keyword">if</span>((pid = fork())== <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//child does the work</span></span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        close(<span class="number">1</span>);</span><br><span class="line">        fd = creat(<span class="string">&quot;userlist&quot;</span>,<span class="number">0644</span>);</span><br><span class="line">        execlp(<span class="string">&quot;who&quot;</span>,<span class="string">&quot;who&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line">        perror(<span class="string">&quot;execlp&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//parent waits then reports</span></span><br><span class="line">    <span class="keyword">if</span>(pid!=<span class="number">0</span>)&#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Done running who. results in userlist\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="管道编程"><a href="#管道编程" class="headerlink" title="管道编程"></a>管道编程</h3><p>本节讨论如何使用管道来连接一个进程的输出和另一个进程的输入。</p>
<p>管道是内核中的一个单向的数据通道。管道有一个读取端和一个写入段。</p>
<p>管道编程涉及：如何创建管道和如何将标准输入和输出通过管道连接起来</p>
<img src="https://pic.imgdb.cn/item/6323d92816f2c2beb1a07728.jpg" style="zoom:80%;" />

<p><strong>创建管道</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>; <span class="comment">//包含两个int类型数据的数组</span></span><br><span class="line"><span class="comment">//发生错误返回-1，成功返回0</span></span><br></pre></td></tr></table></figure>

<img src="https://pic.imgdb.cn/item/6323dcf616f2c2beb1a5e996.jpg" style="zoom:80%;" />

<p>调用pipe来创建管道并将其两端连接到两个文件描述符。</p>
<p>array[0]存放数据端的文件描述符，而array[1]存放写数据端的文件描述符。像一个打开的文件的内部情况一样，管道的内部实现隐藏在内核中，进程只能看见两个文件描述符。</p>
<p>下图显示了进程创建一个管道前后的状况。前一张图（调用pipe之前）显示了标准文件描述符集。后一张图（调用pipe之后）显示了内核中新创建的管道，以及进程到管道的两个连接。注意，类似于open调用，pipe调用也使用最低可用文件描述符。</p>
<img src="https://pic.imgdb.cn/item/6323de0216f2c2beb1a779bb.jpg" style="zoom:80%;" />

<p>下面程序展示了创建管道并使用管道向自己发送数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> len, apipe[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> buf[BUFSIZ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe(apipe) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;create a pipe failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Got a pipe! It is file descriptors: &#123;%d %d&#125;\n&quot;</span>, apipe[<span class="number">0</span>], apipe[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fgets(buf, BUFSIZ, <span class="built_in">stdin</span>)) &#123;</span><br><span class="line">        len = <span class="built_in">strlen</span>(buf);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (write(apipe[<span class="number">1</span>], buf, len) != len) &#123;</span><br><span class="line">            perror(<span class="string">&quot;write to a pipe failed&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            buf[i] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        len = read(apipe[<span class="number">0</span>], buf, len);</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read from a pipe failed&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (write(<span class="number">1</span>, buf, len) != len) &#123;</span><br><span class="line">            perror(<span class="string">&quot;write to stdout failed&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数据流从进程到管道，再从管道到进程以及从进程回到终端</p>
<img src="https://pic.imgdb.cn/item/6323e4bb16f2c2beb1b385dd.jpg" style="zoom:80%;" />

<p>将pipe和fork结合起来，就可以连接两个不同的进程了</p>
<p><strong>使用fork来共享管道</strong></p>
<p>当进程创建一个管道之后，该进程就有了连向管道两端的连接。当这个进程调用fork的时候，它的子进程也得到了这两个连向管道的连接。</p>
<p>如图，父进程和子进程都可以将数据写到管道的写数据端口，并从读数据端口将数据读出。</p>
<p>两个进程都可以读写管道，但是当一个进程读，另一个进程写的时候，管道的使用效率最高</p>
<img src="https://pic.imgdb.cn/item/6323e57c16f2c2beb1b48f01.jpg" style="zoom:80%;" />

<p>下面程序将pipe和fork结合起来，创建一对通过管道来通信的进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHILD_MESS <span class="string">&quot;I want a cookie\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PARENT_MESS <span class="string">&quot;testing...\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> oops(m,x) &#123;perror(m); exit(x);&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> len, read_len, pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> buf[BUFSIZ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe(pipefd) == <span class="number">-1</span>)</span><br><span class="line">        oops(<span class="string">&quot;cannot get a pipe&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(fork()) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">            oops(<span class="string">&quot;cannot fork&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            len = <span class="built_in">strlen</span>(CHILD_MESS);</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (write(pipefd[<span class="number">1</span>], CHILD_MESS, len) != len)</span><br><span class="line">                    oops(<span class="string">&quot;cannot&quot;</span>, <span class="number">3</span>);</span><br><span class="line">                sleep(<span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            len = <span class="built_in">strlen</span>(PARENT_MESS);</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (write(pipefd[<span class="number">1</span>], PARENT_MESS, len) != len)</span><br><span class="line">                    oops(<span class="string">&quot;write&quot;</span>, <span class="number">4</span>);</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">                read_len = read(pipefd[<span class="number">0</span>], buf, BUFSIZ); </span><br><span class="line">                <span class="keyword">if</span> (read_len &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                write(<span class="number">1</span>, buf, read_len);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用pipe、fork以及exec</strong></p>
<p>将所有技巧结合在一起，编写一个通用的程序pipe，它使用两个程序的名字作参数，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pipe who sort</span><br><span class="line">pipe ls head</span><br></pre></td></tr></table></figure>

<p>程序内在逻辑：</p>
<img src="https://pic.imgdb.cn/item/6323eb8716f2c2beb1be35e4.jpg" style="zoom:80%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: pipe cmd1 cmd2\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    pipe(pipefd); <span class="comment">// pipe 一定要在 fork 之前执行……</span></span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fork failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line">        dup2(pipefd[<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">        close(pipefd[<span class="number">1</span>]); <span class="comment">// 强力关掉无用的管道 fd 是好习惯</span></span><br><span class="line">        execlp(argv[<span class="number">1</span>], argv[<span class="number">1</span>], <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;exec cmd 1 failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line">        dup2(pipefd[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">        close(pipefd[<span class="number">0</span>]); <span class="comment">// 强力关掉无用的管道 fd 是好习惯</span></span><br><span class="line">        execlp(argv[<span class="number">2</span>], argv[<span class="number">2</span>], <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;exec cmd 2 failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>技术细节：管道并非文件</strong></p>
<p>管道与文件的相同点与不同点</p>
<ol>
<li>从管道中读数据<ul>
<li>管道读取阻塞：当进程试图从管道中读数据时，进程被挂起知道数据被写进管道。那么如何避免进程永无止境地等待下去呢？</li>
<li>管道的读取结束标志：当所有的写者关闭了管道的写数据端时，试图从管道读取数据的调用返回0，这意味着文件的结束</li>
<li>多个读者可能会引起麻烦：管道是一个队列。当进程从管道中读取数据之后，数据已经不存在了。如果两个进程都试图对同一个管道进行读操作，在一个进程读取一些之后，另一个进程读到的将是后面的内容。除非两个进程使用某种方法来协调它们对管道的访问。</li>
</ul>
</li>
<li>向管道中写数据<ul>
<li>写入数据阻塞直到管道有空间去容纳新数据：管道容纳数据的能力要比磁盘文件差得多。当进程试图对管道进行写操作的时候，此调用将挂起进程直到管道中有足够的空间去容纳新的数据。</li>
<li>写入必须保证一个最小的块大小：POSIX标准规定内核不会拆分小于512字节的块。而Linux则保证管道中可以存在4096字节的连续缓存。如果两个进程向管道写数据，并且每一个进程都限制其消息不大于512字节，那么这些消息都不会被内核拆分</li>
<li>若无读者在读取数据，则写操作执行失败：如果所有的读者都已将管道的读取端关闭，那么对管道的写入调用将会执行失败。</li>
</ul>
</li>
</ol>
<h2 id="连接到近端或远端的进程：服务器与Socket"><a href="#连接到近端或远端的进程：服务器与Socket" class="headerlink" title="连接到近端或远端的进程：服务器与Socket"></a>连接到近端或远端的进程：服务器与Socket</h2><p>Unix提供一个接口来处理可能来自不同数据源的数据</p>
<img src="C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20220916232108753.png" alt="image-20220916232108753" style="zoom:80%;" />

<ul>
<li>磁盘&#x2F;设备文件：用open命令连接，用read和write传递数据</li>
<li>管道：用pipe命令创建，用fork共享，用read和write传递数据</li>
<li>sockets：用socket、listen和connect连接，用read和write传递数据</li>
</ul>
<p><strong>以Unix中的计算器bc为例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[zhangqi@localhost chap10]$ bc</span><br><span class="line">bc 1.06.95</span><br><span class="line">Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006 Free Software Foundation, Inc.</span><br><span class="line">This is free software with ABSOLUTELY NO WARRANTY.</span><br><span class="line">For details <span class="built_in">type</span> `warranty<span class="string">&#x27;. </span></span><br><span class="line"><span class="string">17^123</span></span><br><span class="line"><span class="string">22142024630120207359320573764236957523345603216987331732240497016947\</span></span><br><span class="line"><span class="string">29282299663749675090635587202539117092799463206393818799003722068558\</span></span><br><span class="line"><span class="string">0536286573569713</span></span><br></pre></td></tr></table></figure>

<p><strong>bc并不是一个计算器</strong></p>
<p>一个计算器程序分析输入，执行操作，打印输出。但是大部分版本的bc程序都只分析输入，不执行操作，取而代之的，bc在内部启动了dc计算器程序，并通过管道与其进行通信。</p>
<p>dc是一个基于栈的计算器，它需要用户在指定具体的操作符之前，先输入所有操作的数据（如用户输入 2 2 + 来代表2+2的操作</p>
<p>下图显示了整个过程：</p>
<ul>
<li>用户输入2+2，然后回车</li>
<li>bc从标准输入读取该表达式，分析出数据和操作符</li>
<li>接下来把一系列命令 <code>2</code>，<code>2</code>，<code>+</code>，<code>p</code>传给dc（p是结束符）</li>
<li>dc将数据入栈，运行加操作</li>
<li>最后把栈顶的数值送到标准输出</li>
</ul>
<img src="https://pic.imgdb.cn/item/632498ca16f2c2beb1d08174.jpg" style="zoom:80%;" />

<p>bc从连接到dc标准输出的管道上读取结果，再把结果转发给用户。这样，bc甚至不需要持有变量。</p>
<p>如果用户输入 x &#x3D; 2+2，bc告诉dc执行该操作并且把结果存到寄存器x中。命令<code>bc -c</code>可以显示分析器传给计算器的数据。</p>
<p><strong>从bc中得到的思想</strong></p>
<ol>
<li>客户&#x2F;服务器模型<ul>
<li>bc&#x2F;dc程序是对C&#x2F;S模型程序设计的一个实例。dc提供服务：计算。</li>
<li>dc所标识的语言是逆波兰表示法。bc和dc之间通过标准输入stdin和标准输出stdout进行通信</li>
<li>bc提供用户界面，并使用dc提供的服务。bc被称为dc的客户</li>
<li>这两部分是根本上独立的程序</li>
</ul>
</li>
<li>双向通信<ul>
<li>C&#x2F;S模型不同于生产线的数据处理模型，它要求一个进程既跟另一个进程的标准输入也要和它的标准输出进行通信。</li>
<li>传统的Unix的管道只是单方向地传送数据。如上图中bc和dc之间的两个管道，上面的管道把一些计算命令传给dc的标准输入，下面的管道把dc的标准输出传给bc</li>
</ul>
</li>
<li>永久性服务<ul>
<li>bc只是让单一的dc进程处于运行状态，这就不同于shell程序，这种程序中的每个用户命令都创建一个新的进程。</li>
<li>bc程序持续不断地和dc的同一个实例进行通信，把用户的输入转换成命令传给dc。</li>
<li>他们之间的关系并不同于标准函数中所使用的调用返回机制</li>
<li>bc&#x2F;dc对被称之为协同进程（coroutines）以用来区别于子程序（subroutines）</li>
</ul>
</li>
</ol>
<p><strong>编写bc：pipe、fork、dup、exec</strong></p>
<p>流程：</p>
<ul>
<li>创建两个管道</li>
<li>创建一个进程来运行dc</li>
<li>在新创建的进程中，重定向标准输入和标准输出到管道，然后运行exec dc</li>
<li>在父进程中，读取并分析用户的输入，将命令传给dc，dc读取响应，并把响应传给用户</li>
</ul>
<img src="https://pic.imgdb.cn/item/63249dfd16f2c2beb1db427a.jpg" style="zoom:80%;" />

<p>以下简单实现了一个bc（只能对两个数做计算）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tinybc.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> oops(m,x) &#123;perror(m);exit(x);&#125;</span></span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line">    <span class="type">int</span> pid, todc[<span class="number">2</span>], fromdc[<span class="number">2</span>]; <span class="comment">//todc存储从bc到dc管道的读fd和写fd，fromdc相反</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//make 2 pipes</span></span><br><span class="line">    <span class="keyword">if</span>(pipe(todc) == <span class="number">-1</span> || pipe(fromdc) == <span class="number">-1</span>)</span><br><span class="line">        oops(<span class="string">&quot;pipe failed&quot;</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((pid = fork()) == <span class="number">-1</span>)	<span class="comment">//fork调用一次，返回两次，父进程中返回子进程的进程id，子进程中返回0</span></span><br><span class="line">        oops(<span class="string">&quot;cannot fork&quot;</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)<span class="comment">//child is dc </span></span><br><span class="line">        be_dc(todc,fromdc);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        be_bc(todc,fromdc);</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">be_dc(<span class="type">int</span> in[<span class="number">2</span>], <span class="type">int</span> out[<span class="number">2</span>])&#123;</span><br><span class="line">    <span class="comment">//在子进程dc中处理bc通过todc[0]的数据，计算，再从fromdc[1]输出</span></span><br><span class="line">    <span class="comment">//set up stdin and stdout, then execl dc</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//set up stdin from pipe in</span></span><br><span class="line">    <span class="keyword">if</span>(dup2(in[<span class="number">0</span>],<span class="number">0</span>) == <span class="number">-1</span>)         <span class="comment">//copy read end to 0</span></span><br><span class="line">        oops(<span class="string">&quot;dc: cannot redirect stdin&quot;</span>, <span class="number">3</span>);</span><br><span class="line">    close(in[<span class="number">0</span>]);   <span class="comment">//close old fd, newfd is fd 0</span></span><br><span class="line">    close(in[<span class="number">1</span>]);   <span class="comment">//won&#x27;t write here</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//set up stdout to pipeout</span></span><br><span class="line">    <span class="keyword">if</span>(dup2(out[<span class="number">1</span>],<span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">        oops(<span class="string">&quot;dc: cannot redirect stdout&quot;</span>,<span class="number">4</span>);</span><br><span class="line">    close(out[<span class="number">1</span>]);	<span class="comment">//moved to fd 1</span></span><br><span class="line">    close(out[<span class="number">0</span>]);	<span class="comment">//won&#x27;t read from here</span></span><br><span class="line">    <span class="comment">//now execl dc with the - option</span></span><br><span class="line">    execlp(<span class="string">&quot;dc&quot;</span>, <span class="string">&quot;dc&quot;</span>, <span class="string">&quot;-&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    oops(<span class="string">&quot;Cannot run dc&quot;</span>,<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">be_bc(<span class="type">int</span> todc[<span class="number">2</span>], <span class="type">int</span> fromdc[<span class="number">2</span>])&#123;</span><br><span class="line">    <span class="type">int</span> num1, num2;</span><br><span class="line">    <span class="type">char</span> operation[BUFSIZ], message[BUFSIZ], *fgets();</span><br><span class="line">    FILE *fpout, *fpin, *fdopen();</span><br><span class="line"></span><br><span class="line">    close(todc[<span class="number">0</span>]);		<span class="comment">//won&#x27;t read from pipe to dc</span></span><br><span class="line">    close(fromdc[<span class="number">1</span>]);	<span class="comment">//won&#x27;t write to pipe from dc</span></span><br><span class="line">    fpout = fdopen(todc[<span class="number">1</span>],<span class="string">&quot;w&quot;</span>);</span><br><span class="line">    fpin = fdopen(fromdc[<span class="number">0</span>],<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fpout == <span class="literal">NULL</span> || fpin == <span class="literal">NULL</span>)</span><br><span class="line">        fatal(<span class="string">&quot;Error converting pipes to streams&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//main loop</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">printf</span>(<span class="string">&quot;tinybc: &quot;</span>),fgets(message, BUFSIZ, <span class="built_in">stdin</span>)!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">//parse input</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">sscanf</span>(message,<span class="string">&quot;%d %[- + */^]%d&quot;</span>,</span><br><span class="line">                  &amp;num1,operation,&amp;num2)!=<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;syntax error\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">fprintf</span>(fpout, <span class="string">&quot;%d\n%d\n%c\np\n&quot;</span>,num1,num2,*operation) == EOF)</span><br><span class="line">            fatal(<span class="string">&quot;Error writing&quot;</span>);</span><br><span class="line">        fflush(fpout);</span><br><span class="line">        <span class="keyword">if</span>(fgets(message,BUFSIZ,fpin)==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %c %d = %s&quot;</span>,num1,*operation, num2,message);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fpout);</span><br><span class="line">    fclose(fpin);</span><br><span class="line">&#125;</span><br><span class="line">fatal(<span class="type">char</span> * mess[])&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Error: %s\n&quot;</span>,mess);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译并运行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[zhangqi@localhost chap11]$ cc tinybc.c -o tinybc</span><br><span class="line">[zhangqi@localhost chap11]$ ./tinybc </span><br><span class="line">tinybc: 2+2</span><br><span class="line">2 + 2 = 4</span><br><span class="line">tinybc: 55^5</span><br><span class="line">55 ^ 5 = 503284375</span><br><span class="line">tinybc: </span><br></pre></td></tr></table></figure>

<p>注意tinybc.c中使用了库函数fdopen：</p>
<ul>
<li>fdopen与fopen类似，返回一个FILE *类型的值，不同的是此函数以文件描述符而非文件作为参数</li>
<li>使用fopen的时候，将文件名作为参数传给它，fopen可以打开设备文件也可以打开常规的磁盘文件。如只知道文件描述符而不清楚文件名的时候可以使用fdopen命令。</li>
<li>注意tinybc.c使用fprintf和fgets来通过管道和dc进行通信的方式</li>
<li>使用fdopen使得对远端的进程的处理就如同处理常规文件一样</li>
</ul>
<h3 id="popen：让进程看似文件"><a href="#popen：让进程看似文件" class="headerlink" title="popen：让进程看似文件"></a>popen：让进程看似文件</h3><p>fopen打开一个指向文件的带缓存的连接：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">File * fp;				<span class="comment">//a pointer to a struct</span></span><br><span class="line">fp = fopen(<span class="string">&quot;file1&quot;</span>,<span class="string">&quot;r&quot;</span>);<span class="comment">//args are filename, connection type</span></span><br><span class="line">c = getc(fp);			<span class="comment">//read char by char</span></span><br><span class="line">fgets(buf, len, fp);	<span class="comment">//line by line</span></span><br><span class="line"><span class="built_in">fscanf</span>(fp,<span class="string">&quot;%d %d %s&quot;</span>,&amp;x,&amp;y,x);<span class="comment">//token by token</span></span><br><span class="line">fclose(fp);				<span class="comment">//close when done</span></span><br></pre></td></tr></table></figure>

<p>connection type：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">r      Open text file for reading.  The stream is positioned at the beginning of the file.</span><br><span class="line"></span><br><span class="line">r+     Open for reading and writing.  The stream is positioned at the beginning of the file.</span><br><span class="line"></span><br><span class="line">w      Truncate file to zero length or create text file for writing.  The stream is positioned</span><br><span class="line">at the beginning of the file.</span><br><span class="line"></span><br><span class="line">w+     Open for reading and writing.  The file is created if it does not exist,  otherwise  it</span><br><span class="line">is truncated.  The stream is positioned at the beginning of the file.</span><br><span class="line"></span><br><span class="line">a      Open for appending (writing at end of file).  The file is created if it does not exist.</span><br><span class="line">The stream is positioned at the end of the file.</span><br><span class="line"></span><br><span class="line">a+     Open for reading and appending (writing at end of file).  The file  is  created  if  it</span><br><span class="line">does not exist.  The initial file position for reading is at the beginning of the file,</span><br><span class="line">but output is always appended to the end of the file.</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>popen看上去跟fopen很类似（使用相同的语法格式，并具有相同的返回值类型），popen打开一个指向进程的带缓冲的连接</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">File * fp;				<span class="comment">//same type of struct</span></span><br><span class="line">fp = popen(<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;r&quot;</span>);	<span class="comment">//args are connection name, connection type</span></span><br><span class="line">fgets(buf, len, fp);	<span class="comment">//exactly the same functions</span></span><br><span class="line">pclose(fp);				<span class="comment">//close when done</span></span><br></pre></td></tr></table></figure>

<img src="https://pic.imgdb.cn/item/6324bc7a16f2c2beb11025e2.jpg" style="zoom:80%;" />

<p>下面的程序将who|sort作为数据源，通过popen来获得当前用户排序列表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        FILE* fp;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        fp = popen(<span class="string">&quot;who|sort&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fgets(buf,<span class="number">100</span>,fp)!=<span class="literal">NULL</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%3d %s&quot;</span>,i++,buf);</span><br><span class="line"></span><br><span class="line">        pclose(fp);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的程序将popen和邮件程序相连接，用来提示用户一些系统故障</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  FILE *fp = popen(<span class="string">&quot;mail admin backup&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(fp, <span class="string">&quot;Error with backup!\n&quot;</span>);</span><br><span class="line">  pclose(fp);</span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意pclose命令是必须的。</p>
<p>当完成对popen所打开连接的读写后，必须使用pclose关闭连接，而不能用fclose。</p>
<p>进程在产生之后必须等待退出运行，否则它将成为僵尸进程。而pclose中调用了wait函数来等待进程的结束。</p>
<p><strong>实现popen：使用fdopen命令</strong></p>
<p>popen运行了一个程序并返回指向改程序标准输入或标准输出的连接</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READ 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WRITE 1</span></span><br><span class="line"></span><br><span class="line">FILE *<span class="title function_">popen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *command, <span class="type">const</span> <span class="type">char</span> *mode)</span> &#123;</span><br><span class="line">    <span class="type">int</span> p[<span class="number">2</span>],pid;</span><br><span class="line">    <span class="type">int</span> parent_end, child_end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*mode == <span class="string">&#x27;r&#x27;</span>) &#123;</span><br><span class="line">        parent_end = READ;</span><br><span class="line">        child_end = WRITE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*mode == <span class="string">&#x27;w&#x27;</span>) &#123;</span><br><span class="line">        parent_end = WRITE;</span><br><span class="line">        child_end = READ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pipe(p)==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span>((pid = fork())==<span class="number">-1</span>)&#123;</span><br><span class="line">        close(p[<span class="number">0</span>]);</span><br><span class="line">        close(p[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(close(p[child_end]) == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> fdopen(p[parent_end], mode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(p[parent_end]);</span><br><span class="line">    dup2(p[child_end], child_end);</span><br><span class="line">    close(p[child_end]);</span><br><span class="line"></span><br><span class="line">    execl(<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, command, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改版本的popen对信号不做任何处理，这是有问题的</p>
<p><strong>访问数据：文件、应用程序接口（API）和服务器</strong></p>
<p>以获取登录系统的用户列表为例：</p>
<ul>
<li><p>方法1：fopen从文件获得数据</p>
<p>之前的章节所写的who程序就是从utmp文件中读取数据的。基于文件的信息服务并不是很完美。客户端程序依赖于特定的文件格式和结构体中的特定成员名称。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Backwards compatibility hacks*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ut_name ut_user</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>方法2：从函数获取数据</p>
<p>可以通过调用函数来得到数据。一个库函数用标准的函数接口来封装数据的格式和位置。Unix提供了读取utmp文件的函数接口。getutent的版主信息描述了读取utmp数据库函数的细节。</p>
<p>这样，就算底层的存储结构变化了，使用这个借口的程序仍能正常工作</p>
</li>
<li><p>方法3：从进程获取数据</p>
<p>bc&#x2F;dc和popen例子显示了如何创建一个进程到另外一个进程的连接。一个要得到用户列表的程序可以使用popen来建立与who程序的连接。由who命令来负责使用正确的文件名和文件格式以及正确的库函数。</p>
<p>以独立的程序获得数据有以下好处：</p>
<ul>
<li>服务器程序可以使用任何程序设计语言编写：shell、C、Java、Perl</li>
<li>最大好处是客户端程序和服务端程序可以运行在不同的机器上</li>
</ul>
</li>
</ul>
<h2 id="Socket：与远端进程相连"><a href="#Socket：与远端进程相连" class="headerlink" title="Socket：与远端进程相连"></a>Socket：与远端进程相连</h2><p>管道使得进程向其他进程发送数据就像向文件发送数据一样容易，但是管道具有两个重大缺陷：</p>
<ul>
<li>管道在一个进程中被创建，通过fork来实现共享。因此管道只能连接相关的进程，也只能连接同一台主机上的进程</li>
</ul>
<p>Unix提供了另外一种进程间的通信机制——socket</p>
<p>socket允许在不想管的进程间创建类似管道的连接，甚至可以通过socket连接其他主机上的进程。</p>
<img src="https://pic.imgdb.cn/item/6324ca3616f2c2beb12411a4.jpg" style="zoom:80%;" />

<p>重要概念：</p>
<ol>
<li>客户端和服务器：<ul>
<li>服务器是提供服务的程序。在Unix中，服务器是一个程序不是一台计算机。服务器进程等待请求，处理请求，然后循环回去等待下一个请求</li>
<li>客户端进程则不需要循环，它只需建立一个连接，与服务器交换数据，然后继续自己的工作。</li>
</ul>
</li>
<li>主机名和端口<ul>
<li>运行于因特网上的服务器其实是某台计算机上运行的一个进程。这里计算机被称为主机</li>
<li>机器通常被指定一个名字如sales.xyzcorp.com，这被称为该主机的名字。</li>
<li>服务器在该主机上拥有一个端口。主机和端口的组合才标识了一个服务器</li>
</ul>
</li>
<li>地址族（AF，address family）</li>
<li>协议：协议是服务器和客户端之间交互的规则</li>
</ol>
<p><strong>编写自己的时间服务器</strong></p>
<p>设计6个步骤：</p>
<ul>
<li>socket</li>
<li>bind</li>
<li>listen</li>
<li>accept</li>
<li>read&#x2F;write</li>
<li>close</li>
</ul>
<p>socket()相关：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br><span class="line"><span class="comment">//domain:通信域，其中PF_INET用于Internet socket</span></span><br><span class="line"><span class="comment">//type:socket的类型。SOCK_STREAM和管道类似</span></span><br><span class="line"><span class="comment">//protocol:socket中所用的协议，默认为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遇到错误，返回-1，成功，返回sockid</span></span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       <span class="title function_">socket</span><span class="params">()</span> creates an endpoint <span class="keyword">for</span> communication and returns a descriptor.</span><br><span class="line"></span><br><span class="line">       The  domain  argument specifies a communication domain; this selects the protocol family which</span><br><span class="line">       will be used <span class="keyword">for</span> communication.  These families are defined in &lt;sys/socket.h&gt;.  The  currently</span><br><span class="line">       understood formats include:</span><br><span class="line"></span><br><span class="line">       Name                Purpose                          Man page</span><br><span class="line">       AF_UNIX, AF_LOCAL   Local communication              <span class="title function_">unix</span><span class="params">(<span class="number">7</span>)</span></span><br><span class="line">       AF_INET             IPv4 Internet protocols          <span class="title function_">ip</span><span class="params">(<span class="number">7</span>)</span></span><br><span class="line">       AF_INET6            IPv6 Internet protocols          <span class="title function_">ipv6</span><span class="params">(<span class="number">7</span>)</span></span><br><span class="line">       AF_IPX              IPX - Novell protocols</span><br><span class="line">       AF_NETLINK          Kernel user interface device     <span class="title function_">netlink</span><span class="params">(<span class="number">7</span>)</span></span><br><span class="line">       AF_X25              ITU-T X.25 / ISO-8208 protocol   <span class="title function_">x25</span><span class="params">(<span class="number">7</span>)</span></span><br><span class="line">       AF_AX25             Amateur radio AX.25 protocol</span><br><span class="line">       AF_ATMPVC           Access to raw ATM PVCs</span><br><span class="line">       AF_APPLETALK        Appletalk                        <span class="title function_">ddp</span><span class="params">(<span class="number">7</span>)</span></span><br><span class="line">       AF_PACKET           Low level packet interface       <span class="title function_">packet</span><span class="params">(<span class="number">7</span>)</span></span><br></pre></td></tr></table></figure>



<p>程序如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORTNUM 13000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOSTLEN 256</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> oops(msg) &#123;perror(msg);exit(1);&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> ac, <span class="type">char</span> * av[])</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span>       <span class="comment">//build our address here</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">hp</span>;</span>             <span class="comment">//this is part of our</span></span><br><span class="line">    <span class="type">char</span> hostname[HOSTLEN];         <span class="comment">//address</span></span><br><span class="line">    <span class="type">int</span> sock_id,sock_fd;            <span class="comment">//line id, file desc</span></span><br><span class="line">    FILE *sock_fp;                  <span class="comment">//use socket as stream</span></span><br><span class="line">    <span class="type">char</span> *<span class="title function_">ctime</span><span class="params">()</span>;                  <span class="comment">//convert secs to string</span></span><br><span class="line">    <span class="type">time_t</span> thetime;                 <span class="comment">//the time we report</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//step1: ask kernel for a socket</span></span><br><span class="line">    sock_id = socket(PF_INET, SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sock_id == <span class="number">-1</span>)</span><br><span class="line">        oops(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//step2:bind address to socket. Address is host,port</span></span><br><span class="line">    bzero((<span class="type">void</span> *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));           <span class="comment">//clear out struct</span></span><br><span class="line"></span><br><span class="line">    gethostname(hostname,HOSTLEN);                  <span class="comment">//where am I?</span></span><br><span class="line">    <span class="comment">//printf(&quot;hostname: %s&quot;,hostname);</span></span><br><span class="line">    hp = gethostbyname(hostname);                   <span class="comment">//get info about host</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//fill in host part</span></span><br><span class="line">    bcopy((<span class="type">void</span>*)hp-&gt;h_addr,(<span class="type">void</span>*)&amp;saddr.sin_addr,hp-&gt;h_length);</span><br><span class="line">    saddr.sin_port = htons(PORTNUM);                <span class="comment">//fill in socket port</span></span><br><span class="line">    saddr.sin_family = AF_INET;                     <span class="comment">//fill in addr family</span></span><br><span class="line">    oops(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//step3:allow incoming calls with Qsize = 1 on socket</span></span><br><span class="line">    <span class="keyword">if</span>(listen(sock_id,<span class="number">1</span>)!=<span class="number">0</span>)</span><br><span class="line">        oops(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//main loop: accept(),write(),close()</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        sock_fd = accept(sock_id,<span class="literal">NULL</span>,<span class="literal">NULL</span>);    <span class="comment">//wait for call</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Got a call!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(sock_fd == <span class="number">-1</span>)</span><br><span class="line">            oops(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line"></span><br><span class="line">        sock_fp = fdopen(sock_fd,<span class="string">&quot;w&quot;</span>);          <span class="comment">//will write to the socket as a stream</span></span><br><span class="line">        <span class="keyword">if</span>(sock_fp == <span class="literal">NULL</span>)</span><br><span class="line">            oops(<span class="string">&quot;fdopen&quot;</span>);</span><br><span class="line"></span><br><span class="line">        thetime = time(<span class="literal">NULL</span>);                   <span class="comment">//get times and convert to string</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">fprintf</span>(sock_fp,<span class="string">&quot;The time here is ..&quot;</span>);</span><br><span class="line">        <span class="built_in">fprintf</span>(sock_fp,<span class="string">&quot;%s&quot;</span>,ctime(&amp;thetime));</span><br><span class="line">        fclose(sock_fp);                        <span class="comment">//release connection</span></span><br><span class="line">    &#125;</span><br><span class="line">    close(sock_id);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>流程：</p>
<p>步骤1：向内核申请一个socket</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br><span class="line"><span class="comment">//domain:通信域，其中PF_INET用于Internet socket</span></span><br><span class="line"><span class="comment">//type:socket的类型。SOCK_STREAM和管道类似</span></span><br><span class="line"><span class="comment">//protocol:socket中所用的协议，默认为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遇到错误，返回-1，成功，返回sockid</span></span><br></pre></td></tr></table></figure>

<ul>
<li>socket调用创建一个通信端点并返回一个标识符。有很多种类型的通信系统，每个被称为一个通信域。Internet本身就是一个域。在后面会看到Unix内核是另一个域。Linux支持好几个其他域的通信</li>
<li>socket的类型指出了程序将要使用的数据流类型。SOCK_STREAM类型和双向管道类似。数据作为连续的字节流从一端写入，再从另一端读出。</li>
<li>protocol值得是内核中网络代码所使用的的协议，并不是客户端和服务器之间的协议。一个为0的值代表选择标准的协议</li>
</ul>
<p>步骤2：bind绑定地址到socket上，地址包括主机，端口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr,</span></span><br><span class="line"><span class="params">         <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line"><span class="comment">//sockfd为socket的id</span></span><br><span class="line"><span class="comment">//addr为指向包含地址结构的指针</span></span><br><span class="line"><span class="comment">//addrlen为地址的长度</span></span><br><span class="line"><span class="comment">//成功返回0，失败返回-1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注意需要使用没被占用的端口（低端口号可能已经被系统服务所占用，不能被普通用户所使用）</li>
<li>每个地址族都有自己的格式，因特网地址族（AF_INET）使用主机和端口来标志。地址就是一个以主机和端口为成员的结构体。</li>
<li>自己写的程序应首先初始化该结构的成员，然后再填充具体的主机地址和端口号，最后填充地址族。</li>
<li>当所有的部分被填充了之后，地址已经被绑定到该socket上。其他类型的socket会使用包含不同成员的地址</li>
</ul>
<p>步骤3：在socket上，允许接入呼叫并设置队列长度为1。listen</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br><span class="line"><span class="comment">//backlog:允许接入连接的数目</span></span><br><span class="line"><span class="comment">//成功，返回0，错误，返回-1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>listen请求内核允许指定的socket接收接入呼叫。</li>
<li>注意不是所有类型的socket都能接收接入呼叫。但SOCK_STREAM类型是可以的</li>
<li>第二个参数指出接收队列的长度，在这里使用长度为1的队列。队列最大长度取决于具体socket的实现</li>
</ul>
<p>步骤4：等待&#x2F;接收呼叫 accept</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br><span class="line"><span class="comment">//addr:指向呼叫者地址结构的指针</span></span><br><span class="line"><span class="comment">//addelenp:指向呼叫者地址结构长度的指针</span></span><br><span class="line"><span class="comment">//遇到错误，返回-1，正确，返回fd(用于读写的文件描述符)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>一旦socket被建立并被分配一个地址，而且准备等待接收呼叫，程序即将开始工作。服务器等待直到呼叫到来。</li>
<li>accept阻塞当前进程，一直到指定socket上的接入连接被建立起来，然后accept将返回文件描述符，并用该文件描述符来进行读写操作。此文件描述符实际上是连到呼叫进程的某个文件描述符的一个连接</li>
<li>accept支持一种类型的呼叫者的ID。在呼叫发起者一边，socket有自己的地址，例如对应因特网连接，地址就是主机地址和端口号。如果addr和addrlen指针不为空的话，内核将把呼叫者地址填充到addr所指向的结构中，并把该结构的长度填充到addrlen所指向的内存单元中。</li>
<li>一个网络程序可以使用呼叫进程的地址来决定如何处理该连接</li>
</ul>
<p>步骤5：传输数据</p>
<ul>
<li>accept调用所返回的文件描述符是一个普通文件的描述符。</li>
<li>可以使用相关的操作进行读写。我们的程序用fdopen将文件描述符定向到缓存的数据流，以便于使用fprintf调用来进行输出。</li>
</ul>
<p>步骤6：关闭连接</p>
<ul>
<li>accept所返回的文件描述符可以由标准的系统调用close关闭。当一段的进程关闭了该端的socket，若另一端的进程在试图读数据的话，它将得到文件结束标记。这跟管道的工作原理类似</li>
</ul>
<p><strong>测试timeserv.c</strong></p>
<p>编译并运行：（启动读物以&amp;号结尾</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[zhangqi@localhost chap11]$ ./timeserv&amp;</span><br><span class="line">[1] 91871</span><br><span class="line">[zhangqi@localhost chap11]$ telnet <span class="string">&#x27;127.0.0.1&#x27;</span> 13000</span><br><span class="line">Trying 127.0.0.1...</span><br><span class="line">Got a call!</span><br><span class="line">Connected to 127.0.0.1.</span><br><span class="line">Escape character is <span class="string">&#x27;^]&#x27;</span>.</span><br><span class="line">The time here is ..Sat Sep 17 04:35:06 2022</span><br><span class="line">Connection closed by foreign host.</span><br></pre></td></tr></table></figure>

<p>可见服务器响应了连接</p>
<p>服务器将持续运行，直到使用kill命令来结束其运行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zhangqi@localhost chap11]$ <span class="built_in">kill</span> 91871</span><br><span class="line">[1]+  Terminated              ./timeserv</span><br></pre></td></tr></table></figure>



<p><strong>编写timeclient.c：时间服务客户端</strong></p>
<p>时间服务客户端的实现包含4个步骤：</p>
<ul>
<li>socket</li>
<li>connect</li>
<li>read&#x2F;write</li>
<li>close</li>
</ul>
<p>程序代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> oops(msg) &#123;perror(msg);exit(1);&#125;</span></span><br><span class="line"></span><br><span class="line">main(<span class="type">int</span> ac,<span class="type">char</span> *av[])&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servadd</span>;</span>     <span class="comment">//the number to call</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">hp</span>;</span>             <span class="comment">//used to get number</span></span><br><span class="line">    <span class="type">int</span> sock_id,sock_fd;            <span class="comment">//the socket and fd</span></span><br><span class="line">    <span class="type">char</span> message[BUFSIZ];           <span class="comment">//to receive message</span></span><br><span class="line">    <span class="type">int</span> messlen;                    <span class="comment">//for message length</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//step1: Get a socket</span></span><br><span class="line">    sock_id = socket(AF_INET, SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sock_id == <span class="number">-1</span>)</span><br><span class="line">        oops(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//step2:connect to server</span></span><br><span class="line">    bzero(&amp;servadd, <span class="keyword">sizeof</span>(servadd));       <span class="comment">//zero the address</span></span><br><span class="line">    hp = gethostbyname(av[<span class="number">1</span>]);              <span class="comment">//lookup hosts ip</span></span><br><span class="line">    <span class="keyword">if</span>(hp==<span class="literal">NULL</span>)</span><br><span class="line">        oops(av[<span class="number">1</span>]);</span><br><span class="line">    bcopy(hp-&gt;h_addr,(<span class="keyword">struct</span> sockaddr*)&amp;servadd.sin_addr,hp-&gt;h_length);</span><br><span class="line">    servadd.sin_port = htons(atoi(av[<span class="number">2</span>]));</span><br><span class="line">    servadd.sin_family = AF_INET;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(connect(sock_id,(<span class="keyword">struct</span> sockaddr*)&amp;servadd,<span class="keyword">sizeof</span>(servadd))!=<span class="number">0</span>)</span><br><span class="line">        oops(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//step3: transfet data from server, then hangup</span></span><br><span class="line">    messlen = read(sock_id,message,BUFSIZ);</span><br><span class="line">    <span class="keyword">if</span>(messlen == <span class="number">-1</span>)</span><br><span class="line">        oops(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(write(<span class="number">1</span>,message,messlen)!=messlen)</span><br><span class="line">        oops(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">    close(sock_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序流程：</p>
<p>步骤1：向内核请求建立socket</p>
<ul>
<li>客户端需要一个socket跟网络相连。客户端必须建立Internet域（AF_INET）socket，并且它还必须是SOCK_STREAM</li>
</ul>
<p>步骤2：与服务器相连</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr,</span></span><br><span class="line"><span class="params">            <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line"><span class="comment">//sockfd 用于建立链接的socket</span></span><br><span class="line"><span class="comment">//addr 指向服务器地址结构的指针</span></span><br><span class="line"><span class="comment">//addrlen 结构的长度</span></span><br></pre></td></tr></table></figure>

<ul>
<li>客户端需要连接到时间服务器</li>
<li>connect调用试图把由sockfd所标识的socket和由addr所指向的socket地址相连接。如果连接成功，connect返回0。</li>
<li>此时，sockfd是一个合法的文件描述符，可以用来进行读写操作。</li>
<li>写入该文件描述符的数据被发送到连接的另一端的socket，而从另一端写入的数据将从该文件描述符读取</li>
</ul>
<p>步骤3和4：传送数据和挂断</p>
<ul>
<li>成功连接之后，进程可以从该文件描述符读写数据，就像与普通的文件或管道相连接一样。在我们的程序中。timeclient只是从服务器读取一行数据</li>
<li>读取时间之后，客户端关闭文件描述符然后退出。若客户端退出而不关闭描述符，内核将完成关闭文件描述符的任务</li>
</ul>
<p><strong>测试timeclient.c</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[zhangqi@localhost chap11]$ ./timeserv&amp;</span><br><span class="line">[1] 123362</span><br><span class="line">[zhangqi@localhost chap11]$ ./timeclient localhost 13000</span><br><span class="line">Got a call!</span><br><span class="line">The time here is ..Sat Sep 17 12:30:22 2022</span><br></pre></td></tr></table></figure>

<p><strong>另一种服务器：远程的ls</strong></p>
<p>rls（remote ls）可以远程查看另一台机器上的文件列表</p>
<img src="https://pic.imgdb.cn/item/63254f5916f2c2beb1b96939.jpg" style="zoom:80%;" />

<p>需要3个要素来实现rls系统：</p>
<ul>
<li>协议</li>
<li>客户端程序</li>
<li>服务端程序</li>
</ul>
<p>协议包含有请求和应答。首先，客户端发送一行包含有目录名称的请求。服务器读取该目录名后打开并读取该目录，然后把文件列表发送到客户端。客户端循环地读取文件列表，直到服务器挂断连接产生文件结尾标志</p>
<p>客户端程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> oops(msg) &#123;perror(msg);exit(1);&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORTNUM 15000</span></span><br><span class="line"></span><br><span class="line">main(<span class="type">int</span> ac,<span class="type">char</span> *av[])&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servadd</span>;</span>     <span class="comment">//the number to call</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">hp</span>;</span>             <span class="comment">//used to get number</span></span><br><span class="line">        <span class="type">int</span> sock_id, sock_fd;           <span class="comment">//the socket and fd</span></span><br><span class="line">        <span class="type">char</span> buffer[BUFSIZ];            <span class="comment">//to receive message</span></span><br><span class="line">        <span class="type">int</span> n_read;                     <span class="comment">//message length</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ac!=<span class="number">3</span>) <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//step1: get a socket</span></span><br><span class="line">        sock_id = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//printf(&quot;sock_id:%d\n &quot;,sock_id);</span></span><br><span class="line">        <span class="keyword">if</span>(sock_id == <span class="number">-1</span>)</span><br><span class="line">                oops(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//step2:connect to server</span></span><br><span class="line">        bzero(&amp;servadd, <span class="keyword">sizeof</span>(servadd));</span><br><span class="line">        hp = gethostbyname(av[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(hp == <span class="literal">NULL</span>)</span><br><span class="line">                oops(av[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        bcopy(hp-&gt;h_addr,(<span class="keyword">struct</span> sockaddr *)&amp;servadd.sin_addr,hp-&gt;h_length);</span><br><span class="line">        servadd.sin_port = htons(PORTNUM);</span><br><span class="line">        servadd.sin_family = AF_INET;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(connect(sock_id,(<span class="keyword">struct</span> sockaddr *)&amp;servadd,<span class="keyword">sizeof</span>(servadd))!=<span class="number">0</span>)</span><br><span class="line">                oops(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//step3: send directory name, then read back results</span></span><br><span class="line">        <span class="keyword">if</span>(write(sock_id, av[<span class="number">2</span>],<span class="built_in">strlen</span>(av[<span class="number">2</span>]))==<span class="number">-1</span>)</span><br><span class="line">                oops(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(write(sock_id,<span class="string">&quot;\n&quot;</span>,<span class="number">1</span>)==<span class="number">-1</span>)</span><br><span class="line">                oops(<span class="string">&quot;write&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>((n_read = read(sock_id,buffer,BUFSIZ))&gt;<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span>(write(<span class="number">1</span>,buffer,n_read)==<span class="number">-1</span>)</span><br><span class="line">                        oops(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">        close(sock_id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意该客户端与时间服务客户端的不同之处：</p>
<ul>
<li>rls客户端首先把目录名写到socket中。上面的协议规定了客户端每次发送一行，因此程序中在行尾增加一个换行符。接下来，客户端进入一个循环，将从socket所接收的数据复制到标准输出，直到接收到文件结尾标志。</li>
<li>rls.c使用低级别的write和read调用来和服务器交换数据。循环中用到标准大小的缓存以提高效率</li>
</ul>
<p>服务器程序rlsd</p>
<p>服务器必须得到一个socket，然后调用bind、listen命令，最后调用acceptt来接受一次呼叫。在接收呼叫之后，服务器从socket读取目录名，然后列出该目录下的内容。然后我们可以使用popen读取常规版本的ls程序的输出</p>
<img src="https://pic.imgdb.cn/item/632558fb16f2c2beb1c5300b.jpg" style="zoom:80%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORTNUM 15000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">sanitize</span><span class="params">(<span class="type">char</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sock_id = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> hostname[BUFSIZ];</span><br><span class="line">    gethostname(hostname, BUFSIZ);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">hp</span> =</span> gethostbyname(hostname);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">void</span> *)&amp;saddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="type">void</span> *)&amp;saddr.sin_addr, (<span class="type">const</span> <span class="type">void</span> *)hp-&gt;h_addr_list[<span class="number">0</span>], <span class="keyword">sizeof</span>(hp-&gt;h_length));</span><br><span class="line">    saddr.sin_port = PORTNUM;</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line"></span><br><span class="line">    bind(sock_id, (<span class="keyword">struct</span> sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line">    listen(sock_id, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sock_fd;</span><br><span class="line">    FILE *sock_fpi, *sock_fpo, *pipe_fp;</span><br><span class="line">    <span class="type">char</span> dirname[BUFSIZ];</span><br><span class="line">    <span class="type">char</span> command[BUFSIZ];</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        sock_fd = accept(sock_id, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        sock_fpi = fdopen(sock_fd, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">        fgets(dirname, BUFSIZ, sock_fpi);</span><br><span class="line">        sanitize(dirname);</span><br><span class="line">        sock_fpo = fdopen(sock_fd, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">        <span class="built_in">sprintf</span>(command, <span class="string">&quot;ls %s&quot;</span>, dirname);</span><br><span class="line">        pipe_fp = popen(command, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> ((c = getc(pipe_fp)) != EOF)</span><br><span class="line">            putc(c, sock_fpo);</span><br><span class="line">        pclose(pipe_fp);</span><br><span class="line">        fclose(sock_fpi);</span><br><span class="line">        fclose(sock_fpo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sock_id);</span><br><span class="line">    close(sock_fd);</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">sanitize</span><span class="params">(<span class="type">char</span> *str)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *src, *dest;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (src = dest = str; *src; src++)</span><br><span class="line">        <span class="keyword">if</span> (*src == <span class="string">&#x27;/&#x27;</span> || <span class="built_in">isalnum</span>(*src))</span><br><span class="line">            *dest++ = *src;</span><br><span class="line"></span><br><span class="line">    *dest = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意服务器程序使用标准缓存流来读写数据。服务器用fgets调用从客户端读取目录名。</p>
<p>在调用popen后，服务器就像复制文件一样地使用getc和putc来传输数据。当然，服务器实际上是从本机上的进程向另一台机器上的进程复制数据</p>
<p>注意sanitize函数的使用，对于任何运行参数中所含的命令或从因特网上获取数据的服务器，在编写的时候都要格外小心。程序中的服务器等待接收来自客户端的目录名，然后把它追加到ls命令的尾部。</p>
<p>例如，如果客户端发送字符串 <code>/bin</code>，服务器将创建并运行 <code>ls /bin</code>这是正确的，但是如果有人发送字符串 <code>; rm *</code>给服务器，服务器将创建并运行 <code>ls ; rm *</code>命令，这会造成被破坏的风险。</p>
<h2 id="连接和协议：编写Web服务器"><a href="#连接和协议：编写Web服务器" class="headerlink" title="连接和协议：编写Web服务器"></a>连接和协议：编写Web服务器</h2><img src="https://pic.imgdb.cn/item/6325638b16f2c2beb1d1314f.jpg" style="zoom:80%;" />

<p>客户端与服务器的交互主要包含：</p>
<ul>
<li>服务器设立服务</li>
<li>客户连接到服务器</li>
<li>服务器和客户处理事务</li>
</ul>
<p><strong>操作1：建立服务器端socket</strong></p>
<p>设立一个服务一般需要以下三步：</p>
<ul>
<li><p>创建一个socket</p>
<p><code>socket = socket(PF_INET, SOCK_STREAM, 0);</code></p>
</li>
<li><p>给socket绑定一个地址</p>
<p><code>bind(sock,&amp;addr,sizeof(addr));</code></p>
</li>
<li><p>监听接入请求</p>
<p><code>listen(sock,queue_size);</code></p>
</li>
</ul>
<p>为了避免在编写服务器时重复输入上述代码，可以将三个步骤组合成一个函数：make_server_socket。在编写服务器的时候，只要调用该函数就可以创建一个服务器端的socket</p>
<p><strong>操作2：建立到服务器的连接</strong></p>
<p>基于流的网络客户连接到服务器包含以下两个步骤：</p>
<ul>
<li><p>创建一个socket</p>
</li>
<li><p>使用该socket连接到服务器</p>
<p><code>connect(sock,&amp;serv_addr,sizeof(serv_addr))</code></p>
</li>
</ul>
<p>这两个步骤可以抽象成一个函数：connect_to_server。在编写客户端程序时，只要调用该函数就可以建立到服务器的连接</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//socklib.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOSTLEN 256</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BACKLOG 1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">make_server_socket_q</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">make_server_socket</span><span class="params">(<span class="type">int</span> portnum)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> make_server_socket_q(portnum,BACKLOG);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> make <span class="title function_">server_socket_q</span><span class="params">(<span class="type">int</span> portnum, <span class="type">int</span> backlog)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">hp</span>;</span></span><br><span class="line">    <span class="type">char</span> hostname[HOSTLEN];</span><br><span class="line">    <span class="type">int</span> sock_id;</span><br><span class="line"></span><br><span class="line">    sock_id = socket(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sock_id == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    bzero((<span class="type">void</span>*)&amp;saddr,<span class="keyword">sizeof</span>(saddr));</span><br><span class="line">    gethostname(hostname,HOSTLEN);</span><br><span class="line">    hp = gethostbyname(hostname);</span><br><span class="line"></span><br><span class="line">    bcopy((<span class="type">void</span> *)hp-&gt;h_addr,(<span class="type">void</span>*)&amp;saddr.sin_addr,hp-&gt;h_length);</span><br><span class="line">    saddr.sin_port = htons(portnum);</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    <span class="keyword">if</span>(bind(sock_id,(<span class="keyword">struct</span> sockaddr*)&amp;saddr,<span class="keyword">sizeof</span>(saddr))!=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(listen(sock_id,backlog) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sock_id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect_to_server</span><span class="params">(<span class="type">char</span>* host, <span class="type">int</span> portnum)</span>&#123;</span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servadd</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">hp</span>;</span></span><br><span class="line"></span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sock == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    bzero((<span class="type">void</span>*)&amp;servadd,<span class="keyword">sizeof</span>(servadd));</span><br><span class="line">    hp = gethostbyname(host);</span><br><span class="line">    <span class="keyword">if</span>(hp == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    bcopy(hp-&gt;h_addr,(<span class="keyword">struct</span> sockaddr *)&amp;servadd.sin_addr, hp-&gt;h_length);</span><br><span class="line">    servadd.sin_port = htons(portnum);</span><br><span class="line">    servadd.sin_family = AF_INET;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(connect(sock,(<span class="keyword">struct</span> sockaddr *)&amp;servadd,<span class="keyword">sizeof</span>(servadd))!=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>操作3：客户&#x2F;服务器的会话</strong></p>
<p>一个典型的客户程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    fd = connect_to_server(host,port);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    talk_with_server(fd);<span class="comment">//根据不同的应用处理与服务器的会话</span></span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>典型的服务器端：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">    <span class="type">int</span> sock,fd;</span><br><span class="line">    sock = make_server_socket(port);</span><br><span class="line">    <span class="keyword">if</span>(sock == <span class="number">-1</span>) <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        fd = accept(sock,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(fd == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        process_request(fd);<span class="comment">//处理客户的请求</span></span><br><span class="line">        close(fd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用socklib.c的timeserv和timeclient</strong></p>
<p>只要编写处理回话的talk_with_server用于客户端，process_request用于服务器端就行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">talk_with_server(fd)&#123;</span><br><span class="line">    <span class="type">char</span> buf[LEN];</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    </span><br><span class="line">    n = read(fd,buf,LEN);</span><br><span class="line">    write(<span class="number">1</span>,buf,n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">process_request(fd)&#123;</span><br><span class="line">    <span class="type">time_t</span> now;</span><br><span class="line">    <span class="type">char</span> *cp;</span><br><span class="line">    time(&amp;now);</span><br><span class="line">    cp = ctime(&amp;now);</span><br><span class="line">    write(fd,cp,<span class="built_in">strlen</span>(cp));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二版的服务器：使用fork</strong></p>
<p>不通过调用time函数来获得时间，而是直接使用一个shell命令（date）</p>
<p>服务器用fork建立一个新的子进程，该子进程将标准输出重定向到socket，然后运行date。date命令给出日期，然后将日期写到标准输出，这样就把字符串发送到客户端了。</p>
<img src="https://pic.imgdb.cn/item/6325995f16f2c2beb119b64c.jpg" style="zoom:80%;" />

<p>代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">process_request(fd)&#123;</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">switch</span>(pid)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">-1</span>:<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:dup2(fd,<span class="number">1</span>);</span><br><span class="line">            close(fd);</span><br><span class="line">            execl(<span class="string">&quot;/bin/date&quot;</span>,<span class="string">&quot;date&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line">            oops(<span class="string">&quot;execlp&quot;</span>);</span><br><span class="line">        <span class="keyword">default</span>:wait(<span class="literal">NULL</span>);	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>服务器的设计问题：DIY或代理</strong></p>
<p>两种设计方法：</p>
<ul>
<li>自己做（Do It Yourself，DIY）——服务器接收请求，自己处理工作<ul>
<li>适用于快速简单的任务。</li>
<li>不需要额外的系统调用（fork()、exec() ……）和创建新的进程的开销。</li>
<li>对于一些服务器，效率最高的方法是服务器自己来完成工作并且在listen中限制连接队列的大小。</li>
</ul>
</li>
<li>代理——服务器接收请求，然后创建一个新进程来处理工作<ul>
<li>适用于慢速的更加复杂的任务。</li>
<li>可以使服务器同时处理多个任务</li>
</ul>
</li>
</ul>
<p>使用SIGCHLD来阻止僵尸进程问题</p>
<ul>
<li><p>除了等待子进程死亡外，父进程可以设置为接收表示子进程死亡的信号（为SIGCHLD设置一个信号处理函数，它可以调用wait）</p>
</li>
<li><p>具体方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SIGCHLD   20,17,18    Ign     Child stopped or terminated</span></span><br><span class="line">main()&#123;</span><br><span class="line">    <span class="type">int</span> sock,fd;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">child_waiter</span><span class="params">(<span class="type">int</span>)</span>, <span class="title function_">process_request</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line">    signal(SIGCHLD, child_waiter);</span><br><span class="line">    <span class="keyword">if</span>((sock = make_server_socket(PORTNUM)) == <span class="number">-1</span>)</span><br><span class="line">        oops(<span class="string">&quot;make_server_socket&quot;</span>);;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        fd = accept(sock,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(fd == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">    	process_request(fd);</span><br><span class="line">        close(fd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">child_waiter</span><span class="params">(<span class="type">int</span> signum)</span>&#123;</span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">process_request</span><span class="params">(<span class="type">int</span> fd)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">        dup2(fd,<span class="number">1</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        execlp(<span class="string">&quot;data&quot;</span>,<span class="string">&quot;date&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line">        oops(<span class="string">&quot;execlp date&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>该程序的流程控制：当收到一个请求，父进程使用fork，然后父进程立即返回去接收下一个请求，调到处理函数并调用wait。子进程从进程表中被删除，父进程从处理函数返回到主函数。</p>
</li>
<li><p>该过程存在两个问题：</p>
<ul>
<li><p>程序运行到信号处理函数跳转时会终端系统调用accept。accpet被信号中断时会返回-1，然后设置errno到EINTR。代码中把accept返回的-1作为错误，然后从主循环中跳出。因此需要更改main函数来区分真正的错误和被打断的系统调用产生的错误</p>
</li>
<li><p>Unix是如何处理多个信号的，多个子进程几乎同时退出，将会发生什么？假设同时有3个SIGCHLD大送到父进程，最先到达的信号导致父进程调到处理函数，此时其他两个信号的到达导致Unix阻塞，但是并不缓存信号。从而，第二个信号被阻塞，而第三个信号丢失了。此时如果还有其他的子进程退出，这些信号也将丢失。会产生很多僵尸进程。</p>
<p>解决方法是在处理函数中调用wait足够多的次数来去除所有的终止进程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//waitpid函数解决了这个问题</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">child_waiter</span><span class="params">(<span class="type">int</span> signum)</span>&#123;</span><br><span class="line">    <span class="comment">//该循环直到所有推出的子进程都被等待了才停止，即所有信号都会被处理</span></span><br><span class="line">    <span class="keyword">while</span>(waitpid(<span class="number">-1</span>,<span class="literal">NULL</span>,WHOHANG)&gt;<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="编写Web服务器"><a href="#编写Web服务器" class="headerlink" title="编写Web服务器"></a>编写Web服务器</h3><p>功能：</p>
<ul>
<li>列举目录信息</li>
<li>cat文件</li>
<li>运行程序</li>
</ul>
<img src="https://pic.imgdb.cn/item/6325a6d416f2c2beb12792b2.jpg" style="zoom:80%;" />

<p>Web服务器通过基于流的socket连接为客户提供上述三种操作。</p>
<p>如图所示，用户连接到服务器后，发送请求，然后服务器返回客户请求的信息</p>
<p><strong>设计Web服务器</strong></p>
<p>要编写的操作如下：</p>
<ol>
<li>建立服务器。使用（make_server_socket）</li>
<li>接收请求。使用accept来得到指向客户端的文件描述符，使用fdopen使得该文件描述符转换成缓冲流</li>
<li>读取请求</li>
<li>处理请求。</li>
<li>发送应答</li>
</ol>
<p><strong>Web服务器协议</strong></p>
<p>请求和应答的格式在超文本传输协议（HTTP）中有定义。</p>
<p>可以用telnet和Web服务器交互。Web服务器在端口80监听</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[zhangqi@localhost chap11]$ telnet</span><br><span class="line">telnet&gt; o example.com 80</span><br><span class="line">Trying 93.184.216.34...</span><br><span class="line">Connected to example.com.</span><br><span class="line">Escape character is <span class="string">&#x27;^]&#x27;</span>.</span><br><span class="line">HEAD /index.html HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Age: 555320</span><br><span class="line">Cache-Control: max-age=604800</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">Date: Sat, 17 Sep 2022 13:44:31 GMT</span><br><span class="line">Etag: <span class="string">&quot;3147526947+gzip&quot;</span></span><br><span class="line">Expires: Sat, 24 Sep 2022 13:44:31 GMT</span><br><span class="line">Last-Modified: Thu, 17 Oct 2019 07:18:26 GMT</span><br><span class="line">Server: ECS (sab/56BC)</span><br><span class="line">X-Cache: HIT</span><br><span class="line">Content-Length: 1256</span><br></pre></td></tr></table></figure>

<p>GET方式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">[zhangqi@localhost chap11]$ telnet</span><br><span class="line">telnet&gt; o example.com 80</span><br><span class="line">Trying 93.184.216.34...</span><br><span class="line">Connected to example.com.</span><br><span class="line">Escape character is <span class="string">&#x27;^]&#x27;</span>.</span><br><span class="line">GET /index.html HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Age: 555530</span><br><span class="line">Cache-Control: max-age=604800</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">Date: Sat, 17 Sep 2022 13:48:01 GMT</span><br><span class="line">Etag: <span class="string">&quot;3147526947+gzip&quot;</span></span><br><span class="line">Expires: Sat, 24 Sep 2022 13:48:01 GMT</span><br><span class="line">Last-Modified: Thu, 17 Oct 2019 07:18:26 GMT</span><br><span class="line">Server: ECS (sab/56BC)</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">X-Cache: HIT</span><br><span class="line">Content-Length: 1256</span><br><span class="line"></span><br><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;<span class="built_in">head</span>&gt;</span><br><span class="line">    &lt;title&gt;Example Domain&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">    &lt;meta charset=<span class="string">&quot;utf-8&quot;</span> /&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">&quot;Content-type&quot;</span> content=<span class="string">&quot;text/html; charset=utf-8&quot;</span> /&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span> /&gt;</span><br><span class="line">    &lt;style <span class="built_in">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><br><span class="line">    body &#123;</span><br><span class="line">        background-color: <span class="comment">#f0f0f2;</span></span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line">        font-family: -apple-system, system-ui, BlinkMacSystemFont, <span class="string">&quot;Segoe UI&quot;</span>, <span class="string">&quot;Open Sans&quot;</span>, <span class="string">&quot;Helvetica Neue&quot;</span>, Helvetica, Arial, sans-serif;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    div &#123;</span><br><span class="line">        width: 600px;</span><br><span class="line">        margin: 5em auto;</span><br><span class="line">        padding: 2em;</span><br><span class="line">        background-color: <span class="comment">#fdfdff;</span></span><br><span class="line">        border-radius: 0.5em;</span><br><span class="line">        box-shadow: 2px 3px 7px 2px rgba(0,0,0,0.02);</span><br><span class="line">    &#125;</span><br><span class="line">    a:<span class="built_in">link</span>, a:visited &#123;</span><br><span class="line">        color: <span class="comment">#38488f;</span></span><br><span class="line">        text-decoration: none;</span><br><span class="line">    &#125;</span><br><span class="line">    @media (max-width: 700px) &#123;</span><br><span class="line">        div &#123;</span><br><span class="line">            margin: 0 auto;</span><br><span class="line">            width: auto;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;/style&gt;    </span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;h1&gt;Example Domain&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;This domain is <span class="keyword">for</span> use <span class="keyword">in</span> illustrative examples <span class="keyword">in</span> documents. You may use this</span><br><span class="line">    domain <span class="keyword">in</span> literature without prior coordination or asking <span class="keyword">for</span> permission.&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;&lt;a href=<span class="string">&quot;https://www.iana.org/domains/example&quot;</span>&gt;More information...&lt;/a&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>HTTP请求：GET</p>
<p>telnet创建了一个socket并调用了connect来连接到Web服务器。服务器接收连接请求，并创建了一个基于socket的从客户端的键盘到Web服务进程的数据通道。</p>
<p>添加了Host的可选参数</p>
</li>
<li><p>HTTP应答：OK</p>
<ul>
<li><p>服务器读取请求，检查请求，然后返回一个请求。应答有两部分：头部和内容。头部以状态行起始：</p>
<p><code>HTTP/1.1 200 OK</code></p>
</li>
<li><p>状态行含有两个或更多个字符串。第一个串是协议的版本，第二个串是返回码，这里是200，其文本解释是OK。如果服务器中没有所请求的文件名，返回码将是404，解释是“未找到”</p>
</li>
<li><p>头部的其余部分是关于应答的附加信息，在该例子中，包含服务器名、应答时间、服务器所发送数据类型以及应答的连接类型。一个应答头部可以包含多行信息，以空行表示结束。</p>
</li>
<li><p>应答的其余部分是返回的具体内容，这里，服务器返回了文件&#x2F;index.html的内容</p>
</li>
</ul>
</li>
</ol>
<p><strong>编写Web服务器</strong></p>
<p>要求Web服务器只支持GET命令，只接收请求行，跳过其余参数，然后处理请求和发送应答。</p>
<p>主要循环：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    fd = accept(sock,<span class="literal">NULL</span>,<span class="literal">NULL</span>);	<span class="comment">//take a call</span></span><br><span class="line">    fpin = fdopen(fd, <span class="string">&quot;r&quot;</span>);			<span class="comment">//make it a FILE*</span></span><br><span class="line">    fgets(fpin, request, LEN);		<span class="comment">//read client request</span></span><br><span class="line">    read_until_crnl(fpin);			<span class="comment">//skip over arguments</span></span><br><span class="line">    process_rq(request,fd);			<span class="comment">//reply to client</span></span><br><span class="line">    fclose(fpin);					<span class="comment">//hang up connection</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简介起见，这里忽略了出错检查</p>
<ol>
<li><p>处理请求：包含识别命令和根据参数进行处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">process_rq(<span class="type">char</span> * rq, <span class="type">int</span> fd)&#123;</span><br><span class="line">    <span class="type">char</span> cmd[<span class="number">11</span>],arg[<span class="number">513</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(fork()!=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">sscanf</span>(rq,<span class="string">&quot;%10s %512s&quot;</span>,cmd, arg);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(cmd,<span class="string">&quot;GET&quot;</span>)!=<span class="number">0</span>)</span><br><span class="line">        connot_do(fd);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(not_exist(arg))</span><br><span class="line">        do_404(arg,fd);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(isadir(fd))</span><br><span class="line">        do_ls(arg,fd);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ends_in_cgi(arg))</span><br><span class="line">        do_exec(arg,fd);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        do_cat(arg,fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器为每个请求创建一个新的进程来处理。子进程将请求分割成命令和参数。如果命令不是GET，服务器应答HTTP返回码表示未实现的命令。如果命令是GET，服务器将期望得到目录名，一个以 <code>.cgi</code>结尾的可执行程序或文件名。如果没有该目录或指定文件名，则服务器报错。</p>
<p>如果存在目录或文件，服务器决定所要使用的操作：ls、exec或cat</p>
</li>
<li><p>目录列表函数</p>
<p>函数do_ls处理列出目录信息的请求：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">do_ls(<span class="type">char</span> * dir, <span class="type">int</span> fd)&#123;</span><br><span class="line">    FILE * fp;</span><br><span class="line">    </span><br><span class="line">    fp = fdopen(fd,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">    header(fp,<span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(fp,<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    fflush(fp);</span><br><span class="line">    </span><br><span class="line">    dup2(fd,<span class="number">1</span>);</span><br><span class="line">    dup2(fd,<span class="number">2</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">    execl(<span class="string">&quot;/bin/ls&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-l&quot;</span>,dir,<span class="literal">NULL</span>);</span><br><span class="line">    perror(dir);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他函数</p>
<p>其他函数包含在本章后面部分中。程序可以工作，但它并不完整，也不安全。需要做如下改进：</p>
<ul>
<li>僵尸进程的去除</li>
<li>缓存溢出保护</li>
<li>CGI（Common Gateway Interface，通用网关接口）程序需要设置一些环境变量</li>
<li>HTTP头部可以包含更多的信息</li>
</ul>
</li>
</ol>
<p><strong>webserv的源程序</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">make_server_socket</span><span class="params">(<span class="type">int</span> port)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">make_server_socket_q</span><span class="params">(<span class="type">int</span> port, <span class="type">int</span> backlog)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">process_rq</span><span class="params">(<span class="type">char</span> *request, <span class="type">int</span> sock_fd)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">header</span><span class="params">(FILE *sock_fp, <span class="type">char</span> *content_type)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">cannot_do</span><span class="params">(<span class="type">int</span> sock_fd)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">not_exist</span><span class="params">(<span class="type">char</span> *f)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">do_404</span><span class="params">(<span class="type">char</span> *item, <span class="type">int</span> sock_fd)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">is_dir</span><span class="params">(<span class="type">char</span> *dir)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">do_ls</span><span class="params">(<span class="type">char</span> *arg, <span class="type">int</span> sock_fd)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> *<span class="title function_">file_type</span><span class="params">(<span class="type">char</span> *f)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">ends_in_cgi</span><span class="params">(<span class="type">char</span> *arg)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">do_exec</span><span class="params">(<span class="type">char</span> *comm, <span class="type">int</span> sock_fd)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">do_cat</span><span class="params">(<span class="type">char</span> *f, <span class="type">int</span> sock_fd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123; </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: ./webserv portnum\n&quot;</span>);     </span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sock_id = make_server_socket(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sock_fd;</span><br><span class="line">    <span class="type">char</span> request[BUFSIZ];</span><br><span class="line">    FILE *sock_fp;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">// 循环中自然可以多次接收命令</span></span><br><span class="line">        sock_fd = accept(sock_id, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        sock_fp = fdopen(sock_fd, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">        fgets(request, BUFSIZ, sock_fp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;got a call: request = %s\n&quot;</span>, request);</span><br><span class="line">        <span class="comment">// sock_fp 和 sock_fd 的位置就是同一个，所以必须处理掉 sock_fp 的输出</span></span><br><span class="line">        <span class="type">char</span> buf[BUFSIZ];</span><br><span class="line">        <span class="keyword">while</span> (fgets(buf, BUFSIZ, sock_fp) != <span class="literal">NULL</span> &amp;&amp; <span class="built_in">strcmp</span>(buf, <span class="string">&quot;\r\n&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">            ;</span><br><span class="line"></span><br><span class="line">        process_rq(request, sock_fd);</span><br><span class="line">        fclose(sock_fp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//rq is HTTP command: GET /foo/bar.html HTTP/1.0</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">process_rq</span><span class="params">(<span class="type">char</span> *request, <span class="type">int</span> sock_fd)</span> &#123;</span><br><span class="line">    <span class="type">char</span> cmd[BUFSIZ], arg[BUFSIZ];</span><br><span class="line">    <span class="built_in">strcpy</span>(arg, <span class="string">&quot;./&quot;</span>);</span><br><span class="line">    <span class="built_in">sscanf</span>(request, <span class="string">&quot;%s %s&quot;</span>, cmd, arg + <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fork() != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(cmd, <span class="string">&quot;GET&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        cannot_do(sock_fd);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (not_exist(arg)) &#123;</span><br><span class="line">        do_404(arg, sock_fd);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_dir(arg)) &#123;</span><br><span class="line">        do_ls(arg, sock_fd);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ends_in_cgi(arg)) &#123;</span><br><span class="line">        do_exec(arg, sock_fd);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        do_cat(arg, sock_fd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">header</span><span class="params">(FILE *sock_fp, <span class="type">char</span> *content_type)</span> &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(sock_fp, <span class="string">&quot;HTTP/1.0 200 OK\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (content_type)</span><br><span class="line">        <span class="built_in">fprintf</span>(sock_fp, <span class="string">&quot;Content-type: %s\r\n&quot;</span>, content_type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">cannot_do</span><span class="params">(<span class="type">int</span> sock_fd)</span> &#123;</span><br><span class="line">    FILE *sock_fp = fdopen(sock_fd, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(sock_fp, <span class="string">&quot;HTTP/1.0 501 Not Implemented\r\n&quot;</span></span><br><span class="line">            <span class="string">&quot;Content-type: text/plain\r\n&quot;</span></span><br><span class="line">            <span class="string">&quot;\r\n&quot;</span></span><br><span class="line">            <span class="string">&quot;That command is not yet implementd\r\n&quot;</span>);</span><br><span class="line">    fclose(sock_fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">not_exist</span><span class="params">(<span class="type">char</span> *f)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">info</span>;</span></span><br><span class="line">    <span class="keyword">return</span> (stat(f, &amp;info) == <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">do_404</span><span class="params">(<span class="type">char</span> *item, <span class="type">int</span> sock_fd)</span> &#123;</span><br><span class="line">    FILE *sock_fp = fdopen(sock_fd, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(sock_fp, <span class="string">&quot;HTTP/1.0 404 Not Found\r\n&quot;</span></span><br><span class="line">            <span class="string">&quot;Content-type: text/plain\r\n&quot;</span></span><br><span class="line">            <span class="string">&quot;\r\n&quot;</span></span><br><span class="line">            <span class="string">&quot;The item you requested: %s\r\n&quot;</span></span><br><span class="line">            <span class="string">&quot;is not found\r\n&quot;</span>, item);</span><br><span class="line">    fclose(sock_fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">is_dir</span><span class="params">(<span class="type">char</span> *dir)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">info</span>;</span></span><br><span class="line">    <span class="keyword">return</span> (stat(dir, &amp;info) != <span class="number">-1</span> &amp;&amp; S_ISDIR(info.st_mode));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">do_ls</span><span class="params">(<span class="type">char</span> *dir, <span class="type">int</span> sock_fd)</span> &#123;</span><br><span class="line">    FILE *sock_fp = fdopen(sock_fd, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    header(sock_fp, <span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(sock_fp, <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    fflush(sock_fp);</span><br><span class="line"></span><br><span class="line">    dup2(sock_fd, <span class="number">1</span>);</span><br><span class="line">    dup2(sock_fd, <span class="number">2</span>);</span><br><span class="line">    close(sock_fd);</span><br><span class="line"></span><br><span class="line">    execlp(<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, dir, <span class="literal">NULL</span>);</span><br><span class="line">    perror(dir);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> *<span class="title function_">file_type</span><span class="params">(<span class="type">char</span> *f)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *cp;</span><br><span class="line">    <span class="keyword">if</span> ((cp = <span class="built_in">strrchr</span>(f, <span class="string">&#x27;.&#x27;</span>)) != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> cp + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">ends_in_cgi</span><span class="params">(<span class="type">char</span> *f)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">strcmp</span>(file_type(f), <span class="string">&quot;cgi&quot;</span>) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">do_exec</span><span class="params">(<span class="type">char</span> *comm, <span class="type">int</span> sock_fd)</span> &#123;</span><br><span class="line">    FILE *sock_fp = fdopen(sock_fd, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    header(sock_fp, <span class="literal">NULL</span>);</span><br><span class="line">    fflush(sock_fp);</span><br><span class="line"></span><br><span class="line">    dup2(sock_fd, <span class="number">1</span>);</span><br><span class="line">    dup2(sock_fd, <span class="number">2</span>);</span><br><span class="line">    close(sock_fd);</span><br><span class="line">    execl(comm, comm, <span class="literal">NULL</span>);</span><br><span class="line">    perror(comm);</span><br><span class="line">    <span class="comment">// 这里没有 exit(), 服务器可以继续接收命令</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">do_cat</span><span class="params">(<span class="type">char</span> *f, <span class="type">int</span> sock_fd)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *extension = file_type(f);</span><br><span class="line">    <span class="type">char</span> *content = <span class="string">&quot;text/plain&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(extension, <span class="string">&quot;html&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        content = <span class="string">&quot;text/html&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(extension, <span class="string">&quot;gif&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        content = <span class="string">&quot;image/gif&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(extension, <span class="string">&quot;jpg&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        content = <span class="string">&quot;image/jpg&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(extension, <span class="string">&quot;jpeg&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        content = <span class="string">&quot;image/jpeg&quot;</span>;</span><br><span class="line"></span><br><span class="line">    FILE *sock_fp = fdopen(sock_fd, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    FILE *file_fp = fopen(f, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="keyword">if</span> (sock_fp != <span class="literal">NULL</span> &amp;&amp; file_fp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        header(sock_fp, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">fprintf</span>(sock_fp, <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> ((c = getc(file_fp)) != EOF)</span><br><span class="line">            putc(c, sock_fp);</span><br><span class="line">        fclose(sock_fp);</span><br><span class="line">        fclose(file_fp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译并运行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[zhangqi@localhost chap11]$ ./webserver 12345</span><br><span class="line"></span><br><span class="line"><span class="comment">#在浏览器输入localhost:12345</span></span><br><span class="line">got a call: request = GET / HTTP/1.1</span><br><span class="line"></span><br><span class="line">got a call: request = GET /favicon.ico HTTP/1.1</span><br><span class="line"></span><br><span class="line"><span class="comment">#在浏览器输入localhost:12345/hello.cgi</span></span><br><span class="line">got a call: request = GET /hello.cgi HTTP/1.1</span><br></pre></td></tr></table></figure>

<p>将html文件放到该目录中，并且用localhost:12345&#x2F;&#x2F;filename.html来打开它</p>
<p>创建下面的shell脚本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /bin/sh</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hello.cgi-a cheery cgi page</span></span><br><span class="line">printf &quot;Content-type:text/plain\n\nhello\n&quot;</span><br></pre></td></tr></table></figure>

<p>命名为hello.cgi，用chmod改变权限位755，然后用浏览器调用改程序：</p>
<p><code>http://localhost:12345/hello.cgi</code></p>
<h2 id="基于数据包（Datagram）的编程"><a href="#基于数据包（Datagram）的编程" class="headerlink" title="基于数据包（Datagram）的编程"></a>基于数据包（Datagram）的编程</h2><h2 id="线程机制：并发函数的使用"><a href="#线程机制：并发函数的使用" class="headerlink" title="线程机制：并发函数的使用"></a>线程机制：并发函数的使用</h2><p>考虑一个程序如何才能在同一时刻完成多个任务？</p>
<p>前面曾使用fork和exec同时运行多个程序，但如果希望同时运行几个函数，或同时对一个函数调用很多次要怎么做？</p>
<p>因此引入线程的概念。线程相对于函数类似于进程相对于程序，后者为前者提供了运行环境。很多函数可以同时运行，但它们都在相同的进程中。</p>
<h3 id="函数的执行路线"><a href="#函数的执行路线" class="headerlink" title="函数的执行路线"></a>函数的执行路线</h3><p><strong>单线程程序：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM 5</span></span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">print_msg</span><span class="params">(<span class="type">char</span> *)</span>;</span><br><span class="line"></span><br><span class="line">    print_msg(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    print_msg(<span class="string">&quot;world\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_msg</span><span class="params">(<span class="type">char</span> *m)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;NUM;++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,m);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译并运行：可以看到main函数顺序地调用了两个函数。每个函数执行了一个循环。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[zhangqi@localhost chap14]$ ./hello_single </span><br><span class="line">hellohellohellohellohelloworld</span><br><span class="line">world</span><br><span class="line">world</span><br><span class="line">world</span><br><span class="line">world</span><br></pre></td></tr></table></figure>

<img src="https://pic.imgdb.cn/item/632613d616f2c2beb1b35afb.jpg" style="zoom:80%;" />

<p><strong>一个多线程程序</strong></p>
<p>如果想同时执行两个对于print_msg函数的调用，它必须创建多个线程：</p>
<img src="https://pic.imgdb.cn/item/6326143916f2c2beb1b3a96f.jpg" style="zoom:80%;" />

<p>代码实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM 5</span></span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1,t2;                <span class="comment">//two threads</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* <span class="title function_">print_msg</span><span class="params">(<span class="type">void</span> *)</span>;</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;t1, <span class="literal">NULL</span>, print_msg,(<span class="type">void</span>*)<span class="string">&quot;hello&quot;</span>);<span class="comment">//对应一个控制流分支</span></span><br><span class="line">    pthread_create(&amp;t2, <span class="literal">NULL</span>, print_msg,(<span class="type">void</span>*)<span class="string">&quot;world\n&quot;</span>);</span><br><span class="line">    pthread_join(t1,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(t2,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">print_msg</span><span class="params">(<span class="type">void</span> *m)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;NUM;++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,m);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译并运行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[zhangqi@localhost chap14]$ cc hello_multi.c -lpthread -o  hello_multi</span><br><span class="line">[zhangqi@localhost chap14]$ <span class="built_in">ls</span></span><br><span class="line">hello_multi  hello_multi.c  hello_single  hello_single.c</span><br><span class="line">[zhangqi@localhost chap14]$ ./hello_multi </span><br><span class="line">helloworld</span><br><span class="line">helloworld</span><br><span class="line">helloworld</span><br><span class="line">helloworld</span><br><span class="line">helloworld</span><br><span class="line"><span class="comment">#注意这里的输出根据线程调度的不同可能导致不一样的结果</span></span><br></pre></td></tr></table></figure>

<p><strong>相关调用：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,</span></span><br><span class="line"><span class="params">                   <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br><span class="line"><span class="comment">//thread: 指向pthread_t类型变量的指针</span></span><br><span class="line"><span class="comment">//attr: 指向pthread_attr_t类型变量的指针，或者为NULL</span></span><br><span class="line"><span class="comment">//func: 指向新线程所运行函数的指针</span></span><br><span class="line"><span class="comment">//arg: 传递给func的参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//成功，返回0，失败，errcode</span></span><br></pre></td></tr></table></figure>

<p>pthread_create函数创建了一条新的执行路线，在此新的线程内调用了func(arg)。新线程的属性由attr参数来指定，func是一个函数，它接收一个指针作为它的参数，并且运行结束后返回一个指针。</p>
<p>参数和返回值都被定义为类型为void*的指针，以允许它们指向任何类型的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br><span class="line"><span class="comment">//thread: 所等待的线程</span></span><br><span class="line"><span class="comment">//retval: 指向某存储线程返回值的变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//成功，返回0，失败，errcode</span></span><br></pre></td></tr></table></figure>

<p>pthread_join使得调用线程挂起直至由thread参数指定的线程终止。如果retval不是null，那么线程的返回值就存储在由retval指向的变量中。</p>
<p>错误发生的情况：试图等待一个不存在的线程、多个线程同时等待一个线程返回、线程试图等待自己</p>
<h3 id="线程使用示例"><a href="#线程使用示例" class="headerlink" title="线程使用示例"></a>线程使用示例</h3><p>进程间可以通过管道、socket、信号、退出&#x2F;等待以及运行环境来进行会话。</p>
<p>线程间通信也很容易，由于多个线程在一个单独的进程中运行，共享全局变量，因此线程间可以通过设置和读取这些全局变量来进行通信。不过对共享内存的访问是既有用又非常危险的，要非常小心。</p>
<p><strong>示例1</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//incrprint.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM 5</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">main()&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1;</span><br><span class="line">    <span class="type">void</span> *<span class="title function_">print_count</span><span class="params">(<span class="type">void</span>*)</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;t1, <span class="literal">NULL</span>, print_count, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NUM; ++i)&#123;</span><br><span class="line">        ++counter;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_join(t1,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">print_count</span><span class="params">(<span class="type">void</span> *m)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NUM; ++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;count = %d\n&quot;</span>,counter);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序使用了两个线程。初始线程执行了一个循环来使计数器值每秒钟增1。初始线程在进入循环之前，创建了一个新的线程。</p>
<p>新的线程运行了一个函数来讲counter的值打印出来。</p>
<p>由于main函数和print_count函数运行在同一个进程中，所以都有对于counter的访问权。当main函数改变了counter值之后，print_counter函数立即可以访问到新的值。因此不需要通过管道或套接字等方法传送新的值。</p>
<img src="https://pic.imgdb.cn/item/63261ee616f2c2beb1bc2add.jpg" style="zoom:80%;" />

<p>编译并运行：可以看到一个函数修改了变量，另一个函数读取并显示了变量的值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[zhangqi@localhost chap14]$ ./incrprint </span><br><span class="line">count = 1</span><br><span class="line">count = 2</span><br><span class="line">count = 3</span><br><span class="line">count = 4</span><br><span class="line">count = 5</span><br></pre></td></tr></table></figure>

<p><strong>示例2：twordcount.c</strong></p>
<p>设计一个统计多个文件中总字数的多线程程序（用并行的思想，分别分给每个线程一个文件，然后将结果累加）</p>
<p>Unix平台的wc程序可以计算一个或多个文件中的行、单词以及字符个数。但是wc是单线程程序。</p>
<p>版本1：两个线程，一个计数器</p>
<ul>
<li><p>程序创建分开的线程来对每一个文件进行计算。所有的线程在检查到单词的时候对同一个计数器增值</p>
<img src="https://pic.imgdb.cn/item/6326229416f2c2beb1be540f.jpg" style="zoom:80%;" /></li>
</ul>
<p>代码实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//twordcount1.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> total_words;</span><br><span class="line"></span><br><span class="line">main(<span class="type">int</span> ac, <span class="type">char</span> *av[])&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1,t2;</span><br><span class="line">    <span class="type">void</span> *<span class="title function_">count_words</span><span class="params">(<span class="type">void</span> *)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ac!=<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s file1 file2\n&quot;</span>,av[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    total_words = <span class="number">0</span>;</span><br><span class="line">    pthread_create(&amp;t1, <span class="literal">NULL</span>, count_words,(<span class="type">void</span>*)av[<span class="number">1</span>]);</span><br><span class="line">    pthread_create(&amp;t2, <span class="literal">NULL</span>, count_words,(<span class="type">void</span>*)av[<span class="number">2</span>]);</span><br><span class="line">    pthread_join(t1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(t2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%5d:total words\n&quot;</span>, total_words);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">count_words</span><span class="params">(<span class="type">void</span>* f)</span>&#123;</span><br><span class="line">    <span class="type">char</span> * filename = (<span class="type">char</span>*)f;</span><br><span class="line">    FILE* fp;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> c, prevc = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((fp = fopen(filename,<span class="string">&quot;r&quot;</span>))!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>((c = getc(fp))!=EOF)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">isalnum</span>(c) &amp;&amp; <span class="built_in">isalnum</span>(prevc))</span><br><span class="line">                ++total_words;</span><br><span class="line">            prevc = c;</span><br><span class="line">        &#125;</span><br><span class="line">        fclose(fp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        perror(filename);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译并运行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[zhangqi@localhost chap14]$ cc twordcount1.c -lpthread -o twordcount1</span><br><span class="line">[zhangqi@localhost chap14]$ ./twordcount1 /etc/group /bin/stat</span><br><span class="line">12723:total words</span><br></pre></td></tr></table></figure>

<p>此程序存在问题：如果所有线程对同一个计数器进行操作，并且同时进行，会出现问题。</p>
<p>由于total_words++并不是一个原子操作，计算机可能先将计数器当前值存入寄存器中，加1操作后，再恢复到内存中。</p>
<p>这样如果所有线程在同一时刻都使用 ”取出 - 》加1存储“ 的序列来完成对计数器的操作，会产生线程之间的干扰现象。</p>
<p><strong>版本2：两个线程、一个计数器、一个互斥量</strong></p>
<p>线程系统包含了称为互斥锁的变量，它可以使线程间很好的合作，避免对于变量、函数以及资源的访问冲突</p>
<p>示例程序：（改进上一部分的代码）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//twordcount2.c</span></span><br><span class="line"><span class="comment">//实际只增添了三行代码：定义一个pthread_mutex_t类型的全局变量counter_lock,赋一个初值</span></span><br><span class="line"><span class="comment">//在count_words++的前后分别调用pthread_mutex_lock以及pthread_mutex_unlock</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> total_words;</span><br><span class="line"><span class="type">pthread_mutex_t</span> counter_lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line">main(<span class="type">int</span> ac, <span class="type">char</span> *av[])&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1,t2;</span><br><span class="line">    <span class="type">void</span> *<span class="title function_">count_words</span><span class="params">(<span class="type">void</span> *)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ac!=<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s file1 file2\n&quot;</span>,av[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    total_words = <span class="number">0</span>;</span><br><span class="line">    pthread_create(&amp;t1, <span class="literal">NULL</span>, count_words,(<span class="type">void</span>*)av[<span class="number">1</span>]);</span><br><span class="line">    pthread_create(&amp;t2, <span class="literal">NULL</span>, count_words,(<span class="type">void</span>*)av[<span class="number">2</span>]);</span><br><span class="line">    pthread_join(t1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(t2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%5d:total words\n&quot;</span>, total_words);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">count_words</span><span class="params">(<span class="type">void</span>* f)</span>&#123;</span><br><span class="line">    <span class="type">char</span> * filename = (<span class="type">char</span>*)f;</span><br><span class="line">    FILE* fp;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> c, prevc = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((fp = fopen(filename,<span class="string">&quot;r&quot;</span>))!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>((c = getc(fp))!=EOF)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">isalnum</span>(c) &amp;&amp; <span class="built_in">isalnum</span>(prevc))&#123;</span><br><span class="line">                pthread_mutex_lock(&amp;counter_lock);</span><br><span class="line">                ++total_words;</span><br><span class="line">                pthread_mutex_unlock(&amp;counter_lock);</span><br><span class="line">            &#125;</span><br><span class="line">            prevc = c;</span><br><span class="line">        &#125;</span><br><span class="line">        fclose(fp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        perror(filename);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样两个线程可以安全地共享计数器了。当一个线程调用 <code>pthread_mutex_lock</code>的时候，如果另一个线程已经将这个互斥量锁住了，那这个线程只好阻塞等待着这个锁被另一个线程解开后，才可以对计数器进行操作。每个线程对计数器进行操作后，都将互斥量解锁，然后循环地处理其他数据</p>
<p>任何数目的线程都可以挂起等待互斥量解锁。当一个线程对互斥量解锁之后，系统就将控制权教给等候的某一线程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="comment">//用于锁住指定的互斥量。如果互斥量是开放的，它被锁住，并只能由调用线程来管理</span></span><br><span class="line"><span class="comment">//mutex:指向互斥锁对象的指针</span></span><br><span class="line"><span class="comment">//成功，返回0，失败，返回errcode</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="comment">//给指定的互斥量解锁。如果有线程挂起等待此互斥量，其中一个线程将获得对互斥锁的控制权</span></span><br></pre></td></tr></table></figure>

<p>使用互斥量会使程序运行速度变慢。对所有文件中的每一个单词都需要执行检查，设置以及释放所的操作，这使得程序效率低下。</p>
<p>更有效的方法是为每个线程设置自己的计数器</p>
<p><strong>版本3：两个线程、两个计数器、向线程传递多个参数</strong></p>
<p>下面这个程序避免了对互斥量的使用。当线程返回时，再将这两个计数器的值加起来得到最后的结果</p>
<p>线程可以通过调用pthread_exit来得到返回值，这个返回值又可以通过pthread_join的调用被原先的线程得到。</p>
<p>不过这里使用一个简单点的方法：向函数传递一个指向一个变量的指针，让函数对变量进行操作，从而避免让线程将值返回。但是pthread_create只能允许传递一个参数给函数，因此我们要建一个包含两个成员的结构体，然后将此结构体的地址传给函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//twordcount3.c</span></span><br><span class="line">include &lt;stdio.h&gt;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arg_set</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> * fname;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line">main(<span class="type">int</span> ac, <span class="type">char</span> *av[])&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1,t2;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arg_set</span> <span class="title">args1</span>, <span class="title">args2</span>;</span></span><br><span class="line">    <span class="type">void</span> *<span class="title function_">count_words</span><span class="params">(<span class="type">void</span> *)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ac!=<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s file1 file2\n&quot;</span>,av[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    args1.fname = av[<span class="number">1</span>];</span><br><span class="line">    args1.count = <span class="number">0</span>;</span><br><span class="line">    args2.fname = av[<span class="number">2</span>];</span><br><span class="line">    args2.count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;t1, <span class="literal">NULL</span>, count_words,(<span class="type">void</span>*)&amp;args1);</span><br><span class="line">    pthread_create(&amp;t2, <span class="literal">NULL</span>, count_words,(<span class="type">void</span>*)&amp;args2);</span><br><span class="line">    pthread_join(t1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(t2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%5d: %s\n&quot;</span>, args1.count,av[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%5d: %s\n&quot;</span>, args2.count,av[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%5d: total words\n&quot;</span>,args1.count+args2.count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">count_words</span><span class="params">(<span class="type">void</span>* a)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arg_set</span> *<span class="title">args</span> =</span> a;</span><br><span class="line">    <span class="type">char</span> * filename = args-&gt;fname;</span><br><span class="line">    FILE* fp;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> c, prevc = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>((fp = fopen(filename,<span class="string">&quot;r&quot;</span>))!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>((c = getc(fp))!=EOF)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">isalnum</span>(c) &amp;&amp; <span class="built_in">isalnum</span>(prevc))</span><br><span class="line">                ++(args-&gt;count);</span><br><span class="line">            prevc = c;</span><br><span class="line">        &#125;</span><br><span class="line">        fclose(fp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        perror(filename);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h3><p>进程与线程有根本上的不同：</p>
<ul>
<li>每个进程有其独立的数据空间、文件描述符以及进程ID</li>
<li>线程共享一个数据空间、文件描述符以及进程ID</li>
</ul>
<p>共享数据空间：</p>
<ul>
<li>考虑一个在存储器中村塾了巨大而复杂的树结构数据库的数据库系统。多个线程可以轻易读到这个共享的数据集。客户的多个查询可以由一个进程来实现。如果变量不会被改变，共享这个数据空间不会导致任何问题</li>
<li>考虑一个使用malloc和free系统调用来管理内存的程序。一个线程分配了一块空间存储一个字符串。当此线程做其他事情的时候，另一个线程使用free释放了这块空间。那么原先的线程中本来指向此空间的指针现在指向了一块已经被释放的地方（甚至这块内存已经被别的地方使用了），这会导致严重的错误</li>
<li>线程机制还会带来内存的堆积。因为程序员往往害怕影响者在使用的内存空间，只分配而不释放存储区域。这直接导致了内存的囤积，使用完毕也得不到释放</li>
<li>单线程环境中返回指向静态局部变量的指针的函数无法兼容与多线程环境。因为同样的函数可能在多个线程中同时被调用而导致结果出错。</li>
</ul>
<p>共享的文件描述符：</p>
<ul>
<li>fork原语调用之后，文件描述符自动地被赋值，从而子进程得到了一套新的文件描述符。在子进程关闭了某一个从父进程哪里继承来的文件描述符之后，此描述符对父进程来说仍然是打开的。</li>
<li>多线程程序中，很可能会将同一个文件描述符传递给两个不同的线程，即传递给它们的两个值指向同一个文件描述符。显然如果一个线程中的函数关闭了这个文件，此文件描述符对此进程中的任何线程来说都已经被关闭。然而其他县城或许仍然需要对此文件描述符的连接。</li>
</ul>
<p>fork、exec、exit、signals</p>
<ul>
<li>所有线程共享同一个进程。如果一个线程调用了exec，系统内核用一个新的程序取代当前的程序，从而所有正在运行的线程都会消失。如果一个线程执行了exit，那么整个进程都将结束</li>
<li>如果线程中的某函数调用了fork，其他的线程不会被复制给新的进程，只有调用fork的线程在新的进程中运行。</li>
<li>进程可以接收任何种类的信号量</li>
</ul>
<h3 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h3><p>对于进程来说，当子进程终止后，系统调用wait返回。</p>
<p>线程没有类似的机制，因为对于线程而言没有父子的概念，不存在某一个明显的线程可以去通知</p>
<p><strong>使用条件变量编写程序</strong></p>
<img src="https://pic.imgdb.cn/item/6327709716f2c2beb1eff2a4.jpg" style="zoom:80%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arg_set</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> * fname;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arg_set</span> * <span class="title">mailbox</span>;</span>	<span class="comment">//保存数据</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;	<span class="comment">//互斥量</span></span><br><span class="line"><span class="type">pthread_cond_t</span> flag = PTHREAD_MUTEX_INITIALIZER;	<span class="comment">//条件变量</span></span><br><span class="line"></span><br><span class="line">main(<span class="type">int</span> ac, <span class="type">char</span> *av[])&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1,t2;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arg_set</span> <span class="title">args1</span>, <span class="title">args2</span>;</span></span><br><span class="line">    <span class="type">void</span> *<span class="title function_">count_words</span><span class="params">(<span class="type">void</span> *)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> reports_in = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> total_words = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ac!=<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s file1 file2\n&quot;</span>,av[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_lock(&amp;lock);</span><br><span class="line"></span><br><span class="line">    args1.fname = av[<span class="number">1</span>];</span><br><span class="line">    args1.count = <span class="number">0</span>;</span><br><span class="line">    args2.fname = av[<span class="number">2</span>];</span><br><span class="line">    args2.count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;t1, <span class="literal">NULL</span>, count_words,(<span class="type">void</span>*)&amp;args1);</span><br><span class="line">    pthread_create(&amp;t2, <span class="literal">NULL</span>, count_words,(<span class="type">void</span>*)&amp;args2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(reports_in&lt;<span class="number">2</span>)&#123;<span class="comment">//两次处理mailbox中的信息</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;MAIN: waiting for flag to go up\n&quot;</span>);</span><br><span class="line">        pthread_cond_wait(&amp;flag,&amp;lock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;MAIN: Wow!flag was raised, I have the lock\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%7d: %s\n&quot;</span>,mailbox-&gt;count,mailbox-&gt;fname);</span><br><span class="line">        total_words += mailbox-&gt;count;</span><br><span class="line">        <span class="keyword">if</span>(mailbox == &amp;args1)</span><br><span class="line">            pthread_join(t1,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(mailbox == &amp;args2)</span><br><span class="line">            pthread_join(t2,<span class="literal">NULL</span>);</span><br><span class="line">        mailbox = <span class="literal">NULL</span>;</span><br><span class="line">        pthread_cond_signal(&amp;flag);</span><br><span class="line">        reports_in++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%7d: total words\n&quot;</span>,total_words);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">count_words</span><span class="params">(<span class="type">void</span>* a)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arg_set</span> *<span class="title">args</span> =</span> a;</span><br><span class="line">    <span class="type">char</span> * filename = args-&gt;fname;</span><br><span class="line">    FILE* fp;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> c, prevc = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>((fp = fopen(filename,<span class="string">&quot;r&quot;</span>))!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>((c = getc(fp))!=EOF)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">isalnum</span>(c) &amp;&amp; <span class="built_in">isalnum</span>(prevc))</span><br><span class="line">                ++(args-&gt;count);</span><br><span class="line">            prevc = c;</span><br><span class="line">        &#125;</span><br><span class="line">        fclose(fp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        perror(filename);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;COUNT: waiting to get lock\n&quot;</span>);</span><br><span class="line">    pthread_mutex_lock(&amp;lock);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;COUNT: have lock, storing data\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(mailbox != <span class="literal">NULL</span>)</span><br><span class="line">        pthread_cond_wait(&amp;flag, &amp;lock);</span><br><span class="line">    mailbox = args;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;COUNT: raising flag\n&quot;</span>);</span><br><span class="line">    pthread_cond_signal(&amp;flag);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;COUNT: unlocking box\n&quot;</span>);</span><br><span class="line">    pthread_mutex_unlock(&amp;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译并运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[zhangqi@localhost ~/ZZQ/test/chap14]$ ./twordcount4 /etc/group /bin/stat</span><br><span class="line">MAIN: waiting <span class="keyword">for</span> flag to go up</span><br><span class="line">COUNT: waiting to get lock</span><br><span class="line">COUNT: have lock, storing data</span><br><span class="line">COUNT: raising flag</span><br><span class="line">COUNT: unlocking box</span><br><span class="line">MAIN: Wow!flag was raised, I have the lock</span><br><span class="line">  12494: /bin/stat</span><br><span class="line">MAIN: waiting <span class="keyword">for</span> flag to go up</span><br><span class="line">COUNT: waiting to get lock</span><br><span class="line">COUNT: have lock, storing data</span><br><span class="line">COUNT: raising flag</span><br><span class="line">COUNT: unlocking box</span><br><span class="line">MAIN: Wow!flag was raised, I have the lock</span><br><span class="line">    229: /etc/group</span><br><span class="line">  12723: total words</span><br></pre></td></tr></table></figure>

<p>注意线程中调用pthread_cond_wait函数来等待条件变量的改变。</p>
<ul>
<li>该调用使线程挂起直到另一个线程通过条件变量发出消息。</li>
<li>pthread_cond_wait总是和互斥锁在一起使用。</li>
<li>此函数先自动释放指定的锁，然后等待条件变量的变化。如果在调用此函数之前，互斥量mutex并没有被锁住，函数执行的结果是不确定的。</li>
<li>在返回原调用函数之前，此函数自动将指定的互斥量重新锁住</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">                      <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span>;</span><br><span class="line"><span class="comment">//cond 指向某条件变量的指针</span></span><br><span class="line"><span class="comment">//mutex 指向互斥锁对象的指针</span></span><br><span class="line"><span class="comment">//成功，返回0，错误，errcode</span></span><br></pre></td></tr></table></figure>



<p>pthread_cond_signal函数通过条件变量cond发消息。若没有线程等候消息，什么都不会发生；若是多个线程都在等待，只唤醒它们中的一个。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"><span class="comment">//cond 指向某条件变量的指针</span></span><br><span class="line"><span class="comment">//成功，返回0，失败，errcode</span></span><br></pre></td></tr></table></figure>

<p>个人思考：</p>
<ul>
<li>在存储消息到共享变量这一步的前后加锁</li>
<li>保证信息存储完成以后进程要完成对信息的处理，没完成处理则等待</li>
</ul>
<h3 id="多线程Web服务器"><a href="#多线程Web服务器" class="headerlink" title="多线程Web服务器"></a>多线程Web服务器</h3><p>更改前一个版本的Web服务器程序，使用pthread_create替换fork，使客户端的请求不再由单独的进程来处理，而是由同一进程的多个线程来处理。</p>
<p>另外之前通过exec来执行ls命令完成对目录的列表，这里重新写了一个对目录进行列表的函数。</p>
<p>多线程的特性允许我们添加一个新的功能：内部统计。服务器的运行者通常希望知道服务器的运行时间、接收的客户端请求的数目以及发送回客户端的数据量。</p>
<p>因为对于所有的请求共享内存空间，可以使用共享变量的方式来进行统计。</p>
<p>用户如何访问这些统计数据呢？加入一个特殊的URL：status。当远程用户请求此URL时，服务器将内部的统计数据发给客户端。</p>
<p><strong>防止僵尸线程：独立线程</strong></p>
<p>注意这里提到的所有程序都使用了pthread_join函数来等待线程的返回。每个线程都占用了系统资源。如果程序员忘记使用pthread_join来收回线程，这些线程所占用的资源就无法被回收。</p>
<p>在字数统计的程序中，原线程不得不等待所有的计数线程返回之后，才可以收集数据。但是Web服务器没有理由等待处理请求的线程返回。因为原线程不需要从这些线程得到任何返回数据。</p>
<p>这里同样可以创建不需要返回的线程，称之为独立线程（Detached Threads）。当函数执行完毕之后，独立线程自动释放它所占用的所有的资源，他们自身甚至也不允许等待其他的线程返回。可以通过传递一个特殊的属性参数给函数pthread_create来创建一个独立线程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//creating a detached thread</span></span><br><span class="line"><span class="type">pthread_t</span> 		t;</span><br><span class="line"><span class="type">pthread_attr_t</span> attr_detached;</span><br><span class="line">pthread_attr_init(&amp;attr_detached);</span><br><span class="line">pthread_attr_setdetached(&amp;attr_detached, PTHREAD_CREATE_DETACHED);</span><br><span class="line">pthread_create(&amp;t, &amp;attr_detached,func,arg);</span><br></pre></td></tr></table></figure>

<p>多线程Web服务器完整代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* twebserv.c - a threaded minimal web server (version 0.2)</span></span><br><span class="line"><span class="comment"> *    usage: tws portnumber</span></span><br><span class="line"><span class="comment"> * features: supports the GET command only</span></span><br><span class="line"><span class="comment"> *           runs in the current directory</span></span><br><span class="line"><span class="comment"> *           creates a thread to handle each request</span></span><br><span class="line"><span class="comment"> *           supports a special status URL to report internal state</span></span><br><span class="line"><span class="comment"> * building: cc twebserv.c socklib.c -lpthread -o twebserv</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* server facts here */</span></span><br><span class="line"></span><br><span class="line"><span class="type">time_t</span>	 server_started ;</span><br><span class="line"><span class="type">int</span>	 server_bytes_sent;</span><br><span class="line"><span class="type">int</span>	 server_requests;</span><br><span class="line"></span><br><span class="line">main(<span class="type">int</span> ac, <span class="type">char</span> *av[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> 		sock, fd;</span><br><span class="line">    <span class="type">int</span>		*fdptr;</span><br><span class="line">    <span class="type">pthread_t</span>	worker;</span><br><span class="line">    <span class="type">pthread_attr_t</span>	attr;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *<span class="title function_">handle_call</span><span class="params">(<span class="type">void</span> *)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( ac == <span class="number">1</span> )&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;usage: tws portnum\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sock = make_server_socket( atoi(av[<span class="number">1</span>]) );</span><br><span class="line">    <span class="keyword">if</span> ( sock == <span class="number">-1</span> ) &#123; perror(<span class="string">&quot;making socket&quot;</span>); <span class="built_in">exit</span>(<span class="number">2</span>); &#125;</span><br><span class="line"></span><br><span class="line">    setup(&amp;attr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* main loop here: take call, handle call in new thread  */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        fd = accept( sock, <span class="literal">NULL</span>, <span class="literal">NULL</span> );</span><br><span class="line">        server_requests++;</span><br><span class="line"></span><br><span class="line">        fdptr = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        *fdptr = fd;</span><br><span class="line">        pthread_create(&amp;worker,&amp;attr,handle_call,fdptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * initialize the status variables and</span></span><br><span class="line"><span class="comment"> * set the thread attribute to detached</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">setup(<span class="type">pthread_attr_t</span> *attrp)</span><br><span class="line">&#123;</span><br><span class="line">    pthread_attr_init(attrp);</span><br><span class="line">    pthread_attr_setdetachstate(attrp,PTHREAD_CREATE_DETACHED);</span><br><span class="line"></span><br><span class="line">    time(&amp;server_started);</span><br><span class="line">    server_requests = <span class="number">0</span>;</span><br><span class="line">    server_bytes_sent = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">handle_call</span><span class="params">(<span class="type">void</span> *fdptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE	*fpin;</span><br><span class="line">    <span class="type">char</span>	request[BUFSIZ];</span><br><span class="line">    <span class="type">int</span>	fd ;</span><br><span class="line"></span><br><span class="line">    fd = *(<span class="type">int</span> *)fdptr;</span><br><span class="line">    <span class="built_in">free</span>(fdptr);				<span class="comment">/* get fd from arg  */</span></span><br><span class="line"></span><br><span class="line">    fpin = fdopen(fd, <span class="string">&quot;r&quot;</span>);			<span class="comment">/* buffer input	*/</span></span><br><span class="line">    fgets(request,BUFSIZ,fpin);		<span class="comment">/* read client request */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;got a call on %d: request = %s&quot;</span>, fd, request);</span><br><span class="line">    skip_rest_of_header(fpin);</span><br><span class="line"></span><br><span class="line">    process_rq(request, fd);		<span class="comment">/* process client rq */</span></span><br><span class="line"></span><br><span class="line">    fclose(fpin);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ------------------------------------------------------ *</span></span><br><span class="line"><span class="comment">   skip_rest_of_header(FILE *)</span></span><br><span class="line"><span class="comment">   skip over all request info until a CRNL is seen</span></span><br><span class="line"><span class="comment">   ------------------------------------------------------ */</span></span><br><span class="line">skip_rest_of_header(FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>	buf[BUFSIZ];</span><br><span class="line">    <span class="keyword">while</span>( fgets(buf,BUFSIZ,fp) != <span class="literal">NULL</span> &amp;&amp; <span class="built_in">strcmp</span>(buf,<span class="string">&quot;\r\n&quot;</span>) != <span class="number">0</span> )</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ------------------------------------------------------ *</span></span><br><span class="line"><span class="comment">   process_rq( char *rq, int fd )</span></span><br><span class="line"><span class="comment">   do what the request asks for and write reply to fd </span></span><br><span class="line"><span class="comment">   handles request in a new process</span></span><br><span class="line"><span class="comment">   rq is HTTP command:  GET /foo/bar.html HTTP/1.0</span></span><br><span class="line"><span class="comment">   ------------------------------------------------------ */</span></span><br><span class="line">process_rq( <span class="type">char</span> *rq, <span class="type">int</span> fd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>	cmd[BUFSIZ], arg[BUFSIZ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">sscanf</span>(rq, <span class="string">&quot;%s%s&quot;</span>, cmd, arg) != <span class="number">2</span> )</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    sanitize(arg);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sanitized version is %s\n&quot;</span>, arg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(cmd,<span class="string">&quot;GET&quot;</span>) != <span class="number">0</span> )</span><br><span class="line">        not_implemented();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( built_in(arg, fd) )</span><br><span class="line">        ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( not_exist( arg ) )</span><br><span class="line">        do_404(arg, fd);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( isadir( arg ) )</span><br><span class="line">        do_ls( arg, fd );</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        do_cat( arg, fd );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * make sure all paths are below the current directory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">sanitize(<span class="type">char</span> *str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>	*src, *dest;</span><br><span class="line"></span><br><span class="line">    src = dest = str;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( *src )&#123;</span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">strncmp</span>(src,<span class="string">&quot;/../&quot;</span>,<span class="number">4</span>) == <span class="number">0</span> )</span><br><span class="line">            src += <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">strncmp</span>(src,<span class="string">&quot;//&quot;</span>,<span class="number">2</span>) == <span class="number">0</span> )</span><br><span class="line">            src++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            *dest++ = *src++;</span><br><span class="line">    &#125;</span><br><span class="line">    *dest = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> ( *str == <span class="string">&#x27;/&#x27;</span> )</span><br><span class="line">        <span class="built_in">strcpy</span>(str,str+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( str[<span class="number">0</span>]==<span class="string">&#x27;\0&#x27;</span> || <span class="built_in">strcmp</span>(str,<span class="string">&quot;./&quot;</span>)==<span class="number">0</span> || <span class="built_in">strcmp</span>(str,<span class="string">&quot;./..&quot;</span>)==<span class="number">0</span> )</span><br><span class="line">        <span class="built_in">strcpy</span>(str,<span class="string">&quot;.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* handle built-in URLs here.  Only one so far is &quot;status&quot; */</span></span><br><span class="line">built_in(<span class="type">char</span> *arg, <span class="type">int</span> fd)</span><br><span class="line">&#123;</span><br><span class="line">    FILE	*fp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(arg,<span class="string">&quot;status&quot;</span>) != <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    http_reply(fd, &amp;fp, <span class="number">200</span>, <span class="string">&quot;OK&quot;</span>, <span class="string">&quot;text/plain&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(fp,<span class="string">&quot;Server started: %s&quot;</span>, ctime(&amp;server_started));</span><br><span class="line">    <span class="built_in">fprintf</span>(fp,<span class="string">&quot;Total requests: %d\n&quot;</span>, server_requests);</span><br><span class="line">    <span class="built_in">fprintf</span>(fp,<span class="string">&quot;Bytes sent out: %d\n&quot;</span>, server_bytes_sent);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http_reply(<span class="type">int</span> fd, FILE **fpp, <span class="type">int</span> code, <span class="type">char</span> *msg, <span class="type">char</span> *type, <span class="type">char</span> *content)</span><br><span class="line">&#123;</span><br><span class="line">    FILE	*fp = fdopen(fd, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="type">int</span>	bytes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( fp != <span class="literal">NULL</span> )&#123;</span><br><span class="line">        bytes = <span class="built_in">fprintf</span>(fp,<span class="string">&quot;HTTP/1.0 %d %s\r\n&quot;</span>, code, msg);</span><br><span class="line">        bytes += <span class="built_in">fprintf</span>(fp,<span class="string">&quot;Content-type: %s\r\n\r\n&quot;</span>, type);</span><br><span class="line">        <span class="keyword">if</span> ( content )</span><br><span class="line">            bytes += <span class="built_in">fprintf</span>(fp,<span class="string">&quot;%s\r\n&quot;</span>, content);</span><br><span class="line">    &#125;</span><br><span class="line">    fflush(fp);</span><br><span class="line">    <span class="keyword">if</span> ( fpp )</span><br><span class="line">        *fpp = fp;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ------------------------------------------------------ *</span></span><br><span class="line"><span class="comment">   simple functions first:</span></span><br><span class="line"><span class="comment">        not_implemented(fd)      unimplemented HTTP command</span></span><br><span class="line"><span class="comment">        and do_404(item,fd)     no such object</span></span><br><span class="line"><span class="comment">   ------------------------------------------------------ */</span></span><br><span class="line">not_implemented(<span class="type">int</span> fd)</span><br><span class="line">&#123;</span><br><span class="line">    http_reply(fd,<span class="literal">NULL</span>,<span class="number">501</span>,<span class="string">&quot;Not Implemented&quot;</span>,<span class="string">&quot;text/plain&quot;</span>,</span><br><span class="line">               <span class="string">&quot;That command is not implemented&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">do_404(<span class="type">char</span> *item, <span class="type">int</span> fd)</span><br><span class="line">&#123;</span><br><span class="line">    http_reply(fd,<span class="literal">NULL</span>,<span class="number">404</span>,<span class="string">&quot;Not Found&quot;</span>,<span class="string">&quot;text/plain&quot;</span>,</span><br><span class="line">               <span class="string">&quot;The item you seek is not here&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ------------------------------------------------------ *</span></span><br><span class="line"><span class="comment">   the directory listing section</span></span><br><span class="line"><span class="comment">   isadir() uses stat, not_exist() uses stat</span></span><br><span class="line"><span class="comment">   ------------------------------------------------------ */</span></span><br><span class="line">isadir(<span class="type">char</span> *f)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">info</span>;</span></span><br><span class="line">    <span class="keyword">return</span> ( stat(f, &amp;info) != <span class="number">-1</span> &amp;&amp; S_ISDIR(info.st_mode) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">not_exist(<span class="type">char</span> *f)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">info</span>;</span></span><br><span class="line">    <span class="keyword">return</span>( stat(f,&amp;info) == <span class="number">-1</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">do_ls(<span class="type">char</span> *dir, <span class="type">int</span> fd)</span><br><span class="line">&#123;</span><br><span class="line">    DIR	      *dirptr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">direntp</span>;</span></span><br><span class="line">    FILE	      *fp;</span><br><span class="line">    <span class="type">int</span>	      bytes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    bytes = http_reply(fd,&amp;fp,<span class="number">200</span>,<span class="string">&quot;OK&quot;</span>,<span class="string">&quot;text/plain&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line">    bytes += <span class="built_in">fprintf</span>(fp,<span class="string">&quot;Listing of Directory %s\n&quot;</span>, dir);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( (dirptr = opendir(dir)) != <span class="literal">NULL</span> )&#123;</span><br><span class="line">        <span class="keyword">while</span>( direntp = readdir(dirptr) )&#123;</span><br><span class="line">            bytes += <span class="built_in">fprintf</span>(fp, <span class="string">&quot;%s\n&quot;</span>, direntp-&gt;d_name);</span><br><span class="line">        &#125;</span><br><span class="line">        closedir(dirptr);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    server_bytes_sent += bytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ------------------------------------------------------ *</span></span><br><span class="line"><span class="comment">   functions to cat files here.</span></span><br><span class="line"><span class="comment">   file_type(filename) returns the &#x27;extension&#x27;: cat uses it</span></span><br><span class="line"><span class="comment">   ------------------------------------------------------ */</span></span><br><span class="line"><span class="type">char</span> * <span class="title function_">file_type</span><span class="params">(<span class="type">char</span> *f)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>	*cp;</span><br><span class="line">    <span class="keyword">if</span> ( (cp = <span class="built_in">strrchr</span>(f, <span class="string">&#x27;.&#x27;</span> )) != <span class="literal">NULL</span> )</span><br><span class="line">        <span class="keyword">return</span> cp+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* do_cat(filename,fd): sends header then the contents */</span></span><br><span class="line"></span><br><span class="line">do_cat(<span class="type">char</span> *f, <span class="type">int</span> fd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>	*extension = file_type(f);</span><br><span class="line">    <span class="type">char</span>	*type = <span class="string">&quot;text/plain&quot;</span>;</span><br><span class="line">    FILE	*fpsock, *fpfile;</span><br><span class="line">    <span class="type">int</span>	c;</span><br><span class="line">    <span class="type">int</span>	bytes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(extension,<span class="string">&quot;html&quot;</span>) == <span class="number">0</span> )</span><br><span class="line">        type = <span class="string">&quot;text/html&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(extension, <span class="string">&quot;gif&quot;</span>) == <span class="number">0</span> )</span><br><span class="line">        type = <span class="string">&quot;image/gif&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(extension, <span class="string">&quot;jpg&quot;</span>) == <span class="number">0</span> )</span><br><span class="line">        type = <span class="string">&quot;image/jpeg&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(extension, <span class="string">&quot;jpeg&quot;</span>) == <span class="number">0</span> )</span><br><span class="line">        type = <span class="string">&quot;image/jpeg&quot;</span>;</span><br><span class="line"></span><br><span class="line">    fpsock = fdopen(fd, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    fpfile = fopen( f , <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( fpsock != <span class="literal">NULL</span> &amp;&amp; fpfile != <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        bytes = http_reply(fd,&amp;fpsock,<span class="number">200</span>,<span class="string">&quot;OK&quot;</span>,type,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">while</span>( (c = getc(fpfile) ) != EOF )&#123;</span><br><span class="line">            putc(c, fpsock);</span><br><span class="line">            bytes++;</span><br><span class="line">        &#125;</span><br><span class="line">        fclose(fpfile);</span><br><span class="line">        fclose(fpsock);</span><br><span class="line">    &#125;</span><br><span class="line">    server_bytes_sent += bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="进程间通信（IPC）"><a href="#进程间通信（IPC）" class="headerlink" title="进程间通信（IPC）"></a>进程间通信（IPC）</h2><ul>
<li>管道</li>
<li>select、poll 挂起并等候从多个源端的输入</li>
<li>命名管道</li>
<li>共享内存</li>
<li>文件锁</li>
<li>信号量</li>
</ul>
<h3 id="select系统调用"><a href="#select系统调用" class="headerlink" title="select系统调用"></a><strong>select系统调用</strong></h3><p>系统调用select允许程序挂起，并等待从不止一个文件描述符的输入。</p>
<p>原理：</p>
<ul>
<li>获得所需要的文件描述符列表</li>
<li>将此列表传给select</li>
<li>select挂起直到任何一个文件描述符有数据到达</li>
<li>select设置一个变量中的若干位，用来通知你哪一个文件描述符中已经有输入的数据</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* According to POSIX.1-2001 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* According to earlier standards */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span>;</span><br><span class="line"><span class="comment">//参数说明:</span></span><br><span class="line"><span class="comment">//nfds 需要监听的最大fd值加1</span></span><br><span class="line"><span class="comment">//readfds 等待从此集合包括的文件描述符到来的数据</span></span><br><span class="line"><span class="comment">//writefds 等待向这些文件描述符写数据的许可</span></span><br><span class="line"><span class="comment">//exceptfds 等待这些文件描述符操作的异常</span></span><br><span class="line"><span class="comment">//timeout 超过此时间后函数返回</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值</span></span><br><span class="line"><span class="comment">//-1 发生错误</span></span><br><span class="line"><span class="comment">//0 超时</span></span><br><span class="line"><span class="comment">//num 满足需求的文件描述符的数目</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">int</span>  <span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>select同时监视多个文件描述符，在指定情况发生的时候，函数返回。详细一点说，select监听在三组文件描述符上发生的事件：</p>
<ul>
<li>检查第一组是否可以读取</li>
<li>检查第二组是否可以写入</li>
<li>检查第三组是否有异常发生</li>
</ul>
<p>每一组的文件描述符被记录到一个二进制位的数组中。这里的numfds恰好等于需要监听的最大的文件描述符加1.</p>
<p>若任一参数为null，select将忽略此参数</p>
<h3 id="通信的选择"><a href="#通信的选择" class="headerlink" title="通信的选择"></a>通信的选择</h3> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://www.zzzzzq.com/2022/08/30/UNIX/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2022/10/04/CS144/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            CS144
          
        </div>
      </a>
    
    
      <a href="/2022/08/30/Interview-muduo/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">muduo高性能网络服务器库学习笔记</div>
      </a>
    
  </nav>

   
<!-- valine评论 -->
<div id="vcomments-box">
  <div id="vcomments"></div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdn.staticfile.org/valine/1.4.16/Valine.min.js"></script>
<script>
  new Valine({
    el: "#vcomments",
    app_id: "5J2nSr5DoqBGRRnpdFfTvawi-gzGzoHsz",
    app_key: "24GWRfKBASGr6cA5FSBF4NY4",
    path: window.location.pathname,
    avatar: "monsterid",
    placeholder: "给我的文章加点评论吧~",
    recordIP: true,
  });
  const infoEle = document.querySelector("#vcomments .info");
  if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
    infoEle.childNodes.forEach(function (item) {
      item.parentNode.removeChild(item);
    });
  }
</script>
<style>
  #vcomments-box {
    padding: 5px 30px;
  }

  @media screen and (max-width: 800px) {
    #vcomments-box {
      padding: 5px 0px;
    }
  }

  #vcomments-box #vcomments {
    background-color: #fff;
  }

  .v .vlist .vcard .vh {
    padding-right: 20px;
  }

  .v .vlist .vcard {
    padding-left: 10px;
  }
</style>

 
   
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022
        <i class="ri-heart-fill heart_icon"></i> ZHU
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Keep Making Progress"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>