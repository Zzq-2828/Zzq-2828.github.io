<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Good questions —— 数组篇</title>
    <url>/2022/03/31/questions/</url>
    <content><![CDATA[<p>概述：本文记录了我在<a href="https://leetcode-cn.com/"><em>Leetcode</em></a>刷题过程中遇到的与数组相关的优质题目及解题思路</p>
<span id="more"></span>

<h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><p>给定一个不含重复数字的数组 nums ，返回其 <a href="https://leetcode-cn.com/problems/permutations/"><em>所有可能的全排列</em></a> 。可以 <strong>按任意顺序</strong> 返回答案。 </p>
<p>思路：</p>
<p>使用<strong>dfs+回溯</strong>。比较经典的回溯题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dfs(回溯)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vis</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">dfs</span>(nums,vis);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,vector&lt;<span class="type">int</span>&gt;&amp; vis)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>()==nums.<span class="built_in">size</span>())</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i!=nums.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                vis[i]=<span class="number">1</span>;</span><br><span class="line">                path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                <span class="built_in">dfs</span>(nums,vis);</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">                vis[i]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>非递归版本：</p>
<p>思路：</p>
<p>（1）通过实现<a href="https://leetcode-cn.com/problems/next-permutation/">下一个排列</a>函数来实现找到全部排列</p>
<p>（2）下一个排列：<strong>从后往前</strong>搜索数组，找到第一个逆序对。如&lt;3,4,7,6,5&gt;中4是第一个出现逆序的。将4置换为&lt;7,6,5&gt;中比4大且最小的那个数（即5），数组变为&lt;3,5,7,6,4&gt;。再将&lt;7,6,4&gt;部分升序排列（实际上反转就是排序）即可，变为&lt;3,5,4,6,7&gt;即为下一个排列</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=nums.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;=nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(i<span class="number">-1</span>==<span class="number">0</span>)      <span class="comment">//已经为最大的排列（全降序），那么下一个即为最小的排列（全升序）</span></span><br><span class="line">                    <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到第一个逆序发生的索引i-1</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=nums.<span class="built_in">size</span>()<span class="number">-1</span>;j&gt;i<span class="number">-1</span>;--j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[j]&gt;nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                        <span class="built_in">swap</span>(nums[j],nums[i<span class="number">-1</span>]);</span><br><span class="line">                        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>()+i,nums.<span class="built_in">end</span>());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>给定一个可包含重复数字的数组 nums ，返回其 <em>所有可能的</em><a href="https://leetcode-cn.com/problems/permutations-ii/"><em>全排列</em></a> 。你可以 <strong>按任意顺序</strong> 返回答案。 </p>
<p>思路：</p>
<p>（1）相较于上一题，这题需要多考虑去重的问题，即在同一层中，如果可选择的范围（未被访问过的范围）包含重复的数字，那么只能选择第一个，跳过重复的部分。</p>
<p>（2）另外要预先对nums进行排序，保证重复的数字都是相邻的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());<span class="comment">//为了使重复的数都相邻</span></span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vis</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">dfs</span>(nums,vis);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,vector&lt;<span class="type">int</span>&gt;&amp; vis)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>()==nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i!=nums.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="comment">//要保证在同一层中使用的是不同的数</span></span><br><span class="line">            <span class="comment">//对于有重复的数，要找到第一个未被使用过的</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i]==nums[i<span class="number">-1</span>] &amp;&amp; vis[i<span class="number">-1</span>]==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(vis[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                vis[i]=<span class="number">1</span>;</span><br><span class="line">                path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                <span class="built_in">dfs</span>(nums,vis);</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">                vis[i]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="最长递增子序列问题"><a href="#最长递增子序列问题" class="headerlink" title="最长递增子序列问题"></a>最长递增子序列问题</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">最长递增子序列</a>LIS问题及 <a href="https://leetcode-cn.com/problems/minimum-operations-to-make-the-array-k-increasing/submissions/">变体</a></p>
<p>给定一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p>
<p>子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p>
<p>（1）动态规划方法，时间复杂度O(n^2)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动态规划：dp[i]=max(dp[i],dp[j]+1)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(),<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i!=nums.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j!=i;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]&lt;nums[i])</span><br><span class="line">                dp[i]=<span class="built_in">max</span>(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">max_element</span>(dp.<span class="built_in">begin</span>(),dp.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>（2）维护一个记录长度为i时递增子序列末尾元素的最小值，时间复杂度O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//维护一个数组 temp[i]，表示长度为 i 的最长上升子序列的末尾元素的最小值，temp[0] = nums[0]</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">        temp.<span class="built_in">emplace_back</span>(nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i!=nums.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;temp.<span class="built_in">back</span>())</span><br><span class="line">            temp.<span class="built_in">emplace_back</span>(nums[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//注意这里要使用lower_bound</span></span><br><span class="line">                <span class="keyword">auto</span> it=<span class="built_in">lower_bound</span>(temp.<span class="built_in">begin</span>(),temp.<span class="built_in">end</span>(),nums[i]);</span><br><span class="line">                <span class="comment">//if(it==temp.end())</span></span><br><span class="line">                <span class="comment">//continue;</span></span><br><span class="line">                temp[it-temp.<span class="built_in">begin</span>()]=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="原地哈希"><a href="#原地哈希" class="headerlink" title="原地哈希"></a>原地哈希</h2><p>（1）要求在数组中<a href="https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/">找出所有出现两次的整数</a>，时间复杂度O(n)，空间复杂度O(1)</p>
<p>思想：原地哈希</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//思想，将nums[nums[i]-1]位置的数值加上n（由于是出现两次，直接取反也行）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i!=n;++i)&#123;</span><br><span class="line">            nums[(nums[i]<span class="number">-1</span>)%n]+=n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i!=n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>((nums[i]<span class="number">-1</span>)/n==<span class="number">2</span>)</span><br><span class="line">                res.<span class="built_in">push_back</span>(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>（2）要求在长度为n的数组中[找到没有出现在<a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/">1,n]范围内的数字</a></p>
<p>思想：将nums中出现过的数字作为索引，将对应位置取反</p>
<h2 id="打印螺旋矩阵"><a href="#打印螺旋矩阵" class="headerlink" title="打印螺旋矩阵"></a>打印螺旋矩阵</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/spiral-matrix/">打印螺旋矩阵</a>：</p>
<p>思路：</p>
<p>（1）想到按层来遍历可以省去空间复杂度</p>
<p>（2）定义四个变量（left，right，top，bottom）来控制每一层的边界</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
