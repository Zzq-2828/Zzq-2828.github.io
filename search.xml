<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>SpringBootConfig</title>
    <url>/2022/03/31/SpringBootConfig/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>on writing</tag>
      </tags>
  </entry>
  <entry>
    <title>Java与C++的差异</title>
    <url>/2022/03/31/java-basic/</url>
    <content><![CDATA[<p>概述：本文主要记录Java中与C++有明显差异的语言特性</p>
<span id="more"></span>

<p>（1）C++ 支持指针，而 Java 没有指针的概念。</p>
<h2 id="与C-的差异"><a href="#与C-的差异" class="headerlink" title="与C++的差异"></a>与C++的差异</h2><p>（1）C++ 支持指针，而 Java 没有指针的概念。</p>
<p>（2）C++ 支持多继承，而 Java 不支持多重继承，但允许一个类实现多个接口。</p>
<p>（3）Java 是完全面向对象的语言，并且还取消了 C&#x2F;C++ 中的结构和联合，使编译程序更加简洁</p>
<p>（4）Java 自动进行无用内存回收操作，不再需要程序员进行手动删除，而 C++ 中必须由程序释放内存资源，这就增加了程序员的负担。</p>
<p>（5）Java 不支持操作符重载，而操作符重载则被认为是 C++ 的突出特征。</p>
<p>（6）Java 允许预处理，但不支持预处理器功能，所以为了实现预处理，它提供了引入语句（import），但它与 C++ 预处理器的功能类似。</p>
<p>（7）Java 不支持缺省参数函数，而 C++ 支持 。</p>
<p>（8）C 和 C++ 不支持字符串变量，在 C 和 C++ 程序中使用“Null”终止符代表字符串的结束。在 Java 中字符串是用类对象（String 和 StringBuffer）来实现的</p>
<p>（9）Java 不提供 goto 语句，虽然 Java 指定 goto 作为关键字，但不支持它的使用，这使程序更简洁易读。不过Java中的break&#x2F;continue可以带标签（标签必须放在希望跳出的最外层循环之前，并且必须紧跟一个冒号），用于从内层循环中跳出</p>
<p>（10）Java 不支持 C++ 中的自动强制类型转换，如果需要，必须由程序显式进行强制类型转换。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Good questions —— 数组篇</title>
    <url>/2022/03/31/questions/</url>
    <content><![CDATA[<p>概述：本文记录了我在<a href="https://leetcode-cn.com/"><em>Leetcode</em></a>刷题过程中遇到的与数组相关的优质题目及解题思路</p>
<span id="more"></span>

<h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><p>给定一个不含重复数字的数组 nums ，返回其 <a href="https://leetcode-cn.com/problems/permutations/"><em>所有可能的全排列</em></a> 。可以 <strong>按任意顺序</strong> 返回答案。 </p>
<p>思路：</p>
<p>使用<strong>dfs+回溯</strong>。比较经典的回溯题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dfs(回溯)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vis</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">dfs</span>(nums,vis);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,vector&lt;<span class="type">int</span>&gt;&amp; vis)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>()==nums.<span class="built_in">size</span>())</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i!=nums.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                vis[i]=<span class="number">1</span>;</span><br><span class="line">                path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                <span class="built_in">dfs</span>(nums,vis);</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">                vis[i]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>非递归版本：</p>
<p>思路：</p>
<p>（1）通过实现<a href="https://leetcode-cn.com/problems/next-permutation/">下一个排列</a>函数来实现找到全部排列</p>
<p>（2）下一个排列：<strong>从后往前</strong>搜索数组，找到第一个逆序对。如&lt;3,4,7,6,5&gt;中4是第一个出现逆序的。将4置换为&lt;7,6,5&gt;中比4大且最小的那个数（即5），数组变为&lt;3,5,7,6,4&gt;。再将&lt;7,6,4&gt;部分升序排列（实际上反转就是排序）即可，变为&lt;3,5,4,6,7&gt;即为下一个排列</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=nums.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;=nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(i<span class="number">-1</span>==<span class="number">0</span>)      <span class="comment">//已经为最大的排列（全降序），那么下一个即为最小的排列（全升序）</span></span><br><span class="line">                    <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到第一个逆序发生的索引i-1</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=nums.<span class="built_in">size</span>()<span class="number">-1</span>;j&gt;i<span class="number">-1</span>;--j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[j]&gt;nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                        <span class="built_in">swap</span>(nums[j],nums[i<span class="number">-1</span>]);</span><br><span class="line">                        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>()+i,nums.<span class="built_in">end</span>());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>给定一个可包含重复数字的数组 nums ，返回其 <em>所有可能的</em><a href="https://leetcode-cn.com/problems/permutations-ii/"><em>全排列</em></a> 。你可以 <strong>按任意顺序</strong> 返回答案。 </p>
<p>思路：</p>
<p>（1）相较于上一题，这题需要多考虑去重的问题，即在同一层中，如果可选择的范围（未被访问过的范围）包含重复的数字，那么只能选择第一个，跳过重复的部分。</p>
<p>（2）另外要预先对nums进行排序，保证重复的数字都是相邻的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());<span class="comment">//为了使重复的数都相邻</span></span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vis</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">dfs</span>(nums,vis);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,vector&lt;<span class="type">int</span>&gt;&amp; vis)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>()==nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i!=nums.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="comment">//要保证在同一层中使用的是不同的数</span></span><br><span class="line">            <span class="comment">//对于有重复的数，要找到第一个未被使用过的</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i]==nums[i<span class="number">-1</span>] &amp;&amp; vis[i<span class="number">-1</span>]==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(vis[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                vis[i]=<span class="number">1</span>;</span><br><span class="line">                path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                <span class="built_in">dfs</span>(nums,vis);</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">                vis[i]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="最长递增子序列问题"><a href="#最长递增子序列问题" class="headerlink" title="最长递增子序列问题"></a>最长递增子序列问题</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">最长递增子序列</a>LIS问题及 <a href="https://leetcode-cn.com/problems/minimum-operations-to-make-the-array-k-increasing/submissions/">变体</a></p>
<p>给定一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p>
<p>子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p>
<p>（1）动态规划方法，时间复杂度O(n^2)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动态规划：dp[i]=max(dp[i],dp[j]+1)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(),<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i!=nums.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j!=i;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]&lt;nums[i])</span><br><span class="line">                dp[i]=<span class="built_in">max</span>(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">max_element</span>(dp.<span class="built_in">begin</span>(),dp.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>（2）维护一个记录长度为i时递增子序列末尾元素的最小值，时间复杂度O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//维护一个数组 temp[i]，表示长度为 i 的最长上升子序列的末尾元素的最小值，temp[0] = nums[0]</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">        temp.<span class="built_in">emplace_back</span>(nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i!=nums.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;temp.<span class="built_in">back</span>())</span><br><span class="line">            temp.<span class="built_in">emplace_back</span>(nums[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//注意这里要使用lower_bound</span></span><br><span class="line">                <span class="keyword">auto</span> it=<span class="built_in">lower_bound</span>(temp.<span class="built_in">begin</span>(),temp.<span class="built_in">end</span>(),nums[i]);</span><br><span class="line">                <span class="comment">//if(it==temp.end())</span></span><br><span class="line">                <span class="comment">//continue;</span></span><br><span class="line">                temp[it-temp.<span class="built_in">begin</span>()]=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="原地哈希"><a href="#原地哈希" class="headerlink" title="原地哈希"></a>原地哈希</h2><p>（1）要求在数组中<a href="https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/">找出所有出现两次的整数</a>，时间复杂度O(n)，空间复杂度O(1)</p>
<p>思想：原地哈希</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//思想，将nums[nums[i]-1]位置的数值加上n（由于是出现两次，直接取反也行）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i!=n;++i)&#123;</span><br><span class="line">            nums[(nums[i]<span class="number">-1</span>)%n]+=n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i!=n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>((nums[i]<span class="number">-1</span>)/n==<span class="number">2</span>)</span><br><span class="line">                res.<span class="built_in">push_back</span>(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>（2）要求在长度为n的数组中[找到没有出现在[1,n]<a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/"><em>范围内的数字</em></a></p>
<p>思想：将nums中出现过的数字作为索引，将对应位置取反</p>
<h2 id="打印螺旋矩阵"><a href="#打印螺旋矩阵" class="headerlink" title="打印螺旋矩阵"></a>打印螺旋矩阵</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/spiral-matrix/">打印螺旋矩阵</a>：</p>
<p>思路：</p>
<p>（1）想到按层来遍历可以省去空间复杂度</p>
<p>（2）定义四个变量（left，right，top，bottom）来控制每一层的边界</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Good questions —— 二叉树篇</title>
    <url>/2022/03/31/questions02/</url>
    <content><![CDATA[<p>概述：本文记录了刷题过程中与二叉树相关的优质题目及解题思路</p>
<span id="more"></span>

<h2 id="二叉树的前中后序遍历"><a href="#二叉树的前中后序遍历" class="headerlink" title="二叉树的前中后序遍历"></a>二叉树的前中后序遍历</h2><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><p>（1）递归实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        <span class="built_in">dfs</span>(node-&gt;left);</span><br><span class="line">        <span class="built_in">dfs</span>(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>（2）迭代实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//迭代</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        stk.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            TreeNode* temp=stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();       <span class="comment">//必须先pop出来</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(temp-&gt;val);<span class="comment">//根节点先push到结果数组中</span></span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;right) stk.<span class="built_in">push</span>(temp-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;left)  stk.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>（3）风格统一的迭代写法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//迭代2 用这种写法与中序风格统一</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        TreeNode* cur= root;</span><br><span class="line">        <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>() || cur!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="comment">//前序遍历在节点入栈时即可直接将val放到res中</span></span><br><span class="line">            <span class="keyword">if</span>(cur!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                stk.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur=cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//当访问到最底层时</span></span><br><span class="line">                <span class="comment">//关键步骤，理解cur的改变</span></span><br><span class="line">                cur=stk.<span class="built_in">top</span>()-&gt;right;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>（1）递归实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>（2）迭代实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        TreeNode* cur=root;</span><br><span class="line">        <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>()||cur!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="comment">// 指针来访问节点，访问到最底层</span></span><br><span class="line">            <span class="keyword">if</span>(cur!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="comment">// 将访问的节点放进栈</span></span><br><span class="line">                stk.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur=cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）</span></span><br><span class="line">                res.<span class="built_in">push_back</span>(stk.<span class="built_in">top</span>()-&gt;val);<span class="comment">//中</span></span><br><span class="line">                cur=stk.<span class="built_in">top</span>()-&gt;right;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>（1）递归实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.确定终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">//前中后序遍历只需要改换这三条的顺序</span></span><br><span class="line">        <span class="built_in">postorderTraversal</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">postorderTraversal</span>(root-&gt;right);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>（2）迭代实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//迭代2 可与前中后序相应写法风格相统一，思想是中右左顺序遍历，最后reverse</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        TreeNode* cur= root;</span><br><span class="line">        <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>() || cur!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                stk.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur=cur-&gt;right;  <span class="comment">//注意这里是right,前序是left</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//当访问到最底层时&#123;</span></span><br><span class="line">                <span class="comment">//关键步骤，理解cur的改变</span></span><br><span class="line">                cur=stk.<span class="built_in">top</span>()-&gt;left; <span class="comment">//这里是left，前序是right</span></span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h2><h3 id="从前序和中序遍历序列构造二叉树"><a href="#从前序和中序遍历序列构造二叉树" class="headerlink" title="从前序和中序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">从前序和中序遍历序列构造二叉树</a></h3><p>思路：</p>
<p>（1）明白前序遍历的第一个节点永远是根节点</p>
<p>（2）用哈希表记录中序遍历中每个节点值对应的索引位置</p>
<p>（3）结合（1）（2）可知根节点在中序遍历中的位置，从而可以知道<strong>左子树和右子树的大小</strong></p>
<p>（4）递归地进行左右子树的构建，<strong>函数返回根节点</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;      <span class="comment">//&#123;value, index in inorder array&#125;</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = preorder.<span class="built_in">size</span>();    <span class="comment">//两个数组长度相等</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i!=inorder.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            mp[inorder[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root = <span class="built_in">rebuild</span>(preorder,inorder,<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">rebuild</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; pv,vector&lt;<span class="type">int</span>&gt;&amp; iv,<span class="type">int</span> pl,<span class="type">int</span> pr, <span class="type">int</span> il, <span class="type">int</span> ir)</span></span>&#123;</span><br><span class="line">        <span class="comment">//注意不要落下递归的终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(pr&lt;pl) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//前序遍历的第一个节点即为根节点</span></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(pv[pl]);</span><br><span class="line">        <span class="comment">//在中序遍历中找到对应根节点，即可知道左子树和右子树的大小</span></span><br><span class="line">        <span class="type">int</span> leftsize = mp[pv[pl]] - il;</span><br><span class="line">        root-&gt;left = <span class="built_in">rebuild</span>(pv,iv,pl+<span class="number">1</span>,pl+leftsize,il,il+leftsize<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">rebuild</span>(pv,iv,pl+leftsize+<span class="number">1</span>,pr,il+leftsize+<span class="number">1</span>,ir);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="从中序遍历和后序遍历序列构造二叉树"><a href="#从中序遍历和后序遍历序列构造二叉树" class="headerlink" title="从中序遍历和后序遍历序列构造二叉树"></a>从中序遍历和后序遍历序列构造二叉树</h3><p>思路近似，都是要计算出左右子树的大小，然后进行递归</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;      <span class="comment">//&#123;value, index in inorder array&#125;</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = inorder.<span class="built_in">size</span>();    <span class="comment">//两个数组长度相等</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i!=inorder.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            mp[inorder[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root = <span class="built_in">rebuild</span>(inorder,postorder,<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">rebuild</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; iv,vector&lt;<span class="type">int</span>&gt;&amp; pv,<span class="type">int</span> il,<span class="type">int</span> ir, <span class="type">int</span> pl, <span class="type">int</span> pr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//注意不要落下递归的终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(ir&lt;il) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//后序遍历的最后一个节点即为根节点</span></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(pv[pr]);</span><br><span class="line">        <span class="comment">//在中序遍历中找到对应根节点，即可知道左子树和右子树的大小</span></span><br><span class="line">        <span class="type">int</span> leftsize = mp[pv[pr]] - il;</span><br><span class="line">        root-&gt;left = <span class="built_in">rebuild</span>(iv,pv,il,il+leftsize<span class="number">-1</span>,pl,pl+leftsize<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">rebuild</span>(iv,pv,il+leftsize+<span class="number">1</span>,ir,pl+leftsize,pr<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二叉搜索树中第k小的元素"><a href="#二叉搜索树中第k小的元素" class="headerlink" title="二叉搜索树中第k小的元素"></a>二叉搜索树中第k小的元素</h2><p>给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查<a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/">找其中第 k 个最小元素（从 1 开始计数）</a>。</p>
<p>思路：</p>
<p>（1）要反应过来二叉搜索树的中序遍历即为一个升序数组</p>
<p>（2）取升序数组中的第k个就行</p>
<p>如果要搜索第k大的元素，其实只要调整一下遍历的顺序，先遍历右子树，再遍历左子树即可</p>
<h2 id="二叉树中节点和最大的路径"><a href="#二叉树中节点和最大的路径" class="headerlink" title="二叉树中节点和最大的路径"></a>二叉树中节点和最大的路径</h2><ol>
<li>求二叉树中<a href="https://leetcode-cn.com/problems/jC7MId/"><em>节点之和最大的路径</em></a>，必须至少包含一个节点</li>
</ol>
<p>思路：</p>
<p>（1）关键就是想清楚递归的返回值：应该返回包含当前节点在内的并且最多只包含左右子树其中之一边的最大路径。</p>
<p>（2）在递归的过程中不断更新一个最大路径和，包含当前节点并且可以同时包含左右子树的节点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> maxsum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> lval = <span class="built_in">max</span>(<span class="number">0</span>,<span class="built_in">dfs</span>(root-&gt;left));<span class="comment">//包含根节点root的单条路径的最大值</span></span><br><span class="line">        <span class="type">int</span> rval = <span class="built_in">max</span>(<span class="number">0</span>,<span class="built_in">dfs</span>(root-&gt;right));</span><br><span class="line">        maxsum = <span class="built_in">max</span>(maxsum,root-&gt;val+lval+rval);</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val + <span class="built_in">max</span>(lval,rval);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> maxsum = INT_MIN;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Good questions —— 链表篇</title>
    <url>/2022/03/31/questions03/</url>
    <content><![CDATA[<p>概述：本文记录了刷题过程中与链表相关的优质题目及解题思路</p>
<span id="more"></span>

<h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">反转链表</a></h2><p>（需要完全掌握递归和非递归写法）</p>
<p>（1）迭代</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">迭代方法</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* pre=<span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur=head;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ListNode* temp = cur-&gt;next;  <span class="comment">//暂存后继节点</span></span><br><span class="line">            cur-&gt;next=pre;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;<span class="comment">//注意返回的是pre而不是cur，cur在出循环后是nullptr</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>（2）递归</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">recur</span>(head, <span class="literal">nullptr</span>);           <span class="comment">// 调用递归并返回</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">recur</span><span class="params">(ListNode* cur, ListNode* pre)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) <span class="keyword">return</span> pre;        <span class="comment">// 终止条件</span></span><br><span class="line">        ListNode* res = <span class="built_in">recur</span>(cur-&gt;next, cur); <span class="comment">// 递归后继节点</span></span><br><span class="line">        cur-&gt;next = pre;                       <span class="comment">// 修改节点引用指向</span></span><br><span class="line">        <span class="keyword">return</span> res;                            <span class="comment">// 返回反转链表的头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/">复杂链表的复制</a></h2><p>思路：</p>
<p>（1）哈希表存储所有原节点到新复制的节点的映射</p>
<p>（2）原地复制（在链表每个节点后复制一个新节点），再处理所有的next和random指针，最后断开原链表与新链表之间的连接</p>
<h2 id="重排链表"><a href="#重排链表" class="headerlink" title="重排链表"></a><a href="https://leetcode-cn.com/problems/LGjMqU/">重排链表</a></h2><p>时间O(n), 空间O(1)思想：</p>
<p>（1）找到链表中间节点，并断开</p>
<p>（2）反转后半部分的链表</p>
<p>（3）合并两个链表</p>
<h2 id="k个一组反转链表"><a href="#k个一组反转链表" class="headerlink" title="k个一组反转链表"></a><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/submissions/">k个一组反转链表</a></h2><p>思想：</p>
<p>（1）设计一个反转[head,tail]区间的节点的函数，并<strong>返回反转后的头和尾</strong></p>
<p>（2）注意<strong>保存头结点的前一节点</strong>，用于连接局部反转后的链表</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
