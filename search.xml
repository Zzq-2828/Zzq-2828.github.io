<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>project_in_meituan_06</title>
    <url>/2022/06/23/project-in-meituan-06/</url>
    <content><![CDATA[<p>配置一个白名单功能</p>
<span id="more"></span>

<h3 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h3><p><code>grocerymkthd-interact-mapi-service</code>模块的aop包下：</p>
<p>ConfigMonitorAop类中的collectData和checkData方法都加一个根据MUser过滤的白名单，不收集开发和测试人员的数据。</p>
<h3 id="要点学习"><a href="#要点学习" class="headerlink" title="要点学习"></a>要点学习</h3><p>注意开发的这一部分是一个切面类</p>
<p>表示位于com.sankuai下的所有带<code>@ConfigMonitor</code>注解的方法都作为切点，要织入这个around环绕方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigMonitorAop</span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ConfigMonitorDataService monitorDataService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Around(&quot;execution(public * com.sankuai..*.*(..)) &amp;&amp; @annotation(annotation)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp, ConfigMonitor annotation)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> pjp.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Projects</category>
        <category>MeiTuan</category>
      </categories>
      <tags>
        <tag>MeiTuan</tag>
        <tag>Projects</tag>
      </tags>
  </entry>
  <entry>
    <title>meituan-raptor</title>
    <url>/2022/06/22/meituan-raptor/</url>
    <content><![CDATA[<p>概述：本文简单记录了Raptor服务端的功能和使用规范</p>
<span id="more"></span>

<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Raptor服务端融合改进了CAT和Falcon的功能，提供了java，c&#x2F;c++、node、python、go等多语言客户端，已经在基础架构中间件框架（MVC框架，RPC框架，数据库框架，缓存框架等，消息队列，配置系统等）深度继承，为各业务线提供系统丰富的性能指标、健康状况、实时告警等。</p>
<p>Raptor的优势：</p>
<ul>
<li>Raptor是一个实时系统，大部分系统时分钟级统计，但是从数据生成到服务端处理结束是秒级别；Raptor在一些核心业务指标监控上，支持秒级监控，秒级整体端端延迟10s</li>
<li>监控数据是全量统计，客户端预计算；链路数据是采样计算，大约有5%的项目链路是采样统计</li>
</ul>
<p>Raptor服务端监控主要分为两大类：</p>
<ul>
<li>应用层监控：主要面向的是聚合指标，应用要接入cat-client包，通过cat-client进行埋点上报数据，是一种侵入式监控</li>
<li>系统层监控：主要面向的是非聚合类的时序指标，比如：机器cpu、内存使用率的监控</li>
</ul>
<h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><p>基本使用流程：</p>
<img src="https://pic.imgdb.cn/item/62b2c2c809475431290ccc42.jpg" style="zoom:80%;" />

<ul>
<li>SDK（Software Development Kit，软件开发工具包）埋点接入：Raptor服务端监控通过SDK进行数据埋点</li>
<li>查看监控数据，完成接入后，可在对应网页中查看监控数据：<ul>
<li>Transaction：查看项目中一段代码运行情况数据</li>
<li>Event：查看项目中一段代码运行次数数据</li>
<li>Problem：查看项目在运行过程中出现的问题数据</li>
<li>Business：查看项目业务指标数据</li>
<li>Host：查看项目机器系统指标数据</li>
<li>Stack：查看项目堆栈、jar包信息</li>
</ul>
</li>
</ul>
<p><strong>服务端指标说明</strong></p>
<p>Raptor服务端相关指标包括：Transaction、Event、Metric、Heartbeat等</p>
<ul>
<li><strong>统一框架埋点</strong>：新美大所有的中间件上都继承了Raptor埋点，比如RPC框架Pigeon、Mtthrift，数据访问层框架Zebra，缓存框架Celler、Squirrel，消息中间件Mafka、Swallow等。业务方只需要升级对应监控，并且继承了统一项目命名规范就可以看到中间件访问相关监控</li>
<li><strong>Transaction埋点</strong>：主要记录一些跨项目，跨模块的一些调用，记录一些复杂的比较耗时代码通缉，建议如果是本地代码的Transaction，建议平均执行时间要相对比较长，比如至少超过5ms，不少业务方用了Transaction，基本平均耗时基本都是1ms都不到，可能仅仅只是用统计功能，这个可以用Event来代替，Event相比Transaction开销要很低，并且埋点的代码也更加精简。Transaction支持AppKey、IP、Type、Name四个维度的聚合，统计指标有总数、失败数、成功率、TP90、TP95、TP99等丰富的性能指标。注意Transaction有IP维度的聚合，这样可以根据单台机器看性能指标，很多场景下，机器维度数据是非常有用的。</li>
</ul>
<ul>
<li><strong>Event埋点</strong>： 主要记录用于记录事件。最常见的场景就是当埋Transaction时候，需要Event作为补充，比如记录当时访问参数等。代码一些特殊诡异路径的分析，还有异常信息记录。Event可以解决一些业务统计问题，它更加侧重于业务一些简单统计。Event埋点支持Appkey、IP、Type、Name四个维度的聚合，统计指标相比Transaction少一些，只有总数、失败、以及成功率，Event也支持机器维度的统计。</li>
<li><strong>Metric埋点</strong>： 主要用于记录了一些实际的业务指标，用于运维监控，比如订单量，支付等这类case，Metric侧重于实时，侧重于非常重要关键业务指标，Metric侧重于实时监控，不做统计分析。这边有部分业务将一些某个失败作为一个Metric的指标，后续还想统计这个失败总数等，其实这个非常不适合用Metric来做，这类异常点的统计最好就是封装一个特定场景的业务异常，用logError的api即可。异常可以支持异常告警，也可以根据天等做统计。注意，业务指标没有机器维度的聚合，很大程度上因为业务指标比如订单和具体的某台机器没有关系。Metric业务指标最新版本支持多维度的tag，比如订单指标，可以额外加上来源、渠道等tag，这样当出现问题时候，可以根据来源、渠道等多种选择条件来看业务指标查询。每个Metric允许的多维度的tag乘积总数限制是1w，其实相比于一些faclon的指标上报，多tag一个指标最多可以充当1w个指标情况，每个不同的指标可以支持不一样的tag，这样可以极大解决业务指标监控和分析功能。</li>
<li><strong>Heartbeat</strong>： 是cat客户端主动上报一些jvm等指标，不需要业务埋点。 Heartbeat默认每台机器每分钟上报一次，借助该指标可判断该appkey下正常运行的机器数量。</li>
</ul>
<h3 id="Transaction"><a href="#Transaction" class="headerlink" title="Transaction"></a>Transaction</h3><h4 id="1-主要功能："><a href="#1-主要功能：" class="headerlink" title="1.主要功能："></a><strong>1.主要功能：</strong></h4><p>Transaction主要用于监控一段代码的运行情况：运行次数、QPS、错误次数、失败率、响应时间统计（平均响应时间、Tp9XXX分位值）等等。</p>
<p>应用启动后默认会打点的部分如下，具体打点信息可以参考<a href="https://km.sankuai.com/page/815852655">基础架构组件Raptor打点统计</a>，来源组件非cat的打点问题咨询，可以提TT向各组件部门咨询。</p>
<img src="https://pic.imgdb.cn/item/62b2c4ea09475431290ffad3.jpg" style="zoom:80%;" />

<h4 id="2-报表介绍"><a href="#2-报表介绍" class="headerlink" title="2.报表介绍"></a><strong>2.报表介绍</strong></h4><h5 id="2-1-Transaction统计界面"><a href="#2-1-Transaction统计界面" class="headerlink" title="2.1 Transaction统计界面"></a><strong>2.1 Transaction统计界面</strong></h5><p>Type统计界面展示了一个Transaction的第一层分类的视图(👉 Type统计)，可以知道这段时间里面一个分类运行的次数，平均响应时间，延迟，95线以及99线。</p>
<img src="https://pic.imgdb.cn/item/62b2c71b09475431291355c2.jpg" style="zoom:80%;" />

<p>从上而下分析报表查询功能及Type介绍：</p>
<ol>
<li>输入Appkey，查看项目数据：页面会默认打开上次查看的appkey数据，如果需要切换其他项目数据，输入Appkey，回车即可。</li>
<li>点击切换报表时间类型：小时、天、周、月等维度查看对应时间跨度报表；</li>
<li>在对应时间类型下，切换对应查看的起始时间；或通过快捷按钮【-1小时】、【+1小时】、【当前】进行调整；</li>
<li>可通过选择机器，查看具体机器或指定部分机器的报表；默认为All（即该Appkey的所有机器），还包括单机器、机房、自定义等维度的机器选择；</li>
<li>可选择type类型进行某类数据查看；</li>
<li>报表界面具体展示相应Type的：调用总次数、失败次数、失败率、最大耗时、平均耗时、90线耗时、95线耗时、99线耗时、999线耗时以及QPS信息；</li>
</ol>
<h5 id="2-2-报表分钟级数据查看"><a href="#2-2-报表分钟级数据查看" class="headerlink" title="2.2 报表分钟级数据查看"></a>2.2 报表分钟级数据查看</h5><ol>
<li>点击报表的<strong>【[::show::]】</strong>可查看该Type的分钟级数据统计。</li>
</ol>
<img src="https://pic.imgdb.cn/item/62b2c76b094754312913c5e7.jpg" style="zoom:80%;" />

<ol start="2">
<li>分钟级统计主要包括：耗时分布、分钟级调用量、分钟平均耗时、分钟成功率、分钟最大耗时、分钟失败数、调用量机器分布、错误量机器分布以及机器维护报表；如下图：</li>
</ol>
<img src="https://pic.imgdb.cn/item/62b2c79d09475431291409b0.jpg" style="zoom:80%;" />

<img src="https://pic.imgdb.cn/item/62b2c7b80947543129142f2d.jpg" style="zoom:80%;" />

<img src="https://pic.imgdb.cn/item/62b2c7cf0947543129145691.jpg" style="zoom:80%;" />

<h5 id="2-3-查看Type下二级分类数据"><a href="#2-3-查看Type下二级分类数据" class="headerlink" title="2.3 查看Type下二级分类数据"></a>2.3 查看Type下二级分类数据</h5><ol>
<li>点击对应<strong>Type的名称</strong>，可查看该Type下的二级分类（Name）数据</li>
</ol>
<img src="https://pic.imgdb.cn/item/62b2cbf409475431291a6f23.jpg" style="zoom:80%;" />

<ol start="2">
<li>Transaction的埋点的Type和Name由业务自己定义，当打点了Cat.newTransaction(type, name)时，第一层分类是type，第二级分类是name；</li>
<li>第二级分类数据是统计相同type下的所有name数据，点开展示界面的数据均与第一级（type）一样的展示风格。</li>
</ol>
<h5 id="2-4-LogView数据查看"><a href="#2-4-LogView数据查看" class="headerlink" title="2.4 LogView数据查看"></a>2.4 LogView数据查看</h5><p>点击LogView下的【L】最新、【S】最慢可查看当前时间段最新或最慢的一条链路日志信息，如下图：</p>
<h3 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h3><h4 id="1-主要功能：-1"><a href="#1-主要功能：-1" class="headerlink" title="1.主要功能："></a><strong>1.主要功能：</strong></h4><p>监控一段代码运行次数：例如记录程序中一个事件记录了多少次，错误了多少次。Event报表的整体结构与Transaction报表几乎一样，<u>只缺少响应时间的统计</u>。</p>
<p>应用启动后默认会打点的部分如下，具体打点信息可以参考<a href="https://km.sankuai.com/page/815852655">基础架构组件Raptor打点统计</a>，来源组件非cat的打点问题咨询，可以提TT向各组件部门咨询。</p>
<h4 id="2-报表介绍-1"><a href="#2-报表介绍-1" class="headerlink" title="2.报表介绍"></a><strong>2.报表介绍</strong></h4><h5 id="2-1-数据统计逻辑"><a href="#2-1-数据统计逻辑" class="headerlink" title="2.1 数据统计逻辑"></a><strong>2.1 数据统计逻辑</strong></h5><p><strong>第一级分类（Type）统计界面</strong></p>
<p>Type统计界面展示了一个Event的第一层分类的视图(👉 Type统计)，Event相对于Transaction少了运行时间统计。可以知道这段时间里面一个分类运行的次数，失败次数，失败率，采样logView，QPS。</p>
<p><strong>第二级分类（Name）统计界面</strong></p>
<p>第二级分类在Type统计界面中点击具体的Type进入，具体视图(👉 Name统计)，展示的是相同type下所有的name数据，可以理解为某type下更细化的分类。</p>
<h5 id="2-2-界面功能详细介绍"><a href="#2-2-界面功能详细介绍" class="headerlink" title="2.2 界面功能详细介绍"></a>2.2 界面功能详细介绍</h5><p>从上而下分析报表查询功能及Type介绍：</p>
<ol>
<li>输入Appkey，查看项目数据：页面会默认打开上次查看的appkey数据，如果需要切换其他项目数据，输入Appkey，回车即可；</li>
<li>数据粒度时间筛选<ol>
<li>点击切换报表时间类型：小时、天、周、月等维度查看对应时间跨度报表；</li>
<li>在对应时间类型下，切换对应查看的起始时间；或通过快捷按钮【-1小时】、【+1小时】、【当前】进行调整；</li>
</ol>
</li>
<li>机器分组：默认已机房对机器进行分组，支持自定义分组；</li>
<li>可通过选择机器，查看具体机器或指定部分机器的报表；默认为All（即该Appkey的所有机器），还包括单机器、机房、自定义等维度的机器选择；</li>
<li>报表界面具体展示相应Type的：调用总次数、失败次数、失败率以及QPS信息；</li>
</ol>
<h5 id="2-3-报表分钟级数据查看"><a href="#2-3-报表分钟级数据查看" class="headerlink" title="2.3 报表分钟级数据查看"></a>2.3 报表分钟级数据查看</h5><p>1.点击报表的【[::show::]】可查看该Type的分钟级数据统计</p>
<p>2.分钟级统计主要包括：分钟级调用量、分钟失败数、调用量机器分布、错误量机器分布以及机器维护报表；</p>
<h5 id="2-4-查看Type下二级分类数据"><a href="#2-4-查看Type下二级分类数据" class="headerlink" title="2.4 查看Type下二级分类数据"></a>2.4 查看Type下二级分类数据</h5><ol>
<li>点击对应Type的名称，可查看该Type下的二级分类（Name）数据：</li>
<li>Event的埋点的Type和Name由业务自己定义，当打点了Cat.newEvent(type, name)时，第一层分类是type，第二级分类是name；</li>
<li>第二级分类数据是统计相同type下的所有name数据，点开展示界面的数据均与第一级（type）一样的展示风格</li>
</ol>
<h5 id="2-5-LogView数据查看"><a href="#2-5-LogView数据查看" class="headerlink" title="2.5 LogView数据查看"></a>2.5 LogView数据查看</h5><p>点击LogView下的【Logview】查看当前时间段最新的一条链路日志信息</p>
<h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p><strong>主要功能</strong></p>
<p>Problem记录整个项目在运行过程中出现的问题，包括一些异常、错误、访问较长的行为。Problem报表是由logview存在的特征整合而成，方便用户定位问题。</p>
<p>来源：</p>
<ol>
<li>业务代码显示调用Cat.logError(e) API进行埋点，具体埋点说明可查看埋点文档。</li>
<li>中间件框架埋点，如SQL出错、RPC调用出错等。</li>
<li>long-sql、long-cache等耗时较长系列。</li>
<li>与LOG集成，会捕获log日志中有异常堆栈的exception日志。<a href="https://docs.sankuai.com/dp/arch/cat/master/integration/java/#6log">cat-appender集成LOG</a></li>
</ol>
<p><strong>报表介绍</strong></p>
<p>Problem报表展示项目相关异常信息及统计，选择【Problem】标签页，项目、时间、机器选择同Transaction报表，如下图：</p>
<img src="https://pic.imgdb.cn/item/62b325290947543129a16126.jpg" style="zoom:80%;" />

<ol>
<li>选择Problem错误类型，All为展示所有错误，也可选择某一个错误类型type展示。</li>
<li>对于较长耗时，也认为是problem错误，cat已经接入公司绝大多数组件，现支持url、sql、service(远程服务)、call(远程调用)、cache(缓存接口调用)、mq(消息队列)，可以选择不同的耗时阈值。</li>
<li>选择错误的时间展示维度，默认为小时维度；分钟级分布可以查看某一分钟的所有错误分布统计，如下图：</li>
</ol>
<img src="https://pic.imgdb.cn/item/62b3255c0947543129a1bf78.jpg" style="zoom:80%;" />

<ol start="4">
<li>点击【[:::show:]】可查看分钟级错误分布以及机器维度分布；如下图：</li>
</ol>
<img src="https://pic.imgdb.cn/item/62b328c10947543129a7b200.jpg" style="zoom:80%;" />

<p>对于机器分布，在时间轴上可选择开始、结束分钟数，可以看到这段时间内的机器错误分布。 同时，除了机器错误分布，还可展示机房错误分布，如yp表示月浦、dx表示大兴。业务方可通过机房错误分布check是否是机房影响。</p>
<h3 id="Business"><a href="#Business" class="headerlink" title="Business"></a>Business</h3><p>Business监控为您提供了自定义监控项和报警规则的功能；</p>
<p>您可以通过上报监控数据接口，将自己关心的业务指标上报至Raptor监控，并在Raptor监控上配置、添加监控图表和设置报警规则，对于故障指标发送报警通知，便于您及时处理故障，保障业务的正常运行。</p>
<img src="https://pic.imgdb.cn/item/62b3298b0947543129a90574.jpg" style="zoom:80%;" />

<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><img src="https://pic.imgdb.cn/item/62b33c1c0947543129c4beb1.jpg" style="zoom:80%;" />

<ul>
<li><p>AppKey：应用的唯一key</p>
</li>
<li><p>BusinessKey：业务指标；business包括普通指标、复合指标两种类型的指标；</p>
<ul>
<li>普通指标：直接由业务上报数据生成的指标；</li>
<li>复合指标：有多个“普通指标”通过表达式组合而成的指标；</li>
</ul>
</li>
<li><p>Tag：business指标的维度，每个指标可以包括最多20个tag；</p>
<p>举例：比如一个订单，可以包括status维度（成功、失败、待付款等等）、category维度（母婴、女装、男装等等）、source维度、chennel维度等等；</p>
</li>
<li><p>TagValue：Tag对应的值；business指标的每个维度Tag，可以包括多个具体的维度值；</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Tools</category>
        <category>MeiTuan</category>
      </categories>
      <tags>
        <tag>MeiTuan</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>Interview-Network</title>
    <url>/2022/06/22/Interview-Network/</url>
    <content><![CDATA[<p>本文对计算机网络的基础知识做了一些梳理和总结（主要针对面试中常见的一些问题）</p>
<span id="more"></span>

<h3 id="1-网络分层模型"><a href="#1-网络分层模型" class="headerlink" title="1. 网络分层模型"></a>1. 网络分层模型</h3><p>OSI七层模型（Open Systems Interconnection）和五层模型：</p>
<img src="https://pic.imgdb.cn/item/62b1f38d09475431292a933a.jpg" style="zoom:80%;" />

<p><strong>七层模型中各层的功能简要概述</strong>：</p>
<ul>
<li>物理层：底层数据传输（比特流形式），如网线；网卡标准。</li>
<li>数据链路层：定义数据的基本格式，如何传输，如何标识；如网卡MAC地址。管理相邻节点之间的数据通信</li>
<li>网络层：定义IP编址，定义路由功能（路由和寻址）；如不同设备的数据转发。</li>
<li>传输层：端到端传输数据的基本功能；如 TCP、UDP。</li>
<li>会话层：控制（建立、维护、重连）应用程序之间会话能力；如不同软件数据分发给不同软件。</li>
<li>表示层：数据处理（编解码、加密解密、压缩解压缩）。</li>
<li>应用层：各种应用软件，包括 Web 应用。为计算机用户提供服务</li>
</ul>
<p><strong>说明</strong></p>
<ul>
<li>在四层，既传输层数据被称作<strong>段</strong>（Segments）；</li>
<li>三层网络层数据被称做<strong>包</strong>（Packages）；</li>
<li>二层数据链路层时数据被称为<strong>帧</strong>（Frames）；</li>
<li>一层物理层时数据被称为<strong>比特流</strong>（Bits）。</li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li>网络七层模型是一个标准，而非实现。</li>
<li>网络四层模型是一个实现的应用模型。</li>
<li>网络四层模型由七层模型简化合并而来。</li>
</ul>
<p><strong>应用层常见协议：</strong></p>
<img src="https://pic.imgdb.cn/item/62b1f7ac0947543129324b3c.jpg" style="zoom:80%;" />

<p><strong>网络层常见协议：</strong></p>
<img src="https://pic.imgdb.cn/item/62b1f9520947543129353bf0.jpg" style="zoom:80%;" />

<p><strong>数据链路层常见协议：</strong></p>
<img src="https://pic.imgdb.cn/item/62b1f98609475431293596d6.jpg" style="zoom:80%;" />

<h3 id="2-DNS"><a href="#2-DNS" class="headerlink" title="2. DNS"></a>2. DNS</h3><p><strong>DNS是什么？</strong></p>
<p><strong>官方解释</strong>：DNS（<strong>Domain Name System，域名系统</strong>），本质上是因特网上作为域名和IP地址相互映射的一个分布式数据库（数据库中记录了域名和IP的对应关系），能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。同时也是一种用于客户端和服务端通讯的应用层的计算机网络协议。</p>
<p>通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。</p>
<p>通俗的讲，我们更习惯于记住一个网站的名字，比如<a href="http://www.baidu.com,而不是记住它的ip地址，比如：167.23.10.2。">www.baidu.com,而不是记住它的ip地址，比如：167.23.10.2。</a></p>
<p><strong>DNS的工作原理？</strong></p>
<p>将主机域名转换为ip地址，属于应用层协议，使用UDP传输。（DNS应用层协议，以前有个考官问过）</p>
<img src="https://pic.imgdb.cn/item/62b1fb36094754312938537b.jpg" style="zoom:67%;" />

<p>总结： 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。 </p>
<p>一、<strong>主机向本地域名服务器的查询一般都是采用递归查询</strong>。</p>
<p>二、<strong>本地域名服务器向根域名服务器的查询的迭代查询</strong>。</p>
<p>1)当用户输入域名时，浏览器先检查自己的缓存中是否 这个域名映射的ip地址，有解析结束。 </p>
<p>2）若没命中，则检查操作系统缓存（如Windows的hosts）中有没有解析过的结果，有解析结束。</p>
<p>3）若无命中，则请求本地域名服务器解析（ LDNS）。 </p>
<p>4）若LDNS没有命中就直接跳到根域名服务器请求解析。根域名服务器返回给LDNS一个 主域名服务器地址。</p>
<p>5） 此时LDNS再发送请求给上一步返回的gTLD（ 通用顶级域）， 接受请求的gTLD查找并返回这个域名对应的Name Server的地址 </p>
<p>6） Name Server根据映射关系表找到目标ip，返回给LDNS </p>
<p>7） LDNS缓存这个域名和对应的ip， 把解析的结果返回给用户，用户根据TTL值缓存到本地系统缓存中，域名解析过程至此结</p>
<p><strong>为什么域名解析用UDP协议？</strong></p>
<p>因为UDP很快，<strong>UDP的DNS协议只要一个请求、一个应答就好了</strong>。</p>
<p>而使用基于TCP的DNS协议要三次握手、发送数据以及应答、四次挥手，但是UDP协议传输内容不能超过512字节。</p>
<p>不过客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。</p>
<p><strong>为什么区域传送用TCP协议？</strong></p>
<p>（DNS区域传送（DNS zone transfer）指的是一台备用服务器使用来自主服务器的数据刷新自己的域（zone）数据库，目的是为了做冗余备份，防止主服务器出现故障时 dns 解析不可用。）</p>
<p>因为TCP协议可靠性好。</p>
<p>要从主DNS上复制内容，不能用不可靠的UDP。 因为TCP协议传输的内容大，如果使用UDP，最大只能传512字节。如果同步的数据大于512字节就没有办</p>
<p><strong>DNS的解析过程：</strong></p>
<img src="https://pic.imgdb.cn/item/62b1fbf00947543129396cc5.jpg" style="zoom: 80%;" />

<ul>
<li>请求一旦发起，若是chrome浏览器，先在浏览器找之前<strong>有没有缓存过的域名所对应的ip地址</strong>，有的话，直接跳过dns解析了，若是没有，就会<strong>找硬盘的hosts文件</strong>，看看有没有，有的话，直接找到hosts文件里面的ip</li>
<li>如果本地的hosts文件没有能得到对应的ip地址，浏览器会发出一个<strong>dns请求到本地dns服务器</strong>，<strong>本地dns服务器一般都是你的网络接入服务器商提供</strong>，比如中国电信，中国移动等。</li>
<li>查询你输入的网址的DNS请求到达本地DNS服务器之后，<strong>本地DNS服务器会首先查询它的缓存记录</strong>，如果缓存中有此条记录，就可以直接返回结果，此过程是<strong>递归的方式进行查询</strong>。如果没有，本地DNS服务器还要向<strong>DNS根服务器</strong>进行查询。</li>
<li>本地DNS服务器继续向域服务器发出请求，在这个例子中，请求的对象是.com域服务器。.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址。</li>
<li>最后，本地DNS服务器向<strong>域名的解析服务器</strong>发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。</li>
</ul>
<p><strong>DNS负载均衡策略</strong></p>
<p>当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会崩掉。处理办法就是用DNS负载均衡技术，它的原理是在<strong>DNS服务器中为同一个主机名配置多个IP地址,在应答DNS查询时,DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器</strong>,从而达到负载均衡的目的｡例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。</p>
<h3 id="3-HTTP和HTTPS"><a href="#3-HTTP和HTTPS" class="headerlink" title="3. HTTP和HTTPS"></a>3. HTTP和HTTPS</h3><h4 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h4><p><strong>HTTP 协议介绍</strong></p>
<p>HTTP 协议，全称超文本传输协议（Hypertext Transfer Protocol）。顾名思义，HTTP 协议就是用来规范超文本的传输，超文本，也就是网络上的包括文本在内的各式各样的消，具体来说，主要是来规范浏览器和服务器端的行为的。</p>
<p>并且，HTTP 是一个无状态（stateless）协议，也就是说服务器不维护任何有关客户端过去所发请求的消息。这其实是一种懒政，有状态协议会更加复杂，需要维护状态（历史信息），而且如果客户或服务器失效，会产生状态的不一致，解决这种不一致的代价更高。</p>
<p><strong>HTTP 协议通信过程</strong></p>
<p>HTTP 是应用层协议，它以 TCP（传输层）作为底层协议，默认端口为 80. 通信过程主要如下：</p>
<ol>
<li>服务器在 <u>80 端口</u>等待客户的请求。</li>
<li>浏览器发起到服务器的 TCP 连接（创建套接字 Socket）。</li>
<li>服务器接收来自浏览器的 TCP 连接。</li>
<li>浏览器（HTTP 客户端）与 Web 服务器（HTTP 服务器）交换 HTTP 消息。</li>
<li>关闭 TCP 连接。</li>
</ol>
<p><strong>HTTP 协议优点</strong></p>
<p>扩展性强、速度快、跨平台支持性好。</p>
<h4 id="HTTPS-协议"><a href="#HTTPS-协议" class="headerlink" title="HTTPS 协议"></a>HTTPS 协议</h4><p><strong>HTTPS 协议介绍</strong></p>
<p>HTTPS 协议（Hyper Text Transfer Protocol Secure），是 HTTP 的加强安全版本。HTTPS 是基于 HTTP 的，也是用 TCP 作为底层协议，并额外使用 SSL&#x2F;TLS 协议用作加密和安全认证。<u>默认端口号是 443</u>.</p>
<p>HTTPS 协议中，SSL 通道通常使用基于密钥的加密算法，密钥长度通常是 40 比特或 128 比特。</p>
<p><strong>HTTPS 协议优点</strong></p>
<p>保密性好、信任度高。</p>
<h4 id="HTTPS-的核心—SSL-x2F-TLS协议"><a href="#HTTPS-的核心—SSL-x2F-TLS协议" class="headerlink" title="HTTPS 的核心—SSL&#x2F;TLS协议"></a>HTTPS 的核心—SSL&#x2F;TLS协议</h4><p>HTTPS 之所以能达到较高的安全性要求，就是结合了 SSL&#x2F;TLS 和 TCP 协议，对通信数据进行加密，解决了 HTTP 数据透明的问题。接下来重点介绍一下 SSL&#x2F;TLS 的工作原理。</p>
<p><strong>SSL 和 TLS 的区别？</strong></p>
<p><u>SSL 和 TLS 没有太大的区别。</u></p>
<p>SSL 指安全套接字协议（Secure Sockets Layer），首次发布与 1996 年。SSL 的首次发布其实已经是他的 3.0 版本，SSL 1.0 从未面世，SSL 2.0 则具有较大的缺陷（DROWN 缺陷——Decrypting RSA with Obsolete and Weakened eNcryption）。很快，在 1999 年，SSL 3.0 进一步升级，<strong>新版本被命名为 TLS 1.0</strong>。因此，TLS 是基于 SSL 之上的，但由于习惯叫法，通常把 HTTPS 中的核心加密协议混成为 SSL&#x2F;TLS。</p>
<p><strong>SSL&#x2F;TLS 的工作原理</strong></p>
<ul>
<li><u>非对称加密</u></li>
</ul>
<p>SSL&#x2F;TLS 的核心要素是<strong>非对称加密</strong>。非对称加密采用两个密钥——一个公钥，一个私钥。在通信时，私钥仅由解密者保存，公钥由任何一个想与解密者通信的发送者（加密者）所知。可以设想一个场景，</p>
<blockquote>
<p>在某个自助邮局，每个通信信道都是一个邮箱，每一个邮箱所有者都在旁边立了一个牌子，上面挂着一把钥匙：这是我的公钥，发送者请将信件放入我的邮箱，并用公钥锁好。</p>
<p>但是公钥只能加锁，并不能解锁。解锁只能由邮箱的所有者——因为只有他保存着私钥。</p>
<p>这样，通信信息就不会被其他人截获了，这依赖于私钥的保密性。</p>
</blockquote>
<img src="https://pic.imgdb.cn/item/62b2003a09475431293fb2d8.jpg" style="zoom: 50%;" />

<p>非对称加密的公钥和私钥需要采用一种复杂的数学机制生成（密码学认为，为了较高的安全性，尽量不要自己创造加密方案）。公私钥对的生成算法依赖于单向陷门函数。</p>
<blockquote>
<p>单向函数：已知单向函数 f，给定任意一个输入 x，易计算输出 y&#x3D;f(x)；而给定一个输出 y，假设存在 f(x)&#x3D;y，很难根据 f 来计算出 x。</p>
<p>单向陷门函数：一个较弱的单向函数。已知单向陷门函数 f，陷门 h，给定任意一个输入 x，易计算出输出 y&#x3D;f(x;h)；而给定一个输出 y，假设存在 f(x;h)&#x3D;y，很难根据 f 来计算出 x，但可以根据 f 和 h 来推导出 x。</p>
</blockquote>
<img src="https://pic.imgdb.cn/item/62b2008f0947543129402626.jpg" style="zoom: 33%;" />

<p>在这里，函数 f 的计算方法相当于公钥，陷门 h 相当于私钥。公钥 f 是公开的，任何人对已有输入，都可以用 f 加密，而要想根据加密信息还原出原信息，必须要有私钥才行。</p>
<ul>
<li><u>对称加密</u></li>
</ul>
<p>使用 SSL&#x2F;TLS 进行通信的双方需要使用非对称加密方案来通信，但是非对称加密设计了较为复杂的数学算法，在实际通信过程中，计算的代价较高，效率太低，因此，SSL&#x2F;TLS 实际对消息的加密使用的是对称加密。</p>
<blockquote>
<p>对称加密：通信双方共享唯一密钥 k，加解密算法已知，加密方利用密钥 k 加密，解密方利用密钥 k 解密，保密性依赖于密钥 k 的保密性。</p>
</blockquote>
<img src="https://pic.imgdb.cn/item/62b200f7094754312940b4f5.jpg" style="zoom:50%;" />

<p>对称加密的密钥生成代价比公私钥对的生成代价低得多，那么有的人会问了，为什么 SSL&#x2F;TLS 还需要使用非对称加密呢？因为对称加密的保密性完全依赖于密钥的保密性。在双方通信之前，需要商量一个用于对称加密的密钥。我们知道网络通信的信道是不安全的，传输报文对任何人是可见的，密钥的交换肯定不能直接在网络信道中传输。因此，使用非对称加密，对对称加密的密钥进行加密，保护该密钥不在网络信道中被窃听。这样，通信双方只需要一次非对称加密，交换对称加密的密钥，在之后的信息通信中，使用绝对安全的密钥，对信息进行对称加密，即可保证传输消息的保密性。</p>
<p><strong>公钥传输的信赖性</strong></p>
<p>SSL&#x2F;TLS 介绍到这里，了解信息安全的朋友又会想到一个安全隐患，设想一个下面的场景：</p>
<blockquote>
<p>客户端 C 和服务器 S 想要使用 SSL&#x2F;TLS 通信，由上述 SSL&#x2F;TLS 通信原理，C 需要先知道 S 的公钥，而 S 公钥的唯一获取途径，就是把 S 公钥在网络信道中传输。要注意网络信道通信中有几个前提：</p>
<ol>
<li>任何人都可以捕获通信包</li>
<li>通信包的保密性由发送者设计</li>
<li>保密算法设计方案默认为公开，而（解密）密钥默认是安全的</li>
</ol>
<p>因此，假设 S 公钥不做加密，在信道中传输，那么很有可能存在一个攻击者 A，发送给 C 一个诈包，假装是 S 公钥，其实是诱饵服务器 AS 的公钥。当 C 收获了 AS 的公钥（却以为是 S 的公钥），C 后续就会使用 AS 公钥对数据进行加密，并在公开信道传输，那么 A 将捕获这些加密包，用 AS 的私钥解密，就截获了 C 本要给 S 发送的内容，而 C 和 S 二人全然不知。</p>
<p>同样的，S 公钥即使做加密，也难以避免这种信任性问题，C 被 AS 拐跑了！</p>
</blockquote>
<img src="https://pic.imgdb.cn/item/62b201680947543129415942.jpg" style="zoom: 80%;" />

<p>为了公钥传输的信赖性问题，第三方机构应运而生——证书颁发机构（CA，Certificate Authority）。CA 默认是受信任的第三方。CA 会给各个服务器颁发证书，证书存储在服务器上，并附有 CA 的<strong>电子签名</strong>（见下节）。</p>
<p>当客户端（浏览器）向服务器发送 HTTPS 请求时，一定要先获取目标服务器的证书，并根据证书上的信息，检验证书的合法性。一旦客户端检测到证书非法，就会发生错误。客户端获取了服务器的证书后，由于证书的信任性是由第三方信赖机构认证的，而证书上又包含着服务器的公钥信息，客户端就可以放心的信任证书上的公钥就是目标服务器的公钥。</p>
<p><strong>数字签名</strong></p>
<p>好，到这一小节，已经是 SSL&#x2F;TLS 的尾声了。上一小节提到了数字签名，数字签名要解决的问题，是防止证书被伪造。第三方信赖机构 CA 之所以能被信赖，就是 <strong>靠数字签名技术</strong> 。</p>
<p>数字签名，是 CA 在给服务器颁发证书时，使用散列+加密的组合技术，在证书上盖个章，以此来提供验伪的功能。具体行为如下：</p>
<blockquote>
<p>CA 知道服务器的公钥，对该公钥采用散列技术生成一个摘要。CA 使用 CA 私钥对该摘要进行加密，并附在证书下方，发送给服务器。</p>
<p>现在服务器将该证书发送给客户端，客户端需要验证该证书的身份。客户端找到第三方机构 CA，获知 CA 的公钥，并用 CA 公钥对证书的签名进行解密，获得了 CA 生成的摘要。</p>
<p>客户端对证书数据（也就是服务器的公钥）做相同的散列处理，得到摘要，并将该摘要与之前从签名中解码出的摘要做对比，如果相同，则身份验证成功；否则验证失败。</p>
</blockquote>
<img src="https://pic.imgdb.cn/item/62b202ad0947543129436674.jpg" style="zoom:80%;" />

<p>总结来说，带有证书的公钥传输机制如下：</p>
<ol>
<li>设有服务器 S，客户端 C，和第三方信赖机构 CA。</li>
<li>S 信任 CA，CA 是知道 S 公钥的，CA 向 S 颁发证书。并附上 CA 私钥对消息摘要的加密签名。</li>
<li>S 获得 CA 颁发的证书，将该证书传递给 C。</li>
<li>C 获得 S 的证书，信任 CA 并知晓 CA 公钥，使用 CA 公钥对 S 证书上的签名解密，同时对消息进行散列处理，得到摘要。比较摘要，验证 S 证书的真实性。</li>
<li>如果 C 验证 S 证书是真实的，则信任 S 的公钥（在 S 证书中）。</li>
</ol>
<img src="https://pic.imgdb.cn/item/62b204dd0947543129469c6f.jpg" style="zoom:67%;" />

<h4 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h4><p>客户端发送的 请求报文 第一行为请求行，包含了方法字段。</p>
<p>根据 HTTP 标准，HTTP 请求可以使用多种请求方法。</p>
<p><strong>HTTP1.0</strong> 定义了三种请求方法： GET, POST 和 HEAD方法。</p>
<p><strong>HTTP1.1</strong> 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。</p>
<img src="https://pic.imgdb.cn/item/62b4a0bb09475431298cbe10.jpg" style="zoom:80%;" />

<p>GET和POST的区别：</p>
<ol>
<li><p>get是获取数据，post是修改数据</p>
</li>
<li><p>get把请求的数据放在url上， 以?分割URL和传输数据，参数之间以&amp;相连，所以get不太安全。而post把数据放在HTTP的包体内（requrest body）</p>
</li>
<li><p>get提交的数据最大是2k（ 限制实际上取决于浏览器）， post理论上没有限制。</p>
</li>
<li><p>GET产生一个TCP数据包，浏览器会把http header和data一并发送出去，服务器响应200(返回数据); POST产生两个TCP数据包，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。</p>
</li>
<li><p>GET请求会被浏览器主动缓存，而POST不会，除非手动设置。</p>
</li>
<li><p>本质区别：GET是幂等的，而POST不是幂等的</p>
<blockquote>
<p>这里的幂等性：幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一URL的多个请求应该返回同样的结果。</p>
</blockquote>
</li>
</ol>
<p>正因为它们有这样的区别，所以不应该且<strong>不能用get请求做数据的增删改这些有副作用的操作</strong>。因为get请求是幂等的，<strong>在网络不好的隧道中会尝试重试</strong>。如果用get请求增数据，会有<strong>重复操作</strong>的风险，而这种重复操作可能会导致副作用（浏览器和操作系统并不知道你会用get请求去做增操作）。</p>
<h4 id="请求和响应报文字段"><a href="#请求和响应报文字段" class="headerlink" title="请求和响应报文字段"></a>请求和响应报文字段</h4><p>Request：</p>
<ul>
<li>请求行：Request Line</li>
<li>请求头：Request Headers</li>
<li>请求体：Request Body</li>
</ul>
<p>Response：</p>
<ul>
<li>状态行：Status Line</li>
<li>响应头：Response Headers</li>
<li>响应体：Response Body</li>
</ul>
<h4 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h4><p><strong>常见的HTTP状态码有哪些？</strong></p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>类别</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>1XX</td>
<td>Informational（信息性状态码）</td>
<td>接收的请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td>Success（成功状态码）</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td>Redirection（重定向状态码）</td>
<td>需要进行附加操作以完成请求</td>
</tr>
<tr>
<td>4XX</td>
<td>Client Error（客户端错误状态码）</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td>Server Error（服务器错误状态码）</td>
<td>服务器处理请求出</td>
</tr>
</tbody></table>
<p><strong>1xx 信息</strong></p>
<ul>
<li><strong>100 Continue</strong> ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</li>
</ul>
<p><strong>2xx 成功</strong></p>
<ul>
<li><strong>200 OK</strong></li>
<li><strong>204 No Content</strong> ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</li>
<li><strong>206 Partial Content</strong> ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。</li>
</ul>
<p><strong>3xx 重定向</strong></p>
<ul>
<li><strong>301 Moved Permanently</strong> ：永久性重定向</li>
<li><strong>302 Found</strong> ：临时性重定向</li>
<li><strong>303 See Other</strong> ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。</li>
<li><strong>304 Not Modified</strong> ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</li>
<li><strong>307 Temporary Redirect</strong> ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</li>
</ul>
<p><strong>4xx 客户端错误</strong></p>
<ul>
<li><strong>400 Bad Request</strong> ：请求报文中存在语法错误。</li>
<li><strong>401 Unauthorized</strong> ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</li>
<li><strong>403 Forbidden</strong> ：请求被拒绝。</li>
<li><strong>404 Not Found</strong></li>
</ul>
<p><strong>5xx 服务器错误</strong></p>
<ul>
<li><strong>500 Internal Server Error</strong> ：服务器正在执行请求时发生错误。</li>
<li><strong>503 Service Unavailable</strong> ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li>
</ul>
<h4 id="HTTP1-0和HTTP1-1区别"><a href="#HTTP1-0和HTTP1-1区别" class="headerlink" title="HTTP1.0和HTTP1.1区别"></a>HTTP1.0和HTTP1.1区别</h4><ol>
<li><strong>连接方式</strong> : HTTP 1.0 为短连接，HTTP 1.1 支持长连接。</li>
<li><strong>状态响应码</strong> : HTTP&#x2F;1.1中新加入了大量的状态码，光是错误响应状态码就新增了24种。比如说，<code>100 (Continue)</code>——在请求大资源前的预热请求，<code>206 (Partial Content)</code>——范围请求的标识码，<code>409 (Conflict)</code>——请求与当前资源的规定冲突，<code>410 (Gone)</code>——资源已被永久转移，而且没有任何已知的转发地址。</li>
<li><strong>缓存处理</strong> : 在 HTTP1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。</li>
<li><strong>带宽优化及网络连接的使用</strong> :HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>
<li><strong>Host头处理</strong> : HTTP&#x2F;1.1在请求头中加入了<code>Host</code>字段。</li>
</ol>
<h3 id="4-TCP"><a href="#4-TCP" class="headerlink" title="4. TCP"></a>4. TCP</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p><u>本质的目的：为了建立可靠的通讯信道，保证服务器端和客户端的发送和接收能力都是正常的</u></p>
<p>过程：</p>
<p>刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态，进行三次握手：</p>
<ul>
<li><p>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 <code>SYN_SEND</code> 状态。</p>
<p>首部的同步位SYN&#x3D;1，初始序号seq&#x3D;x，SYN&#x3D;1的报文段不能携带数据，但要消耗掉一个序号。</p>
</li>
<li><p>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 <code>SYN_RCVD</code> 的状态。</p>
<p>在确认报文段中SYN&#x3D;1，ACK&#x3D;1，确认号ack&#x3D;x+1，初始序号seq&#x3D;y。</p>
</li>
<li><p>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 <code>ESTABLISHED</code> 状态。服务器收到 ACK 报文之后，也处于 <code>ESTABLISHED</code> 状态，此时，双方已建立起了连接。</p>
<p>确认报文段ACK&#x3D;1，确认号ack&#x3D;y+1，序号seq&#x3D;x+1（初始为seq&#x3D;x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。</p>
</li>
</ul>
<p>发送第一个SYN的一端将执行主动打开（active open），接收这个SYN并发回下一个SYN的另一端执行被动打开（passive open）。</p>
<p>在socket编程中，客户端执行connect()时，将触发三次握手。</p>
<img src="https://pic.imgdb.cn/item/62b4a88b09475431299a7189.jpg" style="zoom:80%;" />

<p><strong>为什么需要三次握手而不是两次</strong></p>
<p>弄清这个问题，我们需要先弄明白三次握手的目的是什么，能不能只用两次握手来达到同样的目的。</p>
<ul>
<li>第一次握手：客户端发送网络包，服务端收到了。 这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</li>
<li>第二次握手：服务端发包，客户端收到了。 这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</li>
<li>第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</li>
</ul>
<p>因此，需要三次握手才能确认双方的接收与发送能力是否正常。</p>
<p>试想如果是用两次握手，则会出现下面这种情况：</p>
<blockquote>
<p>如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在<strong>某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端</strong>，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。</p>
</blockquote>
<p><strong>三次握手的缺点</strong>——实际上就是TCP协议的缺点：</p>
<p>慢，效率低，占用系统资源高，易被攻击。而且要在每台设备上维护所有的传输连接，事实上，每个连接都会占用系统的CPU、内存等硬件资源。</p>
<p>另外，TCP的三次握手机制，导致TCP容易被人利用，实现DOS、DDOS、CC等攻击。</p>
<ul>
<li><p><strong>DOS攻击：</strong></p>
<p>DoS是“Denial of Service”的简称，中文意思即“拒绝服务”，造成DoS的攻击行为被称为“DoS攻击”，其目的是使计算机&#x2F;服务器或网络无法提供正常的服务。最常见的DoS攻击有“计算机网络的带宽攻击”和“连通性攻击”。</p>
<p>DoS攻击是利用TCP协议“三次握手”的缺陷进行的。当黑客要进行DoS攻击时，他会操纵很多僵尸主机向被攻击的服务器发送SYN数据包，当服务器回复ACK确认包后，僵尸主机则不再回应，这样服务器就会保持这种“半连接”的状态进行等待。每一个这样的“半连接”状态，都会耗费服务器的资源，如果有数量极大的“半连接”，服务器就会停止正常工作了。</p>
</li>
<li><p><strong>DDOS攻击：</strong></p>
<p>DDoS( 英文全称： Distributed Denial of Service，缩写：DDoS )，翻译成中文，意思是“分布式拒绝服务”。DDoS攻击，是一种耗尽攻击目标的系统资源，导致攻击目标无法响应正常服务请求的网络攻击方式。这种攻击手法通过借助于“客户&#x2F;服务器”技术，将多个计算机联合起来作为攻击平台，对一个或者多个目标发动攻击。</p>
</li>
</ul>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：</p>
<ul>
<li>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 <code>FIN_WAIT1</code> 状态。 即发出<strong>连接释放报文段</strong>（FIN&#x3D;1，序号seq&#x3D;u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。</li>
<li>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 <code>CLOSE_WAIT</code> 状态。 即服务端收到连接释放报文段后即发出<strong>确认报文段</strong>（ACK&#x3D;1，确认号ack&#x3D;u+1，序号seq&#x3D;v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。</li>
<li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 <code>LAST_ACK</code> 的状态。 即服务端没有要向客户端发出的数据，服务端发出<strong>连接释放报文段</strong>（FIN&#x3D;1，ACK&#x3D;1，序号seq&#x3D;w，确认号ack&#x3D;u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。</li>
<li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的确认号值，此时客户端处于 <code>TIME_WAIT</code> 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 <code>CLOSED</code> 状态。 即客户端收到服务端的连接释放报文段后，对此发出<strong>确认报文段</strong>（ACK&#x3D;1，seq&#x3D;u+1，ack&#x3D;w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。</li>
</ul>
<p>收到一个FIN只意味着在这一方向上没有数据流动。<strong>客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态。</strong></p>
<p>在socket编程中，任何一方执行close()操作即可产生挥手操作。</p>
<img src="https://pic.imgdb.cn/item/62b4ad200947543129a157d2.jpg" style="zoom:80%;" />

<p><strong>CLOSE_WAIT状态：</strong></p>
<p><strong>出现时间：</strong></p>
<p>TCP 连接断开时需要进行“四次挥手”，TCP 连接的<u>两端都可以发起关闭连接的请求</u>，若其中<u>一端发起了关闭连接</u>，但<u>另外一端没有关闭连接，那么该连接就会处于 CLOSE_WAIT 状态</u>。</p>
<p><strong>出现原因</strong>：</p>
<p>通常来说，CLOSE_WAIT 在服务器停留的时间很短，且只会发生在被动关闭连接的一端。除非 Kill 掉进程，否则它是不会消失的，意味着一直占用资源。</p>
<p><u>如果发现有大量的 CLOSE_WAIT，那就是被动关闭的一方没有及时发送 FIN（根本原因是没有关闭连接）</u>，一般来说有以下几种可能：</p>
<ol>
<li><strong>代码问题</strong>：请求的时候没有显式关闭 Socket 连接，或者死循环导致关闭连接的代码没有执行到，即 FIN     包没有发出，导致 CLOSE_WAIT 不断累积</li>
<li><strong>响应过慢 &#x2F;     超时设置过小</strong>：双方连接不稳定，一方     Timeout，另外一方还在处理逻辑，导致 Close 被延后</li>
</ol>
<p><strong>为什么需要四次挥手？</strong></p>
<p>（1）第一次挥手</p>
<p>因此当主动方发送断开连接的请求（即FIN报文）给被动方时，仅仅代表主动方不会再发送数据报文了，但主动方仍可以接收数据报文。</p>
<p>（2）第二次挥手</p>
<p>被动方此时有可能还有相应的数据报文需要发送，因此需要先发送ACK报文，告知主动方“我知道你想断开连接的请求了”。这样<strong>主动方便不会因为没有收到应答而继续发送断开连接的请求</strong>（即FIN报文）。</p>
<p>（3）第三次挥手</p>
<p>被动方在处理完数据报文后，便发送给主动方FIN报文；这样可以保证数据通信正常可靠地完成。发送完FIN报文后，被动方进入LAST_ACK阶段（超时等待）。</p>
<p>（4）第四挥手</p>
<p>如果主动方及时发送ACK报文进行连接中断的确认，这时被动方就直接释放连接，进入可用状态。</p>
<h4 id="TCP和UDP"><a href="#TCP和UDP" class="headerlink" title="TCP和UDP"></a>TCP和UDP</h4><p><strong>TCP（Transmission Control Protocol，传输控制协议）</strong></p>
<ul>
<li><strong>优点</strong>： 可靠，稳定 TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。</li>
<li><strong>缺点</strong>： 慢，效率低，占用系统资源高，易被攻击 TCP在传递数据之前，要先建连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，事实上，每个连接都会占用系统的CPU、内存等硬件资源。 而且，因为TCP有确认机制、三次握手机制，这些也导致TCP容易被人利用，实现DOS、DDOS、CC等攻击。</li>
</ul>
<p><strong>UDP（User Datagram Protocol ,用户数据报协议）</strong></p>
<ul>
<li><strong>优点</strong>： 快，比TCP稍安全 UDP没有TCP的握手、确认、窗口、重传、拥塞控制等机制，UDP是一个无状态的传输协议，所以它在传递数据时非常快。没有TCP的这些机制，UDP较TCP被攻击者利用的漏洞就要少一些。但UDP也是无法避免攻击的，比如：UDP Flood攻击…… </li>
<li><strong>缺点</strong>： 不可靠，不稳定 因为UDP没有TCP那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包。</li>
</ul>
<p><strong>区别总结：</strong></p>
<ul>
<li><strong>TCP面向连接</strong>（如打电话要先拨号建立连接）；<strong>UDP是无连接的</strong>，即发送数据之前不需要建立连接</li>
<li><strong>TCP提供可靠的服务</strong>。也就是说，通过TCP连接传送的数据，<strong>无差错，不丢失，不重复</strong>，且按序到达;<strong>UDP尽最大努力交付</strong>，即不保证可靠交付</li>
<li><strong>TCP面向字节流</strong>，实际上是TCP把数据看成一连串无结构的字节流;<strong>UDP是面向报文的</strong></li>
<li>UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）</li>
<li>每一条TCP连接只能是点到点的；UDP支持一对一，一对多，多对一和多对多的交互通信</li>
<li>TCP首部开销20字节;UDP的首部开销小，只有8个字节</li>
<li>TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</li>
</ul>
<p><strong>什么时候应该使用TCP</strong>： 当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。 在日常生活中，常见使用TCP协议的应用如下： 浏览器，用的HTTP FlashFXP，用的FTP Outlook，用的POP、SMTP Putty，用的Telnet、SSH QQ文件传输 …………</p>
<p><strong>什么时候应该使用UDP</strong>： 当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。 比如，日常生活中，常见使用UDP协议的应用如下： QQ语音 QQ视频 TFTP ……</p>
]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>project_in_meituan_05</title>
    <url>/2022/06/16/project-in-meituan-05/</url>
    <content><![CDATA[<p>第五个需求，优选游戏接入平台游戏部广告聚合接口，较为复杂，仅实现M端的配置</p>
<span id="more"></span>

<h3 id="任务中心"><a href="#任务中心" class="headerlink" title="任务中心"></a>任务中心</h3><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><ol>
<li>特殊类型下新增【平游广告接口】类型</li>
<li>投放信息：<ul>
<li>名称、业态类型、活动门店、面向用户、结束时间、是否进行任务测试，全部复用</li>
<li>渠道仅支持选择美团app，不提供其他选项</li>
</ul>
</li>
<li>任务规则<ul>
<li>展示位置：默认资源位气泡，不提供配置能力</li>
<li>展示优先级：复用</li>
<li>资源位交互方式：复用</li>
<li>资源位描述文案：不提供配置能力，调广告平台接口返回文案加上特殊字段拼装</li>
<li><u>资源位文案极限情况兜底：文字配置框。字数限制13个字&#x2F;&#x2F;“敬请期待，点击查看更多内容”</u></li>
<li>资源位匹配标识：复用</li>
<li>任务有效时间：默认为1自然天，不提供配置能力</li>
<li>任务领取次数限制<ul>
<li>每人总领取上限：允许填写1-999，-1表示无限制</li>
<li>每日次数限制：不提供配置能力，默认1</li>
</ul>
</li>
</ul>
</li>
<li>游戏行为<ul>
<li>浏览页面时长（秒）：允许填写1-300</li>
<li><u>可浏览次数：允许填写1-99</u></li>
<li>发放奖励：<ul>
<li>固定奖励：复用</li>
<li>奖励配置：复用</li>
</ul>
</li>
</ul>
</li>
<li>保存限制：全部必选</li>
</ol>
<img src="https://pic.imgdb.cn/item/62aace3d0947543129b02a52.jpg" style="zoom: 80%;" />

<h4 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h4><p>定位API：</p>
<ul>
<li>前端请求定义：grocery&#x2F;interact&#x2F;taskcenter&#x2F;config&#x2F;detail</li>
<li>后端请求定义：.interact.mapi.client.service.taskcenter.TaskConfigDataMTService</li>
<li>方法名：queryTaskConfigDetail</li>
</ul>
<p><strong>TaskCenter下：</strong></p>
<p>新增任务类型，taskType：143</p>
<ul>
<li>TaskTypeEnum 119 下新增任务</li>
<li>EventRelationFacade 156 188下新增</li>
</ul>
<p>新增DTO和BO字段</p>
<ul>
<li>TaskDisplayConfigDTO下增加browseNumber</li>
<li>TaskDisplayConfigBO下增加字段</li>
</ul>
<h3 id="养鸡"><a href="#养鸡" class="headerlink" title="养鸡"></a>养鸡</h3><h3 id="地摊"><a href="#地摊" class="headerlink" title="地摊"></a>地摊</h3><ol>
<li>特殊类型下新增【平游广告接口】类型</li>
<li>投放信息：<ul>
<li>名称、业态类型、活动门店、面向用户、结束时间、是否进行任务测试，全部复用</li>
<li>渠道仅支持选择美团app，不提供其他选项</li>
</ul>
</li>
<li>任务规则<ul>
<li>展示位置：默认资源位气泡，不提供配置能力</li>
<li>展示优先级：复用</li>
<li>是否非通用UI：默认选否，不提供配置能力</li>
<li>任务列表主标题：不提供配置能力，调广告平台接口返回文案</li>
<li><u>主标题极限情况兜底：文字配置框。字数限制13个字&#x2F;&#x2F;“敬请期待，点击查看更多内容”</u></li>
<li>副标题：支持插入银币数、银币倍数、银币icon、金币icon、<strong>剩余次数</strong>、红包icon</li>
<li>任务有效时间：默认为1自然天，不提供配置能力</li>
<li>任务领取次数限制<ul>
<li>每人总领取上限：允许填写1-999，-1表示无限制</li>
<li>每日次数限制：允许填写1-99，不允许填写-1</li>
</ul>
</li>
<li>是否展示倒计时条：默认选否，不提供配置能力</li>
<li>无可领奖时次日消失：复用</li>
</ul>
</li>
<li>游戏行为<ul>
<li>浏览页面时长（秒）：允许填写1-300</li>
<li>发放奖励：<ul>
<li>固定奖励：拉奖励中心。需奖励中心单独处理，只允许下拉配置游戏金币（100:1换红包余额）、阳光。其他不允许下拉展示</li>
<li>快速购买倍数：复用</li>
</ul>
</li>
</ul>
</li>
<li>保存限制：全部必选</li>
</ol>
<img src="https://pic.imgdb.cn/item/62aafd3d09475431290d3233.jpg" style="zoom: 35%;" />

<img src="https://pic.imgdb.cn/item/62aafda209475431290e187d.jpg" style="zoom:50%;" />

<img src="https://pic.imgdb.cn/item/62aafdc709475431290e6f19.jpg" style="zoom: 43%;" />

<h4 id="开发-1"><a href="#开发-1" class="headerlink" title="开发"></a>开发</h4><p>新增任务类型，taskType：822</p>
<ul>
<li>TaskTypeEnum 119 下新增任务</li>
<li>EventRelationFacade 156 188下新增</li>
</ul>
]]></content>
      <categories>
        <category>Projects</category>
        <category>MeiTuan</category>
      </categories>
      <tags>
        <tag>MeiTuan</tag>
        <tag>Projects</tag>
      </tags>
  </entry>
  <entry>
    <title>上线发布流程</title>
    <url>/2022/06/15/ServiceOnline/</url>
    <content><![CDATA[<p>本文记录了服务上线发布流程规范</p>
<span id="more"></span>

<p>上线发布流程规范的原则，从风险角度出发，预想最坏的情况，做最充分的准备。目标是尽可能用较小的成本发现本次发布变更的问题。</p>
<p>核心：要能准确评估本次变更的影响范围，通过灰度发布等手段将影响降低，又有足够的手段做好功能的测试验证，一旦有问题要有机制可以快速发现，同时具备快速恢复的能力，包括但不限于回滚。</p>
<h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><ul>
<li>灰度发布：指在黑与白之间，能够平滑过渡的一种发布方式。在其上可以进行A&#x2F;B testing，即让一部分用户继续用产品特性A，一部分用户开始用产品特性B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到B上面来。灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度</li>
<li>RD、PM和QA：<ul>
<li>RD：Research and Development engineer</li>
<li>PM：Product Manager</li>
<li>QA：Quality Assurance</li>
</ul>
</li>
<li>回归测试：指修改了旧代码后，重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误。</li>
</ul>
<h3 id="流程规范"><a href="#流程规范" class="headerlink" title="流程规范"></a>流程规范</h3><p>上线总体要求：可验证、可灰度、可回滚</p>
<ul>
<li>上线准入：上线操作人保证待发布的代码经过充分的测试，包括：<ul>
<li>RD自试：单测、CI流水线、集成测试、联调测试</li>
<li>QA介入测试：测试流水线、功能测试、回归测试</li>
</ul>
</li>
<li>上线清单：所有的变更都需要有发布计划&#x2F;清单，明确每个需求的上线时间</li>
<li>上线窗口：发布时间要避开公司静默期，尤其重大节假日前三天禁止重大生产变更</li>
<li>人员要求：上线过程至少2人参与（操作人+观察人）</li>
<li>上线前准备：<ul>
<li>上线发布checklist规范</li>
<li>所有的操作（DB变更、数据变更、MCC配置等）都必须具备可回滚性或可降级性，且经过线下验证有效</li>
</ul>
</li>
<li>上线周知：<ul>
<li>周知小组范围内</li>
<li>对于线上发布可能对上下游系统&#x2F;业务造成影响的变更，负责人与相关上下游系统进行必要的周知，要保证消息触达率</li>
<li>非紧急上线外，正常上线需至少提前4小时周知（不兼容变发布至少提前一周，且发布前再次通知。重大发布提前至少一天）</li>
</ul>
</li>
<li>灰度策略：<ul>
<li>发布过程强制灰度，plus灰度与自定义灰度</li>
<li>如果因为系统架构原因导致方案不能满足时，则需要对系统进行升级改造</li>
<li>Plus机器分组发布，检查间隔时间不少于5分钟</li>
<li>灰度粒度不能过大（比如一台机器不影响一大片业务）、灰度时间需要足够长，对于核心服务的发布，建议灰度分至少3个批次</li>
<li>除了考虑机器分组外，还可以考虑基于代码覆盖率进行灰度放量</li>
</ul>
</li>
<li>执行发布</li>
<li>上线后检查：<ul>
<li>发布过程和完成后需要遵循PDCA方法论，观察并手机信息：在Raptor（含Falcon）监控以及内部的监控大盘</li>
<li>灰度发布的不同阶段，观察判断的点不一样：<ul>
<li>单台发布阶段，一般重点观察本台机器是否有错误日志，要尽可能通过日志来做本次变更正确性的验证，观察数据库和缓存数据的正确性，要观察上下游的业务正确性，抽查的请求日志尽可能覆盖所有场景</li>
<li>比例发布阶段，一般重点观察是否有错误或者异常，因为灰度的比例达到比较高的阈值，可以比较容易触发监控指标的变化和报警，同时需要关注到上下游是否正常，是否有问题的暴露</li>
<li>全量发布阶段，一般重点观察业务和系统的大盘，从宏观的统计数据上看是否有业务问题，同时观察性能指标（耗时等）和机器指标，如果有做相关业务数据的买点，可以通过具体的业务数据指标分析来发现问题。全量发布完成后，需要做全场景的验证回归，防止有些场景不能实时出发（比如定时任务触发）</li>
</ul>
</li>
<li>上线后需进行核心功能的回归验证，如新上线feature，也必须进行功能性回归验证</li>
</ul>
</li>
<li>回滚：<ul>
<li>如果发布完成后发现指标异常或收到用户反馈异常，需要第一时间按照预定的回滚方案进行回滚，而不是选择排查问题。如果回滚后依然解决不了问题，再通过分析日志或指标来排查原因</li>
<li>回滚方案要提前演练，保证有效性</li>
<li>回滚需要考虑回滚所有相关的程序、配置和数据修改，不要只考虑程序本身</li>
<li>回滚顺序，不管是完全回滚到上一个版本，还是选择再次发布一个新版本，仍旧需要遵循灰度的顺序。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>MeiTuan</category>
      </categories>
      <tags>
        <tag>MeiTuan</tag>
      </tags>
  </entry>
  <entry>
    <title>OS Basic</title>
    <url>/2022/06/14/Interview-OSBasic/</url>
    <content><![CDATA[<p>本文对操作系统的基础知识做了一些梳理和总结（主要针对面试中常见的一些问题）</p>
<span id="more"></span>

<h3 id="1-操作系统基础"><a href="#1-操作系统基础" class="headerlink" title="1. 操作系统基础"></a>1. 操作系统基础</h3><h4 id="什么是操作系统？"><a href="#什么是操作系统？" class="headerlink" title="什么是操作系统？"></a>什么是操作系统？</h4><ol>
<li><p><strong>操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基石。</strong></p>
</li>
<li><p><strong>操作系统本质上是一个运行在计算机上的软件程序 ，用于管理计算机硬件和软件资源。</strong> 举例：运行在你电脑上的所有应用程序都通过操作系统来调用系统内存以及磁盘等等硬件。</p>
</li>
<li><p><strong>操作系统存在屏蔽了硬件层的复杂性。</strong> 操作系统就像是硬件使用的负责人，统筹着各种相关事项。</p>
</li>
<li><p><strong>操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理</strong>。 内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。</p>
<img src="https://pic.imgdb.cn/item/62a85506094754312966e906.jpg" style="zoom:50%;" /></li>
</ol>
<h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><p>介绍系统调用之前，我们先来了解一下用户态和内核态。</p>
<p>根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：</p>
<ol>
<li><strong>用户态(user mode)</strong> : 用户态运行的进程可以直接读取用户程序的数据。</li>
<li><strong>内核态(kernel mode)</strong>:可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。</li>
</ol>
<p><strong>从用户态到内核态切换可以通过三种方式</strong>：</p>
<ol>
<li><strong>系统调用</strong>：⽐如printf, open, read, write 。其实系统调用本身就是中断，但是软件中断，跟硬中断不同。</li>
<li><strong>异常</strong>：如果当前进程运行在用户态，如果这个时候发生了异常事件，就会触发切换。例如：缺页异常。</li>
<li><strong>外设中断</strong>：当外设完成用户的请求时，会向CPU发送中断信号。</li>
</ol>
<p>那么什么是系统调用呢？</p>
<p>我们运行的程序基本都是运行在用户态，如果我们调用操作系统提供的系统态级别的子功能咋办呢？那就需要系统调用了！</p>
<p>也就是说在我们运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。</p>
<p>用户是处于用户态，具有的权限是非常有限，肯定是不能直接使用内核态的服务，只能间接通过有访问权限的API函数内嵌的系统调用函数来调用。</p>
<p>这些系统调用按功能大致可分为如下几类：</p>
<ul>
<li>设备管理。完成设备的请求或释放，以及设备启动等功能。</li>
<li>文件管理。完成文件的读、写、创建及删除等功能。</li>
<li>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。</li>
<li>进程通信。完成进程之间的消息传递或信号传递等功能。</li>
<li>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。</li>
</ul>
<p>显然，系统调用运行在系统的内核态。<strong>通过系统调用的方式来使用系统功能，可以保证系统的稳定性和安全性，防止用户随意更改或访问系统的数据或命令</strong>。系统调用命令式由操作系统提供的一个或多个子程序模块来实现的。</p>
<h3 id="2-进程和线程"><a href="#2-进程和线程" class="headerlink" title="2. 进程和线程"></a>2. 进程和线程</h3><p><strong>表格总结</strong></p>
<img src="https://pic.imgdb.cn/item/62a84ae30947543129558ce2.jpg" style="zoom: 67%;" />

<p><strong>进程与线程的概念，以及为什么要有进程线程，其中有什么区别，他们各自又是怎么同步的?</strong></p>
<p><strong>1. 基本概念：</strong></p>
<p>进程是对运行时程序的封装，是<u>系统进行资源调度和分配的的基本单位，实现了操作系统的并发</u>；</p>
<p><u>线程是进程的子任务，是CPU调度和分派的基本单位</u>，用于保证程序的实时性，实现进程内部的并发；线程是操作系统可识别的最小执行和调度单位。每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。每个线程完成不同的任务，但是共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等），打开的文件队列和其他内核资源（共享进程的虚拟内存）。</p>
<p><strong>2. 区别：</strong></p>
<ul>
<li><p>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。</p>
</li>
<li><p>进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。） </p>
</li>
<li><p>进程是资源分配的最小单位，线程是CPU调度的最小单位**； **</p>
</li>
<li><p>系统开销： 由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／O设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，进程切换的开销也远大于线程切换的开销。</p>
</li>
<li><p>通信：由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预</p>
</li>
<li><p>进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。</p>
</li>
<li><p>进程间不会相互影响 ；线程一个线程挂掉将导致整个进程挂掉 </p>
</li>
<li><p>进程适应于多核、多机分布；线程适用于多核</p>
</li>
</ul>
<h4 id="进程有哪几种状态"><a href="#进程有哪几种状态" class="headerlink" title="进程有哪几种状态?"></a>进程有哪几种状态?</h4><p>我们一般把进程大致分为 5 种状态，这一点和线程很像！</p>
<ul>
<li><p><strong>创建状态(new)</strong> ：进程正在被创建，尚未到就绪状态。</p>
</li>
<li><p><strong>就绪状态(ready)</strong> ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。</p>
</li>
<li><p><strong>运行状态(running)</strong> ：进程正在处理器上上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。</p>
</li>
<li><p><strong>阻塞状态(waiting)</strong> ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。</p>
</li>
<li><p><strong>结束状态(terminated)</strong> ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。</p>
<img src="https://pic.imgdb.cn/item/62a8574c09475431296a5c0c.jpg" style="zoom: 80%;" /></li>
</ul>
<h4 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h4><blockquote>
<p>下面这部分总结参考了:<a href="https://www.jianshu.com/p/c1015f5ffa74">《进程间通信 IPC (InterProcess Communication)》</a> 这篇文章，推荐阅读，总结的非常不错。</p>
</blockquote>
<ol>
<li><strong>管道&#x2F;匿名管道(Pipes)</strong> ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。</li>
<li><strong>有名管道(Names Pipes)</strong> : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循**先进先出(first in first out)**。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</li>
<li><strong>信号(Signal)</strong> ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；</li>
<li><strong>消息队列(Message Queuing)</strong> ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显式地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。<strong>消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺点。</strong></li>
<li><strong>信号量(Semaphores)</strong> ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。</li>
<li><strong>共享内存(Shared memory)</strong> ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。</li>
<li><strong>套接字(Sockets)</strong> : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP&#x2F;IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</li>
</ol>
<h4 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h4><ol>
<li><strong>先来先服务 first-come first-serverd（FCFS）</strong></li>
</ol>
<p>   <strong>非抢占式</strong>的调度算法，按照请求的顺序进行调度。</p>
<p>   有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p>
<ol start="2">
<li><p><strong>短作业优先 shortest job first（SJF）</strong></p>
<p>非抢占式的调度算法，按估计运行时间最短的顺序进行调度。</p>
<p>长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p>
</li>
<li><p><strong>最短剩余时间优先 shortest remaining time next（SRTN）</strong></p>
<p>最短作业优先的<strong>抢占式</strong>版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。</p>
<p>如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p>
</li>
<li><p><strong>时间片轮转</strong></p>
<p>将<strong>所有就绪进程按 FCFS 的原则排成一个队列</strong>，每次调度时，把 CPU 时间分配给队首进程，<strong>该进程可以执行一个时间片</strong>。</p>
<p>当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p>
<p>时间片轮转算法的效率和时间片的大小有很大关系：</p>
<ul>
<li><p>因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。</p>
</li>
<li><p>而如果时间片过长，那么实时性就不能得到保证。</p>
<img src="https://pic.imgdb.cn/item/62a84e1d09475431295bb468.jpg" style="zoom: 80%;" /></li>
</ul>
</li>
<li><p><strong>优先级调度</strong></p>
<p>为每个进程分配一个优先级，按优先级进行调度。</p>
<p>为了防止低优先级的进程永远等不到调度，<strong>可以随着时间的推移增加等待进程的优先级</strong>。</p>
</li>
<li><p><strong>多级反馈队列</strong></p>
<p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p>
<p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。</p>
<p>这种方式下，之前的进程只需要交换 7 次。每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p>
<p>可以将这种调度算法看成是<strong>时间片轮转调度算法和优先级调度算法的结合</strong>。</p>
<img src="https://pic.imgdb.cn/item/62a84f7109475431295e0f84.jpg" style="zoom:67%;" /></li>
</ol>
<h4 id="线程间的同步的方式"><a href="#线程间的同步的方式" class="headerlink" title="线程间的同步的方式"></a>线程间的同步的方式</h4><p>线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。操作系统一般有下面三种线程同步的方式：</p>
<ol>
<li>**互斥量(Mutex)**：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。</li>
<li><strong>信号量(Semaphore)</strong> ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。</li>
<li><strong>事件(Event)</strong> :Wait&#x2F;Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</li>
</ol>
<h3 id="3-死锁"><a href="#3-死锁" class="headerlink" title="3. 死锁"></a>3. 死锁</h3><p><strong>场景</strong></p>
<ul>
<li>当有A,B 两个线程，同时申请X,Y两个资源，但A线程先申请X资源再申请Y资源，B线程先申请Y资源再申请X资源，A,B两个线程同时运行，A先锁了X，B先锁了Y，然后A去申请Y，就会一直阻塞，同时，B再去申请X，也会一直阻塞，这样就会造成死锁</li>
</ul>
<p><strong>什么是死锁</strong></p>
<ul>
<li>死锁是指两个或两个以上的进程在执行过程中，由于<strong>竞争资源</strong>或者由于<strong>彼此通信</strong>而造成的一种阻塞现象，若无外力作用，它们都将无法推进下去，此时称系统处于死锁态或系统产生了死锁，这些永远在互相等待的进程称为死锁</li>
</ul>
<h4 id="引起死锁的原因"><a href="#引起死锁的原因" class="headerlink" title="引起死锁的原因"></a>引起死锁的原因</h4><ul>
<li><p>竞争不可抢占资源引起死锁</p>
<p>也就是说我们说的第一种情况，而这都在等待对方占有的不可抢占的资源</p>
</li>
<li><p>竞争可消耗资源引起死锁</p>
<p>有p1，p2，p3 三个进程，p1向p2发送消息并接受p3消息，p2向p3发送消息并接受p1消息，p3向p1发送消息并接受p2消息，如果设置是先接收消息再发送消息，则所有的消息都不能发送，这就造成死锁</p>
</li>
<li><p>进程推进顺序不当引起死锁</p>
<p>有进程p1，p2，都需要资源A，B，当p1，p2同时运行时，p1先锁A再阻塞等待B，p2先锁B再阻塞等待A，这样也会造成互相抢占资源的死锁</p>
</li>
</ul>
<h4 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h4><p>注意四个条件需要同时成立，才会产生死锁</p>
<ul>
<li>互斥条件：（资源角度）某资源只能被一个进程使用，其它进程请求该资源时，只能等待 ，直到资源使用完毕后释放资源</li>
<li>请求和保持条件：（程序角度）程序己经保持了至少一个资源，但是又提出了新的要求，而这个资源被其它进程占用， 自己占用资源却保持不放</li>
<li>不可抢占条件：（资源角度）进程己获得的资源没有使用完，不能被抢占</li>
<li>循环等待条件：必然存在一个循环链</li>
</ul>
<h4 id="处理死锁的思路"><a href="#处理死锁的思路" class="headerlink" title="处理死锁的思路"></a>处理死锁的思路</h4><ul>
<li><p><strong>预防死锁</strong>：破坏死锁的四个必要条件中的一个或多个来预防死锁</p>
<ul>
<li><p><strong>互斥条件</strong>：使得资源是可以同时访问的，这是种简单的方法，磁盘就可以用这种方法管理，但是我们要知道，有很多资源 往往是不能同时访问的，所以这种做法在大多数的场合是行不通的。</p>
</li>
<li><p><strong>破坏请求和保持条件</strong>：（<strong>静态分配策略</strong>）所有进程开始前，<u>必须一次性的申请所需的全部资源</u>，这样运行期间就不会再提出资源要求，破坏了请求条件，即使有一种资源不能满足需求，也不会给它分配正在空闲的资源，这样它就没有资源，就破坏了保持条件，从面预防死锁发生。</p>
<p>静态分配策略逻辑简单，实现也很容易，但这种策略 <u>严重地降低了资源利用率</u>，因为在每个进程所占有的资源中，有些资源是在比较靠后的执行时间里采用的，甚至有些资源是在额外的情况下才是用的，这样就可能造成了一个进程占有了一些 <u>几乎不用的资源而使其他需要该资源的进程产生等待</u> 的情况。</p>
</li>
<li><p><strong>破坏不可抢占条件</strong>：当一个己经保持了某种不可抢占资源的进程，提出了新的资源请求不能被满足时，它必须<u>释放己经保持的所有资源</u>，以后需要时再重新申请</p>
</li>
<li><p><strong>破坏循环等待条件</strong>：（<strong>层次分配策略</strong>）对系统中的所有资源类型进行线性排序，然后规定每个进程必须按顺序请求资源，假如请求到了序列号较高的资源，然后又请求到了序列号较低的资源，则必须先释放前面的资源。</p>
</li>
</ul>
</li>
<li><p><strong>避免死锁</strong>：和预防死锁的区别是，在资源动态分配过程中，用某种方式防止系统进入不安全状态</p>
<ul>
<li>最具有代表性的避免死锁算法就是 Dijkstra 的<strong>银行家算法</strong>，银行家算法用一句话表达就是：当一个进程申请使用资源的时候，银行家算法通过先<u>试探</u>分配给该进程资源，然后通过 <u>安全性算法</u> 判断分配后系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待，若能够进入到安全的状态，则就 <u>真的分配资源给该进程</u>。</li>
<li>死锁的避免(银行家算法)改善解决了 <u>资源使用率低的问题</u> ，但是它要不断地检测每个进程对各类资源的占用和申请情况，以及做安全性检查，需要花费较多的时间。</li>
</ul>
</li>
<li><p><strong>检测死锁</strong>：系统 <strong>定时地运行一个 “死锁检测”</strong> 的程序，判断系统内是否出现死锁，如果检测到系统发生了死锁，再采取措施去解除它。</p>
</li>
<li><p><strong>解除死锁</strong>：当死锁检测程序检测到存在死锁发生时，应设法让其解除，让系统从死锁状态中恢复过来，常用的解除死锁的方法有以下四种：</p>
<ul>
<li><strong>立即结束所有进程的执行，重新启动操作系统</strong> ：这种方法简单，但以前所在的工作全部作废，损失很大。</li>
<li><strong>撤销涉及死锁的所有进程，解除死锁后继续运行</strong> ：这种方法能彻底打破<strong>死锁的循环等待</strong>条件，但将付出很大代价，例如有些进程可能已经计算了很长时间，由于被撤销而使产生的部分结果也被消除了，再重新执行时还要再次进行计算。</li>
<li><strong>逐个撤销涉及死锁的进程，回收其资源直至死锁解除。</strong></li>
<li><em>抢占资源</em>* ：从涉及死锁的一个或几个进程中抢占资源，把夺得的资源再分配给涉及死锁的进程直至死锁解除。</li>
</ul>
</li>
</ul>
<h3 id="4-操作系统内存管理"><a href="#4-操作系统内存管理" class="headerlink" title="4. 操作系统内存管理"></a>4. 操作系统内存管理</h3><h4 id="操作系统的内存管理"><a href="#操作系统的内存管理" class="headerlink" title="操作系统的内存管理"></a>操作系统的内存管理</h4><p><strong>内存管理主要是做什么？</strong></p>
<p>操作系统的内存管理主要负责内存的分配与回收（malloc 函数：申请内存，free 函数：释放内存），另外地址转换也就是将逻辑地址转换成相应的物理地址等功能也是操作系统内存管理做的事情。</p>
<p><strong>内存管理有哪几种方式?</strong></p>
<p>简单分为<strong>连续分配管理方式</strong>和<strong>非连续分配管理方式</strong>这两种。连续分配管理方式是指为一个用户程序分配一个连续的内存空间，常见的如 <strong>块式管理</strong> 。同样地，非连续分配管理方式允许一个程序使用的内存分布在离散或者说不相邻的内存中，常见的如<strong>页式管理</strong> 和 <strong>段式管理</strong>。</p>
<ol>
<li><strong>块式管理</strong> ： 远古时代的计算机操作系统的内存管理方式。将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。</li>
<li><strong>页式管理</strong> ：把主存分为大小相等且固定的一页一页的形式，页较小，相比于块式管理的划分粒度更小，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。</li>
<li><strong>段式管理</strong> ： 页式管理虽然提高了内存利用率，但是页式管理其中的页并无任何实际意义。 段式管理把主存分为一段段的，段是有实际意义的，每个段定义了一组逻辑信息，例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。</li>
<li><strong>段页式管理机制</strong>：结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说段页式管理机制中段与段之间以及段的内部的都是离散的。</li>
</ol>
<p>简单来说：页是物理单位，段是逻辑单位。分页可以有效提高内存利用率，分段可以更好满足用户需求。</p>
<h4 id="快表和多级页表"><a href="#快表和多级页表" class="headerlink" title="快表和多级页表"></a>快表和多级页表</h4><p>页表管理机制中有两个很重要的概念：快表和多级页表，这两个东西分别解决了页表管理中很重要的两个问题：</p>
<ol>
<li>虚拟地址到物理地址的转换要快。</li>
<li>解决虚拟地址空间大，页表也会很大的问题。</li>
</ol>
<p><strong>快表</strong></p>
<p>为了提高虚拟地址到物理地址的转换速度，操作系统在 <strong>页表方案</strong> 基础之上引入了 <strong>快表</strong> 来加速虚拟地址到物理地址的转换。我们可以把快表理解为一种特殊的高速缓冲存储器（Cache），其中的内容是页表的一部分或者全部内容。作为页表的 Cache，它的作用与页表相似，但是提高了访问速率。由于采用页表做地址转换，读写内存数据时 CPU 要访问两次主存。有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。</p>
<p>使用快表之后的地址转换流程是这样的：</p>
<ol>
<li>根据虚拟地址中的页号查快表；</li>
<li>如果该页在快表中，直接从快表中读取相应的物理地址；</li>
<li>如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；</li>
<li>当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。</li>
</ol>
<p>看完了之后你会发现快表和我们平时经常在我们开发的系统使用的缓存（比如 Redis）很像，的确是这样的，操作系统中的很多思想、很多经典的算法，你都可以在我们日常开发使用的各种工具或者框架中找到它们的影子。</p>
<p><strong>多级页表</strong></p>
<p>引入多级页表的主要目的是为了避免把全部页表一直放在内存中占用过多空间，特别是那些根本就不需要的页表就不需要保留在内存中。多级页表属于时间换空间的典型场景，具体可以查看下面这篇文章</p>
<ul>
<li><a href="https://www.polarxiong.com/archives/%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%A6%82%E4%BD%95%E8%8A%82%E7%BA%A6%E5%86%85%E5%AD%98.html">多级页表如何节约内存</a></li>
</ul>
<p><strong>总结</strong></p>
<p>为了提高内存的空间性能，提出了多级页表的概念；但是提到空间性能是以浪费时间性能为基础的，因此为了补充损失的时间性能，提出了快表（即 TLB）的概念。 不论是快表还是多级页表实际上都利用到了程序的局部性原理，局部性原理在后面的虚拟内存这部分会介绍到。</p>
<h4 id="分页与分段技术的区别"><a href="#分页与分段技术的区别" class="headerlink" title="分页与分段技术的区别"></a>分页与分段技术的区别</h4><p><a href="https://www.cnblogs.com/myseries/p/12487211.html">虚拟内存、分页、分段的理解</a></p>
<ul>
<li><p>这两个技术都是为了利用和管理好计算机的资源——内存</p>
</li>
<li><p>在分段技术之前，程序运行需要从内存中分配足够多的连续的内存，然后把整个程序装载进去。如某个程序大小是10M，就需要有连续的10M内存空间才能把这个程序装载到内存里面。如果无法找到连续的10M内存，就无法把这个程序装载进内存里面，程序也就无法得到运行。这种方法(<u>也是直接使用物理内存的问题</u>)有三个问题：</p>
<ul>
<li><p><strong>地址空间不隔离</strong>：不同的程序之间可能由于对错误的内存地址的操作产生相互影响</p>
</li>
<li><p><strong>程序运行时地址不确定</strong>：无法保证每次对同一地址的操作是相同的，因为程序装载进内存的位置会发生改变</p>
</li>
<li><p><strong>内存使用率低下</strong>：在内存占满后想要运行别的程序必须把内存中的程序换出到磁盘上，再把想运行的换入，会导致内存空间可能有一部分无法被利用</p>
</li>
</ul>
</li>
<li><p>分段技术可以解决第一第二个问题：它把虚拟地址空间映射到了物理地址空间，并且你写的程序操作的是虚拟地址。没有解决第三个问题因为每个程序仍然需要被<strong>完整地换入和换出</strong>。</p>
</li>
<li><p>分页技术可以解决第三个问题：分页这个技术仍然是一种虚拟地址空间到物理地址空间映射的机制。但是，粒度更加的小了。单位不是整个程序，而是某个“页”，一段虚拟地址空间组成的某一页映射到一段物理地址空间组成的某一页。</p>
</li>
<li><p>在分段的方法中，每次程序运行时总是把程序全部装入内存，而分页的方法则有所不同。分页的思想是<strong>程序运行时用到哪页就为哪页分配内存</strong>，没用到的页暂时保留在硬盘上。<strong>当用到这些页时再在物理地址空间中为这些页分配内存</strong>，然后建立虚拟地址空间中的页和刚分配的物理内存页间的映射。</p>
</li>
</ul>
<h4 id="逻辑地址和物理地址，虚拟寻址"><a href="#逻辑地址和物理地址，虚拟寻址" class="headerlink" title="逻辑地址和物理地址，虚拟寻址"></a>逻辑地址和物理地址，虚拟寻址</h4><p>我们编程一般只有可能和逻辑地址打交道，比如在 C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。物理地址指的是真实物理内存中地址，更具体一点来说就是内存地址寄存器中的地址。物理地址是内存单元真正的地址。</p>
<p>现代处理器使用的是一种称为 <strong>虚拟寻址(Virtual Addressing)</strong> 的寻址方式。<strong>使用虚拟寻址，CPU 需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。</strong> 实际上完成虚拟地址转换为物理地址转换的硬件是 CPU 中含有一个被称为 <strong>内存管理单元（Memory Management Unit, MMU）</strong> 的硬件。如下图所示：</p>
<img src="https://pic.imgdb.cn/item/62af5e59094754312909530f.jpg" style="zoom:50%;" />

<p>相比于直接访问物理内存的缺陷（上一部分解释过），通过虚拟地址访问内存有以下优势：</p>
<ul>
<li>程序可以使用一系列相邻的虚拟地址来<u>访问物理内存中不相邻的大内存缓冲区</u>。</li>
<li>程序可以使用一系列虚拟地址来<u>访问大于可用物理内存的内存缓冲区</u>。当物理内存的供应量变小时，内存管理器会将物理内存页（通常大小为 4 KB）保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动。</li>
<li><u>不同进程使用的虚拟地址彼此隔离</u>。一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。</li>
</ul>
<h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><p><strong>虚拟内存</strong> 使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存（例如 RAM）的使用也更有效率。目前，大多数操作系统都使用了虚拟内存，如 Windows 家族的“虚拟内存”；Linux 的“交换空间”等。</p>
<p><strong>局部性原理</strong>是虚拟内存技术的基础，正是因为程序运行具有局部性原理，才可以只装入部分程序到内存就开始运行。</p>
<p>局部性原理表现在以下两个方面：</p>
<ol>
<li><strong>时间局部性</strong> ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。</li>
<li><strong>空间局部性</strong> ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。</li>
</ol>
<p>时间局部性是通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。虚拟内存技术实际上就是建立了 “内存一外存”的两级存储器的结构，利用局部性原理实现髙速缓存。</p>
<p><strong>技术实现</strong></p>
<p><strong>虚拟内存的实现需要建立在离散分配的内存管理方式的基础上。</strong> 虚拟内存的实现有以下三种方式：</p>
<ol>
<li><strong>请求分页存储管理</strong> ：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。</li>
<li><strong>请求分段存储管理</strong> ：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。</li>
<li><strong>请求段页式存储管理</strong></li>
</ol>
<p><strong>这里多说一下？很多人容易搞混请求分页与分页存储管理，两者有何不同呢？</strong></p>
<p>请求分页存储管理建立在分页管理之上。他们的根本区别是是否将程序全部所需的全部地址空间都装入主存，这也是请求分页存储管理可以提供虚拟内存的原因，我们在上面已经分析过了。</p>
<p>它们之间的根本区别在于是否将一作业的全部地址空间同时装入主存。请求分页存储管理不要求将作业全部地址空间同时装入主存。基于这一点，请求分页存储管理可以提供虚存，而分页存储管理却不能提供虚存。</p>
<p>不管是上面那种实现方式，我们一般都需要：</p>
<ol>
<li>一定容量的内存和外存：在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了；</li>
<li><strong>缺页中断</strong>：如果<strong>需执行的指令或访问的数据尚未在内存</strong>（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段<strong>调入到内存</strong>，然后继续执行程序；</li>
<li><strong>虚拟地址空间</strong> ：逻辑地址到物理地址的变换。</li>
</ol>
<h4 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h4><p>地址映射过程中，若在页面中发现所要访问的页面不在内存中，则发生缺页中断 。</p>
<blockquote>
<p><strong>缺页中断</strong> 就是要访问的<strong>页</strong>不在主存，需要操作系统将其调入主存后再进行访问。 在这个时候，被内存映射的文件实际上成了一个分页交换文件。</p>
</blockquote>
<p>当发生缺页中断时，如果当前内存中并没有空闲的页面，操作系统就必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。用来选择淘汰哪一页的规则叫做页面置换算法，我们可以把页面置换算法看成是淘汰页面的规则。</p>
<img src="https://pic.imgdb.cn/item/62af60ff09475431290d4b29.jpg" style="zoom: 80%;" />

<h5 id="最佳置换法-OPT"><a href="#最佳置换法-OPT" class="headerlink" title="最佳置换法(OPT)"></a>最佳置换法(OPT)</h5><p>最佳置换算法(OPT，Optimal) :每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率。 </p>
<img src="https://pic.imgdb.cn/item/62af641c094754312910bd79.jpg" style="zoom:80%;" />



<p>最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面访问序列。因此，最佳置换算法是无法实现的</p>
<h5 id="先进先出置换算法-FIFO"><a href="#先进先出置换算法-FIFO" class="headerlink" title="先进先出置换算法(FIFO)"></a>先进先出置换算法(FIFO)</h5><p>先进先出置换算法(FIFO) :每次选择淘汰的页面是最早进入内存的页面 实现方法:把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面队列的最大长度取决于系统为进程分配了多少个内存块。</p>
<img src="https://pic.imgdb.cn/item/62af647b0947543129110ed3.jpg" style="zoom:80%;" />

<p>Belady异常—当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。</p>
<p>只有FIFO算法会产生Belady异常，而LRU和OPT算法永远不会出现Belady异常。另外，FIFO算法虽然实现简单，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问。因此，算法性能差</p>
<p>FIFO的性能较差，因为较早调入的页往往是经常被访问的页，这些页在FIFO算法下被反复调入和调出，并且有Belady现象。所谓Belady现象是指：采用FIFO算法时，如果对—个进程未分配它所要求的全部页面，有时就会出现分配的页面数增多但缺页率反而提高的异常现象。</p>
<h5 id="最近最久未使用置换算法-LRU"><a href="#最近最久未使用置换算法-LRU" class="headerlink" title="最近最久未使用置换算法(LRU)"></a>最近最久未使用置换算法(LRU)</h5><p>最近最久未使用置换算法(LRU，least recently used) :每次淘汰的页面是最近最久未使用的页面 实现方法:赋予每个页面对应的页表项中，用访问字段记录该页面自.上次被访问以来所经历的时间t(该算法的实现需要专门的硬件支持，虽然算法性能好，但是实现困难，开销大)。当需要淘汰一个页面时，选择现有页面中t值最大的，即最近最久未使用的页面。</p>
<p>LRU性能较好，但需要寄存器和栈的硬件支持。LRU是堆栈类算法，理论上可以证明，堆栈类算法不可能出现Belady异常。</p>
<img src="https://pic.imgdb.cn/item/62af638b09475431291040d6.jpg" style="zoom:80%;" />

<p>在手动做题时，若需要淘汰页面，可以逆向检查此时在内存中的几个页面号。在逆向扫描过程中最后一个出现的页号就是要淘汰的页面。</p>
<h5 id="时钟置换算法-CLOCK"><a href="#时钟置换算法-CLOCK" class="headerlink" title="时钟置换算法(CLOCK)"></a>时钟置换算法(CLOCK)</h5><p>最佳置换算法性OPT能最好，但无法实现；先进先出置换算法实现简单，但算法性能差；最近最久未使用置换算法性能好，是最接近OPT算法性能的，但是实现起来需要专门的硬件支持，算法开销大。</p>
<p>所以操作系统的设计者尝试了很多算法，试图用比较小的开销接近LRU的性能，这类算法都是CLOCK算法的变体，因为算法要循环扫描缓冲区像时钟一样转动。所以叫clock算法。</p>
<p>时钟置换算法是一种性能和开销较均衡的算法，又称CLOCK算法，或最近未用算法(NRU，Not Recently Used)</p>
<p>简单的CLOCK算法实现方法:为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。当某页被访问时，其访问位置为1。当需要淘汰-一个页面时，只需检查页的访问位。如果是0，就选择该页换出;如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第- - ~轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描(第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择–个淘汰页面最多会经过两轮扫描)</p>
<img src="https://pic.imgdb.cn/item/62af64b70947543129114310.jpg" style="zoom:80%;" />

<h5 id="改进型的时钟置换算法"><a href="#改进型的时钟置换算法" class="headerlink" title="改进型的时钟置换算法"></a>改进型的时钟置换算法</h5><p>简单的时钟置换算法仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过,就不需要执行I&#x2F;O操作写回外存。只有被淘汰的页面被修改过时，才需要写回外存。</p>
<p>因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。在其他条件都相同时，应优先淘汰没有修改过的页面，避免I&#x2F;O操作。这就是改进型的时钟置换算法的思想。修改位&#x3D;0，表示页面没有被修改过;修改位&#x3D;1，表示页面被修改过。</p>
<p>为方便讨论，用(访问位，修改位)的形式表示各页面状态。如(1, 1)表示一个页面近期被访问过，且被修改过。</p>
<p>改进型的Clock算法需要综合考虑某一内存页面的访问位和修改位来判断是否置换该页面。在实际编写算法过程中，同样可以用一个等长的整型数组来标识每个内存块的修改状态。访问位A和修改位M可以组成一下四种类型的页面。</p>
<p>算法规则:将所有可能被置换的页面排成–个循环队列</p>
<blockquote>
<p>第一轮:从当前位置开始扫描到第一个(A &#x3D;0, M &#x3D; 0)的帧用于替换。表示该页面最近既未被访问，又未被修改，是最佳淘汰页 第二轮:若第一轮扫描失败，则重新扫描，查找第一个(A &#x3D;1, M &#x3D; 0)的帧用于替换。本轮将所有扫描过的帧访问位设为0。表示该页面最近未被访问，但已被修改，并不是很好的淘汰页。 第三轮:若第二轮扫描失败，则重新扫描，查找第一个(A &#x3D;0, M &#x3D; 1)的帧用于替换。本轮扫描不修改任何标志位。表示该页面最近已被访问，但未被修改，该页有可能再被访问。 第四轮:若第三轮扫描失败，则重新扫描，查找第一个A &#x3D;1, M &#x3D; 1)的帧用于替换。表示该页最近已被访问且被修改，该页可能再被访问。</p>
</blockquote>
<p>由于第二轮已将所有帧的访问位设为0，因此经过第三轮、第四轮扫描一定会有一个帧被选中，因此改进型CLOCK置换算法选择- -个淘汰页面最多会进行四轮扫描</p>
<img src="https://pic.imgdb.cn/item/62af652d094754312911a4a8.jpg" style="zoom:80%;" />

<h4 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h4><img src="https://pic.imgdb.cn/item/62b1de3009475431290ba325.jpg" style="zoom:80%;" />

<p><strong>1. 首次适应算法</strong></p>
<p>算法思想：每次都从低地址开始查找，找到第–个能满足大小的空闲分区。</p>
<p>如何实现：<strong>空闲分区以地址递增的次序排列</strong>。每次分配内存时顺序查找空闲分区链( 或空闲分[表)，找到大小能满足要求的第-一个空闲分区。</p>
<img src="https://pic.imgdb.cn/item/62b1de5a09475431290be371.jpg" style="zoom: 67%;" />

<p><strong>2. 最佳适应算法</strong></p>
<p>算法思想:由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以<strong>尽可能多地留下大片的空闲区,即，优先使用更小的空闲区</strong>。</p>
<p>如何实现:<strong>空闲分区按容量递增次序链接</strong>。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第-一个空闲分区。 </p>
<img src="https://pic.imgdb.cn/item/62b1de7809475431290c1bd8.jpg" style="zoom:67%;" />

<p><strong>3. 最坏适应算法</strong></p>
<p>又称最大适应算法(Largest Fit)</p>
<p>算法思想:为了解决最佳适应算法的问题—即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。</p>
<p>如何实现:<strong>空闲分区按容量递减次序链接</strong>。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第-一个空闲分区。</p>
<img src="https://pic.imgdb.cn/item/62b1de9f09475431290c58ed.jpg" style="zoom:67%;" />

<p><strong>4. 邻近适应算法</strong></p>
<p>算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果<strong>每次都从上次查找结束的位置开始检索</strong>，就能解决上述问题。</p>
<p>如何实现：空闲分区以地址递增的顺序排列(可排成-一个循环链表)。每次分配内存时从上次查找结束的位置开始查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。 </p>
<img src="https://pic.imgdb.cn/item/62b1deb909475431290c866a.jpg" style="zoom:67%;" />

<p><strong>5. 总结</strong></p>
<p><strong>首次适应不仅最简单，通常也是最好最快</strong>，不过首次适应算法会使得内存低地址部分出现很多小的空闲分区，而每次查找都要经过这些分区，因此也增加了查找的开销。邻近算法试图解决这个问题，但实际上，它常常会导致在内存的末尾分配空间分裂成小的碎片，它通常比首次适应算法结果要差。</p>
<p>最佳导致大量碎片，最坏导致没有大的空间。</p>
<p>进过实验，首次适应比最佳适应要好，他们都比最坏好。</p>
<h3 id="5-其他"><a href="#5-其他" class="headerlink" title="5. 其他"></a>5. 其他</h3><h4 id="典型的锁"><a href="#典型的锁" class="headerlink" title="典型的锁"></a>典型的锁</h4><p><strong>背景：</strong></p>
<p><u>多线程访问共享资源的时候，避免不了资源竞争而导致数据错乱的问题，所以我们通常为了解决这一问题，都会在访问共享资源之前加锁。</u></p>
<p>最常用的就是互斥锁，当然还有很多种不同的锁，比如自旋锁、读写锁、乐观锁等，不同种类的锁自然适用于不同的场景。</p>
<p>如果选择了错误的锁，那么在一些高并发的场景下，可能会降低系统的性能，这样用户体验就会非常差了。</p>
<p><strong>锁的作用</strong>：</p>
<ul>
<li><strong>保障原子性</strong>：互斥，一个锁一次只能被一个线程持有，保证了临界区代码一次只能被一个线程执行，这使得临界区代码所执行的代码具有不可分割的特性，即保障了原子性</li>
<li><strong>保障可见性</strong>：获取锁时刷新处理器缓存，释放锁时冲刷处理器缓存</li>
<li><strong>保障有序性</strong>：注意：临界区内的内存操作依旧存在重排序</li>
</ul>
<img src="https://pic.imgdb.cn/item/62b1df6209475431290d838c.jpg" style="zoom:80%;" />

<img src="https://pic.imgdb.cn/item/62b1df9709475431290dd395.jpg" style="zoom:80%;" />

<img src="https://pic.imgdb.cn/item/62b1dfb809475431290e0ee2.jpg" style="zoom:80%;" />

<img src="https://pic.imgdb.cn/item/62b1dfdb09475431290e4e76.jpg" style="zoom:80%;" />
]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>DesignTemplate</title>
    <url>/2022/06/13/DesignTemplate/</url>
    <content><![CDATA[<p>本文介绍了软件设计的准则和常用的设计模式</p>
<span id="more"></span>

<h3 id="01-代码质量常用的评价标准"><a href="#01-代码质量常用的评价标准" class="headerlink" title="01. 代码质量常用的评价标准"></a>01. 代码质量常用的评价标准</h3><p>仔细看所有代码质量评价标准，你会发现，有些词语过于笼统、抽象，比较偏向对于整体的描述，比如优雅、好、坏、整洁、清晰等；有些过于细节、偏重方法论，比如模块化、高内聚低耦合、文档详尽、分层清晰等；有些可能并不仅仅局限于编码，跟架构设计等也有关系，比如可伸缩性、可用性、稳定性等。</p>
<p>挑选了其中几个最常用的、最重要的评价标准，来详细讲解，其中就包括：可维护性、可读性、可扩展性、灵活性、简洁性（简单、复杂）、可复用性、可测试性。</p>
<p><strong>1.可维护性（maintainability）</strong></p>
<p>落实到编码开发，所谓的“维护”无外乎就是修改bug、修改老的代码、添加新的代码之类的工作。所谓“代码易维护”就是指，在不破坏原有代码设计、不引入新的bug的情况下，能够快速地修改或者添加代码。所谓“代码不易维护”就是指，修改或者添加代码需要冒着极大的引入新bug的风险，并且需要花费很长的时间才能完成。</p>
<p>我们知道，对于一个项目来说，维护代码的时间远远大于编写代码的时间。工程师大部分的时间可能都是花在修修bug、改改老的功能逻辑、添加一些新的功能逻辑之类的工作上。所以，代码的可维护性就显得格外重要。</p>
<p>维护、易维护、不易维护这三个概念不难理解。不过，对于实际的软件开发来说，更重要的是搞清楚，如何来判断代码可维护性的好坏。</p>
<p>实际上，可维护性也是一个很难量化、偏向对代码整体的评价标准，它有点类似之前提到的“好”“坏”“优雅”之类的笼统评价。代码的可维护性是由很多因素协同作用的结果。代码的可读性好、简洁、可扩展性好，就会使得代码易维护；相反，就会使得代码不易维护。更细化地讲，如果代码分层清晰、模块化好、高内聚低耦合、遵从基于接口而非实现编程的设计原则等等，那就可能意味着代码易维护。除此之外，代码的易维护性还跟项目代码量的多少、业务的复杂程度、利用到的技术的复杂程度、文档是否全面、团队成员的开发水平等诸多因素有关。</p>
<p>所以，从正面去分析一个代码是否易维护稍微有点难度。不过，我们可以从侧面上给出一个比较主观但又比较准确的感受。如果bug容易修复，修改、添加功能能够轻松完成，那我们就可以主观地认为代码对我们来说易维护。相反，如果修改一个bug，修改、添加一个功能，需要花费很长的时间，那我们就可以主观地认为代码对我们来说不易维护。</p>
<p>你可能会说，这样的评价方式也太主观了吧？没错，是否易维护本来就是针对维护的人来说的。不同水平的人对于同一份代码的维护能力并不是相同的。对于同样一个系统，熟悉它的资深工程师会觉得代码的可维护性还不错，而一些新人因为不熟悉代码，修改bug、修改添加代码要花费很长的时间，就有可能会觉得代码的可维护性不那么好。这实际上也印证了我们之前的观点：代码质量的评价有很强的主观性。</p>
<p><strong>2.可读性（readability）</strong></p>
<p>软件设计大师Martin Fowler曾经说过：“Any fool can write code that a computer can understand. Good programmers write code that humans can understand.”翻译成中文就是：“任何傻瓜都会编写计算机能理解的代码。好的程序员能够编写人能够理解的代码。”Google内部甚至专门有个认证就叫作Readability。只有拿到这个认证的工程师，才有资格在code review的时候，批准别人提交代码。可见代码的可读性有多重要，毕竟，代码被阅读的次数远远超过被编写和执行的次数。</p>
<p>我个人认为，代码的可读性应该是评价代码质量最重要的指标之一。我们在编写代码的时候，时刻要考虑到代码是否易读、易理解。除此之外，代码的可读性在非常大程度上会影响代码的可维护性。毕竟，不管是修改bug，还是修改添加功能代码，我们首先要做的事情就是读懂代码。代码读不大懂，就很有可能因为考虑不周全，而引入新的bug。</p>
<p>既然可读性如此重要，那我们又该如何评价一段代码的可读性呢？</p>
<p>我们需要看代码是否符合编码规范、命名是否达意、注释是否详尽、函数是否长短合适、模块划分是否清晰、是否符合高内聚低耦合等等。你应该也能感觉到，从正面上，我们很难给出一个覆盖所有评价指标的列表。这也是我们无法量化可读性的原因。</p>
<p>实际上，code review是一个很好的测验代码可读性的手段。如果你的同事可以轻松地读懂你写的代码，那说明你的代码可读性很好；如果同事在读你的代码时，有很多疑问，那就说明你的代码可读性有待提高了。</p>
<p><strong>3.可扩展性（extensibility）</strong></p>
<p>可扩展性也是一个评价代码质量非常重要的标准。它表示我们的代码应对未来需求变化的能力。跟可读性一样，代码是否易扩展也很大程度上决定代码是否易维护。那到底什么是代码的可扩展性呢？</p>
<p>代码的可扩展性表示，我们<u>在不修改或少量修改原有代码的情况下，通过扩展的方式添加新的功能代码</u>。说直白点就是，代码预留了一些功能扩展点，你可以把新功能代码，直接插到扩展点上，而不需要因为要添加一个功能而大动干戈，改动大量的原始代码。</p>
<p>关于代码的扩展性，在后面讲到“对修改关闭，对扩展开放”这条设计原则的时候，我会来详细讲解，今天我们只需要知道，代码的可扩展性是评价代码质量非常重要的标准就可以了。</p>
<p><strong>4.灵活性（flexibility）</strong></p>
<p>灵活性也是描述代码质量的一个常用词汇。比如我们经常会听到这样的描述：“代码写得很灵活”。那这里的“灵活”该如何理解呢？</p>
<p>尽管有很多人用这个词汇来描述代码的质量。但实际上，灵活性是一个挺抽象的评价标准，要给灵活性下个定义也是挺难的。不过，我们可以想一下，什么情况下我们才会说代码写得好灵活呢？我这里罗列了几个场景，希望能引发你自己对什么是灵活性的思考。</p>
<ul>
<li>当我们添加一个新的功能代码的时候，原有的代码已经预留好了扩展点，我们不需要修改原有的代码，只要在扩展点上添加新的代码即可。这个时候，我们除了可以说代码易扩展，还可以说代码写得好灵活。</li>
<li>当我们要实现一个功能的时候，发现原有代码中，已经抽象出了很多底层可以复用的模块、类等代码，我们可以拿来直接使用。这个时候，我们除了可以说代码易复用之外，还可以说代码写得好灵活。</li>
<li>当我们使用某组接口的时候，如果这组接口可以应对各种使用场景，满足各种不同的需求，我们除了可以说接口易用之外，还可以说这个接口设计得好灵活或者代码写得好灵活。</li>
</ul>
<p>从刚刚举的场景来看，如果一段代码易扩展、易复用或者易用，我们都可以称这段代码写得比较灵活。所以，灵活这个词的含义非常宽泛，很多场景下都可以使用。</p>
<p><strong>5.简洁性（simplicity）</strong></p>
<p>有一条非常著名的设计原则，你一定听过，那就是KISS原则：“Keep It Simple，Stupid”。这个原则说的意思就是，尽量保持代码简单。代码简单、逻辑清晰，也就意味着易读、易维护。我们在编写代码的时候，往往也会把简单、清晰放到首位。</p>
<p>不过，很多编程经验不足的程序员会觉得，简单的代码没有技术含量，喜欢在项目中引入一些复杂的设计模式，觉得这样才能体现自己的技术水平。实际上，<strong>思从深而行从简，真正的高手能云淡风轻地用最简单的方法解决最复杂的问题。这也是一个编程老手跟编程新手的本质区别之一。</strong></p>
<p>除此之外，虽然我们都能认识到，代码要尽量写得简洁，符合KISS原则，但怎么样的代码才算足够简洁？不是每个人都能很准确地判断出来这一点。所以，在后面的章节中，当我们讲到KISS原则的时候，我会通过具体的代码实例，详细给你解释，“为什么KISS原则看似非常简单、好理解，但实际上用好并不容易”。今天，我们就暂且不展开详细讲解了。</p>
<p><strong>6.可复用性（reusability）</strong></p>
<p>代码的可复用性可以简单地理解为，尽量减少重复代码的编写，复用已有的代码。在后面的很多章节中，我们都会经常提到“可复用性”这一代码评价标准。</p>
<p>比如，当讲到面向对象特性的时候，我们会讲到继承、多态存在的目的之一，就是为了提高代码的可复用性；当讲到设计原则的时候，我们会讲到单一职责原则也跟代码的可复用性相关；当讲到重构技巧的时候，我们会讲到解耦、高内聚、模块化等都能提高代码的可复用性。可见，可复用性也是一个非常重要的代码评价标准，是很多设计原则、思想、模式等所要达到的最终效果。</p>
<p>实际上，代码可复用性跟DRY（Don’t Repeat Yourself）这条设计原则的关系挺紧密的，所以，在后面的章节中，当我们讲到DRY设计原则的时候，我还会讲更多代码复用相关的知识，比如，“有哪些编程方法可以提高代码的复用性”等。</p>
<p><strong>7.可测试性（testability）</strong></p>
<p>相对于前面六个评价标准，代码的可测试性是一个相对较少被提及，但又非常重要的代码质量评价标准。代码可测试性的好坏，能从侧面上非常准确地反应代码质量的好坏。代码的可测试性差，比较难写单元测试，那基本上就能说明代码设计得有问题。关于代码的可测试性，我们在重构那一部分，会花两节课的时间来详细讲解。现在，你暂时只需要知道，代码的可测试性非常重要就可以了。</p>
<h3 id="02-面向对象、设计原则、设计模式、编程规范、重构"><a href="#02-面向对象、设计原则、设计模式、编程规范、重构" class="headerlink" title="02. 面向对象、设计原则、设计模式、编程规范、重构"></a>02. 面向对象、设计原则、设计模式、编程规范、重构</h3><p><strong>面向对象</strong></p>
<p>现在，主流的编程范式或者是编程风格有三种，它们分别是面向过程、面向对象和函数式编程。面向对象这种编程风格又是这其中最主流的。现在比较流行的编程语言大部分都是面向对象编程语言。大部分项目也都是基于面向对象编程风格开发的。面向对象编程因为其具有丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式编码实现的基础。</p>
<p>主要有下面这7个大的知识点。</p>
<ul>
<li>面向对象的四大特性：封装、抽象、继承、多态</li>
<li>面向对象编程与面向过程编程的区别和联系</li>
<li>面向对象分析、面向对象设计、面向对象编程</li>
<li>接口和抽象类的区别以及各自的应用场景</li>
<li>基于接口而非实现编程的设计思想</li>
<li>多用组合少用继承的设计思想</li>
<li>面向过程的贫血模型和面向对象的充血模型</li>
</ul>
<p><strong>设计原则</strong></p>
<p>设计原则是指导我们代码设计的一些经验总结。设计原则这块儿的知识有一个非常大的特点，那就是这些原则听起来都比较抽象，定义描述都比较模糊，不同的人会有不同的解读。所以，如果单纯地去记忆定义，对于编程、设计能力的提高，意义并不大。对于每一种设计原则，我们需要掌握它的设计初衷，能解决哪些编程问题，有哪些应用场景。只有这样，我们才能在项目中灵活恰当地应用这些原则。</p>
<p>对于这一部分内容，你需要透彻理解并且掌握，如何应用下面这样几个常用的设计原则。</p>
<ul>
<li>SOLID原则-SRP单一职责原则</li>
<li>SOLID原则-OCP开闭原则</li>
<li>SOLID原则-LSP里式替换原则</li>
<li>SOLID原则-ISP接口隔离原则</li>
<li>SOLID原则-DIP依赖倒置原则</li>
<li>DRY原则、KISS原则、YAGNI原则、LOD法则</li>
</ul>
<p><strong>设计模式</strong></p>
<p>设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。大部分设计模式要解决的都是代码的可扩展性问题。设计模式相对于设计原则来说，没有那么抽象，而且大部分都不难理解，代码实现也并不复杂。这一块的学习难点是了解它们都能解决哪些问题，掌握典型的应用场景，并且懂得不过度应用。</p>
<p>经典的设计模式有23种。随着编程语言的演进，一些设计模式（比如Singleton）也随之过时，甚至成了反模式，一些则被内置在编程语言中（比如Iterator），另外还有一些新的模式诞生（比如Monostate）。</p>
<p>在专栏中，我们会重点讲解23种经典的设计模式。它们又可以分为三大类：创建型、结构型、行为型。对于这23种设计模式的学习，我们要有侧重点，因为有些模式是比较常用的，有些模式是很少被用到的。对于常用的设计模式，我们要花多点时间理解掌握。对于不常用的设计模式，我们只需要稍微了解即可。</p>
<p>我按照类型和是否常用，对专栏中讲到的这些设计模式，进行了简单的分类，具体如下所示。</p>
<ul>
<li>创建型<ul>
<li>常用的有：单例模式、工厂模式（工厂方法和抽象工厂）、建造者模式。</li>
<li>不常用的有：原型模式。</li>
</ul>
</li>
<li>结构型<ul>
<li>常用的有：代理模式、桥接模式、装饰者模式、适配器模式。</li>
<li>不常用的有：门面模式、组合模式、享元模式。</li>
</ul>
</li>
<li>行为型<ul>
<li>常用的有：观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式。</li>
<li>不常用的有：访问者模式、备忘录模式、命令模式、解释器模式、中介模式。</li>
</ul>
</li>
</ul>
<p><strong>编程规范</strong></p>
<p>编程规范主要解决的是代码的可读性问题。编码规范相对于设计原则、设计模式，更加具体、更加偏重代码细节。即便你可能对设计原则不熟悉、对设计模式不了解，但你最起码要掌握基本的编码规范，比如，如何给变量、类、函数命名，如何写代码注释，函数不宜过长、参数不能过多等等。</p>
<p>对于编码规范，考虑到很多书籍已经讲得很好了（比如《重构》《代码大全》《代码整洁之道》等）。而且，每条编码规范都非常简单、非常明确，比较偏向于记忆，你只要照着来做可以。它不像设计原则，需要融入很多个人的理解和思考。所以，在这个专栏中，我并没有花太多的篇幅来讲解所有的编码规范，而是总结了我认为的最能改善代码质量的20条规范。如果你暂时没有时间去看那些经典的书籍，看我这些就够了。</p>
<p>除此之外，专栏并没有将编码规范单独作为一个模块来讲解，而是跟重构放到了一起。之所以这样做，那是因为我把重构分为大重构和小重构两种类型，而小重构利用的知识基本上就是编码规范。</p>
<p>除了编码规范，我们还会介绍一些代码的坏味道，让你知道什么样的代码是不符合规范的，应该如何优化。参照编码规范，你可以写出可读性好的代码；参照代码的坏味道，你可以找出代码存在的可读性问题。</p>
<p><strong>代码重构</strong></p>
<p>在软件开发中，只要软件在不停地迭代，就没有一劳永逸的设计。随着需求的变化，代码的不停堆砌，原有的设计必定会存在这样那样的问题。针对这些问题，我们就需要进行代码重构。重构是软件开发中非常重要的一个环节。持续重构是保持代码质量不下降的有效手段，能有效避免代码腐化到无可救药的地步。</p>
<p>而重构的工具就是我们前面罗列的那些面向对象设计思想、设计原则、设计模式、编码规范。实际上，设计思想、设计原则、设计模式一个最重要的应用场景就是在重构的时候。我们前面讲过，虽然使用设计模式可以提高代码的可扩展性，但过度不恰当地使用，也会增加代码的复杂度，影响代码的可读性。在开发初期，除非特别必须，我们一定不要过度设计，应用复杂的设计模式。而是当代码出现问题的时候，我们再针对问题，应用原则和模式进行重构。这样就能有效避免前期的过度设计。</p>
<p>对于重构这部分内容，你需要掌握以下几个知识点：</p>
<ul>
<li>重构的目的（why）、对象（what）、时机（when）、方法（how）；</li>
<li>保证重构不出错的技术手段：单元测试和代码的可测试性；</li>
<li>两种不同规模的重构：大重构（大规模高层次）和小重构（小规模低层次）。</li>
</ul>
<p>希望你学完这部分内容之后，不仅仅是掌握一些重构技巧、套路，更重要的是建立持续重构意识，把重构当作开发的一部分，融入到日常的开发中。</p>
<p><strong>五者之间的联系</strong></p>
<p>关于面向对象、设计原则、设计模式、编程规范和代码重构，这五者的关系总结梳理：</p>
<ul>
<li>面向对象编程因为其具有丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式等编码实现的基础。</li>
<li>设计原则是指导我们代码设计的一些经验总结，对于某些场景下，是否应该应用某种设计模式，具有指导意义。比如，“开闭原则”是很多设计模式（策略、模板等）的指导原则。</li>
<li>设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。应用设计模式的主要目的是提高代码的可扩展性。从抽象程度上来讲，设计原则比设计模式更抽象。设计模式更加具体、更加可执行。</li>
<li>编程规范主要解决的是代码的可读性问题。编码规范相对于设计原则、设计模式，更加具体、更加偏重代码细节、更加能落地。持续的小重构依赖的理论基础主要就是编程规范。</li>
<li>重构作为保持代码质量不下降的有效手段，利用的就是面向对象、设计原则、设计模式、编码规范这些理论。</li>
</ul>
<p>实际上，面向对象、设计原则、设计模式、编程规范、代码重构，这五者都是保持或者提高代码质量的方法论，本质上都是服务于编写高质量代码这一件事的。当我们追本逐源，看清这个本质之后，很多事情怎么做就清楚了，很多选择怎么选也清楚了。比如，在某个场景下，该不该用这个设计模式，那就看能不能提高代码的可扩展性；要不要重构，那就看重代码是否存在可读、可维护问题等。</p>
<h3 id="03-封装、抽象、继承、多态"><a href="#03-封装、抽象、继承、多态" class="headerlink" title="03. 封装、抽象、继承、多态"></a>03. 封装、抽象、继承、多态</h3><p><strong>封装（Encapsulation）</strong></p>
<p>首先，我们来看封装特性。封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式（或者叫函数）来访问内部信息或者数据。这句话怎么理解呢？我们通过一个简单的例子来解释一下。</p>
<p>下面这段代码是金融系统中一个简化版的虚拟钱包的代码实现。在金融系统中，我们会给每个用户创建一个虚拟钱包，用来记录用户在我们的系统中的虚拟货币量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Wallet</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String id;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> createTime;</span><br><span class="line">  <span class="keyword">private</span> BigDecimal balance;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> balanceLastModifiedTime;</span><br><span class="line">  <span class="comment">// ...省略其他属性...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Wallet</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.id = IdGenerator.getInstance().generate();</span><br><span class="line">     <span class="built_in">this</span>.createTime = System.currentTimeMillis();</span><br><span class="line">     <span class="built_in">this</span>.balance = BigDecimal.ZERO;</span><br><span class="line">     <span class="built_in">this</span>.balanceLastModifiedTime = System.currentTimeMillis();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意：下面对get方法做了代码折叠，是为了减少代码所占文章的篇幅</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.id; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getCreateTime</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.createTime; &#125;</span><br><span class="line">  <span class="keyword">public</span> BigDecimal <span class="title function_">getBalance</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.balance; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getBalanceLastModifiedTime</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.balanceLastModifiedTime;  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increaseBalance</span><span class="params">(BigDecimal increasedAmount)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (increasedAmount.compareTo(BigDecimal.ZERO) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidAmountException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.balance.add(increasedAmount);</span><br><span class="line">    <span class="built_in">this</span>.balanceLastModifiedTime = System.currentTimeMillis();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decreaseBalance</span><span class="params">(BigDecimal decreasedAmount)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (decreasedAmount.compareTo(BigDecimal.ZERO) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidAmountException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (decreasedAmount.compareTo(<span class="built_in">this</span>.balance) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InsufficientAmountException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.balance.subtract(decreasedAmount);</span><br><span class="line">    <span class="built_in">this</span>.balanceLastModifiedTime = System.currentTimeMillis();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中，我们可以发现，Wallet类主要有四个属性（也可以叫作成员变量），也就是我们前面定义中提到的信息或者数据。其中，id表示钱包的唯一编号，createTime表示钱包创建的时间，balance表示钱包中的余额，balanceLastModifiedTime表示上次钱包余额变更的时间。</p>
<p>我们参照封装特性，对钱包的这四个属性的访问方式进行了限制。调用者只允许通过下面这六个方法来访问或者修改钱包里的数据。</p>
<ul>
<li><code>String getId()</code></li>
<li><code>long getCreateTime()</code></li>
<li><code>BigDecimal getBalance()</code></li>
<li><code>long getBalanceLastModifiedTime()</code></li>
<li><code>void increaseBalance(BigDecimal increasedAmount)</code></li>
<li><code>void decreaseBalance(BigDecimal decreasedAmount)</code></li>
</ul>
<p>之所以这样设计，是因为从业务的角度来说，id、createTime在创建钱包的时候就确定好了，之后不应该再被改动，所以，我们并没有在Wallet类中，暴露id、createTime这两个属性的任何修改方法，比如set方法。而且，这两个属性的初始化设置，对于Wallet类的调用者来说，也应该是透明的，所以，我们在Wallet类的构造函数内部将其初始化设置好，而不是通过构造函数的参数来外部赋值。</p>
<p>对于钱包余额balance这个属性，从业务的角度来说，只能增或者减，不会被重新设置。所以，我们在Wallet类中，只暴露了increaseBalance()和decreaseBalance()方法，并没有暴露set方法。对于balanceLastModifiedTime这个属性，它完全是跟balance这个属性的修改操作绑定在一起的。只有在balance修改的时候，这个属性才会被修改。所以，我们把balanceLastModifiedTime这个属性的修改操作完全封装在了increaseBalance()和decreaseBalance()两个方法中，不对外暴露任何修改这个属性的方法和业务细节。这样也可以保证balance和balanceLastModifiedTime两个数据的一致性。</p>
<p>对于封装这个特性，我们需要编程语言本身提供一定的语法机制来支持。这个语法机制就是<strong>访问权限控制。</strong>例子中的private、public等关键字就是Java语言中的访问权限控制语法。private关键字修饰的属性只能类本身访问，可以保护其不被类之外的代码直接访问。如果Java语言没有提供访问权限控制语法，所有的属性默认都是public的，那任意外部代码都可以通过类似wallet.id&#x3D;123;这样的方式直接访问、修改属性，也就没办法达到隐藏信息和保护数据的目的了，也就无法支持封装特性了。</p>
<p><strong>封装特性的定义讲完了，我们再来看一下，封装的意义是什么？它能解决什么编程问题？</strong></p>
<p>如果我们对类中属性的访问不做限制，那任何代码都可以访问、修改类中的属性，虽然这样看起来更加灵活，但从另一方面来说，过度灵活也意味着不可控，属性可以随意被以各种奇葩的方式修改，而且修改逻辑可能散落在代码中的各个角落，势必影响代码的可读性、可维护性。比如某个同事在不了解业务逻辑的情况下，在某段代码中“偷偷地”重设了wallet中的balanceLastModifiedTime属性，这就会导致balance和balanceLastModifiedTime两个数据不一致。</p>
<p>除此之外，类仅仅通过有限的方法暴露必要的操作，也能提高类的易用性。如果我们把类属性都暴露给类的调用者，调用者想要正确地操作这些属性，就势必要对业务细节有足够的了解。而这对于调用者来说也是一种负担。相反，如果我们将属性封装起来，暴露少许的几个必要的方法给调用者使用，调用者就不需要了解太多背后的业务细节，用错的概率就减少很多。这就好比，如果一个冰箱有很多按钮，你就要研究很长时间，还不一定能操作正确。相反，如果只有几个必要的按钮，比如开、停、调节温度，你一眼就能知道该如何来操作，而且操作出错的概率也会降低很多。</p>
<p><strong>抽象（Abstraction）</strong></p>
<p>讲完了封装特性，我们再来看抽象特性。 封装主要讲的是如何隐藏信息、保护数据，而抽象讲的是如何隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的。</p>
<p>在面向对象编程中，我们常借助编程语言提供的接口类（比如Java中的interface关键字语法）或者抽象类（比如Java中的abstract关键字语法）这两种语法机制，来实现抽象这一特性。</p>
<p>这里我稍微说明一下，在专栏中，我们把编程语言提供的接口语法叫作“接口类”而不是“接口”。之所以这么做，是因为“接口”这个词太泛化，可以指好多概念，比如API接口等，所以，我们用“接口类”特指编程语言提供的接口语法。</p>
<p>对于抽象这个特性，我举一个例子来进一步解释一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IPictureStorage</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">savePicture</span><span class="params">(Picture picture)</span>;</span><br><span class="line">  Image <span class="title function_">getPicture</span><span class="params">(String pictureId)</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">deletePicture</span><span class="params">(String pictureId)</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">modifyMetaInfo</span><span class="params">(String pictureId, PictureMetaInfo metaInfo)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PictureStorage</span> <span class="keyword">implements</span> <span class="title class_">IPictureStorage</span> &#123;</span><br><span class="line">  <span class="comment">// ...省略其他属性...</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">savePicture</span><span class="params">(Picture picture)</span> &#123; ... &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Image <span class="title function_">getPicture</span><span class="params">(String pictureId)</span> &#123; ... &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deletePicture</span><span class="params">(String pictureId)</span> &#123; ... &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">modifyMetaInfo</span><span class="params">(String pictureId, PictureMetaInfo metaInfo)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的这段代码中，我们利用Java中的interface接口语法来实现抽象特性。调用者在使用图片存储功能的时候，只需要了解IPictureStorage这个接口类暴露了哪些方法就可以了，不需要去查看PictureStorage类里的具体实现逻辑。</p>
<p>实际上，抽象这个特性是非常容易实现的，并不需要非得依靠接口类或者抽象类这些特殊语法机制来支持。换句话说，并不是说一定要为实现类（PictureStorage）抽象出接口类（IPictureStorage），才叫作抽象。即便不编写IPictureStorage接口类，单纯的PictureStorage类本身就满足抽象特性。</p>
<p>之所以这么说，那是因为，类的方法是通过编程语言中的“函数”这一语法机制来实现的。通过函数包裹具体的实现逻辑，这本身就是一种抽象。调用者在使用函数的时候，并不需要去研究函数内部的实现逻辑，只需要通过函数的命名、注释或者文档，了解其提供了什么功能，就可以直接使用了。比如，我们在使用C语言的malloc()函数的时候，并不需要了解它的底层代码是怎么实现的。</p>
<p>除此之外，抽象有时候会被排除在面向对象的四大特性之外，现在解释一下为什么。</p>
<p>抽象这个概念是一个非常通用的设计思想，并不单单用在面向对象编程中，也可以用来指导架构设计等。而且这个特性也并不需要编程语言提供特殊的语法机制来支持，只需要提供“函数”这一非常基础的语法机制，就可以实现抽象特性、所以，它没有很强的“特异性”，有时候并不被看作面向对象编程的特性之一。</p>
<p><strong>抽象特性的定义讲完了，我们再来看一下，抽象的意义是什么？它能解决什么编程问题？</strong></p>
<p>实际上，如果上升一个思考层面的话，抽象及其前面讲到的封装都是人类处理复杂性的有效手段。在面对复杂系统的时候，人脑能承受的信息复杂程度是有限的，所以我们必须忽略掉一些非关键性的实现细节。而抽象作为一种只关注功能点不关注实现的设计思路，正好帮我们的大脑过滤掉许多非必要的信息。</p>
<p>除此之外，抽象作为一个非常宽泛的设计思想，在代码设计中，起到非常重要的指导作用。很多设计原则都体现了抽象这种设计思想，比如基于接口而非实现编程、开闭原则（对扩展开放、对修改关闭）、代码解耦（降低代码的耦合性）等。</p>
<p>换一个角度来考虑，我们在定义（或者叫命名）类的方法的时候，也要有抽象思维，不要在方法定义中，暴露太多的实现细节，以保证在某个时间点需要改变方法的实现逻辑的时候，不用去修改其定义。举个简单例子，比如getAliyunPictureUrl()就不是一个具有抽象思维的命名，因为某一天如果我们不再把图片存储在阿里云上，而是存储在私有云上，那这个命名也要随之被修改。相反，如果我们定义一个比较抽象的函数，比如叫作getPictureUrl()，那即便内部存储方式修改了，我们也不需要修改命名。</p>
<p><strong>继承（Inheritance）</strong></p>
<p>学习完了封装和抽象两个特性，我们再来看继承特性。如果你熟悉的是类似Java、C++这样的面向对象的编程语言，那你对继承这一特性，应该不陌生了。<u>继承是用来表示类之间的is-a关系</u>，比如猫是一种哺乳动物。从继承关系上来讲，继承可以分为两种模式，单继承和多继承。单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类，比如猫既是哺乳动物，又是爬行动物。</p>
<p>为了实现继承这个特性，编程语言需要提供特殊的语法机制来支持，比如Java使用extends关键字来实现继承，C++使用冒号（class B : public A），Python使用parentheses ()，Ruby使用&lt;。不过，有些编程语言只支持单继承，不支持多重继承，比如Java、PHP、C#、Ruby等，而有些编程语言既支持单重继承，也支持多重继承，比如C++、Python、Perl等。</p>
<p><strong>继承特性的定义讲完了，我们再来看，继承存在的意义是什么？它能解决什么编程问题？</strong></p>
<p>继承最大的一个好处就是<u>代码复用</u>。假如两个类有一些相同的属性和方法，我们就可以将这些相同的部分，抽取到父类中，让两个子类继承父类。这样，两个子类就可以重用父类中的代码，避免代码重复写多遍。不过，这一点也并不是继承所独有的，我们也可以通过其他方式来解决这个代码复用的问题，比如利用组合关系而不是继承关系。</p>
<p>如果我们再上升一个思维层面，去思考继承这一特性，可以这么理解：我们代码中有一个猫类，有一个哺乳动物类。猫属于哺乳动物，从人类认知的角度上来说，是一种is-a关系。我们通过继承来关联两个类，反应真实世界中的这种关系，非常符合人类的认知，而且，从设计的角度来说，也有一种结构美感。</p>
<p>继承的概念很好理解，也很容易使用。不过，过度使用继承，继承层次过深过复杂，就会导致代码可读性、可维护性变差。为了了解一个类的功能，我们不仅需要查看这个类的代码，还需要按照继承关系一层一层地往上查看“父类、父类的父类……”的代码。还有，子类和父类高度耦合，修改父类的代码，会直接影响到子类。</p>
<p>所以，继承这个特性也是一个非常有争议的特性。很多人觉得继承是一种反模式。我们应该尽量少用，甚至不用。关于这个问题，在后面讲到“多用组合少用继承”这种设计思想的时候，我会非常详细地再讲解，这里暂时就不展开讲解了。</p>
<p><strong>多态（Polymorphism）</strong></p>
<p>学习完了封装、抽象、继承之后，我们再来看面向对象编程的最后一个特性，多态。<u>多态是指，子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。</u>看一个具体的例子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicArray</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> DEFAULT_CAPACITY;</span><br><span class="line">  <span class="keyword">protected</span> Integer[] elements = <span class="keyword">new</span> <span class="title class_">Integer</span>[DEFAULT_CAPACITY];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.size; &#125;</span><br><span class="line">  <span class="keyword">public</span> Integer <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123; <span class="keyword">return</span> elements[index];&#125;</span><br><span class="line">  <span class="comment">//...省略n多方法...</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Integer e)</span> &#123;</span><br><span class="line">    ensureCapacity();</span><br><span class="line">    elements[size++] = e;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...如果数组满了就扩容...代码省略...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortedDynamicArray</span> <span class="keyword">extends</span> <span class="title class_">DynamicArray</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Integer e)</span> &#123;</span><br><span class="line">    ensureCapacity();</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = size-<span class="number">1</span>; i&gt;=<span class="number">0</span>; --i) &#123; <span class="comment">//保证数组中的数据有序</span></span><br><span class="line">      <span class="keyword">if</span> (elements[i] &gt; e) &#123;</span><br><span class="line">        elements[i+<span class="number">1</span>] = elements[i];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    elements[i+<span class="number">1</span>] = e;</span><br><span class="line">    ++size;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(DynamicArray dynamicArray)</span> &#123;</span><br><span class="line">    dynamicArray.add(<span class="number">5</span>);</span><br><span class="line">    dynamicArray.add(<span class="number">1</span>);</span><br><span class="line">    dynamicArray.add(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dynamicArray.size(); ++i) &#123;</span><br><span class="line">      System.out.println(dynamicArray.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">    <span class="type">DynamicArray</span> <span class="variable">dynamicArray</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SortedDynamicArray</span>();</span><br><span class="line">    test(dynamicArray); <span class="comment">// 打印结果：1、3、5</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多态这种特性也需要编程语言提供特殊的语法机制来实现。在上面的例子中，我们用到了三个语法机制来实现多态。</p>
<ul>
<li>第一个语法机制是编程语言<u>要支持父类对象可以引用子类对象</u>，也就是可以将SortedDynamicArray传递给DynamicArray。</li>
<li>第二个语法机制是编程语言<u>要支持继承</u>，也就是SortedDynamicArray继承了DynamicArray，才能将SortedDyamicArray传递给DynamicArray。</li>
<li>第三个语法机制是编程语言<u>要支持子类可以重写（override）父类中的方法</u>，也就是SortedDyamicArray重写了DynamicArray中的add()方法。</li>
</ul>
<p>通过这三种语法机制配合在一起，我们就实现了在test()方法中，子类SortedDyamicArray替换父类DynamicArray，执行子类SortedDyamicArray的add()方法，也就是实现了多态特性。</p>
<p>对于多态特性的实现方式，除了利用“继承加方法重写”这种实现方式之外，我们还有其他两种比较常见的的实现方式，一个是利用接口类语法，另一个是利用duck-typing语法。不过，并不是每种编程语言都支持接口类或者duck-typing这两种语法机制，比如C++就不支持接口类语法，而duck-typing只有一些动态语言才支持，比如Python、JavaScript等。</p>
<p><strong>接下来，我们先来看如何利用接口类来实现多态特性。</strong>我们还是先来看一段代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">  String <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">  String <span class="title function_">remove</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Array</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String[] data;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">next</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">remove</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">  <span class="comment">//...省略其他方法...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> LinkedListNode head;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">next</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">remove</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">  <span class="comment">//...省略其他方法... </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(Iterator iterator)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">      System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">arrayIterator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">    print(arrayIterator);</span><br><span class="line">    </span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">linkedListIterator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">    print(linkedListIterator);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段代码中，Iterator是一个接口类，定义了一个可以遍历集合数据的迭代器。Array和LinkedList都实现了接口类Iterator。我们通过传递不同类型的实现类（Array、LinkedList）到print(Iterator iterator)函数中，支持动态的调用不同的next()、hasNext()实现。</p>
<p>具体点讲就是，当我们往print(Iterator iterator)函数传递Array类型的对象的时候，print(Iterator iterator)函数就会调用Array的next()、hasNext()的实现逻辑；当我们往print(Iterator iterator)函数传递LinkedList类型的对象的时候，print(Iterator iterator)函数就会调用LinkedList的next()、hasNext()的实现逻辑。</p>
<p><strong>刚刚讲的是用接口类来实现多态特性。现在，我们再来看下，如何用duck-typing来实现多态特性。</strong>我们还是先来看一段代码。这是一段Python代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">record</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(“I write a log into file.”)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DB</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">record</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(“I insert data into db. ”)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">recorder</span>):</span><br><span class="line">    recorder.record()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">demo</span>():</span><br><span class="line">    logger = Logger()</span><br><span class="line">    db = DB()</span><br><span class="line">    test(logger)</span><br><span class="line">    test(db)</span><br></pre></td></tr></table></figure>

<p>从这段代码中，我们发现，duck-typing实现多态的方式非常灵活。Logger和DB两个类没有任何关系，既不是继承关系，也不是接口和实现的关系，但是只要它们都有定义了record()方法，就可以被传递到test()方法中，在实际运行的时候，执行对应的record()方法。</p>
<p>也就是说，只要两个类具有相同的方法，就可以实现多态，并不要求两个类之间有任何关系，这就是所谓的duck-typing，是一些动态语言所特有的语法机制。而像Java这样的静态语言，通过继承实现多态特性，必须要求两个类之间有继承关系，通过接口实现多态特性，类必须实现对应的接口。</p>
<p><strong>多态特性讲完了，我们再来看，多态特性存在的意义是什么？它能解决什么编程问题？</strong></p>
<p>多态特性能提高代码的可扩展性和复用性。为什么这么说呢？我们回过头去看讲解多态特性的时候，举的第二个代码实例（Iterator的例子）。</p>
<p>在那个例子中，我们利用多态的特性，仅用一个print()函数就可以实现遍历打印不同类型（Array、LinkedList）集合的数据。当再增加一种要遍历打印的类型的时候，比如HashMap，我们只需让HashMap实现Iterator接口，重新实现自己的hasNext()、next()等方法就可以了，完全不需要改动print()函数的代码。所以说，多态提高了代码的可扩展性。</p>
<p>如果我们不使用多态特性，我们就无法将不同的集合类型（Array、LinkedList）传递给相同的函数（print(Iterator iterator)函数）。我们需要针对每种要遍历打印的集合，分别实现不同的print()函数，比如针对Array，我们要实现print(Array array)函数，针对LinkedList，我们要实现print(LinkedList linkedList)函数。而利用多态特性，我们只需要实现一个print()函数的打印逻辑，就能应对各种集合数据的打印操作，这显然提高了代码的复用性。</p>
<p>除此之外，多态也是很多设计模式、设计原则、编程技巧的代码实现基础，比如策略模式、基于接口而非实现编程、依赖倒置原则、里式替换原则、利用多态去掉冗长的if-else语句等等。关于这点，在学习后面的章节中，你慢慢会有更深的体会。</p>
<h3 id="04-面向对象与面向过程"><a href="#04-面向对象与面向过程" class="headerlink" title="04. 面向对象与面向过程"></a>04. 面向对象与面向过程</h3><p><strong>什么是面向过程编程与面向过程编程语言</strong>？</p>
<p>如果你是一名比较资深的程序员，最开始学习编程的时候，接触的是Basic、Pascal、C等面向过程的编程语言，那你对这两个概念肯定不陌生。但如果你是新生代的程序员，一开始学编程的时候，接触的就是面向对象编程语言，那你对这两个概念可能会比较不熟悉。所以，在对比面向对象与面向过程优劣之前，我们先把面向过程编程和面向过程编程语言这两个概念搞清楚。</p>
<p>实际上，我们可以对比着面向对象编程和面向对象编程语言这两个概念，来理解面向过程编程和面向过程编程语言。</p>
<ul>
<li>面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。</li>
<li>面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言。</li>
</ul>
<p>类比面向对象编程与面向对象编程语言的定义，对于面向过程编程和面向过程编程语言这两个概念，给出下面这样的定义。</p>
<ul>
<li>面向过程编程也是一种编程范式或编程风格。它以过程（可以理解为方法、函数、操作）作为组织代码的基本单元，以数据（可以理解为成员变量、属性）与方法相分离为最主要的特点。面向过程风格是一种<u>流程化的编程风格，通过拼接一组顺序执行的方法来操作数据完成一项功能</u>。</li>
<li>面向过程编程语言首先是一种编程语言。它最大的特点是不支持类和对象两个语法概念，不支持丰富的面向对象编程特性（比如继承、多态、封装），仅支持面向过程编程。</li>
</ul>
<p>不过，这里我必须声明一下，就像我们在之前讲到的，面向对象编程和面向对象编程语言并没有官方的定义一样，这里我给出的面向过程编程和面向过程编程语言的定义，也并不是严格的官方定义。之所以要给出这样的定义，只是为了跟面向对象编程及面向对象编程语言做个对比，以方便你理解它们的区别。</p>
<p>定义不是很严格，也比较抽象，所以，我再用一个例子进一步解释一下。假设我们有一个记录了用户信息的文本文件users.txt，每行文本的格式是name&amp;age&amp;gender（比如，小王&amp;28&amp;男）。我们希望写一个程序，从users.txt文件中逐行读取用户信息，然后格式化成name\tage\tgender（其中，\t是分隔符）这种文本格式，并且按照age从小到大排序之后，重新写入到另一个文本文件formatted_users.txt中。针对这样一个小程序的开发，我们一块来看看，用面向过程和面向对象两种编程风格，编写出来的代码有什么不同。</p>
<p>首先，我们先来看，用面向过程这种编程风格写出来的代码是什么样子的。注意，下面的代码是用C语言这种面向过程的编程语言来编写的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">64</span>];</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  <span class="type">char</span> gender[<span class="number">16</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> User <span class="title function_">parse_to_user</span><span class="params">(<span class="type">char</span>* text)</span> &#123;</span><br><span class="line">  <span class="comment">// 将text(“小王&amp;28&amp;男”)解析成结构体struct User</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">format_to_text</span><span class="params">(<span class="keyword">struct</span> User user)</span> &#123;</span><br><span class="line">  <span class="comment">// 将结构体struct User格式化成文本（&quot;小王\t28\t男&quot;）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sort_users_by_age</span><span class="params">(<span class="keyword">struct</span> User users[])</span> &#123;</span><br><span class="line">  <span class="comment">// 按照年龄从小到大排序users</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">format_user_file</span><span class="params">(<span class="type">char</span>* origin_file_path, <span class="type">char</span>* new_file_path)</span> &#123;</span><br><span class="line">  <span class="comment">// open files...</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">User</span> <span class="title">users</span>[1024];</span> <span class="comment">// 假设最大1024个用户</span></span><br><span class="line">  <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123; <span class="comment">// read until the file is empty</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">User</span> <span class="title">user</span> =</span> parse_to_user(line);</span><br><span class="line">    users[count++] = user;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  sort_users_by_age(users);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">    <span class="type">char</span>* formatted_user_text = format_to_text(users[i]);</span><br><span class="line">    <span class="comment">// write to new file...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// close files...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">char</span>** args, <span class="type">int</span> argv)</span> &#123;</span><br><span class="line">  format_user_file(<span class="string">&quot;/home/zheng/user.txt&quot;</span>, <span class="string">&quot;/home/zheng/formatted_users.txt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，我们再来看，用面向对象这种编程风格写出来的代码是什么样子的。注意，下面的代码是用Java这种面向对象的编程语言来编写的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">  <span class="keyword">private</span> String gender;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, <span class="type">int</span> age, String gender)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.gender = gender;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> User <span class="title function_">praseFrom</span><span class="params">(String userInfoText)</span> &#123;</span><br><span class="line">    <span class="comment">// 将text(“小王&amp;28&amp;男”)解析成类User</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">formatToText</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 将类User格式化成文本（&quot;小王\t28\t男&quot;）</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserFileFormatter</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">format</span><span class="params">(String userFile, String formattedUserFile)</span> &#123;</span><br><span class="line">    <span class="comment">// Open files...</span></span><br><span class="line">    <span class="type">List</span> <span class="variable">users</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123; <span class="comment">// read until file is empty </span></span><br><span class="line">      <span class="comment">// read from file into userText...</span></span><br><span class="line">      <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> User.parseFrom(userText);</span><br><span class="line">      users.add(user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// sort users by age...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; users.size(); ++i) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">formattedUserText</span> <span class="operator">=</span> user.formatToText();</span><br><span class="line">      <span class="comment">// write to new file...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// close files...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApplication</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">UserFileFormatter</span> <span class="variable">userFileFormatter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserFileFormatter</span>();</span><br><span class="line">    userFileFormatter.format(<span class="string">&quot;/home/zheng/users.txt&quot;</span>, <span class="string">&quot;/home/zheng/formatted_users.txt&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中，我们可以看出，面向过程和面向对象最基本的区别就是，代码的组织方式不同。面向过程风格的代码被组织成了一组方法集合及其数据结构（struct User），方法和数据结构的定义是分开的。面向对象风格的代码被组织成一组类，方法和数据结构被绑定一起，定义在类中。</p>
<p>看完这个例子之后，你可能会说，面向对象编程和面向过程编程，两种风格的区别就这么一点吗？当然不是，对于这两种编程风格的更多区别，我们继续往下看。</p>
<p><strong>面向对象编程相比面向过程编程有哪些优势</strong>？</p>
<p>刚刚我们介绍了面向过程编程及面向过程编程语言的定义，并跟面向对象编程及面向对象编程语言做了一个简单对比。接下来，我们再来看一下，为什么面向对象编程晚于面向过程编程出现，却能取而代之，成为现在主流的编程范式？面向对象编程跟面向过程编程比起来，到底有哪些优势？</p>
<p><strong>1.OOP更加能够应对大规模复杂程序的开发</strong></p>
<p>看了刚刚举的那个格式化文本文件的例子，你可能会有这样的疑问，两种编程风格实现的代码貌似差不多啊，顶多就是代码的组织方式有点区别，没有感觉到面向对象编程有什么明显的优势呀！你的感觉没错。之所以有这种感觉，主要原因是这个例子程序比较简单、不够复杂。</p>
<p>对于简单程序的开发来说，不管是用面向过程编程风格，还是用面向对象编程风格，差别确实不会很大，甚至有的时候，面向过程的编程风格反倒更有优势。因为需求足够简单，整个程序的处理流程只有一条主线，很容易被划分成顺序执行的几个步骤，然后逐句翻译成代码，这就非常适合采用面向过程这种面条式的编程风格来实现。</p>
<p>但对于大规模复杂程序的开发来说，整个程序的处理流程错综复杂，并非只有一条主线。如果把整个程序的处理流程画出来的话，会是一个网状结构。如果我们再用面向过程编程这种流程化、线性的思维方式，去翻译这个网状结构，去思考如何把程序拆解为一组顺序执行的方法，就会比较吃力。这个时候，面向对象的编程风格的优势就比较明显了。</p>
<p>面向对象编程是以类为思考对象。在进行面向对象编程的时候，我们并不是一上来就去思考，如何将复杂的流程拆解为一个一个方法，而是采用曲线救国的策略，先去思考如何给业务建模，如何将需求翻译为类，如何给类之间建立交互关系，而完成这些工作完全不需要考虑错综复杂的处理流程。当我们有了类的设计之后，然后再像搭积木一样，按照处理流程，将类组装起来形成整个程序。这种开发模式、思考问题的方式，能让我们在应对复杂程序开发的时候，思路更加清晰。</p>
<p>除此之外，面向对象编程还提供了一种更加清晰的、更加模块化的代码组织方式。比如，我们开发一个电商交易系统，业务逻辑复杂，代码量很大，可能要定义数百个函数、数百个数据结构，那如何分门别类地组织这些函数和数据结构，才能不至于看起来比较凌乱呢？类就是一种非常好的组织这些函数和数据结构的方式，是一种将代码模块化的有效手段。</p>
<p>你可能会说，像C语言这种面向过程的编程语言，我们也可以按照功能的不同，把函数和数据结构放到不同的文件里，以达到给函数和数据结构分类的目的，照样可以实现代码的模块化。你说得没错。只不过面向对象编程本身提供了类的概念，强制你做这件事情，而面向过程编程并不强求。这也算是面向对象编程相对于面向过程编程的一个微创新吧。</p>
<p>实际上，利用面向过程的编程语言照样可以写出面向对象风格的代码，只不过可能会比用面向对象编程语言来写面向对象风格的代码，付出的代价要高一些。而且，面向过程编程和面向对象编程并非完全对立的。很多软件开发中，尽管利用的是面向过程的编程语言，也都有借鉴面向对象编程的一些优点。</p>
<p><strong>2.OOP风格的代码更易复用、易扩展、易维护</strong></p>
<p>在刚刚的那个例子中，因为代码比较简单，所以只用到到了类、对象这两个最基本的面向对象概念，并没有用到更加高级的四大特性，封装、抽象、继承、多态。因此，面向对象编程的优势其实并没有发挥出来。</p>
<p>面向过程编程是一种非常简单的编程风格，并没有像面向对象编程那样提供丰富的特性。而面向对象编程提供的封装、抽象、继承、多态这些特性，能极大地满足复杂的编程需求，能方便我们写出更易复用、易扩展、易维护的代码。为什么这么说呢？还记得我们在上一节课中讲到的封装、抽象、继承、多态存在的意义吗？我们再来简单回顾一下。</p>
<p>首先，我们先来看下封装特性。封装特性是面向对象编程相比于面向过程编程的一个最基本的区别，因为它基于的是面向对象编程中最基本的类的概念。面向对象编程通过类这种组织代码的方式，将数据和方法绑定在一起，通过访问权限控制，只允许外部调用者通过类暴露的有限方法访问数据，而不会像面向过程编程那样，数据可以被任意方法随意修改。因此，面向对象编程提供的封装特性更有利于提高代码的易维护性。</p>
<p>其次，我们再来看下抽象特性。我们知道，函数本身就是一种抽象，它隐藏了具体的实现。我们在使用函数的时候，只需要了解函数具有什么功能，而不需要了解它是怎么实现的。从这一点上，不管面向过程编程还是是面向对象编程，都支持抽象特性。不过，面向对象编程还提供了其他抽象特性的实现方式。这些实现方式是面向过程编程所不具备的，比如基于接口实现的抽象。基于接口的抽象，可以让我们在不改变原有实现的情况下，轻松替换新的实现逻辑，提高了代码的可扩展性。</p>
<p>再次，我们来看下继承特性。继承特性是面向对象编程相比于面向过程编程所特有的两个特性之一（另一个是多态）。如果两个类有一些相同的属性和方法，我们就可以将这些相同的代码，抽取到父类中，让两个子类继承父类。这样两个子类也就可以重用父类中的代码，避免了代码重复写多遍，提高了代码的复用性。</p>
<p>最后，我们来看下多态特性。基于这个特性，我们在需要修改一个功能实现的时候，可以通过实现一个新的子类的方式，在子类中重写原来的功能逻辑，用子类替换父类。在实际的代码运行过程中，调用子类新的功能逻辑，而不是在原有代码上做修改。这就遵从了“对修改关闭、对扩展开放”的设计原则，提高代码的扩展性。除此之外，利用多态特性，不同的类对象可以传递给相同的方法，执行不同的代码逻辑，提高了代码的复用性。</p>
<p>所以说，基于这四大特性，利用面向对象编程，我们可以更轻松地写出易复用、易扩展、易维护的代码。当然，我们不能说，利用面向过程风格就不可以写出易复用、易扩展、易维护的代码，但没有四大特性的帮助，付出的代价可能就要高一些。</p>
<p><strong>3.OOP语言更加人性化、更加高级、更加智能</strong></p>
<p>人类最开始跟机器打交道是通过0、1这样的二进制指令，然后是汇编语言，再之后才出现了高级编程语言。在高级编程语言中，面向过程编程语言又早于面向对象编程语言出现。之所以先出现面向过程编程语言，那是因为跟机器交互的方式，从二进制指令、汇编语言到面向过程编程语言，是一个非常自然的过渡，都是一种流程化的、面条式的编程风格，用一组指令顺序操作数据，来完成一项任务。</p>
<p>从指令到汇编再到面向过程编程语言，跟机器打交道的方式在不停地演进，从中我们很容易发现这样一条规律，那就是编程语言越来越人性化，让人跟机器打交道越来越容易。笼统点讲，就是编程语言越来越高级。实际上，在面向过程编程语言之后，面向对象编程语言的出现，也顺应了这样的发展规律，也就是说，面向对象编程语言比面向过程编程语言更加高级！</p>
<p>跟二进制指令、汇编语言、面向过程编程语言相比，面向对象编程语言的编程套路、思考问题的方式，是完全不一样的。前三者是一种计算机思维方式，而面向对象是一种人类的思维方式。我们在用前面三种语言编程的时候，我们是在思考，如何设计一组指令，告诉机器去执行这组指令，操作某些数据，帮我们完成某个任务。而在进行面向对象编程时候，我们是在思考，如何给业务建模，如何将真实的世界映射为类或者对象，这让我们更加能聚焦到业务本身，而不是思考如何跟机器打交道。可以这么说，越高级的编程语言离机器越“远”，离我们人类越“近”，越“智能”。</p>
<p>这里多聊几句，顺着刚刚这个编程语言的发展规律来想，如果一种新的突破性的编程语言出现，那它肯定是更加“智能”的。大胆想象一下，使用这种编程语言，我们可以无需对计算机知识有任何了解，无需像现在这样一行一行地敲很多代码，只需要把需求文档写清楚，就能自动生成我们想要的软件了。</p>
<h3 id="05-哪些代码设计看似是面向对象，实际是面向过程的？"><a href="#05-哪些代码设计看似是面向对象，实际是面向过程的？" class="headerlink" title="05. 哪些代码设计看似是面向对象，实际是面向过程的？"></a>05. 哪些代码设计看似是面向对象，实际是面向过程的？</h3><p>在用面向对象编程语言进行软件开发的时候，我们有时候会写出面向过程风格的代码。有些是有意为之，并无不妥；而有些是无意为之，会影响到代码的质量。下面我就通过三个典型的代码案例，给你展示一下，什么样的代码看似是面向对象风格，实际上是面向过程风格的。我也希望你通过对这三个典型例子的学习，能够做到举一反三，在平时的开发中，多留心一下自己编写的代码是否满足面向对象风格。</p>
<p><strong>1.滥用getter、setter方法</strong></p>
<p>在之前参与的项目开发中，我经常看到，有同事定义完类的属性之后，就顺手把这些属性的getter、setter方法都定义上。有些同事更加省事，直接用IDE或者Lombok插件（如果是Java项目的话）自动生成所有属性的getter、setter方法。</p>
<p>当我问起，为什么要给每个属性都定义getter、setter方法的时候，他们的理由一般是，为了以后可能会用到，现在事先定义好，类用起来就更加方便，而且即便用不到这些getter、setter方法，定义上它们也无伤大雅。</p>
<p>实际上，这样的做法我是非常不推荐的。它违反了面向对象编程的封装特性，相当于将面向对象编程风格退化成了面向过程编程风格。我通过下面这个例子来给你解释一下这句话。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShoppingCart</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> itemsCount;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">double</span> totalPrice;</span><br><span class="line">  <span class="keyword">private</span> List&lt;ShoppingCartItem&gt; items = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getItemsCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.itemsCount;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setItemsCount</span><span class="params">(<span class="type">int</span> itemsCount)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.itemsCount = itemsCount;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getTotalPrice</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.totalPrice;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTotalPrice</span><span class="params">(<span class="type">double</span> totalPrice)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.totalPrice = totalPrice;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> List&lt;ShoppingCartItem&gt; <span class="title function_">getItems</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.items;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addItem</span><span class="params">(ShoppingCartItem item)</span> &#123;</span><br><span class="line">    items.add(item);</span><br><span class="line">    itemsCount++;</span><br><span class="line">    totalPrice += item.getPrice();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...省略其他方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段代码中，ShoppingCart是一个简化后的购物车类，有三个私有（private）属性：itemsCount、totalPrice、items。对于itemsCount、totalPrice两个属性，我们定义了它们的getter、setter方法。对于items属性，我们定义了它的getter方法和addItem()方法。代码很简单，理解起来不难。那你有没有发现，这段代码有什么问题呢？</p>
<p>我们先来看前两个属性，itemsCount和totalPrice。虽然我们将它们定义成private私有属性，但是提供了public的getter、setter方法，这就跟将这两个属性定义为public公有属性，没有什么两样了。外部可以通过setter方法随意地修改这两个属性的值。除此之外，任何代码都可以随意调用setter方法，来重新设置itemsCount、totalPrice属性的值，这也会导致其跟items属性的值不一致。</p>
<p>而面向对象封装的定义是：<u>通过访问权限控制，隐藏内部数据，外部仅能通过类提供的有限的接口访问、修改内部数据</u>。所以，暴露不应该暴露的setter方法，明显违反了面向对象的封装特性。数据没有访问权限控制，任何代码都可以随意修改它，代码就退化成了面向过程编程风格的了。</p>
<p>看完了前两个属性，我们再来看items这个属性。对于items这个属性，我们定义了它的getter方法和addItem()方法，并没有定义它的setter方法。这样的设计貌似看起来没有什么问题，但实际上并不是。</p>
<p>对于itemsCount和totalPrice这两个属性来说，定义一个public的getter方法，确实无伤大雅，毕竟getter方法不会修改数据。但是，对于items属性就不一样了，这是因为items属性的getter方法，返回的是一个List集合容器。<u>外部调用者在拿到这个容器之后，是可以操作容器内部数据的，也就是说，外部代码还是能修改items中的数据</u>。比如像下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ShoppingCart</span> <span class="variable">cart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShoppCart</span>();</span><br><span class="line">...</span><br><span class="line">cart.getItems().clear(); <span class="comment">// 清空购物车</span></span><br></pre></td></tr></table></figure>

<p>你可能会说，清空购物车这样的功能需求看起来合情合理啊，上面的代码没有什么不妥啊。你说得没错，需求是合理的，但是这样的代码写法，会导致itemsCount、totalPrice、items三者数据不一致。我们不应该将清空购物车的业务逻辑暴露给上层代码。正确的做法应该是，在ShoppingCart类中定义一个clear()方法，将清空购物车的业务逻辑封装在里面，透明地给调用者使用。ShoppingCart类的clear()方法的具体代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShoppingCart</span> &#123;</span><br><span class="line">  <span class="comment">// ...省略其他代码...</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    items.clear();</span><br><span class="line">    itemsCount = <span class="number">0</span>;</span><br><span class="line">    totalPrice = <span class="number">0.0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可能还会说，我有一个需求，需要查看购物车中都买了啥，那这个时候，ShoppingCart类不得不提供items属性的getter方法了，那又该怎么办才好呢？</p>
<p>如果你熟悉Java语言，那解决这个问题的方法还是挺简单的。我们可以通过Java提供的Collections.unmodifiableList()方法，让getter方法返回一个不可被修改的UnmodifiableList集合容器，而这个容器类重写了List容器中跟修改数据相关的方法，比如add()、clear()等方法。一旦我们调用这些修改数据的方法，代码就会抛出UnsupportedOperationException异常，这样就避免了容器中的数据被修改。具体的代码实现如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShoppingCart</span> &#123;</span><br><span class="line">  <span class="comment">// ...省略其他代码...</span></span><br><span class="line">  <span class="keyword">public</span> List&lt;ShoppingCartItem&gt; <span class="title function_">getItems</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableList(<span class="built_in">this</span>.items);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnmodifiableList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">UnmodifiableCollection</span>&lt;E&gt;</span><br><span class="line">                          <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...省略其他代码...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ShoppingCart</span> <span class="variable">cart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShoppingCart</span>();</span><br><span class="line">List&lt;ShoppingCartItem&gt; items = cart.getItems();</span><br><span class="line">items.clear();<span class="comment">//抛出UnsupportedOperationException异常</span></span><br></pre></td></tr></table></figure>

<p>不过，这样的实现思路还是有点问题。因为当调用者通过ShoppingCart的getItems()获取到items之后，虽然我们没法修改容器中的数据，但我们仍然可以修改容器中每个对象（ShoppingCartItem）的数据。听起来有点绕，看看下面这几行代码你就明白了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ShoppingCart</span> <span class="variable">cart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShoppingCart</span>();</span><br><span class="line">cart.add(<span class="keyword">new</span> <span class="title class_">ShoppingCartItem</span>(...));</span><br><span class="line">List&lt;ShoppingCartItem&gt; items = cart.getItems();</span><br><span class="line"><span class="type">ShoppingCartItem</span> <span class="variable">item</span> <span class="operator">=</span> items.get(<span class="number">0</span>);</span><br><span class="line">item.setPrice(<span class="number">19.0</span>); <span class="comment">// 这里修改了item的价格属性</span></span><br></pre></td></tr></table></figure>

<p>这个问题该如何解决呢？我今天就不展开来讲了。在后面讲到设计模式的时候，我还会详细地讲到。</p>
<p>getter、setter问题我们就讲完了，我稍微总结一下，<u>在设计实现类的时候，除非真的需要，否则，尽量不要给属性定义setter方法。除此之外，尽管getter方法相对setter方法要安全些，但是如果返回的是集合容器（比如例子中的List容器），也要防范集合内部数据被修改的危险。</u></p>
<p><strong>2.滥用全局变量和全局方法</strong></p>
<p>我们再来看，另外一个违反面向对象编程风格的例子，那就是滥用全局变量和全局方法。首先，我们先来看，什么是全局变量和全局方法？</p>
<p>如果你是用类似C语言这样的面向过程的编程语言来做开发，那对全局变量、全局方法肯定不陌生，甚至可以说，在代码中到处可见。但如果你是用类似Java这样的面向对象的编程语言来做开发，全局变量和全局方法就不是很多见了。</p>
<p>在面向对象编程中，<u>常见的全局变量有单例类对象、静态成员变量、常量等，常见的全局方法有静态方法。</u>单例类对象在全局代码中只有一份，所以，它相当于一个全局变量。静态成员变量归属于类上的数据，被所有的实例化对象所共享，也相当于一定程度上的全局变量。而常量是一种非常常见的全局变量，比如一些代码中的配置参数，一般都设置为常量，放到一个Constants类中。<u>静态方法一般用来操作静态变量或者外部数据。你可以联想一下我们常用的各种Utils类，里面的方法一般都会定义成静态方法，可以在不用创建对象的情况下，直接拿来使用。</u>静态方法将方法与数据分离，破坏了封装特性，是典型的面向过程风格。</p>
<p>在刚刚介绍的这些全局变量和全局方法中，Constants类和Utils类最常用到。现在，我们就结合这两个几乎在每个软件开发中都会用到的类，来深入探讨一下全局变量和全局方法的利与弊。</p>
<p><strong>我们先来看一下，在我过去参与的项目中，一种常见的Constants类的定义方法</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Constants</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MYSQL_ADDR_KEY</span> <span class="operator">=</span> <span class="string">&quot;mysql_addr&quot;</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MYSQL_DB_NAME_KEY</span> <span class="operator">=</span> <span class="string">&quot;db_name&quot;</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MYSQL_USERNAME_KEY</span> <span class="operator">=</span> <span class="string">&quot;mysql_username&quot;</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MYSQL_PASSWORD_KEY</span> <span class="operator">=</span> <span class="string">&quot;mysql_password&quot;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REDIS_DEFAULT_ADDR</span> <span class="operator">=</span> <span class="string">&quot;192.168.7.2:7234&quot;</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">REDIS_DEFAULT_MAX_TOTAL</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">REDIS_DEFAULT_MAX_IDLE</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">REDIS_DEFAULT_MIN_IDLE</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REDIS_DEFAULT_KEY_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;rt:&quot;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...省略更多的常量定义...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段代码中，我们把程序中所有用到的常量，都集中地放到这个Constants类中。不过，定义一个如此大而全的Constants类，并不是一种很好的设计思路。为什么这么说呢？原因主要有以下几点。</p>
<p>首先，这样的设计会影响代码的可维护性。</p>
<p>如果参与开发同一个项目的工程师有很多，在开发过程中，可能都要涉及修改这个类，比如往这个类里添加常量，那这个类就会变得越来越大，成百上千行都有可能，查找修改某个常量也会变得比较费时，而且还会增加提交代码冲突的概率。</p>
<p>其次，这样的设计还会增加代码的编译时间。</p>
<p>当Constants类中包含很多常量定义的时候，依赖这个类的代码就会很多。那每次修改Constants类，都会导致依赖它的类文件重新编译，因此会浪费很多不必要的编译时间。不要小看编译花费的时间，对于一个非常大的工程项目来说，编译一次项目花费的时间可能是几分钟，甚至几十分钟。而我们在开发过程中，每次运行单元测试，都会触发一次编译的过程，这个编译时间就有可能会影响到我们的开发效率。</p>
<p>最后，这样的设计还会影响代码的复用性。</p>
<p>如果我们要在另一个项目中，复用本项目开发的某个类，而这个类又依赖Constants类。即便这个类只依赖Constants类中的一小部分常量，我们仍然需要把整个Constants类也一并引入，也就引入了很多无关的常量到新的项目中。</p>
<p>那如何改进Constants类的设计呢？我这里有两种思路可以借鉴。</p>
<ul>
<li>第一种是将Constants类拆解为功能更加单一的多个类，比如跟MySQL配置相关的常量，我们放到MysqlConstants类中；跟Redis配置相关的常量，我们放到RedisConstants类中。</li>
<li>还有一种我个人觉得更好的设计思路，那就是并不单独地设计Constants常量类，而是哪个类用到了某个常量，我们就把这个常量定义到这个类中。比如，RedisConfig类用到了Redis配置相关的常量，那我们就直接将这些常量定义在RedisConfig中，这样也提高了类设计的内聚性和代码的复用性。</li>
</ul>
<p><strong>讲完了Constants类，我们再来讨论一下Utils类。</strong>首先，我想问你这样一个问题，我们为什么需要Utils类？Utils类存在的意义是什么？希望你先思考一下，然后再来看我下面的讲解。</p>
<p>实际上，Utils类的出现是基于这样一个问题背景：如果我们有两个类A和B，它们要用到一块相同的功能逻辑，为了避免代码重复，我们不应该在两个类中，将这个相同的功能逻辑，重复地实现两遍。这个时候我们该怎么办呢？</p>
<p>我们在讲面向对象特性的时候，讲过继承可以实现代码复用。利用继承特性，我们把相同的属性和方法，抽取出来，定义到父类中。子类复用父类中的属性和方法，达到代码复用的目的。但是，有的时候，从业务含义上，A类和B类并不一定具有继承关系，比如Crawler类和PageAnalyzer类，它们都用到了URL拼接和分割的功能，但并不具有继承关系（既不是父子关系，也不是兄弟关系）。仅仅为了代码复用，生硬地抽象出一个父类出来，会影响到代码的可读性。如果不熟悉背后设计思路的同事，发现Crawler类和PageAnalyzer类继承同一个父类，而父类中定义的却是URL相关的操作，会觉得这个代码写得莫名其妙，理解不了。</p>
<p>既然继承不能解决这个问题，我们可以定义一个新的类，实现URL拼接和分割的方法。而拼接和分割两个方法，不需要共享任何数据，所以新的类不需要定义任何属性，这个时候，我们就可以把它定义为只包含静态方法的Utils类了。</p>
<p>实际上，<u>只包含静态方法不包含任何属性的Utils类，是彻彻底底的面向过程的编程风格</u>。但这并不是说，我们就要杜绝使用Utils类了。实际上，从刚刚讲的Utils类存在的目的来看，它在软件开发中还是挺有用的，能解决代码复用问题。所以，这里并不是说完全不能用Utils类，而是说，<u>要尽量避免滥用，不要不加思考地随意去定义Utils类</u>。</p>
<p>在定义Utils类之前，你要问一下自己，你真的需要单独定义这样一个Utils类吗？是否可以把Utils类中的某些方法定义到其他类中呢？如果在回答完这些问题之后，你还是觉得确实有必要去定义这样一个Utils类，那就大胆地去定义它吧。因为即便在面向对象编程中，我们也并不是完全排斥面向过程风格的代码。只要它能为我们写出好的代码贡献力量，我们就可以适度地去使用。</p>
<p>除此之外，类比Constants类的设计，我们设计Utils类的时候，最好也能细化一下，针对不同的功能，设计不同的Utils类，比如FileUtils、IOUtils、StringUtils、UrlUtils等，<u>不要设计一个过于大而全的Utils类</u>。</p>
<p><strong>3.定义数据和方法分离的类</strong></p>
<p>我们再来看最后一种面向对象编程过程中，常见的面向过程风格的代码。那就是，数据定义在一个类中，方法定义在另一个类中。你可能会觉得，这么明显的面向过程风格的代码，谁会这么写呢？实际上，如果你是基于MVC三层结构做Web方面的后端开发，这样的代码你可能天天都在写。</p>
<p>传统的MVC结构分为Model层、Controller层、View层这三层。不过，在做前后端分离之后，三层结构在后端开发中，会稍微有些调整，被分为Controller层、Service层、Repository层。Controller层负责暴露接口给前端调用，Service层负责核心业务逻辑，Repository层负责数据读写。而在每一层中，我们又会定义相应的VO（View Object）、BO（Business Object）、Entity。一般情况下，VO、BO、Entity中只会定义数据，不会定义方法，所有操作这些数据的业务逻辑都定义在对应的Controller类、Service类、Repository类中。这就是典型的面向过程的编程风格。</p>
<p>实际上，这种开发模式叫作<u>基于贫血模型的开发模式</u>，也是我们现在非常常用的一种Web项目的开发模式。看到这里，你内心里应该有很多疑惑吧？既然这种开发模式明显违背面向对象的编程风格，为什么大部分Web项目都是基于这种开发模式来开发呢？</p>
<p>关于这个问题，我今天不打算展开讲解。因为它跟我们平时的项目开发结合得非常紧密，所以，更加细致、全面的讲解，我把它安排在面向对象实战环节里了，希望用两节课的时间，把这个问题给你讲透彻。</p>
<p><strong>在面向对象编程中，为什么容易写出面向过程风格的代码？</strong></p>
<p>我们在进行面向对象编程的时候，很容易不由自主地就写出面向过程风格的代码，或者说感觉面向过程风格的代码更容易写。这是为什么呢？</p>
<p>你可以联想一下，在生活中，你去完成一个任务，你一般都会思考，应该先做什么、后做什么，如何一步一步地顺序执行一系列操作，最后完成整个任务。面向过程编程风格恰恰符合人的这种流程化思维方式。而面向对象编程风格正好相反。它是一种自底向上的思考方式。它不是先去按照执行流程来分解任务，而是将任务翻译成一个一个的小的模块（也就是类），设计类之间的交互，最后按照流程将类组装起来，完成整个任务。我们在上一节课讲到了，这样的思考路径比较适合复杂程序的开发，但并不是特别符合人类的思考习惯。</p>
<p>除此之外，面向对象编程要比面向过程编程难一些。在面向对象编程中，类的设计还是挺需要技巧，挺需要一定设计经验的。你要去思考如何封装合适的数据和方法到一个类里，如何设计类之间的关系，如何设计类之间的交互等等诸多设计问题。</p>
<p>所以，基于这两点原因，很多工程师在开发的过程，更倾向于用不太需要动脑子的方式去实现需求，也就不由自主地就将代码写成面向过程风格的了。</p>
<p><strong>面向过程编程及面向过程编程语言就真的无用武之地了吗？</strong></p>
<p>前面我们讲了面向对象编程相比面向过程编程的各种优势，又讲了哪些代码看起来像面向对象风格，而实际上是面向过程编程风格的。那是不是面向过程编程风格就过时了被淘汰了呢？是不是在面向对象编程开发中，我们就要杜绝写面向过程风格的代码呢？</p>
<p>前面我们有讲到，如果我们开发的是微小程序，或者是一个数据处理相关的代码，以算法为主，数据为辅，那脚本式的面向过程的编程风格就更适合一些。当然，面向过程编程的用武之地还不止这些。实际上，面向过程编程是面向对象编程的基础，面向对象编程离不开基础的面向过程编程。为什么这么说？我们仔细想想，类中每个方法的实现逻辑，不就是面向过程风格的代码吗？</p>
<p>除此之外，面向对象和面向过程两种编程风格，也并不是非黑即白、完全对立的。在用面向对象编程语言开发的软件中，面向过程风格的代码并不少见，甚至在一些标准的开发库（比如JDK、Apache Commons、Google Guava）中，也有很多面向过程风格的代码。</p>
<p>不管使用面向过程还是面向对象哪种风格来写代码，我们最终的目的还是写出易维护、易读、易复用、易扩展的高质量代码。只要我们能避免面向过程编程风格的一些弊端，控制好它的副作用，在掌控范围内为我们所用，我们就大可不用避讳在面向对象编程中写面向过程风格的代码。</p>
<h3 id="06-接口和抽象类"><a href="#06-接口和抽象类" class="headerlink" title="06. 接口和抽象类"></a>06. 接口和抽象类</h3><p>不同的编程语言对接口和抽象类的定义方式可能有些差别，但差别并不会很大。Java这种编程语言，既支持抽象类，也支持接口，所以，为了让你对这两个语法概念有比较直观的认识，我们拿Java这种编程语言来举例讲解。</p>
<p><strong>首先，我们来看一下，在Java这种编程语言中，我们是如何定义抽象类的。</strong></p>
<p>下面这段代码是一个比较典型的抽象类的使用场景（模板设计模式）。Logger是一个记录日志的抽象类，FileLogger和MessageQueueLogger继承Logger，分别实现两种不同的日志记录方式：记录日志到文件中和记录日志到消息队列中。FileLogger和MessageQueueLogger两个子类复用了父类Logger中的name、enabled、minPermittedLevel属性和log()方法，但因为这两个子类写日志的方式不同，它们又各自重写了父类中的doLog()方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 抽象类</span><br><span class="line">public abstract class Logger &#123;</span><br><span class="line">  private String name;</span><br><span class="line">  private boolean enabled;</span><br><span class="line">  private Level minPermittedLevel;</span><br><span class="line"></span><br><span class="line">  public Logger(String name, boolean enabled, Level minPermittedLevel) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.enabled = enabled;</span><br><span class="line">    this.minPermittedLevel = minPermittedLevel;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void log(Level level, String message) &#123;</span><br><span class="line">    boolean loggable = enabled &amp;&amp; (minPermittedLevel.intValue() &lt;= level.intValue());</span><br><span class="line">    if (!loggable) return;</span><br><span class="line">    doLog(level, message);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  protected abstract void doLog(Level level, String message);</span><br><span class="line">&#125;</span><br><span class="line">// 抽象类的子类：输出日志到文件</span><br><span class="line">public class FileLogger extends Logger &#123;</span><br><span class="line">  private Writer fileWriter;</span><br><span class="line"></span><br><span class="line">  public FileLogger(String name, boolean enabled,</span><br><span class="line">    Level minPermittedLevel, String filepath) &#123;</span><br><span class="line">    super(name, enabled, minPermittedLevel);</span><br><span class="line">    this.fileWriter = new FileWriter(filepath); </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Override</span><br><span class="line">  public void doLog(Level level, String mesage) &#123;</span><br><span class="line">    // 格式化level和message,输出到日志文件</span><br><span class="line">    fileWriter.write(...);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 抽象类的子类: 输出日志到消息中间件(比如kafka)</span><br><span class="line">public class MessageQueueLogger extends Logger &#123;</span><br><span class="line">  private MessageQueueClient msgQueueClient;</span><br><span class="line">  </span><br><span class="line">  public MessageQueueLogger(String name, boolean enabled,</span><br><span class="line">    Level minPermittedLevel, MessageQueueClient msgQueueClient) &#123;</span><br><span class="line">    super(name, enabled, minPermittedLevel);</span><br><span class="line">    this.msgQueueClient = msgQueueClient;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Override</span><br><span class="line">  protected void doLog(Level level, String mesage) &#123;</span><br><span class="line">    // 格式化level和message,输出到消息中间件</span><br><span class="line">    msgQueueClient.send(...);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的这个例子，我们来看一下，抽象类具有哪些特性。我总结了下面三点。</p>
<ul>
<li>抽象类不允许被实例化，只能被继承。也就是说，你不能new一个抽象类的对象出来（Logger logger &#x3D; new Logger(…);会报编译错误）。</li>
<li>抽象类可以包含属性和方法。方法既可以包含代码实现（比如Logger中的log()方法），也可以不包含代码实现（比如Logger中的doLog()方法）。不包含代码实现的方法叫作抽象方法。</li>
<li>子类继承抽象类，必须实现抽象类中的所有抽象方法。对应到例子代码中就是，所有继承Logger抽象类的子类，都必须重写doLog()方法。</li>
</ul>
<p><strong>刚刚我们讲了如何定义抽象类，现在我们再来看一下，在Java这种编程语言中，我们如何定义接口。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 接口</span><br><span class="line">public interface Filter &#123;</span><br><span class="line">  void doFilter(RpcRequest req) throws RpcException;</span><br><span class="line">&#125;</span><br><span class="line">// 接口实现类：鉴权过滤器</span><br><span class="line">public class AuthencationFilter implements Filter &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void doFilter(RpcRequest req) throws RpcException &#123;</span><br><span class="line">    //...鉴权逻辑..</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 接口实现类：限流过滤器</span><br><span class="line">public class RateLimitFilter implements Filter &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void doFilter(RpcRequest req) throws RpcException &#123;</span><br><span class="line">    //...限流逻辑...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 过滤器使用Demo</span><br><span class="line">public class Application &#123;</span><br><span class="line">  // filters.add(new AuthencationFilter());</span><br><span class="line">  // filters.add(new RateLimitFilter());</span><br><span class="line">  private List&lt;Filter&gt; filters = new ArrayList&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  public void handleRpcRequest(RpcRequest req) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      for (Filter filter : filters) &#123;</span><br><span class="line">        filter.doFilter(req);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch(RpcException e) &#123;</span><br><span class="line">      // ...处理过滤结果...</span><br><span class="line">    &#125;</span><br><span class="line">    // ...省略其他处理逻辑...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码是一个比较典型的接口的使用场景。我们通过Java中的interface关键字定义了一个Filter接口。AuthencationFilter和RateLimitFilter是接口的两个实现类，分别实现了对RPC请求鉴权和限流的过滤功能。</p>
<p>代码非常简洁。结合代码，我们再来看一下，接口都有哪些特性。我也总结了三点。</p>
<ul>
<li>接口不能包含属性（也就是成员变量）。</li>
<li>接口只能声明方法，方法不能包含代码实现。</li>
<li>类实现接口的时候，必须实现接口中声明的所有方法。</li>
</ul>
<p>前面我们讲了抽象类和接口的定义，以及各自的语法特性。从语法特性上对比，这两者有比较大的区别，比如抽象类中可以定义属性、方法的实现，而接口中不能定义属性，方法也不能包含代码实现等等。除了语法特性，从设计的角度，两者也有比较大的区别。</p>
<p>抽象类实际上就是类，只不过是一种特殊的类，这种类不能被实例化为对象，只能被子类继承。我们知道，继承关系是一种is-a的关系，那抽象类既然属于类，也表示一种is-a的关系。相对于抽象类的is-a关系来说，接口表示一种has-a关系，表示具有某些功能。对于接口，有一个更加形象的叫法，那就是协议（contract）。</p>
<p><strong>抽象类和接口能解决什么编程问题？</strong></p>
<p>刚刚我们学习了抽象类和接口的定义和区别，现在我们再来学习一下，抽象类和接口存在的意义，让你知其然知其所以然。</p>
<p><strong>首先，我们来看一下，我们为什么需要抽象类？它能够解决什么编程问题？</strong></p>
<p>刚刚我们讲到，抽象类不能实例化，只能被继承。而前面的章节中，我们还讲到，继承能解决代码复用的问题。所以，抽象类也是为代码复用而生的。多个子类可以继承抽象类中定义的属性和方法，避免在子类中，重复编写相同的代码。</p>
<p>不过，既然继承本身就能达到代码复用的目的，而继承也并不要求父类一定是抽象类，那我们不使用抽象类，照样也可以实现继承和复用。从这个角度上来讲，我们貌似并不需要抽象类这种语法呀。那抽象类除了解决代码复用的问题，还有什么其他存在的意义吗？</p>
<p>我们还是拿之前那个打印日志的例子来讲解。我们先对上面的代码做下改造。在改造之后的代码中，Logger不再是抽象类，只是一个普通的父类，删除了Logger中log()、doLog()方法，新增了isLoggable()方法。FileLogger和MessageQueueLogger还是继承Logger父类，以达到代码复用的目的。具体的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类：非抽象类，就是普通的类. 删除了log(),doLog()，新增了isLoggable().</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> enabled;</span><br><span class="line">  <span class="keyword">private</span> Level minPermittedLevel;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Logger</span><span class="params">(String name, <span class="type">boolean</span> enabled, Level minPermittedLevel)</span> &#123;</span><br><span class="line">    <span class="comment">//...构造函数不变，代码省略...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isLoggable</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">loggable</span> <span class="operator">=</span> enabled &amp;&amp; (minPermittedLevel.intValue() &lt;= level.intValue());</span><br><span class="line">    <span class="keyword">return</span> loggable;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类：输出日志到文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileLogger</span> <span class="keyword">extends</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Writer fileWriter;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">FileLogger</span><span class="params">(String name, <span class="type">boolean</span> enabled,</span></span><br><span class="line"><span class="params">    Level minPermittedLevel, String filepath)</span> &#123;</span><br><span class="line">    <span class="comment">//...构造函数不变，代码省略...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(Level level, String mesage)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isLoggable()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 格式化level和message,输出到日志文件</span></span><br><span class="line">    fileWriter.write(...);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类: 输出日志到消息中间件(比如kafka)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageQueueLogger</span> <span class="keyword">extends</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> MessageQueueClient msgQueueClient;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MessageQueueLogger</span><span class="params">(String name, <span class="type">boolean</span> enabled,</span></span><br><span class="line"><span class="params">    Level minPermittedLevel, MessageQueueClient msgQueueClient)</span> &#123;</span><br><span class="line">    <span class="comment">//...构造函数不变，代码省略...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(Level level, String mesage)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isLoggable()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 格式化level和message,输出到消息中间件</span></span><br><span class="line">    msgQueueClient.send(...);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个设计思路虽然达到了代码复用的目的，但是无法使用多态特性了。像下面这样编写代码，就会出现编译错误，因为Logger中并没有定义log()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileLogger</span>(<span class="string">&quot;access-log&quot;</span>, <span class="literal">true</span>, Level.WARN, <span class="string">&quot;/users/wangzheng/access.log&quot;</span>);</span><br><span class="line">logger.log(Level.ERROR, <span class="string">&quot;This is a test log message.&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>你可能会说，这个问题解决起来很简单啊。我们在Logger父类中，定义一个空的log()方法，让子类重写父类的log()方法，实现自己的记录日志的逻辑，不就可以了吗？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">  <span class="comment">// ...省略部分代码...</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(Level level, String mesage)</span> &#123; <span class="comment">// do nothing... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileLogger</span> <span class="keyword">extends</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">  <span class="comment">// ...省略部分代码...</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(Level level, String mesage)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isLoggable()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 格式化level和message,输出到日志文件</span></span><br><span class="line">    fileWriter.write(...);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageQueueLogger</span> <span class="keyword">extends</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">  <span class="comment">// ...省略部分代码...</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(Level level, String mesage)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isLoggable()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 格式化level和message,输出到消息中间件</span></span><br><span class="line">    msgQueueClient.send(...);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个设计思路能用，但是，它显然没有之前通过抽象类的实现思路优雅。我为什么这么说呢？主要有以下几点原因。</p>
<ul>
<li>在Logger中定义一个空的方法，会影响代码的可读性。如果我们不熟悉Logger背后的设计思想，代码注释又不怎么给力，我们在阅读Logger代码的时候，就可能对为什么定义一个空的log()方法而感到疑惑，需要查看Logger、FileLogger、MessageQueueLogger之间的继承关系，才能弄明白其设计意图。</li>
<li>当创建一个新的子类继承Logger父类的时候，我们有可能会忘记重新实现log()方法。之前基于抽象类的设计思路，编译器会强制要求子类重写log()方法，否则会报编译错误。你可能会说，我既然要定义一个新的Logger子类，怎么会忘记重新实现log()方法呢？我们举的例子比较简单，Logger中的方法不多，代码行数也很少。但是，如果Logger有几百行，有n多方法，除非你对Logger的设计非常熟悉，否则忘记重新实现log()方法，也不是不可能的。</li>
<li>Logger可以被实例化，换句话说，我们可以new一个Logger出来，并且调用空的log()方法。这也增加了类被误用的风险。当然，这个问题可以通过设置私有的构造函数的方式来解决。不过，显然没有通过抽象类来的优雅。</li>
</ul>
<p><strong>其次，我们再来看一下，我们为什么需要接口？它能够解决什么编程问题？</strong></p>
<p>抽象类更多的是为了代码复用，而接口就更侧重于解耦。接口是对行为的一种抽象，相当于一组协议或者契约，你可以联想类比一下API接口。调用者只需要关注抽象的接口，不需要了解具体的实现，具体的实现代码对调用者透明。接口实现了约定和实现相分离，可以降低代码间的耦合性，提高代码的可扩展性。</p>
<p>实际上，接口是一个比抽象类应用更加广泛、更加重要的知识点。比如，我们经常提到的“基于接口而非实现编程”，就是一条几乎天天会用到，并且能极大地提高代码的灵活性、扩展性的设计思想。关于接口这个知识点，我会单独再用一节课的时间，更加详细全面的讲解，这里就不展开了。</p>
<p><strong>如何模拟抽象类和接口两个语法概念？</strong></p>
<p>在前面举的例子中，我们使用Java的接口语法实现了一个Filter过滤器。不过，如果你熟悉的是C++这种编程语言，你可能会说，C++只有抽象类，并没有接口，那从代码实现的角度上来说，是不是就无法实现Filter的设计思路了呢？</p>
<p>实际上，我们可以通过抽象类来模拟接口。怎么来模拟呢？这是一个不错的面试题，你可以先思考一下，然后再来看我的讲解。</p>
<p>我们先来回忆一下接口的定义：接口中没有成员变量，只有方法声明，没有方法实现，实现接口的类必须实现接口中的所有方法。只要满足这样几点，从设计的角度上来说，我们就可以把它叫作接口。实际上，要满足接口的这些语法特性并不难。在下面这段C++代码中，我们就用抽象类模拟了一个接口（下面这段代码实际上是策略模式中的一段代码）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Strategy</span> &#123; <span class="comment">// 用抽象类模拟接口</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    ~Strategy();</span><br><span class="line">    virtual <span class="keyword">void</span> <span class="title function_">algorithm</span><span class="params">()</span>=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    Strategy();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>抽象类Strategy没有定义任何属性，并且所有的方法都声明为virtual类型（等同于Java中的abstract关键字），这样，所有的方法都不能有代码实现，并且所有继承这个抽象类的子类，都要实现这些方法。从语法特性上来看，这个抽象类就相当于一个接口。</p>
<p>不过，如果你熟悉的既不是Java，也不是C++，而是现在比较流行的动态编程语言，比如Python、Ruby等，你可能还会有疑问：在这些动态语言中，不仅没有接口的概念，也没有类似abstract、virtual这样的关键字来定义抽象类，那该如何实现上面的讲到的Filter、Logger的设计思路呢？实际上，除了用抽象类来模拟接口之外，我们还可以用普通类来模拟接口。具体的Java代码实现如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MockInteface</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">MockInteface</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">funcA</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MethodUnSupportedException</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道类中的方法必须包含实现，这个不符合接口的定义。但是，我们可以让类中的方法抛出MethodUnSupportedException异常，来模拟不包含实现的接口，并且能强迫子类在继承这个父类的时候，都去主动实现父类的方法，否则就会在运行时抛出异常。那又如何避免这个类被实例化呢？实际上很简单，我们只需要将这个类的构造函数声明为protected访问权限就可以了。</p>
<p>刚刚我们讲了如何用抽象类来模拟接口，以及如何用普通类来模拟接口，那如何用普通类来模拟抽象类呢？这个问题留给你自己思考，你可以留言说说你的实现方法。</p>
<p>实际上，对于动态编程语言来说，还有一种对接口支持的策略，那就是duck-typing。我们在上一节课中讲到多态的时候也有讲过，你可以再回忆一下。</p>
<p><strong>如何决定该用抽象类还是接口？</strong></p>
<p>刚刚的讲解可能有些偏理论，现在，我们就从真实项目开发的角度来看一下，在代码设计、编程开发的时候，什么时候该用抽象类？什么时候该用接口？</p>
<p>实际上，判断的标准很简单。如果我们要表示一种is-a的关系，并且是为了解决代码复用的问题，我们就用抽象类；如果我们要表示一种has-a关系，并且是为了解决抽象而非代码复用的问题，那我们就可以使用接口。</p>
<p>从类的继承层次上来看，抽象类是一种自下而上的设计思路，先有子类的代码重复，然后再抽象成上层的父类（也就是抽象类）。而接口正好相反，它是一种自上而下的设计思路。我们在编程的时候，一般都是先设计接口，再去考虑具体的实现。</p>
<h3 id="07-基于接口而非实现编程"><a href="#07-基于接口而非实现编程" class="headerlink" title="07. 基于接口而非实现编程"></a>07. 基于接口而非实现编程</h3><p><strong>如何解读原则中的“接口”二字？</strong></p>
<p>“基于接口而非实现编程”这条原则的英文描述是：“Program to an interface, not an implementation”。我们理解这条原则的时候，千万不要一开始就与具体的编程语言挂钩，局限在编程语言的“接口”语法中（比如Java中的interface接口语法）。这条原则最早出现于1994年GoF的《设计模式》这本书，它先于很多编程语言而诞生（比如Java语言），是一条比较抽象、泛化的设计思想。</p>
<p>实际上，理解这条原则的关键，就是理解其中的“接口”两个字。还记得我们上一节课讲的“接口”的定义吗？从本质上来看，“接口”就是一组“协议”或者“约定”，是功能提供者提供给使用者的一个“功能列表”。“接口”在不同的应用场景下会有不同的解读，比如服务端与客户端之间的“接口”，类库提供的“接口”，甚至是一组通信的协议都可以叫作“接口”。刚刚对“接口”的理解，都比较偏上层、偏抽象，与实际的写代码离得有点远。如果落实到具体的编码，“基于接口而非实现编程”这条原则中的“接口”，可以理解为编程语言中的接口或者抽象类。</p>
<p>前面我们提到，这条原则能非常有效地提高代码质量，之所以这么说，那是因为，应用这条原则，可以将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低耦合性，提高扩展性。</p>
<p>实际上，“基于接口而非实现编程”这条原则的另一个表述方式，是“基于抽象而非实现编程”。后者的表述方式其实更能体现这条原则的设计初衷。在软件开发中，最大的挑战之一就是需求的不断变化，这也是考验代码设计好坏的一个标准。<u>越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对。</u>而抽象就是提高代码扩展性、灵活性、可维护性最有效的手段之一。</p>
<p><strong>如何将这条原则应用到实战中？</strong></p>
<p>对于这条原则，我们结合一个具体的实战案例来进一步讲解一下。</p>
<p>假设我们的系统中有很多涉及图片处理和存储的业务逻辑。图片经过处理之后被上传到阿里云上。为了代码复用，我们封装了图片存储相关的代码逻辑，提供了一个统一的AliyunImageStore类，供整个系统来使用。具体的代码实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliyunImageStore</span> &#123;</span><br><span class="line">  <span class="comment">//...省略属性、构造函数等...</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createBucketIfNotExisting</span><span class="params">(String bucketName)</span> &#123;</span><br><span class="line">    <span class="comment">// ...创建bucket代码逻辑...</span></span><br><span class="line">    <span class="comment">// ...失败会抛出异常..</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">generateAccessToken</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...根据accesskey/secrectkey等生成access token</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">uploadToAliyun</span><span class="params">(Image image, String bucketName, String accessToken)</span> &#123;</span><br><span class="line">    <span class="comment">//...上传图片到阿里云...</span></span><br><span class="line">    <span class="comment">//...返回图片存储在阿里云上的地址(url）...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> Image <span class="title function_">downloadFromAliyun</span><span class="params">(String url, String accessToken)</span> &#123;</span><br><span class="line">    <span class="comment">//...从阿里云下载图片...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AliyunImageStore类的使用举例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImageProcessingJob</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BUCKET_NAME</span> <span class="operator">=</span> <span class="string">&quot;ai_images_bucket&quot;</span>;</span><br><span class="line">  <span class="comment">//...省略其他无关代码...</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Image</span> <span class="variable">image</span> <span class="operator">=</span> ...; <span class="comment">//处理图片，并封装为Image对象</span></span><br><span class="line">    <span class="type">AliyunImageStore</span> <span class="variable">imageStore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AliyunImageStore</span>(<span class="comment">/*省略参数*/</span>);</span><br><span class="line">    imageStore.createBucketIfNotExisting(BUCKET_NAME);</span><br><span class="line">    <span class="type">String</span> <span class="variable">accessToken</span> <span class="operator">=</span> imageStore.generateAccessToken();</span><br><span class="line">    imagestore.uploadToAliyun(image, BUCKET_NAME, accessToken);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个上传流程包含三个步骤：创建bucket（你可以简单理解为存储目录）、生成access token访问凭证、携带access token上传图片到指定的bucket中。代码实现非常简单，类中的几个方法定义得都很干净，用起来也很清晰，乍看起来没有太大问题，完全能满足我们将图片存储在阿里云的业务需求。</p>
<p>不过，软件开发中唯一不变的就是变化。过了一段时间后，我们自建了私有云，不再将图片存储到阿里云了，而是将图片存储到自建私有云上。为了满足这样一个需求的变化，我们该如何修改代码呢？</p>
<p>我们需要重新设计实现一个存储图片到私有云的PrivateImageStore类，并用它替换掉项目中所有的AliyunImageStore类对象。这样的修改听起来并不复杂，只是简单替换而已，对整个代码的改动并不大。不过，我们经常说，“细节是魔鬼”。这句话在软件开发中特别适用。实际上，刚刚的设计实现方式，就隐藏了很多容易出问题的“魔鬼细节”，我们一块来看看都有哪些。</p>
<p>新的PrivateImageStore类需要设计实现哪些方法，才能在尽量最小化代码修改的情况下，替换掉AliyunImageStore类呢？这就要求我们必须将AliyunImageStore类中所定义的所有public方法，在PrivateImageStore类中都逐一定义并重新实现一遍。而这样做就会存在一些问题，我总结了下面两点。</p>
<p>首先，AliyunImageStore类中有些函数命名暴露了实现细节，比如，uploadToAliyun()和downloadFromAliyun()。如果开发这个功能的同事没有接口意识、抽象思维，那这种暴露实现细节的命名方式就不足为奇了，毕竟最初我们只考虑将图片存储在阿里云上。而我们把这种包含“aliyun”字眼的方法，照抄到PrivateImageStore类中，显然是不合适的。如果我们在新类中重新命名uploadToAliyun()、downloadFromAliyun()这些方法，那就意味着，我们要修改项目中所有使用到这两个方法的代码，代码修改量可能就会很大。</p>
<p>其次，将图片存储到阿里云的流程，跟存储到私有云的流程，可能并不是完全一致的。比如，阿里云的图片上传和下载的过程中，需要生产access token，而私有云不需要access token。一方面，AliyunImageStore中定义的generateAccessToken()方法不能照抄到PrivateImageStore中；另一方面，我们在使用AliyunImageStore上传、下载图片的时候，代码中用到了generateAccessToken()方法，如果要改为私有云的上传下载流程，这些代码都需要做调整。</p>
<p>那这两个问题该如何解决呢？解决这个问题的根本方法就是，在编写代码的时候，要遵从“基于接口而非实现编程”的原则，具体来讲，我们需要做到下面这3点。</p>
<ol>
<li><u>函数的命名不能暴露任何实现细节</u>。比如，前面提到的uploadToAliyun()就不符合要求，应该改为去掉aliyun这样的字眼，改为更加抽象的命名方式，比如：upload()。</li>
<li><u>封装具体的实现细节</u>。比如，跟阿里云相关的特殊上传（或下载）流程不应该暴露给调用者。我们对上传（或下载）流程进行封装，对外提供一个包裹所有上传（或下载）细节的方法，给调用者使用。</li>
<li><u>为实现类定义抽象的接口</u>。具体的实现类都依赖统一的接口定义，遵从一致的上传功能协议。使用者依赖接口，而不是具体的实现类来编程。</li>
</ol>
<p>我们按照这个思路，把代码重构一下。重构后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ImageStore</span> &#123;</span><br><span class="line">  String <span class="title function_">upload</span><span class="params">(Image image, String bucketName)</span>;</span><br><span class="line">  Image <span class="title function_">download</span><span class="params">(String url)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliyunImageStore</span> <span class="keyword">implements</span> <span class="title class_">ImageStore</span> &#123;</span><br><span class="line">  <span class="comment">//...省略属性、构造函数等...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(Image image, String bucketName)</span> &#123;</span><br><span class="line">    createBucketIfNotExisting(bucketName);</span><br><span class="line">    <span class="type">String</span> <span class="variable">accessToken</span> <span class="operator">=</span> generateAccessToken();</span><br><span class="line">    <span class="comment">//...上传图片到阿里云...</span></span><br><span class="line">    <span class="comment">//...返回图片在阿里云上的地址(url)...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Image <span class="title function_">download</span><span class="params">(String url)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">accessToken</span> <span class="operator">=</span> generateAccessToken();</span><br><span class="line">    <span class="comment">//...从阿里云下载图片...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">createBucketIfNotExisting</span><span class="params">(String bucketName)</span> &#123;</span><br><span class="line">    <span class="comment">// ...创建bucket...</span></span><br><span class="line">    <span class="comment">// ...失败会抛出异常..</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String <span class="title function_">generateAccessToken</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...根据accesskey/secrectkey等生成access token</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上传下载流程改变：私有云不需要支持access token</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrivateImageStore</span> <span class="keyword">implements</span> <span class="title class_">ImageStore</span>  &#123;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(Image image, String bucketName)</span> &#123;</span><br><span class="line">    createBucketIfNotExisting(bucketName);</span><br><span class="line">    <span class="comment">//...上传图片到私有云...</span></span><br><span class="line">    <span class="comment">//...返回图片的url...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Image <span class="title function_">download</span><span class="params">(String url)</span> &#123;</span><br><span class="line">    <span class="comment">//...从私有云下载图片...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">createBucketIfNotExisting</span><span class="params">(String bucketName)</span> &#123;</span><br><span class="line">    <span class="comment">// ...创建bucket...</span></span><br><span class="line">    <span class="comment">// ...失败会抛出异常..</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ImageStore的使用举例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImageProcessingJob</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BUCKET_NAME</span> <span class="operator">=</span> <span class="string">&quot;ai_images_bucket&quot;</span>;</span><br><span class="line">  <span class="comment">//...省略其他无关代码...</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Image</span> <span class="variable">image</span> <span class="operator">=</span> ...;<span class="comment">//处理图片，并封装为Image对象</span></span><br><span class="line">    <span class="type">ImageStore</span> <span class="variable">imageStore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrivateImageStore</span>(...);</span><br><span class="line">    imagestore.upload(image, BUCKET_NAME);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外，很多人在定义接口的时候，希望通过实现类来反推接口的定义。先把实现类写好，然后看实现类中有哪些方法，照抄到接口定义中。如果按照这种思考方式，就有可能导致接口定义不够抽象，依赖具体的实现。这样的接口设计就没有意义了。不过，如果你觉得这种思考方式更加顺畅，那也没问题，只是将实现类的方法搬移到接口定义中的时候，要有选择性的搬移，不要将跟具体实现相关的方法搬移到接口中，比如AliyunImageStore中的generateAccessToken()方法。</p>
<p>总结一下，我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。在定义接口的时候，不要暴露任何实现细节。接口的定义只表明做什么，而不是怎么做。而且，在设计接口的时候，我们要多思考一下，这样的接口设计是否足够通用，是否能够做到在替换具体的接口实现的时候，不需要任何接口定义的改动。</p>
<p><strong>是否需要为每个类定义接口？</strong></p>
<p>看了刚刚的讲解，你可能会有这样的疑问：为了满足这条原则，我是不是需要给每个实现类都定义对应的接口呢？在开发的时候，是不是任何代码都要只依赖接口，完全不依赖实现编程呢？</p>
<p>做任何事情都要讲求一个“度”，过度使用这条原则，非得给每个类都定义接口，接口满天飞，也会导致不必要的开发负担。至于什么时候，该为某个类定义接口，实现基于接口的编程，什么时候不需要定义接口，直接使用实现类编程，我们做权衡的根本依据，还是要回归到设计原则诞生的初衷上来。只要搞清楚了这条原则是为了解决什么样的问题而产生的，你就会发现，很多之前模棱两可的问题，都会变得豁然开朗。</p>
<p>前面我们也提到，这条原则的设计初衷是，将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低代码间的耦合性，提高代码的扩展性。</p>
<p>从这个设计初衷上来看，如果在我们的业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那我们就没有必要为其设计接口，也没有必要基于接口编程，直接使用实现类就可以了。</p>
<p>除此之外，越是不稳定的系统，我们越是要在代码的扩展性、维护性上下功夫。相反，如果某个系统特别稳定，在开发完之后，基本上不需要做维护，那我们就没有必要为其扩展性，投入不必要的开发时间。</p>
<h3 id="08-多用组合少用继承"><a href="#08-多用组合少用继承" class="headerlink" title="08. 多用组合少用继承"></a>08. 多用组合少用继承</h3><p><strong>为什么不推荐使用继承？</strong></p>
<p>继承是面向对象的四大特性之一，用来表示类之间的is-a关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。所以，对于是否应该在项目中使用继承，网上有很多争议。很多人觉得继承是一种反模式，应该尽量少用，甚至不用。为什么会有这样的争议？我们通过一个例子来解释一下。</p>
<p>假设我们要设计一个关于鸟的类。我们将“鸟类”这样一个抽象的事物概念，定义为一个抽象类AbstractBird。所有更细分的鸟，比如麻雀、鸽子、乌鸦等，都继承这个抽象类。</p>
<p>我们知道，大部分鸟都会飞，那我们可不可以在AbstractBird抽象类中，定义一个fly()方法呢？答案是否定的。尽管大部分鸟都会飞，但也有特例，比如鸵鸟就不会飞。鸵鸟继承具有fly()方法的父类，那鸵鸟就具有“飞”这样的行为，这显然不符合我们对现实世界中事物的认识。当然，你可能会说，我在鸵鸟这个子类中重写（override）fly()方法，让它抛出UnSupportedMethodException异常不就可以了吗？具体的代码实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractBird</span> &#123;</span><br><span class="line">  <span class="comment">//...省略其他属性和方法...</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ostrich</span> <span class="keyword">extends</span> <span class="title class_">AbstractBird</span> &#123; <span class="comment">//鸵鸟</span></span><br><span class="line">  <span class="comment">//...省略其他属性和方法...</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnSupportedMethodException</span>(<span class="string">&quot;I can&#x27;t fly.&#x27;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种设计思路虽然可以解决问题，但不够优美。因为除了鸵鸟之外，不会飞的鸟还有很多，比如企鹅。对于这些不会飞的鸟来说，我们都需要重写fly()方法，抛出异常。这样的设计，一方面，徒增了编码的工作量；另一方面，也违背了我们之后要讲的最小知识原则（Least Knowledge Principle，也叫最少知识原则或者迪米特法则），暴露不该暴露的接口给外部，增加了类使用过程中被误用的概率。</p>
<p>你可能又会说，那我们再通过AbstractBird类派生出两个更加细分的抽象类：会飞的鸟类AbstractFlyableBird和不会飞的鸟类AbstractUnFlyableBird，让麻雀、乌鸦这些会飞的鸟都继承AbstractFlyableBird，让鸵鸟、企鹅这些不会飞的鸟，都继承AbstractUnFlyableBird类，不就可以了吗？具体的继承关系如下图所示：</p>
<img src="https://static001.geekbang.org/resource/image/1e/b7/1e27919f63ef615dba98bc00673914b7.jpg" alt="img" style="zoom: 33%;" />

<p>从图中我们可以看出，继承关系变成了三层。不过，整体上来讲，目前的继承关系还比较简单，层次比较浅，也算是一种可以接受的设计思路。我们再继续加点难度。在刚刚这个场景中，我们只关注“鸟会不会飞”，但如果我们还关注“鸟会不会叫”，那这个时候，我们又该如何设计类之间的继承关系呢？</p>
<p>是否会飞？是否会叫？两个行为搭配起来会产生四种情况：会飞会叫、不会飞会叫、会飞不会叫、不会飞不会叫。如果我们继续沿用刚才的设计思路，那就需要再定义四个抽象类（AbstractFlyableTweetableBird、AbstractFlyableUnTweetableBird、AbstractUnFlyableTweetableBird、AbstractUnFlyableUnTweetableBird）。</p>
<img src="https://static001.geekbang.org/resource/image/3f/c6/3f99fa541e7ec7656a1dd35cc4f28bc6.jpg" alt="img" style="zoom:33%;" />

<p>如果我们还需要考虑“是否会下蛋”这样一个行为，那估计就要组合爆炸了。类的继承层次会越来越深、继承关系会越来越复杂。而这种层次很深、很复杂的继承关系，一方面，会导致代码的可读性变差。因为我们要搞清楚某个类具有哪些方法、属性，必须阅读父类的代码、父类的父类的代码……一直追溯到最顶层父类的代码。另一方面，这也破坏了类的封装特性，将父类的实现细节暴露给了子类。子类的实现依赖父类的实现，两者高度耦合，一旦父类代码修改，就会影响所有子类的逻辑。</p>
<p>总之，继承最大的问题就在于：继承层次过深、继承关系过于复杂会影响到代码的可读性和可维护性。这也是为什么我们不推荐使用继承。那刚刚例子中继承存在的问题，我们又该如何来解决呢？你可以先自己思考一下，再听我下面的讲解。</p>
<p><strong>组合相比继承有哪些优势？</strong></p>
<p>实际上，我们可以利用组合（composition）、接口、委托（delegation）三个技术手段，一块儿来解决刚刚继承存在的问题。</p>
<p>我们前面讲到接口的时候说过，接口表示具有某种行为特性。针对“会飞”这样一个行为特性，我们可以定义一个Flyable接口，只让会飞的鸟去实现这个接口。对于会叫、会下蛋这些行为特性，我们可以类似地定义Tweetable接口、EggLayable接口。我们将这个设计思路翻译成Java代码的话，就是下面这个样子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Tweetable</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">tweet</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EggLayable</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">layEgg</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ostrich</span> <span class="keyword">implements</span> <span class="title class_">Tweetable</span>, EggLayable &#123;<span class="comment">//鸵鸟</span></span><br><span class="line">  <span class="comment">//... 省略其他属性和方法...</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tweet</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">layEgg</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sparrow</span> impelents Flayable, Tweetable, EggLayable &#123;<span class="comment">//麻雀</span></span><br><span class="line">  <span class="comment">//... 省略其他属性和方法...</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tweet</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">layEgg</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过，我们知道，接口只声明方法，不定义实现。也就是说，每个会下蛋的鸟都要实现一遍layEgg()方法，并且实现逻辑是一样的，这就会导致代码重复的问题。那这个问题又该如何解决呢？</p>
<p>我们可以针对三个接口再定义三个实现类，它们分别是：实现了fly()方法的FlyAbility类、实现了tweet()方法的TweetAbility类、实现了layEgg()方法的EggLayAbility类。然后，通过组合和委托技术来消除代码重复。具体的代码实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>；</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FlyAbility</span> <span class="keyword">implements</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//省略Tweetable/TweetAbility/EggLayable/EggLayAbility</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ostrich</span> <span class="keyword">implements</span> <span class="title class_">Tweetable</span>, EggLayable &#123;<span class="comment">//鸵鸟</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">TweetAbility</span> <span class="variable">tweetAbility</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TweetAbility</span>(); <span class="comment">//组合</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">EggLayAbility</span> <span class="variable">eggLayAbility</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EggLayAbility</span>(); <span class="comment">//组合</span></span><br><span class="line">  <span class="comment">//... 省略其他属性和方法...</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tweet</span><span class="params">()</span> &#123;</span><br><span class="line">    tweetAbility.tweet(); <span class="comment">// 委托</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">layEgg</span><span class="params">()</span> &#123;</span><br><span class="line">    eggLayAbility.layEgg(); <span class="comment">// 委托</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道继承主要有三个作用：表示is-a关系，支持多态特性，代码复用。而这三个作用都可以通过其他技术手段来达成。比如is-a关系，我们可以通过组合和接口的has-a关系来替代；多态特性我们可以利用接口来实现；代码复用我们可以通过组合和委托来实现。所以，从理论上讲，通过组合、接口、委托三个技术手段，我们完全可以替换掉继承，在项目中不用或者少用继承关系，特别是一些复杂的继承关系。</p>
<p><strong>如何判断该用组合还是继承？</strong></p>
<p>尽管我们鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。从上面的例子来看，继承改写成组合意味着要做更细粒度的类的拆分。这也就意味着，我们要定义更多的类和接口。类和接口的增多也就或多或少地增加代码的复杂程度和维护成本。所以，在实际的项目开发中，我们还是要根据具体的情况，来具体选择该用继承还是组合。</p>
<p>如果类之间的继承结构稳定（不会轻易改变），继承层次比较浅（比如，最多有两层继承关系），继承关系不复杂，我们就可以大胆地使用继承。反之，系统越不稳定，继承层次很深，继承关系复杂，我们就尽量使用组合来替代继承。</p>
<p>除此之外，还有一些设计模式会固定使用继承或者组合。比如，装饰者模式（decorator pattern）、策略模式（strategy pattern）、组合模式（composite pattern）等都使用了组合关系，而模板模式（template pattern）使用了继承关系。</p>
<p>前面我们讲到继承可以实现代码复用。利用继承特性，我们把相同的属性和方法，抽取出来，定义到父类中。子类复用父类中的属性和方法，达到代码复用的目的。但是，有的时候，从业务含义上，A类和B类并不一定具有继承关系。比如，Crawler类和PageAnalyzer类，它们都用到了URL拼接和分割的功能，但并不具有继承关系（既不是父子关系，也不是兄弟关系）。仅仅为了代码复用，生硬地抽象出一个父类出来，会影响到代码的可读性。如果不熟悉背后设计思路的同事，发现Crawler类和PageAnalyzer类继承同一个父类，而父类中定义的却只是URL相关的操作，会觉得这个代码写得莫名其妙，理解不了。这个时候，使用组合就更加合理、更加灵活。具体的代码实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Url</span> &#123;</span><br><span class="line">  <span class="comment">//...省略属性和方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Crawler</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Url url; <span class="comment">// 组合</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Crawler</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.url = <span class="keyword">new</span> <span class="title class_">Url</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageAnalyzer</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Url url; <span class="comment">// 组合</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">PageAnalyzer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.url = <span class="keyword">new</span> <span class="title class_">Url</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一些特殊的场景要求我们必须使用继承。如果你不能改变一个函数的入参类型，而入参又非接口，为了支持多态，只能采用继承来实现。比如下面这样一段代码，其中FeignClient是一个外部类，我们没有权限去修改这部分代码，但是我们希望能重写这个类在运行时执行的encode()函数。这个时候，我们只能采用继承来实现了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignClient</span> &#123; <span class="comment">// Feign Client框架代码</span></span><br><span class="line">  <span class="comment">//...省略其他代码...</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(String url)</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demofunction</span><span class="params">(FeignClient feignClient)</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  feignClient.encode(url);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomizedFeignClient</span> <span class="keyword">extends</span> <span class="title class_">FeignClient</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(String url)</span> &#123; <span class="comment">//...重写encode的实现...&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="type">FeignClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomizedFeignClient</span>();</span><br><span class="line">demofunction(client);</span><br></pre></td></tr></table></figure>

<p>尽管有些人说，要杜绝继承，100%用组合代替继承，但是我的观点没那么极端！之所以“多用组合少用继承”这个口号喊得这么响，只是因为，长期以来，我们过度使用继承。还是那句话，组合并不完美，继承也不是一无是处。只要我们控制好它们的副作用、发挥它们各自的优势，在不同的场合下，恰当地选择使用继承还是组合，这才是我们所追求的境界。</p>
<h3 id="09-基于贫血模型的MVC架构"><a href="#09-基于贫血模型的MVC架构" class="headerlink" title="09. 基于贫血模型的MVC架构"></a>09. 基于贫血模型的MVC架构</h3><p><strong>什么是基于贫血模型的传统开发模式？</strong></p>
<p>我相信，对于大部分的后端开发工程师来说，MVC三层架构都不会陌生。不过，为了统一我们之间对MVC的认识，我还是带你一块来回顾一下，什么是MVC三层架构。</p>
<p>MVC三层架构中的M表示Model，V表示View，C表示Controller。它将整个项目分为三层：展示层、逻辑层、数据层。MVC三层开发架构是一个比较笼统的分层方式，落实到具体的开发层面，很多项目也并不会100%遵从MVC固定的分层方式，而是会根据具体的项目需求，做适当的调整。</p>
<p>比如，现在很多Web或者App项目都是前后端分离的，后端负责暴露接口给前端调用。这种情况下，我们一般就将后端项目分为Repository层、Service层、Controller层。其中，Repository层负责数据访问，Service层负责业务逻辑，Controller层负责暴露接口。当然，这只是其中一种分层和命名方式。不同的项目、不同的团队，可能会对此有所调整。不过，万变不离其宗，只要是依赖数据库开发的Web项目，基本的分层思路都大差不差。</p>
<p>刚刚我们回顾了MVC三层开发架构。现在，我们再来看一下，什么是贫血模型？</p>
<p>实际上，你可能一直都在用贫血模型做开发，只是自己不知道而已。不夸张地讲，据我了解，目前几乎所有的业务后端系统，都是基于贫血模型的。我举一个简单的例子来给你解释一下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">////////// Controller+VO(View Object) //////////</span><br><span class="line">public class UserController &#123;</span><br><span class="line">  private UserService userService; //通过构造函数或者IOC框架注入</span><br><span class="line">  </span><br><span class="line">  public UserVo getUserById(Long userId) &#123;</span><br><span class="line">    UserBo userBo = userService.getUserById(userId);</span><br><span class="line">    UserVo userVo = [...convert userBo to userVo...];</span><br><span class="line">    return userVo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UserVo &#123;//省略其他属性、get/set/construct方法</span><br><span class="line">  private Long id;</span><br><span class="line">  private String name;</span><br><span class="line">  private String cellphone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">////////// Service+BO(Business Object) //////////</span><br><span class="line">public class UserService &#123;</span><br><span class="line">  private UserRepository userRepository; //通过构造函数或者IOC框架注入</span><br><span class="line">  </span><br><span class="line">  public UserBo getUserById(Long userId) &#123;</span><br><span class="line">    UserEntity userEntity = userRepository.getUserById(userId);</span><br><span class="line">    UserBo userBo = [...convert userEntity to userBo...];</span><br><span class="line">    return userBo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UserBo &#123;//省略其他属性、get/set/construct方法</span><br><span class="line">  private Long id;</span><br><span class="line">  private String name;</span><br><span class="line">  private String cellphone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">////////// Repository+Entity //////////</span><br><span class="line">public class UserRepository &#123;</span><br><span class="line">  public UserEntity getUserById(Long userId) &#123; //... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UserEntity &#123;//省略其他属性、get/set/construct方法</span><br><span class="line">  private Long id;</span><br><span class="line">  private String name;</span><br><span class="line">  private String cellphone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们平时开发Web后端项目的时候，基本上都是这么组织代码的。其中，UserEntity和UserRepository组成了数据访问层，UserBo和UserService组成了业务逻辑层，UserVo和UserController在这里属于接口层。</p>
<p>从代码中，我们可以发现，UserBo是一个纯粹的数据结构，只包含数据，不包含任何业务逻辑。业务逻辑集中在UserService中。我们通过UserService来操作UserBo。换句话说，Service层的数据和业务逻辑，被分割为BO和Service两个类中。像UserBo这样，只包含数据，不包含业务逻辑的类，就叫作<strong>贫血模型</strong>（Anemic Domain Model）。同理，UserEntity、UserVo都是基于贫血模型设计的。这种贫血模型将数据与操作分离，破坏了面向对象的封装特性，是一种典型的面向过程的编程风格。</p>
<p><strong>什么是基于充血模型的DDD开发模式？</strong></p>
<p>刚刚我们讲了基于贫血模型的传统的开发模式。现在我们再讲一下，另外一种最近更加被推崇的开发模式：基于充血模型的DDD开发模式。</p>
<p><strong>首先，我们先来看一下，什么是充血模型？</strong></p>
<p>在贫血模型中，数据和业务逻辑被分割到不同的类中。<strong>充血模型</strong>（Rich Domain Model）正好相反，数据和对应的业务逻辑被封装到同一个类中。因此，这种充血模型满足面向对象的封装特性，是典型的面向对象编程风格。</p>
<p><strong>接下来，我们再来看一下，什么是领域驱动设计？</strong></p>
<p>领域驱动设计，即DDD，主要是用来指导如何解耦业务系统，划分业务模块，定义业务领域模型及其交互。领域驱动设计这个概念并不新颖，早在2004年就被提出了，到现在已经有十几年的历史了。不过，它被大众熟知，还是基于另一个概念的兴起，那就是微服务。</p>
<p>我们知道，除了监控、调用链追踪、API网关等服务治理系统的开发之外，微服务还有另外一个更加重要的工作，那就是针对公司的业务，合理地做微服务拆分。而领域驱动设计恰好就是用来指导划分服务的。所以，微服务加速了领域驱动设计的盛行。</p>
<p>不过，我个人觉得，领域驱动设计有点儿类似敏捷开发、SOA、PAAS等概念，听起来很高大上，但实际上只值“五分钱”。即便你没有听说过领域驱动设计，对这个概念一无所知，只要你是在开发业务系统，也或多或少都在使用它。做好领域驱动设计的关键是，看你对自己所做业务的熟悉程度，而并不是对领域驱动设计这个概念本身的掌握程度。即便你对领域驱动搞得再清楚，但是对业务不熟悉，也并不一定能做出合理的领域设计。所以，不要把领域驱动设计当银弹，不要花太多的时间去过度地研究它。</p>
<p>实际上，基于充血模型的DDD开发模式实现的代码，也是按照MVC三层架构分层的。Controller层还是负责暴露接口，Repository层还是负责数据存取，Service层负责核心业务逻辑。它跟基于贫血模型的传统开发模式的区别主要在Service层。</p>
<p>在基于贫血模型的传统开发模式中，Service层包含Service类和BO类两部分，BO是贫血模型，只包含数据，不包含具体的业务逻辑。业务逻辑集中在Service类中。在基于充血模型的DDD开发模式中，Service层包含Service类和Domain类两部分。Domain就相当于贫血模型中的BO。不过，Domain与BO的区别在于它是基于充血模型开发的，既包含数据，也包含业务逻辑。而Service类变得非常单薄。总结一下的话就是，基于贫血模型的传统的开发模式，重Service轻BO；基于充血模型的DDD开发模式，轻Service重Domain。</p>
<p>基于充血模型的DDD设计模式的概念，今天我们只是简单地介绍了一下。在下一节课中，我会结合具体的项目，通过代码来给你展示，如何基于这种开发模式来开发一个系统。</p>
<p><strong>为什么基于贫血模型的传统开发模式如此受欢迎？</strong></p>
<p>前面我们讲过，基于贫血模型的传统开发模式，将数据与业务逻辑分离，违反了OOP的封装特性，实际上是一种面向过程的编程风格。但是，现在几乎所有的Web项目，都是基于这种贫血模型的开发模式，甚至连Java Spring框架的官方demo，都是按照这种开发模式来编写的。</p>
<p>我们前面也讲过，面向过程编程风格有种种弊端，比如，数据和操作分离之后，数据本身的操作就不受限制了。任何代码都可以随意修改数据。既然基于贫血模型的这种传统开发模式是面向过程编程风格的，那它又为什么会被广大程序员所接受呢？关于这个问题，我总结了下面三点原因。</p>
<p>第一点原因是，大部分情况下，我们开发的系统业务可能都比较简单，简单到就是基于SQL的CRUD操作，所以，我们根本不需要动脑子精心设计充血模型，贫血模型就足以应付这种简单业务的开发工作。除此之外，因为业务比较简单，即便我们使用充血模型，那模型本身包含的业务逻辑也并不会很多，设计出来的领域模型也会比较单薄，跟贫血模型差不多，没有太大意义。</p>
<p>第二点原因是，充血模型的设计要比贫血模型更加有难度。因为充血模型是一种面向对象的编程风格。我们从一开始就要设计好针对数据要暴露哪些操作，定义哪些业务逻辑。而不是像贫血模型那样，我们只需要定义数据，之后有什么功能开发需求，我们就在Service层定义什么操作，不需要事先做太多设计。</p>
<p>第三点原因是，思维已固化，转型有成本。基于贫血模型的传统开发模式经历了这么多年，已经深得人心、习以为常。你随便问一个旁边的大龄同事，基本上他过往参与的所有Web项目应该都是基于这个开发模式的，而且也没有出过啥大问题。如果转向用充血模型、领域驱动设计，那势必有一定的学习成本、转型成本。很多人在没有遇到开发痛点的情况下，是不愿意做这件事情的。</p>
<p><strong>什么项目应该考虑使用基于充血模型的DDD开发模式？</strong></p>
<p>既然基于贫血模型的开发模式已经成为了一种约定俗成的开发习惯，那什么样的项目应该考虑使用基于充血模型的DDD开发模式呢？</p>
<p>刚刚我们讲到，基于贫血模型的传统的开发模式，比较适合业务比较简单的系统开发。相对应的，基于充血模型的DDD开发模式，更适合业务复杂的系统开发。比如，包含各种利息计算模型、还款模型等复杂业务的金融系统。</p>
<p>你可能会有一些疑问，这两种开发模式，落实到代码层面，区别不就是一个将业务逻辑放到Service类中，一个将业务逻辑放到Domain领域模型中吗？为什么基于贫血模型的传统开发模式，就不能应对复杂业务系统的开发？而基于充血模型的DDD开发模式就可以呢？</p>
<p>实际上，除了我们能看到的代码层面的区别之外（一个业务逻辑放到Service层，一个放到领域模型中），还有一个非常重要的区别，那就是两种不同的开发模式会导致不同的开发流程。基于充血模型的DDD开发模式的开发流程，在应对复杂业务系统的开发的时候更加有优势。为什么这么说呢？我们先来回忆一下，我们平时基于贫血模型的传统的开发模式，都是怎么实现一个功能需求的。</p>
<p>不夸张地讲，我们平时的开发，大部分都是SQL驱动（SQL-Driven）的开发模式。我们接到一个后端接口的开发需求的时候，就去看接口需要的数据对应到数据库中，需要哪张表或者哪几张表，然后思考如何编写SQL语句来获取数据。之后就是定义Entity、BO、VO，然后模板式地往对应的Repository、Service、Controller类中添加代码。</p>
<p>业务逻辑包裹在一个大的SQL语句中，而Service层可以做的事情很少。SQL都是针对特定的业务功能编写的，复用性差。当我要开发另一个业务功能的时候，只能重新写个满足新需求的SQL语句，这就可能导致各种长得差不多、区别很小的SQL语句满天飞。</p>
<p>所以，在这个过程中，很少有人会应用领域模型、OOP的概念，也很少有代码复用意识。对于简单业务系统来说，这种开发方式问题不大。但对于复杂业务系统的开发来说，这样的开发方式会让代码越来越混乱，最终导致无法维护。</p>
<p>如果我们在项目中，应用基于充血模型的DDD的开发模式，那对应的开发流程就完全不一样了。在这种开发模式下，我们需要事先理清楚所有的业务，定义领域模型所包含的属性和方法。领域模型相当于可复用的业务中间层。新功能需求的开发，都基于之前定义好的这些领域模型来完成。</p>
<p>我们知道，越复杂的系统，对代码的复用性、易维护性要求就越高，我们就越应该花更多的时间和精力在前期设计上。而基于充血模型的DDD开发模式，正好需要我们前期做大量的业务调研、领域模型设计，所以它更加适合这种复杂系统的开发。</p>
<h3 id="10-基于充血模型的DDD架构"><a href="#10-基于充血模型的DDD架构" class="headerlink" title="10. 基于充血模型的DDD架构"></a>10. 基于充血模型的DDD架构</h3><p><strong>钱包业务背景介绍</strong></p>
<p>很多具有支付、购买功能的应用（比如淘宝、滴滴出行、极客时间等）都支持钱包的功能。应用为每个用户开设一个系统内的虚拟钱包账户，支持用户充值、提现、支付、冻结、透支、转赠、查询账户余额、查询交易流水等操作。下图是一张典型的钱包功能界面，你可以直观地感受一下。</p>
<img src="https://static001.geekbang.org/resource/image/9e/4a/9e91377602ef154eaf866c7e9263a64a.jpg" alt="img" style="zoom:33%;" />

<p>一般来讲，每个虚拟钱包账户都会对应用户的一个真实的支付账户，有可能是银行卡账户，也有可能是三方支付账户（比如支付宝、微信钱包）。为了方便后续的讲解，我们限定钱包暂时只支持充值、提现、支付、查询余额、查询交易流水这五个核心的功能，其他比如冻结、透支、转赠等不常用的功能，我们暂不考虑。为了让你理解这五个核心功能是如何工作的，接下来，我们来一块儿看下它们的业务实现流程。</p>
<p><strong>1.充值</strong></p>
<p>用户通过三方支付渠道，把自己银行卡账户内的钱，充值到虚拟钱包账号中。这整个过程，我们可以分解为三个主要的操作流程：第一个操作是从用户的银行卡账户转账到应用的公共银行卡账户；第二个操作是将用户的充值金额加到虚拟钱包余额上；第三个操作是记录刚刚这笔交易流水。</p>
<img src="https://static001.geekbang.org/resource/image/39/14/3915a6544403854d35678c81fe65f014.jpg" alt="img" style="zoom:33%;" />

<p><strong>2.支付</strong></p>
<p>用户用钱包内的余额，支付购买应用内的商品。实际上，支付的过程就是一个转账的过程，从用户的虚拟钱包账户划钱到商家的虚拟钱包账户上。除此之外，我们也需要记录这笔支付的交易流水信息。</p>
<img src="https://static001.geekbang.org/resource/image/7e/5e/7eb44e2f8661d1c3debde85f79fb2c5e.jpg" alt="img" style="zoom:33%;" />

<p><strong>3.提现</strong></p>
<p>除了充值、支付之外，用户还可以将虚拟钱包中的余额，提现到自己的银行卡中。这个过程实际上就是扣减用户虚拟钱包中的余额，并且触发真正的银行转账操作，从应用的公共银行账户转钱到用户的银行账户。同样，我们也需要记录这笔提现的交易流水信息。</p>
<img src="https://static001.geekbang.org/resource/image/66/43/66ede1de93d29b86a9194ea0f80d1e43.jpg" alt="img" style="zoom:33%;" />

<p><strong>4.查询余额</strong></p>
<p>查询余额功能比较简单，我们看一下虚拟钱包中的余额数字即可。</p>
<p><strong>5.查询交易流水</strong></p>
<p>查询交易流水也比较简单。我们只支持三种类型的交易流水：充值、支付、提现。在用户充值、支付、提现的时候，我们会记录相应的交易信息。在需要查询的时候，我们只需要将之前记录的交易流水，按照时间、类型等条件过滤之后，显示出来即可。</p>
<p><strong>钱包系统的设计思路</strong></p>
<p>根据刚刚讲的业务实现流程和数据流转图，我们可以把整个钱包系统的业务划分为两部分，其中一部分单纯跟应用内的虚拟钱包账户打交道，另一部分单纯跟银行账户打交道。我们基于这样一个业务划分，给系统解耦，将整个钱包系统拆分为两个子系统：虚拟钱包系统和三方支付系统。</p>
<img src="https://static001.geekbang.org/resource/image/60/62/60d3cfec73986b52e3a6ef4fe147e562.jpg" alt="img" style="zoom:25%;" />

<p>为了能在有限的篇幅内，将今天的内容讲透彻，我们接来下只聚焦于虚拟钱包系统的设计与实现。对于三方支付系统以及整个钱包系统的设计与实现，我们不做讲解。你可以自己思考下。</p>
<p><strong>现在我们来看下，如果要支持钱包的这五个核心功能，虚拟钱包系统需要对应实现哪些操作。</strong>我画了一张图，列出了这五个功能都会对应虚拟钱包的哪些操作。注意，交易流水的记录和查询，我暂时在图中打了个问号，那是因为这块比较特殊，我们待会再讲。</p>
<img src="https://static001.geekbang.org/resource/image/d1/30/d1a9aeb6642404f80a62293ab2e45630.jpg" alt="img" style="zoom: 33%;" />

<p>从图中我们可以看出，虚拟钱包系统要支持的操作非常简单，就是余额的加加减减。其中，充值、提现、查询余额三个功能，只涉及一个账户余额的加减操作，而支付功能涉及两个账户的余额加减操作：一个账户减余额，另一个账户加余额。</p>
<p><strong>现在，我们再来看一下图中问号的那部分，也就是交易流水该如何记录和查询？</strong>我们先来看一下，交易流水都需要包含哪些信息。我觉得下面这几个信息是必须包含的。</p>
<img src="https://static001.geekbang.org/resource/image/38/68/38b56bd1981d8b40ececa4d638e4a968.jpg" alt="img" style="zoom:33%;" />

<p>从图中我们可以发现，交易流水的数据格式包含两个钱包账号，一个是入账钱包账号，一个是出账钱包账号。为什么要有两个账号信息呢？这主要是为了兼容支付这种涉及两个账户的交易类型。不过，对于充值、提现这两种交易类型来说，我们只需要记录一个钱包账户信息就够了，所以，这样的交易流水数据格式的设计稍微有点浪费存储空间。</p>
<p>实际上，我们还有另外一种交易流水数据格式的设计思路，可以解决这个问题。我们把“支付”这个交易类型，拆为两个子类型：支付和被支付。支付单纯表示出账，余额扣减，被支付单纯表示入账，余额增加。这样我们在设计交易流水数据格式的时候，只需要记录一个账户信息即可。我画了一张两种交易流水数据格式的对比图，你可以对比着看一下。</p>
<img src="https://static001.geekbang.org/resource/image/a7/af/a788777e25305614d94d71e5960e06af.jpg" alt="img" style="zoom:33%;" />

<p><strong>那以上两种交易流水数据格式的设计思路，你觉得哪一个更好呢？</strong></p>
<p>答案是第一种设计思路更好些。因为交易流水有两个功能：一个是业务功能，比如，提供用户查询交易流水信息；另一个是非业务功能，保证数据的一致性。这里主要是指支付操作数据的一致性。</p>
<p>支付实际上就是一个转账的操作，在一个账户上加上一定的金额，在另一个账户上减去相应的金额。我们需要保证加金额和减金额这两个操作，要么都成功，要么都失败。如果一个成功，一个失败，就会导致数据的不一致，一个账户明明减掉了钱，另一个账户却没有收到钱。</p>
<p>保证数据一致性的方法有很多，比如依赖数据库事务的原子性，将两个操作放在同一个事务中执行。但是，这样的做法不够灵活，因为我们的有可能做了分库分表，支付涉及的两个账户可能存储在不同的库中，无法直接利用数据库本身的事务特性，在一个事务中执行两个账户的操作。当然，我们还有一些支持分布式事务的开源框架，但是，为了保证数据的强一致性，它们的实现逻辑一般都比较复杂、本身的性能也不高，会影响业务的执行时间。所以，更加权衡的一种做法就是，不保证数据的强一致性，只实现数据的最终一致性，也就是我们刚刚提到的交易流水要实现的非业务功能。</p>
<p>对于支付这样的类似转账的操作，我们在操作两个钱包账户余额之前，先记录交易流水，并且标记为“待执行”，当两个钱包的加减金额都完成之后，我们再回过头来，将交易流水标记为“成功”。在给两个钱包加减金额的过程中，如果有任意一个操作失败，我们就将交易记录的状态标记为“失败”。我们通过后台补漏Job，拉取状态为“失败”或者长时间处于“待执行”状态的交易记录，重新执行或者人工介入处理。</p>
<p>如果选择第二种交易流水的设计思路，使用两条交易流水来记录支付操作，那记录两条交易流水本身又存在数据的一致性问题，有可能入账的交易流水记录成功，出账的交易流水信息记录失败。所以，权衡利弊，我们选择第一种稍微有些冗余的数据格式设计思路。</p>
<p><strong>现在，我们再思考这样一个问题：充值、提现、支付这些业务交易类型，是否应该让虚拟钱包系统感知？换句话说，我们是否应该在虚拟钱包系统的交易流水中记录这三种类型？</strong></p>
<p>答案是否定的。虚拟钱包系统不应该感知具体的业务交易类型。我们前面讲到，虚拟钱包支持的操作，仅仅是余额的加加减减操作，不涉及复杂业务概念，职责单一、功能通用。如果耦合太多业务概念到里面，势必影响系统的通用性，而且还会导致系统越做越复杂。因此，我们不希望将充值、支付、提现这样的业务概念添加到虚拟钱包系统中。</p>
<p>但是，<strong>如果我们不在虚拟钱包系统的交易流水中记录交易类型，那在用户查询交易流水的时候，如何显示每条交易流水的交易类型呢？</strong></p>
<p>从系统设计的角度，我们不应该在虚拟钱包系统的交易流水中记录交易类型。从产品需求的角度来说，我们又必须记录交易流水的交易类型。听起来比较矛盾，这个问题该如何解决呢？</p>
<p>我们可以通过记录两条交易流水信息的方式来解决。我们前面讲到，整个钱包系统分为两个子系统，上层钱包系统的实现，依赖底层虚拟钱包系统和三方支付系统。对于钱包系统来说，它可以感知充值、支付、提现等业务概念，所以，我们在钱包系统这一层额外再记录一条包含交易类型的交易流水信息，而在底层的虚拟钱包系统中记录不包含交易类型的交易流水信息。</p>
<p>为了让你更好地理解刚刚的设计思路，我画了一张图，你可以对比着我的讲解一块儿来看。</p>
<img src="https://static001.geekbang.org/resource/image/fb/18/fb356a2589a14f2f3440247e3c7a7718.jpg" alt="img" style="zoom:33%;" />

<p>我们通过查询上层钱包系统的交易流水信息，去满足用户查询交易流水的功能需求，而虚拟钱包中的交易流水就只是用来解决数据一致性问题。实际上，它的作用还有很多，比如用来对账等。限于篇幅，这里我们就不展开讲了。</p>
<p>整个虚拟钱包的设计思路到此讲完了。接下来，我们来看一下，如何分别用基于贫血模型的传统开发模式和基于充血模型的DDD开发模式，来实现这样一个虚拟钱包系统？</p>
<p><strong>基于贫血模型的传统开发模式</strong></p>
<p>实际上，如果你有一定Web项目的开发经验，并且听明白了我刚刚讲的设计思路，那对你来说，利用基于贫血模型的传统开发模式来实现这样一个系统，应该是一件挺简单的事情。不过，为了对比两种开发模式，我还是带你一块儿来实现一遍。</p>
<p>这是一个典型的Web后端项目的三层结构。其中，Controller和VO负责暴露接口，具体的代码实现如下所示。注意，Controller中，接口实现比较简单，主要就是调用Service的方法，所以，我省略了具体的代码实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VirtualWalletController</span> &#123;</span><br><span class="line">  <span class="comment">// 通过构造函数或者IOC框架注入</span></span><br><span class="line">  <span class="keyword">private</span> VirtualWalletService virtualWalletService;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> BigDecimal <span class="title function_">getBalance</span><span class="params">(Long walletId)</span> &#123; ... &#125; <span class="comment">//查询余额</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debit</span><span class="params">(Long walletId, BigDecimal amount)</span> &#123; ... &#125; <span class="comment">//出账</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">credit</span><span class="params">(Long walletId, BigDecimal amount)</span> &#123; ... &#125; <span class="comment">//入账</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Long fromWalletId, Long toWalletId, BigDecimal amount)</span> &#123; ...&#125; <span class="comment">//转账</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Service和BO负责核心业务逻辑，Repository和Entity负责数据存取。Repository这一层的代码实现比较简单，不是我们讲解的重点，所以我也省略掉了。Service层的代码如下所示。注意，这里我省略了一些不重要的校验代码，比如，对amount是否小于0、钱包是否存在的校验等等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VirtualWalletBo</span> &#123;<span class="comment">//省略getter/setter/constructor方法</span></span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  <span class="keyword">private</span> Long createTime;</span><br><span class="line">  <span class="keyword">private</span> BigDecimal balance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VirtualWalletService</span> &#123;</span><br><span class="line">  <span class="comment">// 通过构造函数或者IOC框架注入</span></span><br><span class="line">  <span class="keyword">private</span> VirtualWalletRepository walletRepo;</span><br><span class="line">  <span class="keyword">private</span> VirtualWalletTransactionRepository transactionRepo;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> VirtualWalletBo <span class="title function_">getVirtualWallet</span><span class="params">(Long walletId)</span> &#123;</span><br><span class="line">    <span class="type">VirtualWalletEntity</span> <span class="variable">walletEntity</span> <span class="operator">=</span> walletRepo.getWalletEntity(walletId);</span><br><span class="line">    <span class="type">VirtualWalletBo</span> <span class="variable">walletBo</span> <span class="operator">=</span> convert(walletEntity);</span><br><span class="line">    <span class="keyword">return</span> walletBo;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> BigDecimal <span class="title function_">getBalance</span><span class="params">(Long walletId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> walletRepo.getBalance(walletId);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debit</span><span class="params">(Long walletId, BigDecimal amount)</span> &#123;</span><br><span class="line">    <span class="type">VirtualWalletEntity</span> <span class="variable">walletEntity</span> <span class="operator">=</span> walletRepo.getWalletEntity(walletId);</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">balance</span> <span class="operator">=</span> walletEntity.getBalance();</span><br><span class="line">    <span class="keyword">if</span> (balance.compareTo(amount) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSufficientBalanceException</span>(...);</span><br><span class="line">    &#125;</span><br><span class="line">    walletRepo.updateBalance(walletId, balance.subtract(amount));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">credit</span><span class="params">(Long walletId, BigDecimal amount)</span> &#123;</span><br><span class="line">    <span class="type">VirtualWalletEntity</span> <span class="variable">walletEntity</span> <span class="operator">=</span> walletRepo.getWalletEntity(walletId);</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">balance</span> <span class="operator">=</span> walletEntity.getBalance();</span><br><span class="line">    walletRepo.updateBalance(walletId, balance.add(amount));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Long fromWalletId, Long toWalletId, BigDecimal amount)</span> &#123;</span><br><span class="line">    <span class="type">VirtualWalletTransactionEntity</span> <span class="variable">transactionEntity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VirtualWalletTransactionEntity</span>();</span><br><span class="line">    transactionEntity.setAmount(amount);</span><br><span class="line">    transactionEntity.setCreateTime(System.currentTimeMillis());</span><br><span class="line">    transactionEntity.setFromWalletId(fromWalletId);</span><br><span class="line">    transactionEntity.setToWalletId(toWalletId);</span><br><span class="line">    transactionEntity.setStatus(Status.TO_BE_EXECUTED);</span><br><span class="line">    <span class="type">Long</span> <span class="variable">transactionId</span> <span class="operator">=</span> transactionRepo.saveTransaction(transactionEntity);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      debit(fromWalletId, amount);</span><br><span class="line">      credit(toWalletId, amount);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InsufficientBalanceException e) &#123;</span><br><span class="line">      transactionRepo.updateStatus(transactionId, Status.CLOSED);</span><br><span class="line">      ...rethrow exception e...</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      transactionRepo.updateStatus(transactionId, Status.FAILED);</span><br><span class="line">      ...rethrow exception e...</span><br><span class="line">    &#125;</span><br><span class="line">    transactionRepo.updateStatus(transactionId, Status.EXECUTED);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上便是利用基于贫血模型的传统开发模式来实现的虚拟钱包系统。尽管我们对代码稍微做了简化，但整体的业务逻辑就是上面这样子。其中大部分代码逻辑都非常简单，最复杂的是Service中的transfer()转账函数。我们为了保证转账操作的数据一致性，添加了一些跟transaction相关的记录和状态更新的代码，理解起来稍微有点难度，你可以对照着之前讲的设计思路，自己多思考一下。</p>
<p><strong>基于充血模型的DDD开发模式</strong></p>
<p>刚刚讲了如何利用基于贫血模型的传统开发模式来实现虚拟钱包系统，现在，我们再来看一下，如何利用基于充血模型的DDD开发模式来实现这个系统？</p>
<p>在上一节课中，我们讲到，基于充血模型的DDD开发模式，跟基于贫血模型的传统开发模式的主要区别就在Service层，Controller层和Repository层的代码基本上相同。所以，我们重点看一下，Service层按照基于充血模型的DDD开发模式该如何来实现。</p>
<p>在这种开发模式下，我们把虚拟钱包VirtualWallet类设计成一个充血的Domain领域模型，并且将原来在Service类中的部分业务逻辑移动到VirtualWallet类中，让Service类的实现依赖VirtualWallet类。具体的代码实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VirtualWallet</span> &#123; <span class="comment">// Domain领域模型(充血模型)</span></span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Long</span> <span class="variable">createTime</span> <span class="operator">=</span> System.currentTimeMillis();;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">BigDecimal</span> <span class="variable">balance</span> <span class="operator">=</span> BigDecimal.ZERO;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">VirtualWallet</span><span class="params">(Long preAllocatedId)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.id = preAllocatedId;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> BigDecimal <span class="title function_">balance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.balance;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debit</span><span class="params">(BigDecimal amount)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.balance.compareTo(amount) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InsufficientBalanceException</span>(...);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.balance = <span class="built_in">this</span>.balance.subtract(amount);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">credit</span><span class="params">(BigDecimal amount)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (amount.compareTo(BigDecimal.ZERO) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidAmountException</span>(...);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.balance = <span class="built_in">this</span>.balance.add(amount);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VirtualWalletService</span> &#123;</span><br><span class="line">  <span class="comment">// 通过构造函数或者IOC框架注入</span></span><br><span class="line">  <span class="keyword">private</span> VirtualWalletRepository walletRepo;</span><br><span class="line">  <span class="keyword">private</span> VirtualWalletTransactionRepository transactionRepo;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> VirtualWallet <span class="title function_">getVirtualWallet</span><span class="params">(Long walletId)</span> &#123;</span><br><span class="line">    <span class="type">VirtualWalletEntity</span> <span class="variable">walletEntity</span> <span class="operator">=</span> walletRepo.getWalletEntity(walletId);</span><br><span class="line">    <span class="type">VirtualWallet</span> <span class="variable">wallet</span> <span class="operator">=</span> convert(walletEntity);</span><br><span class="line">    <span class="keyword">return</span> wallet;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> BigDecimal <span class="title function_">getBalance</span><span class="params">(Long walletId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> walletRepo.getBalance(walletId);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debit</span><span class="params">(Long walletId, BigDecimal amount)</span> &#123;</span><br><span class="line">    <span class="type">VirtualWalletEntity</span> <span class="variable">walletEntity</span> <span class="operator">=</span> walletRepo.getWalletEntity(walletId);</span><br><span class="line">    <span class="type">VirtualWallet</span> <span class="variable">wallet</span> <span class="operator">=</span> convert(walletEntity);</span><br><span class="line">    wallet.debit(amount);</span><br><span class="line">    walletRepo.updateBalance(walletId, wallet.balance());</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">credit</span><span class="params">(Long walletId, BigDecimal amount)</span> &#123;</span><br><span class="line">    <span class="type">VirtualWalletEntity</span> <span class="variable">walletEntity</span> <span class="operator">=</span> walletRepo.getWalletEntity(walletId);</span><br><span class="line">    <span class="type">VirtualWallet</span> <span class="variable">wallet</span> <span class="operator">=</span> convert(walletEntity);</span><br><span class="line">    wallet.credit(amount);</span><br><span class="line">    walletRepo.updateBalance(walletId, wallet.balance());</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Long fromWalletId, Long toWalletId, BigDecimal amount)</span> &#123;</span><br><span class="line">    <span class="comment">//...跟基于贫血模型的传统开发模式的代码一样...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看了上面的代码，你可能会说，领域模型VirtualWallet类很单薄，包含的业务逻辑很简单。相对于原来的贫血模型的设计思路，这种充血模型的设计思路，貌似并没有太大优势。你说得没错！这也是大部分业务系统都使用基于贫血模型开发的原因。不过，如果虚拟钱包系统需要支持更复杂的业务逻辑，那充血模型的优势就显现出来了。比如，我们要支持透支一定额度和冻结部分余额的功能。这个时候，我们重新来看一下VirtualWallet类的实现代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VirtualWallet</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Long</span> <span class="variable">createTime</span> <span class="operator">=</span> System.currentTimeMillis();;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">BigDecimal</span> <span class="variable">balance</span> <span class="operator">=</span> BigDecimal.ZERO;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">isAllowedOverdraft</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">BigDecimal</span> <span class="variable">overdraftAmount</span> <span class="operator">=</span> BigDecimal.ZERO;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">BigDecimal</span> <span class="variable">frozenAmount</span> <span class="operator">=</span> BigDecimal.ZERO;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">VirtualWallet</span><span class="params">(Long preAllocatedId)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.id = preAllocatedId;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">freeze</span><span class="params">(BigDecimal amount)</span> &#123; ... &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unfreeze</span><span class="params">(BigDecimal amount)</span> &#123; ...&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increaseOverdraftAmount</span><span class="params">(BigDecimal amount)</span> &#123; ... &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decreaseOverdraftAmount</span><span class="params">(BigDecimal amount)</span> &#123; ... &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">closeOverdraft</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">openOverdraft</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> BigDecimal <span class="title function_">balance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.balance;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> BigDecimal <span class="title function_">getAvailableBalance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">totalAvaliableBalance</span> <span class="operator">=</span> <span class="built_in">this</span>.balance.subtract(<span class="built_in">this</span>.frozenAmount);</span><br><span class="line">    <span class="keyword">if</span> (isAllowedOverdraft) &#123;</span><br><span class="line">      totalAvaliableBalance += <span class="built_in">this</span>.overdraftAmount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> totalAvaliableBalance;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debit</span><span class="params">(BigDecimal amount)</span> &#123;</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">totalAvaliableBalance</span> <span class="operator">=</span> getAvailableBalance();</span><br><span class="line">    <span class="keyword">if</span> (totoalAvaliableBalance.compareTo(amount) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InsufficientBalanceException</span>(...);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.balance.subtract(amount);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">credit</span><span class="params">(BigDecimal amount)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (amount.compareTo(BigDecimal.ZERO) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidAmountException</span>(...);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.balance.add(amount);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>领域模型VirtualWallet类添加了简单的冻结和透支逻辑之后，功能看起来就丰富了很多，代码也没那么单薄了。如果功能继续演进，我们可以增加更加细化的冻结策略、透支策略、支持钱包账号（VirtualWallet id字段）自动生成的逻辑（不是通过构造函数经外部传入ID，而是通过分布式ID生成算法来自动生成ID）等等。VirtualWallet类的业务逻辑会变得越来越复杂，也就很值得设计成充血模型了。</p>
<p><strong>辩证思考与灵活应用</strong></p>
<p>对于虚拟钱包系统的设计与两种开发模式的代码实现，我想你应该有个比较清晰的了解了。不过，我觉得还有两个问题值得讨论一下。</p>
<p><strong>第一个要讨论的问题是：在基于充血模型的DDD开发模式中，将业务逻辑移动到Domain中，Service类变得很薄，但在我们的代码设计与实现中，并没有完全将Service类去掉，这是为什么？或者说，Service类在这种情况下担当的职责是什么？哪些功能逻辑会放到Service类中？</strong></p>
<p>区别于Domain的职责，Service类主要有下面这样几个职责。</p>
<p>1.Service类负责与Repository交流。在我的设计与代码实现中，VirtualWalletService类负责与Repository层打交道，调用Respository类的方法，获取数据库中的数据，转化成领域模型VirtualWallet，然后由领域模型VirtualWallet来完成业务逻辑，最后调用Repository类的方法，将数据存回数据库。</p>
<p>这里我再稍微解释一下，之所以让VirtualWalletService类与Repository打交道，而不是让领域模型VirtualWallet与Repository打交道，那是因为我们想保持领域模型的独立性，不与任何其他层的代码（Repository层的代码）或开发框架（比如Spring、MyBatis）耦合在一起，将流程性的代码逻辑（比如从DB中取数据、映射数据）与领域模型的业务逻辑解耦，让领域模型更加可复用。</p>
<p>2.Service类负责跨领域模型的业务聚合功能。VirtualWalletService类中的transfer()转账函数会涉及两个钱包的操作，因此这部分业务逻辑无法放到VirtualWallet类中，所以，我们暂且把转账业务放到VirtualWalletService类中了。当然，虽然功能演进，使得转账业务变得复杂起来之后，我们也可以将转账业务抽取出来，设计成一个独立的领域模型。</p>
<p>3.Service类负责一些非功能性及与三方系统交互的工作。比如幂等、事务、发邮件、发消息、记录日志、调用其他系统的RPC接口等，都可以放到Service类中。</p>
<p><strong>第二个要讨论问题是：在基于充血模型的DDD开发模式中，尽管Service层被改造成了充血模型，但是Controller层和Repository层还是贫血模型，是否有必要也进行充血领域建模呢？</strong></p>
<p>答案是没有必要。Controller层主要负责接口的暴露，Repository层主要负责与数据库打交道，这两层包含的业务逻辑并不多，前面我们也提到了，如果业务逻辑比较简单，就没必要做充血建模，即便设计成充血模型，类也非常单薄，看起来也很奇怪。</p>
<p>尽管这样的设计是一种面向过程的编程风格，但我们只要控制好面向过程编程风格的副作用，照样可以开发出优秀的软件。那这里的副作用怎么控制呢？</p>
<p>就拿Repository的Entity来说，即便它被设计成贫血模型，违反面向对象编程的封装特性，有被任意代码修改数据的风险，但Entity的生命周期是有限的。一般来讲，我们把它传递到Service层之后，就会转化成BO或者Domain来继续后面的业务逻辑。Entity的生命周期到此就结束了，所以也并不会被到处任意修改。</p>
<p>我们再来说说Controller层的VO。实际上VO是一种DTO（Data Transfer Object，数据传输对象）。它主要是作为接口的数据传输承载体，将数据发送给其他系统。从功能上来讲，它理应不包含业务逻辑、只包含数据。所以，我们将它设计成贫血模型也是比较合理的。</p>
<h3 id="11-对接口鉴权功能作面向对象分析"><a href="#11-对接口鉴权功能作面向对象分析" class="headerlink" title="11. 对接口鉴权功能作面向对象分析"></a>11. 对接口鉴权功能作面向对象分析</h3><p>假设，你正在参与开发一个微服务。微服务通过HTTP协议暴露接口给其他系统调用，说直白点就是，其他系统通过URL来调用微服务的接口。有一天，你的leader找到你说，“为了保证接口调用的安全性，我们希望设计实现一个接口调用鉴权功能，只有经过认证之后的系统才能调用我们的接口，没有认证过的系统调用我们的接口会被拒绝。我希望由你来负责这个任务的开发，争取尽快上线。”</p>
<p>leader丢下这些话就走了。这个时候，你该如何来做呢？有没有脑子里一团浆糊，一时间无从下手的感觉呢？为什么会有这种感觉呢？我个人觉得主要有下面两点原因。</p>
<p><strong>1.需求不明确</strong></p>
<p>leader给到的需求过于模糊、笼统，不够具体、细化，离落地到设计、编码还有一定的距离。而人的大脑不擅长思考这种过于抽象的问题。这也是真实的软件开发区别于应试教育的地方。应试教育中的考试题目，一般都是一个非常具体的问题，我们去解答就好了。而真实的软件开发中，需求几乎都不是很明确。</p>
<p>我们前面讲过，面向对象分析主要的分析对象是“需求”，因此，面向对象分析可以粗略地看成“需求分析”。实际上，不管是需求分析还是面向对象分析，我们首先要做的都是将笼统的需求细化到足够清晰、可执行。我们需要通过沟通、挖掘、分析、假设、梳理，搞清楚具体的需求有哪些，哪些是现在要做的，哪些是未来可能要做的，哪些是不用考虑做的。</p>
<p><strong>2.缺少锻炼</strong></p>
<p>相比单纯的业务CRUD开发，鉴权这个开发任务，要更有难度。鉴权作为一个跟具体业务无关的功能，我们完全可以把它开发成一个独立的框架，集成到很多业务系统中。而作为被很多系统复用的通用框架，比起普通的业务代码，我们对框架的代码质量要求要更高。</p>
<p>开发这样通用的框架，对工程师的需求分析能力、设计能力、编码能力，甚至逻辑思维能力的要求，都是比较高的。如果你平时做的都是简单的CRUD业务开发，那这方面的锻炼肯定不会很多，所以，一旦遇到这种开发需求，很容易因为缺少锻炼，脑子放空，不知道从何入手，完全没有思路。</p>
<p><strong>对案例进行需求分析</strong></p>
<p>实际上，需求分析的工作很琐碎，也没有太多固定的章法可寻，所以，我不打算很牵强地罗列那些听着有用、实际没用的方法论，而是希望通过鉴权这个例子，来给你展示一下，面对需求分析的时候，我的完整的思考路径是什么样的。希望你能自己去体会，举一反三地类比应用到其他项目的需求分析中。</p>
<p>尽管针对框架、组件、类库等非业务系统的开发，我们一定要有组件化意识、框架意识、抽象意识，开发出来的东西要足够通用，不能局限于单一的某个业务需求，但这并不代表我们就可以脱离具体的应用场景，闷头拍脑袋做需求分析。多跟业务团队聊聊天，甚至自己去参与几个业务系统的开发，只有这样，我们才能真正知道业务系统的痛点，才能分析出最有价值的需求。不过，针对鉴权这一功能的开发，最大的需求方还是我们自己，所以，我们也可以先从满足我们自己系统的需求开始，然后再迭代优化。</p>
<p>现在，我们来看一下，针对鉴权这个功能的开发，我们该如何做需求分析？</p>
<p>实际上，这跟做算法题类似，先从最简单的方案想起，然后再优化。所以，我把整个的分析过程分为了循序渐进的四轮。每一轮都是对上一轮的迭代优化，最后形成一个可执行、可落地的需求列表。</p>
<p><strong>1.第一轮基础分析</strong></p>
<p>对于如何做鉴权这样一个问题，最简单的解决方案就是，通过用户名加密码来做认证。我们给每个允许访问我们服务的调用方，派发一个应用名（或者叫应用ID、AppID）和一个对应的密码（或者叫秘钥）。调用方每次进行接口请求的时候，都携带自己的AppID和密码。微服务在接收到接口调用请求之后，会解析出AppID和密码，跟存储在微服务端的AppID和密码进行比对。如果一致，说明认证成功，则允许接口调用请求；否则，就拒绝接口调用请求。</p>
<p><strong>2.第二轮分析优化</strong></p>
<p>不过，这样的验证方式，每次都要明文传输密码。密码很容易被截获，是不安全的。那如果我们借助加密算法（比如SHA），对密码进行加密之后，再传递到微服务端验证，是不是就可以了呢？实际上，这样也是不安全的，因为加密之后的密码及AppID，照样可以被未认证系统（或者说黑客）截获，未认证系统可以携带这个加密之后的密码以及对应的AppID，伪装成已认证系统来访问我们的接口。这就是典型的“<a href="https://zh.wikipedia.org/wiki/%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB">重放攻击</a>”。</p>
<p>提出问题，然后再解决问题，是一个非常好的迭代优化方法。对于刚刚这个问题，我们可以借助OAuth的验证思路来解决。调用方将请求接口的URL跟AppID、密码拼接在一起，然后进行加密，生成一个token。调用方在进行接口请求的的时候，将这个token及AppID，随URL一块传递给微服务端。微服务端接收到这些数据之后，根据AppID从数据库中取出对应的密码，并通过同样的token生成算法，生成另外一个token。用这个新生成的token跟调用方传递过来的token对比。如果一致，则允许接口调用请求；否则，就拒绝接口调用请求。</p>
<p>这个方案稍微有点复杂，我画了一张示例图，来帮你理解整个流程。</p>
<img src="https://static001.geekbang.org/resource/image/07/d7/0704c4806f9d6c01bb20884d05ee54d7.jpg" alt="img" style="zoom:33%;" />

<p><strong>3.第三轮分析优化</strong></p>
<p>不过，这样的设计仍然存在重放攻击的风险，还是不够安全。每个URL拼接上AppID、密码生成的token都是固定的。未认证系统截获URL、token和AppID之后，还是可以通过重放攻击的方式，伪装成认证系统，调用这个URL对应的接口。</p>
<p>为了解决这个问题，我们可以进一步优化token生成算法，引入一个随机变量，让每次接口请求生成的token都不一样。我们可以选择时间戳作为随机变量。原来的token是对URL、AppID、密码三者进行加密生成的，现在我们将URL、AppID、密码、时间戳四者进行加密来生成token。调用方在进行接口请求的时候，将token、AppID、时间戳，随URL一并传递给微服务端。</p>
<p>微服务端在收到这些数据之后，会验证当前时间戳跟传递过来的时间戳，是否在一定的时间窗口内（比如一分钟）。如果超过一分钟，则判定token过期，拒绝接口请求。如果没有超过一分钟，则说明token没有过期，就再通过同样的token生成算法，在服务端生成新的token，与调用方传递过来的token比对，看是否一致。如果一致，则允许接口调用请求；否则，就拒绝接口调用请求。</p>
<p>优化之后的认证流程如下图所示。</p>
<img src="https://static001.geekbang.org/resource/image/bd/60/bde932c73c6636ad85380e4801dbfb60.jpg" alt="img" style="zoom:33%;" />

<p><strong>4.第四轮分析优化</strong></p>
<p>不过，你可能会说，这样还是不够安全啊。未认证系统还是可以在这一分钟的token失效窗口内，通过截获请求、重放请求，来调用我们的接口啊！</p>
<p>你说得没错。不过，攻与防之间，本来就没有绝对的安全。我们能做的就是，尽量提高攻击的成本。这个方案虽然还有漏洞，但是实现起来足够简单，而且不会过度影响接口本身的性能（比如响应时间）。所以，权衡安全性、开发成本、对系统性能的影响，这个方案算是比较折中、比较合理的了。</p>
<p>实际上，还有一个细节我们没有考虑到，那就是，如何在微服务端存储每个授权调用方的AppID和密码。当然，这个问题并不难。最容易想到的方案就是存储到数据库里，比如MySQL。不过，开发像鉴权这样的非业务功能，最好不要与具体的第三方系统有过度的耦合。</p>
<p>针对AppID和密码的存储，我们最好能灵活地支持各种不同的存储方式，比如ZooKeeper、本地配置文件、自研配置中心、MySQL、Redis等。我们不一定针对每种存储方式都去做代码实现，但起码要留有扩展点，保证系统有足够的灵活性和扩展性，能够在我们切换存储方式的时候，尽可能地减少代码的改动。</p>
<p><strong>5.最终确定需求</strong></p>
<p>到此，需求已经足够细化和具体了。现在，我们按照鉴权的流程，对需求再重新描述一下。如果你熟悉UML，也可以用时序图、流程图来描述。不过，用什么描述不是重点，描述清楚才是最重要的。考虑到在接下来的面向对象设计环节中，我会基于文字版本的需求描述，来进行类、属性、方法、交互等的设计，所以，这里我给出的最终需求描述是文字版本的。</p>
<ul>
<li>调用方进行接口请求的时候，将URL、AppID、密码、时间戳拼接在一起，通过加密算法生成token，并且将token、AppID、时间戳拼接在URL中，一并发送到微服务端。</li>
<li>微服务端在接收到调用方的接口请求之后，从请求中拆解出token、AppID、时间戳。</li>
<li>微服务端首先检查传递过来的时间戳跟当前时间，是否在token失效时间窗口内。如果已经超过失效时间，那就算接口调用鉴权失败，拒绝接口调用请求。</li>
<li>如果token验证没有过期失效，微服务端再从自己的存储中，取出AppID对应的密码，通过同样的token生成算法，生成另外一个token，与调用方传递过来的token进行匹配；如果一致，则鉴权成功，允许接口调用，否则就拒绝接口调用。</li>
</ul>
<p>这就是我们需求分析的整个思考过程，从最粗糙、最模糊的需求开始，通过“提出问题-解决问题”的方式，循序渐进地进行优化，最后得到一个足够清晰、可落地的需求描述。</p>
<h3 id="12-开发接口鉴权功能"><a href="#12-开发接口鉴权功能" class="headerlink" title="12. 开发接口鉴权功能"></a>12. 开发接口鉴权功能</h3><p><strong>如何进行面向对象设计？</strong></p>
<p>我们知道，面向对象分析的产出是详细的需求描述，那面向对象设计的产出就是类。在面向对象设计环节，我们将需求描述转化为具体的类的设计。我们把这一设计环节拆解细化一下，主要包含以下几个部分：</p>
<ul>
<li>划分职责进而识别出有哪些类；</li>
<li>定义类及其属性和方法；</li>
<li>定义类与类之间的交互关系；</li>
<li>将类组装起来并提供执行入口。</li>
</ul>
<p>实话讲，不管是面向对象分析还是面向对象设计，理论的东西都不多，所以我们还是结合鉴权这个例子，在实战中体会如何做面向对象设计。</p>
<p><strong>1.划分职责进而识别出有哪些类</strong></p>
<p>在面向对象有关书籍中经常讲到，类是现实世界中事物的一个建模。但是，并不是每个需求都能映射到现实世界，也并不是每个类都与现实世界中的事物一一对应。对于一些抽象的概念，我们是无法通过映射现实世界中的事物的方式来定义类的。</p>
<p>所以，大多数讲面向对象的书籍中，还会讲到另外一种识别类的方法，那就是把需求描述中的名词罗列出来，作为可能的候选类，然后再进行筛选。对于没有经验的初学者来说，这个方法比较简单、明确，可以直接照着做。</p>
<p>不过，我个人更喜欢另外一种方法，那就是根据需求描述，把其中涉及的功能点，一个一个罗列出来，然后再去看哪些功能点职责相近，操作同样的属性，是否应该归为同一个类。我们来看一下，针对鉴权这个例子，具体该如何来做。</p>
<p>在上一节课中，我们已经给出了详细的需求描述，为了方便你查看，我把它重新贴在了下面。</p>
<ul>
<li>调用方进行接口请求的时候，将URL、AppID、密码、时间戳拼接在一起，通过加密算法生成token，并且将token、AppID、时间戳拼接在URL中，一并发送到微服务端。</li>
<li>微服务端在接收到调用方的接口请求之后，从请求中拆解出token、AppID、时间戳。</li>
<li>微服务端首先检查传递过来的时间戳跟当前时间，是否在token失效时间窗口内。如果已经超过失效时间，那就算接口调用鉴权失败，拒绝接口调用请求。</li>
<li>如果token验证没有过期失效，微服务端再从自己的存储中，取出AppID对应的密码，通过同样的token生成算法，生成另外一个token，与调用方传递过来的token进行匹配。如果一致，则鉴权成功，允许接口调用；否则就拒绝接口调用。</li>
</ul>
<p>首先，我们要做的是逐句阅读上面的需求描述，拆解成小的功能点，一条一条罗列下来。注意，拆解出来的每个功能点要尽可能的小。每个功能点只负责做一件很小的事情（专业叫法是“单一职责”，后面章节中我们会讲到）。下面是我逐句拆解上述需求描述之后，得到的功能点列表：</p>
<ol>
<li>把URL、AppID、密码、时间戳拼接为一个字符串；</li>
<li>对字符串通过加密算法加密生成token；</li>
<li>将token、AppID、时间戳拼接到URL中，形成新的URL；</li>
<li>解析URL，得到token、AppID、时间戳等信息；</li>
<li>从存储中取出AppID和对应的密码；</li>
<li>根据时间戳判断token是否过期失效；</li>
<li>验证两个token是否匹配；</li>
</ol>
<p>从上面的功能列表中，我们发现，1、2、6、7都是跟token有关，负责token的生成、验证；3、4都是在处理URL，负责URL的拼接、解析；5是操作AppID和密码，负责从存储中读取AppID和密码。所以，我们可以粗略地得到三个核心的类：AuthToken、Url、CredentialStorage。AuthToken负责实现1、2、6、7这四个操作；Url负责3、4两个操作；CredentialStorage负责5这个操作。</p>
<p>当然，这是一个初步的类的划分，其他一些不重要的、边边角角的类，我们可能暂时没法一下子想全，但这也没关系，面向对象分析、设计、编程本来就是一个循环迭代、不断优化的过程。根据需求，我们先给出一个粗糙版本的设计方案，然后基于这样一个基础，再去迭代优化，会更加容易一些，思路也会更加清晰一些。</p>
<p>不过，我还要再强调一点，接口调用鉴权这个开发需求比较简单，所以，需求对应的面向对象设计并不复杂，识别出来的类也并不多。但如果我们面对的是更加大型的软件开发、更加复杂的需求开发，涉及的功能点可能会很多，对应的类也会比较多，像刚刚那样根据需求逐句罗列功能点的方法，最后会得到一个长长的列表，就会有点凌乱、没有规律。针对这种复杂的需求开发，我们首先要做的是进行模块划分，将需求先简单划分成几个小的、独立的功能模块，然后再在模块内部，应用我们刚刚讲的方法，进行面向对象设计。而模块的划分和识别，跟类的划分和识别，是类似的套路。</p>
<p><strong>2.定义类及其属性和方法</strong></p>
<p>刚刚我们通过分析需求描述，识别出了三个核心的类，它们分别是AuthToken、Url和CredentialStorage。现在我们来看下，每个类都有哪些属性和方法。我们还是从功能点列表中挖掘。</p>
<p><strong>AuthToken类相关的功能点有四个：</strong></p>
<ul>
<li>把URL、AppID、密码、时间戳拼接为一个字符串；</li>
<li>对字符串通过加密算法加密生成token；</li>
<li>根据时间戳判断token是否过期失效；</li>
<li>验证两个token是否匹配。</li>
</ul>
<p>对于方法的识别，很多面向对象相关的书籍，一般都是这么讲的，识别出需求描述中的动词，作为候选的方法，再进一步过滤筛选。类比一下方法的识别，我们可以把功能点中涉及的名词，作为候选属性，然后同样进行过滤筛选。</p>
<p>我们可以借用这个思路，根据功能点描述，识别出来AuthToken类的属性和方法，如下所示：</p>
<img src="https://static001.geekbang.org/resource/image/69/9b/69c8954e0db1a4db99a6094ee359fc9b.jpg" alt="img" style="zoom:33%;" />

<p>从上面的类图中，我们可以发现这样三个小细节。</p>
<ul>
<li>第一个细节：并不是所有出现的名词都被定义为类的属性，比如URL、AppID、密码、时间戳这几个名词，我们把它作为了方法的参数。</li>
<li>第二个细节：我们还需要挖掘一些没有出现在功能点描述中属性，比如createTime，expireTimeInterval，它们用在isExpired()函数中，用来判定token是否过期。</li>
<li>第三个细节：我们还给AuthToken类添加了一个功能点描述中没有提到的方法getToken()。</li>
</ul>
<p>第一个细节告诉我们，从业务模型上来说，不应该属于这个类的属性和方法，不应该被放到这个类里。比如URL、AppID这些信息，从业务模型上来说，不应该属于AuthToken，所以我们不应该放到这个类中。</p>
<p>第二、第三个细节告诉我们，在设计类具有哪些属性和方法的时候，不能单纯地依赖当下的需求，还要分析这个类从业务模型上来讲，理应具有哪些属性和方法。这样可以一方面保证类定义的完整性，另一方面不仅为当下的需求还为未来的需求做些准备。</p>
<p><strong>Url类相关的功能点有两个：</strong></p>
<ul>
<li>将token、AppID、时间戳拼接到URL中，形成新的URL；</li>
<li>解析URL，得到token、AppID、时间戳等信息。</li>
</ul>
<p>虽然需求描述中，我们都是以URL来代指接口请求，但是，接口请求并不一定是以URL的形式来表达，还有可能是Dubbo、RPC等其他形式。为了让这个类更加通用，命名更加贴切，我们接下来把它命名为ApiRequest。下面是我根据功能点描述设计的ApiRequest类。</p>
<img src="https://static001.geekbang.org/resource/image/1c/d6/1cc9b95e511bd49fbc23c00ac5c0fed6.jpg" alt="img" style="zoom:33%;" />

<p><strong>CredentialStorage类相关的功能点有一个：</strong></p>
<ul>
<li>从存储中取出AppID和对应的密码。</li>
</ul>
<p>CredentialStorage类非常简单，类图如下所示。为了做到抽象封装具体的存储方式，我们将CredentialStorage设计成了接口，基于接口而非具体的实现编程。</p>
<img src="https://static001.geekbang.org/resource/image/3b/85/3b6d2c0cadafa723e26cc032c29c8785.jpg" alt="img" style="zoom:33%;" />

<p><strong>3.定义类与类之间的交互关系</strong></p>
<p>类与类之间都有哪些交互关系呢？UML统一建模语言中定义了六种类之间的关系。它们分别是：泛化、实现、关联、聚合、组合、依赖。关系比较多，而且有些还比较相近，比如聚合和组合，接下来我就逐一讲解一下。</p>
<p><strong>泛化</strong>（Generalization）可以简单理解为继承关系。具体到Java代码就是下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class A &#123; ... &#125;</span><br><span class="line">public class B extends A &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p><strong>实现</strong>（Realization）一般是指接口和实现类之间的关系。具体到Java代码就是下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface A &#123;...&#125;</span><br><span class="line">public class B implements A &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p><strong>聚合</strong>（Aggregation）是一种包含关系，A类对象包含B类对象，B类对象的生命周期可以不依赖A类对象的生命周期，也就是说可以单独销毁A类对象而不影响B对象，比如课程与学生之间的关系。具体到Java代码就是下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class A &#123;</span><br><span class="line">  private B b;</span><br><span class="line">  public A(B b) &#123;</span><br><span class="line">    this.b = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>组合</strong>（Composition）也是一种包含关系。A类对象包含B类对象，B类对象的生命周期依赖A类对象的生命周期，B类对象不可单独存在，比如鸟与翅膀之间的关系。具体到Java代码就是下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class A &#123;</span><br><span class="line">  private B b;</span><br><span class="line">  public A() &#123;</span><br><span class="line">    this.b = new B();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关联</strong>（Association）是一种非常弱的关系，包含聚合、组合两种关系。具体到代码层面，如果B类对象是A类的成员变量，那B类和A类就是关联关系。具体到Java代码就是下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> B b;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(B b)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.b = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> B b;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.b = <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>依赖</strong>（Dependency）是一种比关联关系更加弱的关系，包含关联关系。不管是B类对象是A类对象的成员变量，还是A类的方法使用B类对象作为参数或者返回值、局部变量，只要B类对象和A类对象有任何使用关系，我们都称它们有依赖关系。具体到Java代码就是下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> B b;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(B b)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.b = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> B b;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.b = <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(B b)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看完了UML六种类关系的详细介绍，不知道你有何感受？我个人觉得这样拆分有点太细，增加了学习成本，对于指导编程开发没有太大意义。所以，我从更加贴近编程的角度，对类与类之间的关系做了调整，只保留了四个关系：泛化、实现、组合、依赖，这样你掌握起来会更加容易。</p>
<p>其中，泛化、实现、依赖的定义不变，组合关系替代UML中组合、聚合、关联三个概念，也就相当于重新命名关联关系为组合关系，并且不再区分UML中的组合和聚合两个概念。之所以这样重新命名，是为了跟我们前面讲的“多用组合少用继承”设计原则中的“组合”统一含义。只要B类对象是A类对象的成员变量，那我们就称，A类跟B类是组合关系。</p>
<p>理论的东西讲完了，让我们来看一下，刚刚我们定义的类之间都有哪些关系呢？因为目前只有三个核心的类，所以只用到了实现关系，也即CredentialStorage和MysqlCredentialStorage之间的关系。接下来讲到组装类的时候，我们还会用到依赖关系、组合关系，但是泛化关系暂时没有用到。</p>
<p><strong>4.将类组装起来并提供执行入口</strong></p>
<p>类定义好了，类之间必要的交互关系也设计好了，接下来我们要将所有的类组装在一起，提供一个执行入口。这个入口可能是一个main()函数，也可能是一组给外部用的API接口。通过这个入口，我们能触发整个代码跑起来。</p>
<p>接口鉴权并不是一个独立运行的系统，而是一个集成在系统上运行的组件，所以，我们封装所有的实现细节，设计了一个最顶层的ApiAuthenticator接口类，暴露一组给外部调用者使用的API接口，作为触发执行鉴权逻辑的入口。具体的类的设计如下所示：</p>
<img src="https://static001.geekbang.org/resource/image/f4/ca/f408ac59caffde117716d11148d010ca.jpg" alt="img" style="zoom:33%;" />

<p><strong>如何进行面向对象编程？</strong></p>
<p>面向对象设计完成之后，我们已经定义清晰了类、属性、方法、类之间的交互，并且将所有的类组装起来，提供了统一的执行入口。接下来，面向对象编程的工作，就是将这些设计思路翻译成代码实现。有了前面的类图，这部分工作相对来说就比较简单了。所以，这里我只给出比较复杂的ApiAuthenticator的实现。</p>
<p>对于AuthToken、ApiRequest、CredentialStorage这三个类，在这里我就不给出具体的代码实现了。给你留一个课后作业，你可以试着把整个鉴权框架自己去实现一遍。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApiAuthenticator</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">auth</span><span class="params">(String url)</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">auth</span><span class="params">(ApiRequest apiRequest)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultApiAuthenticatorImpl</span> <span class="keyword">implements</span> <span class="title class_">ApiAuthenticator</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> CredentialStorage credentialStorage;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">DefaultApiAuthenticatorImpl</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.credentialStorage = <span class="keyword">new</span> <span class="title class_">MysqlCredentialStorage</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">DefaultApiAuthenticatorImpl</span><span class="params">(CredentialStorage credentialStorage)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.credentialStorage = credentialStorage;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">auth</span><span class="params">(String url)</span> &#123;</span><br><span class="line">    <span class="type">ApiRequest</span> <span class="variable">apiRequest</span> <span class="operator">=</span> ApiRequest.buildFromUrl(url);</span><br><span class="line">    auth(apiRequest);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">auth</span><span class="params">(ApiRequest apiRequest)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">appId</span> <span class="operator">=</span> apiRequest.getAppId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> apiRequest.getToken();</span><br><span class="line">    <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> apiRequest.getTimestamp();</span><br><span class="line">    <span class="type">String</span> <span class="variable">originalUrl</span> <span class="operator">=</span> apiRequest.getOriginalUrl();</span><br><span class="line"></span><br><span class="line">    <span class="type">AuthToken</span> <span class="variable">clientAuthToken</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AuthToken</span>(token, timestamp);</span><br><span class="line">    <span class="keyword">if</span> (clientAuthToken.isExpired()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Token is expired.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> credentialStorage.getPasswordByAppId(appId);</span><br><span class="line">    <span class="type">AuthToken</span> <span class="variable">serverAuthToken</span> <span class="operator">=</span> AuthToken.generate(originalUrl, appId, password, timestamp);</span><br><span class="line">    <span class="keyword">if</span> (!serverAuthToken.match(clientAuthToken)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Token verfication failed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>辩证思考与灵活应用</strong></p>
<p>在之前的讲解中，面向对象分析、设计、实现，每个环节的界限划分都比较清楚。而且，设计和实现基本上是按照功能点的描述，逐句照着翻译过来的。这样做的好处是先做什么、后做什么，非常清晰、明确，有章可循，即便是没有太多设计经验的初级工程师，都可以按部就班地参照着这个流程来做分析、设计和实现。</p>
<p>不过，在平时的工作中，大部分程序员往往都是在脑子里或者草纸上完成面向对象分析和设计，然后就开始写代码了，边写边思考边重构，并不会严格地按照刚刚的流程来执行。而且，说实话，即便我们在写代码之前，花很多时间做分析和设计，绘制出完美的类图、UML图，也不可能把每个细节、交互都想得很清楚。在落实到代码的时候，我们还是要反复迭代、重构、打破重写。</p>
<p>毕竟，整个软件开发本来就是一个迭代、修修补补、遇到问题解决问题的过程，是一个不断重构的过程。我们没法严格地按照顺序执行各个步骤。这就类似你去学驾照，驾校教的都是比较正规的流程，先做什么，后做什么，你只要照着做就能顺利倒车入库，但实际上，等你开熟练了，倒车入库很多时候靠的都是经验和感觉。</p>
<h3 id="13-SOLID：单一职责原则"><a href="#13-SOLID：单一职责原则" class="headerlink" title="13. SOLID：单一职责原则"></a>13. SOLID：单一职责原则</h3><p><strong>如何理解单一职责原则（SRP）？</strong></p>
<p>文章的开头我们提到了SOLID原则，实际上，SOLID原则并非单纯的1个原则，而是由5个设计原则组成的，它们分别是：单一职责原则、开闭原则、里式替换原则、接口隔离原则和依赖反转原则，依次对应SOLID中的S、O、L、I、D这5个英文字母。我们今天要学习的是SOLID原则中的第一个原则：单一职责原则。</p>
<p>单一职责原则的英文是Single Responsibility Principle，缩写为SRP。这个原则的英文描述是这样的：A class or module should have a single responsibility。如果我们把它翻译成中文，那就是：<u>一个类或者模块只负责完成一个职责（或者功能）</u>。</p>
<p>注意，这个原则描述的对象包含两个，一个是类（class），一个是模块（module）。关于这两个概念，在专栏中，有两种理解方式。一种理解是：把模块看作比类更加抽象的概念，类也可以看作模块。另一种理解是：把模块看作比类更加粗粒度的代码块，模块中包含多个类，多个类组成一个模块。</p>
<p>不管哪种理解方式，单一职责原则在应用到这两个描述对象的时候，道理都是相通的。为了方便你理解，接下来我只从“类”设计的角度，来讲解如何应用这个设计原则。对于“模块”来说，你可以自行引申。</p>
<p>单一职责原则的定义描述非常简单，也不难理解。一个类只负责完成一个职责或者功能。也就是说，不要设计大而全的类，要设计粒度小、功能单一的类。换个角度来讲就是，一个类包含了两个或者两个以上业务不相干的功能，那我们就说它职责不够单一，应该将它拆分成多个功能更加单一、粒度更细的类。</p>
<p>我举一个例子来解释一下。比如，一个类里既包含订单的一些操作，又包含用户的一些操作。而订单和用户是两个独立的业务领域模型，我们将两个不相干的功能放到同一个类中，那就违反了单一职责原则。为了满足单一职责原则，我们需要将这个类拆分成两个粒度更细、功能更加单一的两个类：订单类和用户类。</p>
<p><strong>如何判断类的职责是否足够单一？</strong></p>
<p>从刚刚这个例子来看，单一职责原则看似不难应用。那是因为我举的这个例子比较极端，一眼就能看出订单和用户毫不相干。但大部分情况下，类里的方法是归为同一类功能，还是归为不相关的两类功能，并不是那么容易判定的。在真实的软件开发中，对于一个类是否职责单一的判定，是很难拿捏的。我举一个更加贴近实际的例子来给你解释一下。</p>
<p>在一个社交产品中，我们用下面的UserInfo类来记录用户的信息。你觉得，UserInfo类的设计是否满足单一职责原则呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInfo</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> userId;</span><br><span class="line">  <span class="keyword">private</span> String username;</span><br><span class="line">  <span class="keyword">private</span> String email;</span><br><span class="line">  <span class="keyword">private</span> String telephone;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> createTime;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> lastLoginTime;</span><br><span class="line">  <span class="keyword">private</span> String avatarUrl;</span><br><span class="line">  <span class="keyword">private</span> String provinceOfAddress; <span class="comment">// 省</span></span><br><span class="line">  <span class="keyword">private</span> String cityOfAddress; <span class="comment">// 市</span></span><br><span class="line">  <span class="keyword">private</span> String regionOfAddress; <span class="comment">// 区 </span></span><br><span class="line">  <span class="keyword">private</span> String detailedAddress; <span class="comment">// 详细地址</span></span><br><span class="line">  <span class="comment">// ...省略其他属性和方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于这个问题，有两种不同的观点。一种观点是，UserInfo类包含的都是跟用户相关的信息，所有的属性和方法都隶属于用户这样一个业务模型，满足单一职责原则；另一种观点是，地址信息在UserInfo类中，所占的比重比较高，可以继续拆分成独立的UserAddress类，UserInfo只保留除Address之外的其他信息，拆分之后的两个类的职责更加单一。</p>
<p>哪种观点更对呢？实际上，要从中做出选择，我们不能脱离具体的应用场景。如果在这个社交产品中，用户的地址信息跟其他信息一样，只是单纯地用来展示，那UserInfo现在的设计就是合理的。但是，如果这个社交产品发展得比较好，之后又在产品中添加了电商的模块，用户的地址信息还会用在电商物流中，那我们最好将地址信息从UserInfo中拆分出来，独立成用户物流信息（或者叫地址信息、收货信息等）。</p>
<p>我们再进一步延伸一下。如果做这个社交产品的公司发展得越来越好，公司内部又开发出了很多其他产品（可以理解为其他App）。公司希望支持统一账号系统，也就是用户一个账号可以在公司内部的所有产品中登录。这个时候，我们就需要继续对UserInfo进行拆分，将跟身份认证相关的信息（比如，email、telephone等）抽取成独立的类。</p>
<p>从刚刚这个例子，我们可以总结出，<u>不同的应用场景、不同阶段的需求背景下，对同一个类的职责是否单一的判定，可能都是不一样的</u>。在某种应用场景或者当下的需求背景下，一个类的设计可能已经满足单一职责原则了，但如果换个应用场景或着在未来的某个需求背景下，可能就不满足了，需要继续拆分成粒度更细的类。</p>
<p>除此之外，从不同的业务层面去看待同一个类的设计，对类是否职责单一，也会有不同的认识。比如，例子中的UserInfo类。如果我们从“用户”这个业务层面来看，UserInfo包含的信息都属于用户，满足职责单一原则。如果我们从更加细分的“用户展示信息”“地址信息”“登录认证信息”等等这些更细粒度的业务层面来看，那UserInfo就应该继续拆分。</p>
<p>综上所述，评价一个类的职责是否足够单一，我们并没有一个非常明确的、可以量化的标准，可以说，这是件非常主观、仁者见仁智者见智的事情。实际上，在真正的软件开发中，我们也没必要过于未雨绸缪，过度设计。所以，<strong>我们可以先写一个粗粒度的类，满足业务需求。随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候，我们就可以将这个粗粒度的类，拆分成几个更细粒度的类。这就是所谓的持续重构</strong>（后面的章节中我们会讲到）。</p>
<p>听到这里，你可能会说，这个原则如此含糊不清、模棱两可，到底该如何拿捏才好啊？我这里还有一些小技巧，能够很好地帮你，从侧面上判定一个类的职责是否够单一。而且，我个人觉得，下面这几条判断原则，比起很主观地去思考类是否职责单一，要更有指导意义、更具有可执行性：</p>
<ul>
<li><u>类中的代码行数、函数或属性过多</u>，会影响代码的可读性和可维护性，我们就需要考虑对类进行拆分；</li>
<li><u>类依赖的其他类过多</u>，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，我们就需要考虑对类进行拆分；</li>
<li><u>私有方法过多</u>，我们就要考虑能否将私有方法独立到新的类中，设置为public方法，供更多的类使用，从而提高代码的复用性；</li>
<li><u>比较难给类起一个合适名字</u>，很难用一个业务名词概括，或者只能用一些笼统的Manager、Context之类的词语来命名，这就说明类的职责定义得可能不够清晰；</li>
<li><u>类中大量的方法都是集中操作类中的某几个属性</u>，比如，在UserInfo例子中，如果一半的方法都是在操作address信息，那就可以考虑将这几个属性和对应的方法拆分出来。</li>
</ul>
<p>不过，你可能还会有这样的疑问：在上面的判定原则中，我提到类中的代码行数、函数或者属性过多，就有可能不满足单一职责原则。那多少行代码才算是行数过多呢？多少个函数、属性才称得上过多呢？</p>
<p>比较初级的工程师经常会问这类问题。实际上，这个问题并不好定量地回答，就像你问大厨“放盐少许”中的“少许”是多少，大厨也很难告诉你一个特别具体的量值。</p>
<p>如果继续深究一下的话，你可能还会说，一些菜谱确实给出了，做某某菜需要放多少克盐，放多少克油的具体量值啊。我想说的是，那是给家庭主妇用的，那不是给专业的大厨看的。类比一下做饭，如果你是没有太多项目经验的编程初学者，实际上，我也可以给你一个凑活能用、比较宽泛的、可量化的标准，那就是一个类的代码行数最好不能超过200行，函数个数及属性个数都最好不要超过10个。</p>
<p>实际上， 从另一个角度来看，当一个类的代码，读起来让你头大了，实现某个功能时不知道该用哪个函数了，想用哪个函数翻半天都找不到了，只用到一个小功能要引入整个类（类中包含很多无关此功能实现的函数）的时候，这就说明类的行数、函数、属性过多了。实际上，等你做多项目了，代码写多了，在开发中慢慢“品尝”，自然就知道什么是“放盐少许”了，这就是所谓的“专业第六感”。</p>
<p><strong>类的职责是否设计得越单一越好？</strong></p>
<p>为了满足单一职责原则，是不是把类拆得越细就越好呢？答案是否定的。我们还是通过一个例子来解释一下。Serialization类实现了一个简单协议的序列化和反序列功能，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Protocol format: identifier-string;&#123;gson string&#125;</span></span><br><span class="line"><span class="comment"> * For example: UEUEUE;&#123;&quot;a&quot;:&quot;A&quot;,&quot;b&quot;:&quot;B&quot;&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Serialization</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">IDENTIFIER_STRING</span> <span class="operator">=</span> <span class="string">&quot;UEUEUE;&quot;</span>;</span><br><span class="line">  <span class="keyword">private</span> Gson gson;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Serialization</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.gson = <span class="keyword">new</span> <span class="title class_">Gson</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(Map&lt;String, String&gt; object)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">textBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    textBuilder.append(IDENTIFIER_STRING);</span><br><span class="line">    textBuilder.append(gson.toJson(object));</span><br><span class="line">    <span class="keyword">return</span> textBuilder.toString();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> Map&lt;String, String&gt; <span class="title function_">deserialize</span><span class="params">(String text)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!text.startsWith(IDENTIFIER_STRING)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyMap();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">gsonStr</span> <span class="operator">=</span> text.substring(IDENTIFIER_STRING.length());</span><br><span class="line">    <span class="keyword">return</span> gson.fromJson(gsonStr, Map.class);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们想让类的职责更加单一，我们对Serialization类进一步拆分，拆分成一个只负责序列化工作的Serializer类和另一个只负责反序列化工作的Deserializer类。拆分后的具体代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Serializer</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">IDENTIFIER_STRING</span> <span class="operator">=</span> <span class="string">&quot;UEUEUE;&quot;</span>;</span><br><span class="line">  <span class="keyword">private</span> Gson gson;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Serializer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.gson = <span class="keyword">new</span> <span class="title class_">Gson</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(Map&lt;String, String&gt; object)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">textBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    textBuilder.append(IDENTIFIER_STRING);</span><br><span class="line">    textBuilder.append(gson.toJson(object));</span><br><span class="line">    <span class="keyword">return</span> textBuilder.toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Deserializer</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">IDENTIFIER_STRING</span> <span class="operator">=</span> <span class="string">&quot;UEUEUE;&quot;</span>;</span><br><span class="line">  <span class="keyword">private</span> Gson gson;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Deserializer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.gson = <span class="keyword">new</span> <span class="title class_">Gson</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> Map&lt;String, String&gt; <span class="title function_">deserialize</span><span class="params">(String text)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!text.startsWith(IDENTIFIER_STRING)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyMap();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">gsonStr</span> <span class="operator">=</span> text.substring(IDENTIFIER_STRING.length());</span><br><span class="line">    <span class="keyword">return</span> gson.fromJson(gsonStr, Map.class);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然经过拆分之后，Serializer类和Deserializer类的职责更加单一了，但也随之带来了新的问题。如果我们修改了协议的格式，数据标识从“UEUEUE”改为“DFDFDF”，或者序列化方式从JSON改为了XML，那Serializer类和Deserializer类都需要做相应的修改，代码的内聚性显然没有原来Serialization高了。而且，如果我们仅仅对Serializer类做了协议修改，而忘记了修改Deserializer类的代码，那就会导致序列化、反序列化不匹配，程序运行出错，也就是说，拆分之后，代码的可维护性变差了。</p>
<p>实际上，不管是应用设计原则还是设计模式，最终的目的还是提高代码的可读性、可扩展性、复用性、可维护性等。我们在考虑应用某一个设计原则是否合理的时候，也可以以此作为最终的考量标准。</p>
<h3 id="14-SOLID：开闭原则"><a href="#14-SOLID：开闭原则" class="headerlink" title="14. SOLID：开闭原则"></a>14. SOLID：开闭原则</h3><p>个人觉得，开闭原则是SOLID中最难理解、最难掌握，同时也是最有用的一条原则。</p>
<p>之所以说这条原则难理解，那是因为，“怎样的代码改动才被定义为‘扩展’？怎样的代码改动才被定义为‘修改’？怎么才算满足或违反‘开闭原则’？修改代码就一定意味着违反‘开闭原则’吗？”等等这些问题，都比较难理解。</p>
<p>之所以说这条原则难掌握，那是因为，“如何做到‘对扩展开放、修改关闭’？如何在项目中灵活地应用‘开闭原则’，以避免在追求扩展性的同时影响到代码的可读性？”等等这些问题，都比较难掌握。</p>
<p>之所以说这条原则最有用，那是因为，扩展性是代码质量最重要的衡量标准之一。在23种经典设计模式中，大部分设计模式都是为了解决代码的扩展性问题而存在的，主要遵从的设计原则就是开闭原则。</p>
<p><strong>如何理解“对扩展开放、修改关闭”？</strong></p>
<p>开闭原则的英文全称是Open Closed Principle，简写为OCP。它的英文描述是：software entities (modules, classes, functions, etc.) should be open for extension , but closed for modification。我们把它翻译成中文就是：软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。</p>
<p>这个描述比较简略，如果我们详细表述一下，那就是，添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）。</p>
<p>为了让你更好地理解这个原则，我举一个例子来进一步解释一下。这是一段API接口监控告警的代码。</p>
<p>其中，AlertRule存储告警规则，可以自由设置。Notification是告警通知类，支持邮件、短信、微信、手机等多种通知渠道。NotificationEmergencyLevel表示通知的紧急程度，包括SEVERE（严重）、URGENCY（紧急）、NORMAL（普通）、TRIVIAL（无关紧要），不同的紧急程度对应不同的发送渠道。关于API接口监控告警这部分，更加详细的业务需求分析和设计，我们会在后面的设计模式模块再拿出来进一步讲解，这里你只要简单知道这些，就够我们今天用了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Alert</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> AlertRule rule;</span><br><span class="line">  <span class="keyword">private</span> Notification notification;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Alert</span><span class="params">(AlertRule rule, Notification notification)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.rule = rule;</span><br><span class="line">    <span class="built_in">this</span>.notification = notification;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">(String api, <span class="type">long</span> requestCount, <span class="type">long</span> errorCount, <span class="type">long</span> durationOfSeconds)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">tps</span> <span class="operator">=</span> requestCount / durationOfSeconds;</span><br><span class="line">    <span class="keyword">if</span> (tps &gt; rule.getMatchedRule(api).getMaxTps()) &#123;</span><br><span class="line">      notification.notify(NotificationEmergencyLevel.URGENCY, <span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (errorCount &gt; rule.getMatchedRule(api).getMaxErrorCount()) &#123;</span><br><span class="line">      notification.notify(NotificationEmergencyLevel.SEVERE, <span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码非常简单，业务逻辑主要集中在check()函数中。当接口的TPS（Transactions Per Second，每秒传输的事物处理个数）超过某个预先设置的最大值时，以及当接口请求出错数大于某个最大允许值时，就会触发告警，通知接口的相关负责人或者团队。</p>
<p>现在，如果我们需要添加一个功能，当每秒钟接口超时请求个数，超过某个预先设置的最大阈值时，我们也要触发告警发送通知。这个时候，我们该如何改动代码呢？主要的改动有两处：第一处是修改check()函数的入参，添加一个新的统计数据timeoutCount，表示超时接口请求数；第二处是在check()函数中添加新的告警逻辑。具体的代码改动如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Alert</span> &#123;</span><br><span class="line">  <span class="comment">// ...省略AlertRule/Notification属性和构造函数...</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 改动一：添加参数timeoutCount</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">(String api, <span class="type">long</span> requestCount, <span class="type">long</span> errorCount, <span class="type">long</span> timeoutCount, <span class="type">long</span> durationOfSeconds)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">tps</span> <span class="operator">=</span> requestCount / durationOfSeconds;</span><br><span class="line">    <span class="keyword">if</span> (tps &gt; rule.getMatchedRule(api).getMaxTps()) &#123;</span><br><span class="line">      notification.notify(NotificationEmergencyLevel.URGENCY, <span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (errorCount &gt; rule.getMatchedRule(api).getMaxErrorCount()) &#123;</span><br><span class="line">      notification.notify(NotificationEmergencyLevel.SEVERE, <span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 改动二：添加接口超时处理逻辑</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">timeoutTps</span> <span class="operator">=</span> timeoutCount / durationOfSeconds;</span><br><span class="line">    <span class="keyword">if</span> (timeoutTps &gt; rule.getMatchedRule(api).getMaxTimeoutTps()) &#123;</span><br><span class="line">      notification.notify(NotificationEmergencyLevel.URGENCY, <span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的代码修改实际上存在挺多问题的。一方面，<u>我们对接口进行了修改，这就意味着调用这个接口的代码都要做相应的修改</u>。另一方面，修改了check()函数，相应的单元测试都需要修改（关于单元测试的内容我们在重构那部分会详细介绍）。</p>
<p>上面的代码改动是基于“修改”的方式来实现新功能的。如果我们遵循开闭原则，也就是“对扩展开放、对修改关闭”。那如何通过“扩展”的方式，来实现同样的功能呢？</p>
<p>我们先重构一下之前的Alert代码，让它的扩展性更好一些。重构的内容主要包含两部分：</p>
<ul>
<li>第一部分是<u>将check()函数的多个入参封装成ApiStatInfo类</u>；</li>
<li>第二部分是<u>引入handler的概念，将if判断逻辑分散在各个handler中</u>。</li>
</ul>
<p>具体的代码实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Alert</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> List&lt;AlertHandler&gt; alertHandlers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAlertHandler</span><span class="params">(AlertHandler alertHandler)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.alertHandlers.add(alertHandler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">(ApiStatInfo apiStatInfo)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (AlertHandler handler : alertHandlers) &#123;</span><br><span class="line">      handler.check(apiStatInfo);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiStatInfo</span> &#123;<span class="comment">//省略constructor/getter/setter方法</span></span><br><span class="line">  <span class="keyword">private</span> String api;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> requestCount;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> errorCount;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> durationOfSeconds;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AlertHandler</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> AlertRule rule;</span><br><span class="line">  <span class="keyword">protected</span> Notification notification;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">AlertHandler</span><span class="params">(AlertRule rule, Notification notification)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.rule = rule;</span><br><span class="line">    <span class="built_in">this</span>.notification = notification;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">(ApiStatInfo apiStatInfo)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TpsAlertHandler</span> <span class="keyword">extends</span> <span class="title class_">AlertHandler</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">TpsAlertHandler</span><span class="params">(AlertRule rule, Notification notification)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(rule, notification);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">(ApiStatInfo apiStatInfo)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">tps</span> <span class="operator">=</span> apiStatInfo.getRequestCount()/ apiStatInfo.getDurationOfSeconds();</span><br><span class="line">    <span class="keyword">if</span> (tps &gt; rule.getMatchedRule(apiStatInfo.getApi()).getMaxTps()) &#123;</span><br><span class="line">      notification.notify(NotificationEmergencyLevel.URGENCY, <span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorAlertHandler</span> <span class="keyword">extends</span> <span class="title class_">AlertHandler</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ErrorAlertHandler</span><span class="params">(AlertRule rule, Notification notification)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>(rule, notification);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">(ApiStatInfo apiStatInfo)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (apiStatInfo.getErrorCount() &gt; rule.getMatchedRule(apiStatInfo.getApi()).getMaxErrorCount()) &#123;</span><br><span class="line">      notification.notify(NotificationEmergencyLevel.SEVERE, <span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码是对Alert的重构，我们再来看下，重构之后的Alert该如何使用呢？具体的使用代码我也写在这里了。</p>
<p>其中，ApplicationContext是一个单例类，负责Alert的创建、组装（alertRule和notification的依赖注入）、初始化（添加handlers）工作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContext</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> AlertRule alertRule;</span><br><span class="line">  <span class="keyword">private</span> Notification notification;</span><br><span class="line">  <span class="keyword">private</span> Alert alert;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initializeBeans</span><span class="params">()</span> &#123;</span><br><span class="line">    alertRule = <span class="keyword">new</span> <span class="title class_">AlertRule</span>(<span class="comment">/*.省略参数.*/</span>); <span class="comment">//省略一些初始化代码</span></span><br><span class="line">    notification = <span class="keyword">new</span> <span class="title class_">Notification</span>(<span class="comment">/*.省略参数.*/</span>); <span class="comment">//省略一些初始化代码</span></span><br><span class="line">    alert = <span class="keyword">new</span> <span class="title class_">Alert</span>();</span><br><span class="line">    alert.addAlertHandler(<span class="keyword">new</span> <span class="title class_">TpsAlertHandler</span>(alertRule, notification));</span><br><span class="line">    alert.addAlertHandler(<span class="keyword">new</span> <span class="title class_">ErrorAlertHandler</span>(alertRule, notification));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> Alert <span class="title function_">getAlert</span><span class="params">()</span> &#123; <span class="keyword">return</span> alert; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 饿汉式单例</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ApplicationContext</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApplicationContext</span>();</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">ApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">    initializeBeans();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> ApplicationContext <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ApiStatInfo</span> <span class="variable">apiStatInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApiStatInfo</span>();</span><br><span class="line">    <span class="comment">// ...省略设置apiStatInfo数据值的代码</span></span><br><span class="line">    ApplicationContext.getInstance().getAlert().check(apiStatInfo);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们再来看下，基于重构之后的代码，如果再添加上面讲到的那个新功能，每秒钟接口超时请求个数超过某个最大阈值就告警，我们又该如何改动代码呢？主要的改动有下面四处。</p>
<ul>
<li>第一处改动是：在ApiStatInfo类中添加新的属性timeoutCount。</li>
<li>第二处改动是：添加新的TimeoutAlertHander类。</li>
<li>第三处改动是：在ApplicationContext类的initializeBeans()方法中，往alert对象中注册新的timeoutAlertHandler。</li>
<li>第四处改动是：在使用Alert类的时候，需要给check()函数的入参apiStatInfo对象设置timeoutCount的值。</li>
</ul>
<p>改动之后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Alert</span> &#123; <span class="comment">// 代码未改动... &#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiStatInfo</span> &#123;<span class="comment">//省略constructor/getter/setter方法</span></span><br><span class="line">  <span class="keyword">private</span> String api;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> requestCount;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> errorCount;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> durationOfSeconds;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> timeoutCount; <span class="comment">// 改动一：添加新字段</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AlertHandler</span> &#123; <span class="comment">//代码未改动... &#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TpsAlertHandler</span> <span class="keyword">extends</span> <span class="title class_">AlertHandler</span> &#123;<span class="comment">//代码未改动...&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorAlertHandler</span> <span class="keyword">extends</span> <span class="title class_">AlertHandler</span> &#123;<span class="comment">//代码未改动...&#125;</span></span><br><span class="line"><span class="comment">// 改动二：添加新的handler</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeoutAlertHandler</span> <span class="keyword">extends</span> <span class="title class_">AlertHandler</span> &#123;<span class="comment">//省略代码...&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContext</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> AlertRule alertRule;</span><br><span class="line">  <span class="keyword">private</span> Notification notification;</span><br><span class="line">  <span class="keyword">private</span> Alert alert;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initializeBeans</span><span class="params">()</span> &#123;</span><br><span class="line">    alertRule = <span class="keyword">new</span> <span class="title class_">AlertRule</span>(<span class="comment">/*.省略参数.*/</span>); <span class="comment">//省略一些初始化代码</span></span><br><span class="line">    notification = <span class="keyword">new</span> <span class="title class_">Notification</span>(<span class="comment">/*.省略参数.*/</span>); <span class="comment">//省略一些初始化代码</span></span><br><span class="line">    alert = <span class="keyword">new</span> <span class="title class_">Alert</span>();</span><br><span class="line">    alert.addAlertHandler(<span class="keyword">new</span> <span class="title class_">TpsAlertHandler</span>(alertRule, notification));</span><br><span class="line">    alert.addAlertHandler(<span class="keyword">new</span> <span class="title class_">ErrorAlertHandler</span>(alertRule, notification));</span><br><span class="line">    <span class="comment">// 改动三：注册handler</span></span><br><span class="line">    alert.addAlertHandler(<span class="keyword">new</span> <span class="title class_">TimeoutAlertHandler</span>(alertRule, notification));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...省略其他未改动代码...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ApiStatInfo</span> <span class="variable">apiStatInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApiStatInfo</span>();</span><br><span class="line">    <span class="comment">// ...省略apiStatInfo的set字段代码</span></span><br><span class="line">    apiStatInfo.setTimeoutCount(<span class="number">289</span>); <span class="comment">// 改动四：设置tiemoutCount值</span></span><br><span class="line">    ApplicationContext.getInstance().getAlert().check(apiStatInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重构之后的代码更加灵活和易扩展。如果我们要想添加新的告警逻辑，只需要基于扩展的方式创建新的handler类即可，不需要改动原来的check()函数的逻辑。而且，我们只需要为新的handler类添加单元测试，老的单元测试都不会失败，也不用修改。</p>
<p><strong>修改代码就意味着违背开闭原则吗？</strong></p>
<p>看了上面重构之后的代码，你可能还会有疑问：在添加新的告警逻辑的时候，尽管改动二（添加新的handler类）是基于扩展而非修改的方式来完成的，但改动一、三、四貌似不是基于扩展而是基于修改的方式来完成的，那改动一、三、四不就违背了开闭原则吗？</p>
<p><strong>我们先来分析一下改动一：往ApiStatInfo类中添加新的属性timeoutCount。</strong></p>
<p>实际上，我们不仅往ApiStatInfo类中添加了属性，还添加了对应的getter&#x2F;setter方法。那这个问题就转化为：给类中添加新的属性和方法，算作“修改”还是“扩展”？</p>
<p>我们再一块回忆一下开闭原则的定义：软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。从定义中，我们可以看出，开闭原则可以应用在不同粒度的代码中，可以是模块，也可以类，还可以是方法（及其属性）。同样一个代码改动，在粗代码粒度下，被认定为“修改”，在细代码粒度下，又可以被认定为“扩展”。比如，改动一，添加属性和方法相当于修改类，在类这个层面，这个代码改动可以被认定为“修改”；但这个代码改动并没有修改已有的属性和方法，在方法（及其属性）这一层面，它又可以被认定为“扩展”。</p>
<p>实际上，我们也没必要纠结某个代码改动是“修改”还是“扩展”，更没必要太纠结它是否违反“开闭原则”。我们回到这条原则的设计初衷：只要它没有破坏原有的代码的正常运行，没有破坏原有的单元测试，我们就可以说，这是一个合格的代码改动。</p>
<p><strong>我们再来分析一下改动三和改动四：在ApplicationContext类的initializeBeans()方法中，往alert对象中注册新的timeoutAlertHandler；在使用Alert类的时候，需要给check()函数的入参apiStatInfo对象设置timeoutCount的值。</strong></p>
<p>这两处改动都是在方法内部进行的，不管从哪个层面（模块、类、方法）来讲，都不能算是“扩展”，而是地地道道的“修改”。不过，有些修改是在所难免的，是可以被接受的。为什么这么说呢？我来解释一下。</p>
<p>在重构之后的Alert代码中，我们的核心逻辑集中在Alert类及其各个handler中，当我们在添加新的告警逻辑的时候，Alert类完全不需要修改，而只需要扩展一个新handler类。如果我们把Alert类及各个handler类合起来看作一个“模块”，那模块本身在添加新的功能的时候，完全满足开闭原则。</p>
<p>而且，我们要认识到，添加一个新功能，不可能任何模块、类、方法的代码都不“修改”，这个是做不到的。类需要创建、组装、并且做一些初始化操作，才能构建成可运行的的程序，这部分代码的修改是在所难免的。我们要做的是尽量让修改操作更集中、更少、更上层，尽量让最核心、最复杂的那部分逻辑代码满足开闭原则。</p>
<p><strong>如何做到“对扩展开放、修改关闭”？</strong></p>
<p>在刚刚的例子中，我们通过引入一组handler的方式来实现支持开闭原则。如果你没有太多复杂代码的设计和开发经验，你可能会有这样的疑问：这样的代码设计思路我怎么想不到呢？你是怎么想到的呢？</p>
<p>先给你个结论，之所以我能想到，靠的就是理论知识和实战经验，这些需要你慢慢学习和积累。对于如何做到“对扩展开放、修改关闭”，我们也有一些指导思想和具体的方法论，我们一块来看一下。</p>
<p>实际上，开闭原则讲的就是代码的扩展性问题，是判断一段代码是否易扩展的“金标准”。如果某段代码在应对未来需求变化的时候，能够做到“对扩展开放、对修改关闭”，那就说明这段代码的扩展性比较好。所以，问如何才能做到“对扩展开放、对修改关闭”，也就粗略地等同于在问，如何才能写出扩展性好的代码。</p>
<p><strong>在讲具体的方法论之前，我们先来看一些更加偏向顶层的指导思想。为了尽量写出扩展性好的代码，我们要时刻具备扩展意识、抽象意识、封装意识。这些“潜意识”可能比任何开发技巧都重要。</strong></p>
<p>在写代码的时候后，我们要多花点时间往前多思考一下，这段代码未来可能有哪些需求变更、如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，不需要改动代码整体结构、做到最小代码改动的情况下，新的代码能够很灵活地插入到扩展点上，做到“对扩展开放、对修改关闭”。</p>
<p>还有，在识别出代码可变部分和不可变部分之后，我们要将可变部分封装起来，隔离变化，提供抽象化的不可变接口，给上层系统使用。当具体的实现发生变化的时候，我们只需要基于相同的抽象接口，扩展一个新的实现，替换掉老的实现即可，上游系统的代码几乎不需要修改。</p>
<p><strong>刚刚我们讲了实现开闭原则的一些偏向顶层的指导思想，现在我们再来看下，支持开闭原则的一些更加具体的方法论。</strong></p>
<p>我们前面讲到，代码的扩展性是代码质量评判的最重要的标准之一。实际上，我们整个专栏的大部分知识点都是围绕扩展性问题来讲解的。专栏中讲到的很多设计原则、设计思想、设计模式，都是以提高代码的扩展性为最终目的的。特别是23种经典设计模式，大部分都是为了解决代码的扩展性问题而总结出来的，都是以开闭原则为指导原则的。</p>
<p>在众多的设计原则、思想、模式中，<u>最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态等）。</u>设计模式这一部分内容比较多，后面课程中我们能会详细讲到，这里就不展开了。今天我重点讲一下，如何利用多态、依赖注入、基于接口而非实现编程，来实现“对扩展开放、对修改关闭”。</p>
<p>实际上，多态、依赖注入、基于接口而非实现编程，以及前面提到的抽象意识，说的都是同一种设计思路，只是从不同的角度、不同的层面来阐述而已。这也体现了“很多设计原则、思想、模式都是相通的”这一思想。</p>
<p>接下来，我就通过一个例子来解释一下，如何利用这几个设计思想或原则来实现“对扩展开放、对修改关闭”。注意，依赖注入后面会讲到，如果你对这块不了解，可以暂时先忽略这个概念，只关注多态、基于接口而非实现编程以及抽象意识。</p>
<p>比如，我们代码中通过Kafka来发送异步消息。对于这样一个功能的开发，我们要学会将其抽象成一组跟具体消息队列（Kafka）无关的异步消息接口。所有上层系统都依赖这组抽象的接口编程，并且通过依赖注入的方式来调用。当我们要替换新的消息队列的时候，比如将Kafka替换成RocketMQ，可以很方便地拔掉老的消息队列实现，插入新的消息队列实现。具体代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这一部分体现了抽象意识</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MessageQueue</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaMessageQueue</span> <span class="keyword">implements</span> <span class="title class_">MessageQueue</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RocketMQMessageQueue</span> <span class="keyword">implements</span> <span class="title class_">MessageQueue</span> &#123;<span class="comment">//...&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MessageFromatter</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JsonMessageFromatter</span> <span class="keyword">implements</span> <span class="title class_">MessageFromatter</span> &#123;<span class="comment">//...&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProtoBufMessageFromatter</span> <span class="keyword">implements</span> <span class="title class_">MessageFromatter</span> &#123;<span class="comment">//...&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> MessageQueue msgQueue; <span class="comment">// 基于接口而非实现编程</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Demo</span><span class="params">(MessageQueue msgQueue)</span> &#123; <span class="comment">// 依赖注入</span></span><br><span class="line">    <span class="built_in">this</span>.msgQueue = msgQueue;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// msgFormatter：多态、依赖注入</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendNotification</span><span class="params">(Notification notification, MessageFormatter msgFormatter)</span> &#123;</span><br><span class="line">    <span class="comment">//...    </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于如何写出扩展性好的代码、如何实现“对扩展开放、对修改关闭”这个问题，我今天只是比较笼统地总结了一下，详细的知识我们在后面的章节中慢慢学习。</p>
<p><strong>如何在项目中灵活应用开闭原则？</strong></p>
<p>前面我们提到，写出支持“对扩展开放、对修改关闭”的代码的关键是预留扩展点。那问题是如何才能识别出所有可能的扩展点呢？</p>
<p>如果你开发的是一个业务导向的系统，比如金融系统、电商系统、物流系统等，要想识别出尽可能多的扩展点，就要对业务有足够的了解，能够知道当下以及未来可能要支持的业务需求。如果你开发的是跟业务无关的、通用的、偏底层的系统，比如，框架、组件、类库，你需要了解“它们会被如何使用？今后你打算添加哪些功能？使用者未来会有哪些更多的功能需求？”等问题。</p>
<p>不过，有一句话说得好，“唯一不变的只有变化本身”。即便我们对业务、对系统有足够的了解，那也不可能识别出所有的扩展点，即便你能识别出所有的扩展点，为这些地方都预留扩展点，这样做的成本也是不可接受的。我们没必要为一些遥远的、不一定发生的需求去提前买单，做过度设计。</p>
<p>最合理的做法是，对于一些比较确定的、短期内可能就会扩展，或者需求改动对代码结构影响比较大的情况，或者实现成本不高的扩展点，在编写代码的时候之后，我们就可以事先做些扩展性设计。但对于一些不确定未来是否要支持的需求，或者实现起来比较复杂的扩展点，我们可以等到有需求驱动的时候，再通过重构代码的方式来支持扩展的需求。</p>
<p>而且，开闭原则也并不是免费的。有些情况下，代码的扩展性会跟可读性相冲突。比如，我们之前举的Alert告警的例子。为了更好地支持扩展性，我们对代码进行了重构，重构之后的代码要比之前的代码复杂很多，理解起来也更加有难度。很多时候，我们都需要在扩展性和可读性之间做权衡。在某些场景下，代码的扩展性很重要，我们就可以适当地牺牲一些代码的可读性；在另一些场景下，代码的可读性更加重要，那我们就适当地牺牲一些代码的可扩展性。</p>
<p>在我们之前举的Alert告警的例子中，如果告警规则并不是很多、也不复杂，那check()函数中的if语句就不会很多，代码逻辑也不复杂，代码行数也不多，那最初的第一种代码实现思路简单易读，就是比较合理的选择。相反，如果告警规则很多、很复杂，check()函数的if语句、代码逻辑就会很多、很复杂，相应的代码行数也会很多，可读性、可维护性就会变差，那重构之后的第二种代码实现思路就是更加合理的选择了。总之，这里没有一个放之四海而皆准的参考标准，全凭实际的应用场景来决定。</p>
<h3 id="15-SOLID：里式替换原则"><a href="#15-SOLID：里式替换原则" class="headerlink" title="15. SOLID：里式替换原则"></a>15. SOLID：里式替换原则</h3><p>主要通过几个反例，带你看看，哪些代码是违反里式替换原则的？我们该如何将它们改造成满足里式替换原则？除此之外，这条原则从定义上看起来，跟我们之前讲过的“多态”有点类似。所以，我今天也会讲一下，它跟多态的区别。</p>
<p><strong>如何理解“里式替换原则”？</strong></p>
<p>里式替换原则的英文翻译是：Liskov Substitution Principle，缩写为LSP。这个原则最早是在1986年由Barbara Liskov提出，他是这么描述这条原则的：</p>
<blockquote>
<p>If S is a subtype of T, then objects of type T may be replaced with objects of type S, without breaking the program。</p>
</blockquote>
<p>在1996年，Robert Martin在他的SOLID原则中，重新描述了这个原则，英文原话是这样的：</p>
<blockquote>
<p>Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it。</p>
</blockquote>
<p>我们综合两者的描述，将这条原则用中文描述出来，是这样的：子类对象（object of subtype&#x2F;derived class）能够替换程序（program）中父类对象（object of base&#x2F;parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。</p>
<p>这么说还是比较抽象，我们通过一个例子来解释一下。如下代码中，父类Transporter使用org.apache.http库中的HttpClient类来传输网络数据。子类SecurityTransporter继承父类Transporter，增加了额外的功能，支持传输appId和appToken安全认证信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Transporter</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> HttpClient httpClient;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Transporter</span><span class="params">(HttpClient httpClient)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.httpClient = httpClient;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Response <span class="title function_">sendRequest</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">    <span class="comment">// ...use httpClient to send request</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityTransporter</span> <span class="keyword">extends</span> <span class="title class_">Transporter</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String appId;</span><br><span class="line">  <span class="keyword">private</span> String appToken;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SecurityTransporter</span><span class="params">(HttpClient httpClient, String appId, String appToken)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(httpClient);</span><br><span class="line">    <span class="built_in">this</span>.appId = appId;</span><br><span class="line">    <span class="built_in">this</span>.appToken = appToken;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Response <span class="title function_">sendRequest</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isNotBlank(appId) &amp;&amp; StringUtils.isNotBlank(appToken)) &#123;</span><br><span class="line">      request.addPayload(<span class="string">&quot;app-id&quot;</span>, appId);</span><br><span class="line">      request.addPayload(<span class="string">&quot;app-token&quot;</span>, appToken);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.sendRequest(request);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;    </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demoFunction</span><span class="params">(Transporter transporter)</span> &#123;    </span><br><span class="line">    <span class="type">Reuqest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>();</span><br><span class="line">    <span class="comment">//...省略设置request中数据值的代码...</span></span><br><span class="line">    <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> transporter.sendRequest(request);</span><br><span class="line">    <span class="comment">//...省略其他逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 里式替换原则</span></span><br><span class="line"><span class="type">Demo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">demo.demofunction(<span class="keyword">new</span> <span class="title class_">SecurityTransporter</span>(<span class="comment">/*省略参数*/</span>););</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，子类SecurityTransporter的设计完全符合里式替换原则，可以替换父类出现的任何位置，并且原来代码的逻辑行为不变且正确性也没有被破坏。</p>
<p>不过，你可能会有这样的疑问，刚刚的代码设计不就是简单利用了面向对象的多态特性吗？多态和里式替换原则说的是不是一回事呢？从刚刚的例子和定义描述来看，里式替换原则跟多态看起来确实有点类似，但实际上它们完全是两回事。为什么这么说呢？</p>
<p>我们还是通过刚才这个例子来解释一下。不过，我们需要对SecurityTransporter类中sendRequest()函数稍加改造一下。改造前，如果appId或者appToken没有设置，我们就不做校验；改造后，如果appId或者appToken没有设置，则直接抛出NoAuthorizationRuntimeException未授权异常。改造前后的代码对比如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 改造前：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityTransporter</span> <span class="keyword">extends</span> <span class="title class_">Transporter</span> &#123;</span><br><span class="line">  <span class="comment">//...省略其他代码..</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Response <span class="title function_">sendRequest</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isNotBlank(appId) &amp;&amp; StringUtils.isNotBlank(appToken)) &#123;</span><br><span class="line">      request.addPayload(<span class="string">&quot;app-id&quot;</span>, appId);</span><br><span class="line">      request.addPayload(<span class="string">&quot;app-token&quot;</span>, appToken);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.sendRequest(request);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改造后：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityTransporter</span> <span class="keyword">extends</span> <span class="title class_">Transporter</span> &#123;</span><br><span class="line">  <span class="comment">//...省略其他代码..</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Response <span class="title function_">sendRequest</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(appId) || StringUtils.isBlank(appToken)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoAuthorizationRuntimeException</span>(...);</span><br><span class="line">    &#125;</span><br><span class="line">    request.addPayload(<span class="string">&quot;app-id&quot;</span>, appId);</span><br><span class="line">    request.addPayload(<span class="string">&quot;app-token&quot;</span>, appToken);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.sendRequest(request);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在改造之后的代码中，如果传递进demoFunction()函数的是父类Transporter对象，那demoFunction()函数并不会有异常抛出，但如果传递给demoFunction()函数的是子类SecurityTransporter对象，那demoFunction()有可能会有异常抛出。尽管代码中抛出的是运行时异常（Runtime Exception），我们可以不在代码中显式地捕获处理，但子类替换父类传递进demoFunction函数之后，整个程序的逻辑行为有了改变。</p>
<p>虽然改造之后的代码仍然可以通过Java的多态语法，动态地用子类SecurityTransporter来替换父类Transporter，也并不会导致程序编译或者运行报错。但是，从设计思路上来讲，SecurityTransporter的设计是不符合里式替换原则的。</p>
<p>好了，我们稍微总结一下。虽然从定义描述和代码实现上来看，多态和里式替换有点类似，但它们关注的角度是不一样的：</p>
<ul>
<li><u>多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。</u></li>
<li><u>里式替换是一种设计原则，是用来指导继承关系中子类该如何设计的，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。</u></li>
</ul>
<p><strong>哪些代码明显违背了LSP？</strong></p>
<p>实际上，里式替换原则还有另外一个更加能落地、更有指导意义的描述，那就是“Design By Contract”，中文翻译就是“按照协议来设计”。</p>
<p>看起来比较抽象，我来进一步解读一下。<u>子类在设计的时候，要遵守父类的行为约定（或者叫协议）</u>。父类定义了函数的行为约定，那子类可以改变函数的内部实现逻辑，但不能改变函数原有的行为约定。这里的行为约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。实际上，定义中父类和子类之间的关系，也可以替换成接口和实现类之间的关系。</p>
<p>为了更好地理解这句话，我举几个违反里式替换原则的例子来解释一下。</p>
<p><strong>1.子类违背父类声明要实现的功能</strong></p>
<p>父类中提供的sortOrdersByAmount()订单排序函数，是按照金额从小到大来给订单排序的，而子类重写这个sortOrdersByAmount()订单排序函数之后，是按照创建日期来给订单排序的。那子类的设计就违背里式替换原则。</p>
<p><strong>2.子类违背父类对输入、输出、异常的约定</strong></p>
<p>在父类中，某个函数约定：运行出错的时候返回null；获取数据为空的时候返回空集合（empty collection）。而子类重载函数之后，实现变了，运行出错返回异常（exception），获取不到数据返回null。那子类的设计就违背里式替换原则。</p>
<p>在父类中，某个函数约定，输入数据可以是任意整数，但子类实现的时候，只允许输入数据是正整数，负数就抛出，也就是说，子类对输入的数据的校验比父类更加严格，那子类的设计就违背了里式替换原则。</p>
<p>在父类中，某个函数约定，只会抛出ArgumentNullException异常，那子类的设计实现中只允许抛出ArgumentNullException异常，任何其他异常的抛出，都会导致子类违背里式替换原则。</p>
<p><strong>3.子类违背父类注释中所罗列的任何特殊说明</strong></p>
<p>父类中定义的withdraw()提现函数的注释是这么写的：“用户的提现金额不得超过账户余额……”，而子类重写withdraw()函数之后，针对VIP账号实现了透支提现的功能，也就是提现金额可以大于账户余额，那这个子类的设计也是不符合里式替换原则的。</p>
<p>以上便是三种典型的违背里式替换原则的情况。除此之外，判断子类的设计实现是否违背里式替换原则，还有一个小窍门，那就是拿父类的单元测试去验证子类的代码。如果某些单元测试运行失败，就有可能说明，子类的设计实现没有完全地遵守父类的约定，子类有可能违背了里式替换原则。</p>
<p>实际上，你有没有发现，里式替换这个原则是非常宽松的。一般情况下，我们写的代码都不怎么会违背它。所以，只要你能看懂我今天讲的这些，这个原则就不难掌握，也不难应用。</p>
<h3 id="16-SOLID：接口隔离原则"><a href="#16-SOLID：接口隔离原则" class="headerlink" title="16. SOLID：接口隔离原则"></a>16. SOLID：接口隔离原则</h3><p><strong>如何理解“接口隔离原则”？</strong></p>
<p>接口隔离原则的英文翻译是“ Interface Segregation Principle”，缩写为ISP。Robert Martin在SOLID原则中是这样定义它的：“Clients should not be forced to depend upon interfaces that they do not use。”直译成中文的话就是：客户端不应该被强迫依赖它不需要的接口。其中的“客户端”，可以理解为接口的调用者或者使用者。</p>
<p>实际上，“接口”这个名词可以用在很多场合中。生活中我们可以用它来指插座接口等。在软件开发中，我们既可以把它看作一组抽象的约定，也可以具体指系统与系统之间的API接口，还可以特指面向对象编程语言中的接口等。</p>
<p>前面我提到，理解接口隔离原则的关键，就是理解其中的“接口”二字。在这条原则中，我们可以把“接口”理解为下面三种东西：</p>
<ul>
<li>一组API接口集合</li>
<li>单个API接口或函数</li>
<li>OOP中的接口概念</li>
</ul>
<p>接下来，我就按照这三种理解方式来详细讲一下，在不同的场景下，这条原则具体是如何解读和应用的。</p>
<p><strong>把“接口”理解为一组API接口集合</strong></p>
<p>我们还是结合一个例子来讲解。微服务用户系统提供了一组跟用户相关的API给其他系统使用，比如：注册、登录、获取用户信息等。具体代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">register</span><span class="params">(String cellphone, String password)</span>;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">login</span><span class="params">(String cellphone, String password)</span>;</span><br><span class="line">  UserInfo <span class="title function_">getUserInfoById</span><span class="params">(<span class="type">long</span> id)</span>;</span><br><span class="line">  UserInfo <span class="title function_">getUserInfoByCellphone</span><span class="params">(String cellphone)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们的后台管理系统要实现删除用户的功能，希望用户系统提供一个删除用户的接口。这个时候我们该如何来做呢？你可能会说，这不是很简单吗，我只需要在UserService中新添加一个deleteUserByCellphone()或deleteUserById()接口就可以了。这个方法可以解决问题，但是也隐藏了一些安全隐患。</p>
<p>删除用户是一个非常慎重的操作，我们只希望通过后台管理系统来执行，所以这个接口只限于给后台管理系统使用。如果我们把它放到UserService中，那所有使用到UserService的系统，都可以调用这个接口。不加限制地被其他业务系统调用，就有可能导致误删用户。</p>
<p>当然，最好的解决方案是从架构设计的层面，通过接口鉴权的方式来限制接口的调用。不过，如果暂时没有鉴权框架来支持，我们还可以从代码设计的层面，尽量避免接口被误用。我们参照接口隔离原则，调用者不应该强迫依赖它不需要的接口，将删除接口单独放到另外一个接口RestrictedUserService中，然后将RestrictedUserService只打包提供给后台管理系统来使用。具体的代码实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">register</span><span class="params">(String cellphone, String password)</span>;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">login</span><span class="params">(String cellphone, String password)</span>;</span><br><span class="line">  UserInfo <span class="title function_">getUserInfoById</span><span class="params">(<span class="type">long</span> id)</span>;</span><br><span class="line">  UserInfo <span class="title function_">getUserInfoByCellphone</span><span class="params">(String cellphone)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RestrictedUserService</span> &#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">deleteUserByCellphone</span><span class="params">(String cellphone)</span>;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">deleteUserById</span><span class="params">(<span class="type">long</span> id)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>, RestrictedUserService &#123;</span><br><span class="line">  <span class="comment">// ...省略实现代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在刚刚的这个例子中，我们把接口隔离原则中的接口，理解为一组接口集合，它可以是某个微服务的接口，也可以是某个类库的接口等等。<u>在设计微服务或者类库接口的时候，如果部分接口只被部分调用者使用，那我们就需要将这部分接口隔离出来，单独给对应的调用者使用，而不是强迫其他调用者也依赖这部分不会被用到的接口。</u></p>
<p><strong>把“接口”理解为单个API接口或函数</strong></p>
<p>现在我们再换一种理解方式，把接口理解为单个接口或函数（以下为了方便讲解，我都简称为“函数”）。那接口隔离原则就可以理解为：<u>函数的设计要功能单一，不要将多个不同的功能逻辑在一个函数中实现</u>。接下来，我们还是通过一个例子来解释一下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Statistics &#123;</span><br><span class="line">  private Long max;</span><br><span class="line">  private Long min;</span><br><span class="line">  private Long average;</span><br><span class="line">  private Long sum;</span><br><span class="line">  private Long percentile99;</span><br><span class="line">  private Long percentile999;</span><br><span class="line">  //...省略constructor/getter/setter等方法...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Statistics count(Collection&lt;Long&gt; dataSet) &#123;</span><br><span class="line">  Statistics statistics = new Statistics();</span><br><span class="line">  //...省略计算逻辑...</span><br><span class="line">  return statistics;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，count()函数的功能不够单一，包含很多不同的统计功能，比如，求最大值、最小值、平均值等等。按照接口隔离原则，我们应该把count()函数拆成几个更小粒度的函数，每个函数负责一个独立的统计功能。拆分之后的代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Long max(Collection&lt;Long&gt; dataSet) &#123; //... &#125;</span><br><span class="line">public Long min(Collection&lt;Long&gt; dataSet) &#123; //... &#125; </span><br><span class="line">public Long average(Colletion&lt;Long&gt; dataSet) &#123; //... &#125;</span><br><span class="line">// ...省略其他统计函数...</span><br></pre></td></tr></table></figure>

<p>不过，你可能会说，在某种意义上讲，count()函数也不能算是职责不够单一，毕竟它做的事情只跟统计相关。我们在讲单一职责原则的时候，也提到过类似的问题。实际上，判定功能是否单一，除了很强的主观性，还需要结合具体的场景。</p>
<p>如果在项目中，对每个统计需求，Statistics定义的那几个统计信息都有涉及，那count()函数的设计就是合理的。相反，如果每个统计需求只涉及Statistics罗列的统计信息中一部分，比如，有的只需要用到max、min、average这三类统计信息，有的只需要用到average、sum。而count()函数每次都会把所有的统计信息计算一遍，就会做很多无用功，势必影响代码的性能，特别是在需要统计的数据量很大的时候。所以，在这个应用场景下，count()函数的设计就有点不合理了，我们应该按照第二种设计思路，将其拆分成粒度更细的多个统计函数。</p>
<p>不过，你应该已经发现，接口隔离原则跟单一职责原则有点类似，不过稍微还是有点区别。单一职责原则针对的是模块、类、接口的设计。而接口隔离原则相对于单一职责原则，一方面它更侧重于接口的设计，另一方面它的思考的角度不同。它提供了一种判断接口是否职责单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。</p>
<p><strong>把“接口”理解为OOP中的接口概念</strong></p>
<p>除了刚讲过的两种理解方式，我们还可以把“接口”理解为OOP中的接口概念，比如Java中的interface。我还是通过一个例子来给你解释。</p>
<p>假设我们的项目中用到了三个外部系统：Redis、MySQL、Kafka。每个系统都对应一系列配置信息，比如地址、端口、访问超时时间等。为了在内存中存储这些配置信息，供项目中的其他模块来使用，我们分别设计实现了三个Configuration类：RedisConfig、MysqlConfig、KafkaConfig。具体的代码实现如下所示。注意，这里我只给出了RedisConfig的代码实现，另外两个都是类似的，我这里就不贴了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ConfigSource configSource; <span class="comment">//配置中心（比如zookeeper）</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> timeout;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxTotal;</span><br><span class="line">    <span class="comment">//省略其他配置: maxWaitMillis,maxIdle,minIdle...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisConfig</span><span class="params">(ConfigSource configSource)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.configSource = configSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.address;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...省略其他get()、init()方法...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//从configSource加载配置到address/timeout/maxTotal...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaConfig</span> &#123; <span class="comment">//...省略... &#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MysqlConfig</span> &#123; <span class="comment">//...省略... &#125;</span></span><br></pre></td></tr></table></figure>

<p>现在，我们有一个新的功能需求，希望支持Redis和Kafka配置信息的热更新。所谓<u>“热更新（hot update）”就是，如果在配置中心中更改了配置信息，我们希望在不用重启系统的情况下，能将最新的配置信息加载到内存中（也就是RedisConfig、KafkaConfig类中）</u>。但是，因为某些原因，我们并不希望对MySQL的配置信息进行热更新。</p>
<p>为了实现这样一个功能需求，我们设计实现了一个ScheduledUpdater类，以固定时间频率（periodInSeconds）来调用RedisConfig、KafkaConfig的update()方法更新配置信息。具体的代码实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Updater</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> <span class="keyword">implements</span> <span class="title class_">Updater</span> &#123;</span><br><span class="line">  <span class="comment">//...省略其他属性和方法...</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaConfig</span> <span class="keyword">implements</span> <span class="title class_">Updater</span> &#123;</span><br><span class="line">  <span class="comment">//...省略其他属性和方法...</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MysqlConfig</span> &#123; <span class="comment">//...省略其他属性和方法... &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduledUpdater</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadScheduledExecutor();;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> initialDelayInSeconds;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> periodInSeconds;</span><br><span class="line">    <span class="keyword">private</span> Updater updater;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ScheduleUpdater</span><span class="params">(Updater updater, <span class="type">long</span> initialDelayInSeconds, <span class="type">long</span> periodInSeconds)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.updater = updater;</span><br><span class="line">        <span class="built_in">this</span>.initialDelayInSeconds = initialDelayInSeconds;</span><br><span class="line">        <span class="built_in">this</span>.periodInSeconds = periodInSeconds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        executor.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                updater.update();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="built_in">this</span>.initialDelayInSeconds, <span class="built_in">this</span>.periodInSeconds, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">  <span class="type">ConfigSource</span> <span class="variable">configSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZookeeperConfigSource</span>(<span class="comment">/*省略参数*/</span>);</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">RedisConfig</span> <span class="variable">redisConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisConfig</span>(configSource);</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">KafkaConfig</span> <span class="variable">kafkaConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">KakfaConfig</span>(configSource);</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">MySqlConfig</span> <span class="variable">mysqlConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MysqlConfig</span>(configSource);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ScheduledUpdater</span> <span class="variable">redisConfigUpdater</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScheduledUpdater</span>(redisConfig, <span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line">    redisConfigUpdater.run();</span><br><span class="line">    </span><br><span class="line">    <span class="type">ScheduledUpdater</span> <span class="variable">kafkaConfigUpdater</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScheduledUpdater</span>(kafkaConfig, <span class="number">60</span>, <span class="number">60</span>);</span><br><span class="line">    redisConfigUpdater.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>刚刚的热更新的需求我们已经搞定了。现在，我们又有了一个新的监控功能需求。通过命令行来查看Zookeeper中的配置信息是比较麻烦的。所以，我们希望能有一种更加方便的配置信息查看方式。</p>
<p>我们可以在项目中开发一个内嵌的SimpleHttpServer，输出项目的配置信息到一个固定的HTTP地址，比如：<a href="http://127.0.0.1:2389/config">http://127.0.0.1:2389/config</a> 。我们只需要在浏览器中输入这个地址，就可以显示出系统的配置信息。不过，出于某些原因，我们只想暴露MySQL和Redis的配置信息，不想暴露Kafka的配置信息。</p>
<p>为了实现这样一个功能，我们还需要对上面的代码做进一步改造。改造之后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Updater</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Viewer</span> &#123;</span><br><span class="line">  String <span class="title function_">outputInPlainText</span><span class="params">()</span>;</span><br><span class="line">  Map&lt;String, String&gt; <span class="title function_">output</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> <span class="keyword">implements</span> <span class="title class_">Updater</span>, Viewer &#123;</span><br><span class="line">  <span class="comment">//...省略其他属性和方法...</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">outputInPlainText</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Map&lt;String, String&gt; <span class="title function_">output</span><span class="params">()</span> &#123; <span class="comment">//...&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaConfig</span> <span class="keyword">implements</span> <span class="title class_">Updater</span> &#123;</span><br><span class="line">  <span class="comment">//...省略其他属性和方法...</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MysqlConfig</span> <span class="keyword">implements</span> <span class="title class_">Viewer</span> &#123;</span><br><span class="line">  <span class="comment">//...省略其他属性和方法...</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">outputInPlainText</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Map&lt;String, String&gt; <span class="title function_">output</span><span class="params">()</span> &#123; <span class="comment">//...&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleHttpServer</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String host;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line">  <span class="keyword">private</span> Map&lt;String, List&lt;Viewer&gt;&gt; viewers = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SimpleHttpServer</span><span class="params">(String host, <span class="type">int</span> port)</span> &#123;<span class="comment">//...&#125;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addViewers</span><span class="params">(String urlDirectory, Viewer viewer)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!viewers.containsKey(urlDirectory)) &#123;</span><br><span class="line">      viewers.put(urlDirectory, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Viewer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.viewers.get(urlDirectory).add(viewer);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="type">ConfigSource</span> <span class="variable">configSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZookeeperConfigSource</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">RedisConfig</span> <span class="variable">redisConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisConfig</span>(configSource);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">KafkaConfig</span> <span class="variable">kafkaConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">KakfaConfig</span>(configSource);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">MySqlConfig</span> <span class="variable">mysqlConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MySqlConfig</span>(configSource);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ScheduledUpdater</span> <span class="variable">redisConfigUpdater</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ScheduledUpdater</span>(redisConfig, <span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line">        redisConfigUpdater.run();</span><br><span class="line">        </span><br><span class="line">        <span class="type">ScheduledUpdater</span> <span class="variable">kafkaConfigUpdater</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ScheduledUpdater</span>(kafkaConfig, <span class="number">60</span>, <span class="number">60</span>);</span><br><span class="line">        redisConfigUpdater.run();</span><br><span class="line">        </span><br><span class="line">        <span class="type">SimpleHttpServer</span> <span class="variable">simpleHttpServer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleHttpServer</span>(“<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>”, <span class="number">2389</span>);</span><br><span class="line">        simpleHttpServer.addViewer(<span class="string">&quot;/config&quot;</span>, redisConfig);</span><br><span class="line">        simpleHttpServer.addViewer(<span class="string">&quot;/config&quot;</span>, mysqlConfig);</span><br><span class="line">        simpleHttpServer.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，热更新和监控的需求我们就都实现了。我们来回顾一下这个例子的设计思想。</p>
<p>我们设计了两个功能非常单一的接口：Updater和Viewer。ScheduledUpdater只依赖Updater这个跟热更新相关的接口，不需要被强迫去依赖不需要的Viewer接口，满足接口隔离原则。同理，SimpleHttpServer只依赖跟查看信息相关的Viewer接口，不依赖不需要的Updater接口，也满足接口隔离原则。</p>
<p>你可能会说，如果我们不遵守接口隔离原则，不设计Updater和Viewer两个小接口，而是设计一个大而全的Config接口，让RedisConfig、KafkaConfig、MysqlConfig都实现这个Config接口，并且将原来传递给ScheduledUpdater的Updater和传递给SimpleHttpServer的Viewer，都替换为Config，那会有什么问题呢？我们先来看一下，按照这个思路来实现的代码是什么样的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">  String <span class="title function_">outputInPlainText</span><span class="params">()</span>;</span><br><span class="line">  Map&lt;String, String&gt; <span class="title function_">output</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> <span class="keyword">implements</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">  <span class="comment">//...需要实现Config的三个接口update/outputIn.../output</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaConfig</span> <span class="keyword">implements</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">  <span class="comment">//...需要实现Config的三个接口update/outputIn.../output</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MysqlConfig</span> <span class="keyword">implements</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">  <span class="comment">//...需要实现Config的三个接口update/outputIn.../output</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduledUpdater</span> &#123;</span><br><span class="line">  <span class="comment">//...省略其他属性和方法..</span></span><br><span class="line">  <span class="keyword">private</span> Config config;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ScheduleUpdater</span><span class="params">(Config config, <span class="type">long</span> initialDelayInSeconds, <span class="type">long</span> periodInSeconds)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.config = config;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleHttpServer</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String host;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line">  <span class="keyword">private</span> Map&lt;String, List&lt;Config&gt;&gt; viewers = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SimpleHttpServer</span><span class="params">(String host, <span class="type">int</span> port)</span> &#123;<span class="comment">//...&#125;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addViewer</span><span class="params">(String urlDirectory, Config config)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!viewers.containsKey(urlDirectory)) &#123;</span><br><span class="line">      viewers.put(urlDirectory, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Config&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    viewers.get(urlDirectory).add(config);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的设计思路也是能工作的，但是对比前后两个设计思路，在同样的代码量、实现复杂度、同等可读性的情况下，第一种设计思路显然要比第二种好很多。为什么这么说呢？主要有两点原因。</p>
<p><strong>首先，第一种设计思路更加灵活、易扩展、易复用。</strong>因为Updater、Viewer职责更加单一，单一就意味了通用、复用性好。比如，我们现在又有一个新的需求，开发一个Metrics性能统计模块，并且希望将Metrics也通过SimpleHttpServer显示在网页上，以方便查看。这个时候，尽管Metrics跟RedisConfig等没有任何关系，但我们仍然可以让Metrics类实现非常通用的Viewer接口，复用SimpleHttpServer的代码实现。具体的代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ApiMetrics implements Viewer &#123;//...&#125;</span><br><span class="line">public class DbMetrics implements Viewer &#123;//...&#125;</span><br><span class="line"></span><br><span class="line">public class Application &#123;</span><br><span class="line">    ConfigSource configSource = new ZookeeperConfigSource();</span><br><span class="line">    public static final RedisConfig redisConfig = new RedisConfig(configSource);</span><br><span class="line">    public static final KafkaConfig kafkaConfig = new KakfaConfig(configSource);</span><br><span class="line">    public static final MySqlConfig mySqlConfig = new MySqlConfig(configSource);</span><br><span class="line">    public static final ApiMetrics apiMetrics = new ApiMetrics();</span><br><span class="line">    public static final DbMetrics dbMetrics = new DbMetrics();</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SimpleHttpServer simpleHttpServer = new SimpleHttpServer(“127.0.0.1”, 2389);</span><br><span class="line">        simpleHttpServer.addViewer(&quot;/config&quot;, redisConfig);</span><br><span class="line">        simpleHttpServer.addViewer(&quot;/config&quot;, mySqlConfig);</span><br><span class="line">        simpleHttpServer.addViewer(&quot;/metrics&quot;, apiMetrics);</span><br><span class="line">        simpleHttpServer.addViewer(&quot;/metrics&quot;, dbMetrics);</span><br><span class="line">        simpleHttpServer.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>其次，第二种设计思路在代码实现上做了一些无用功。</strong>因为Config接口中包含两类不相关的接口，一类是update()，一类是output()和outputInPlainText()。理论上，KafkaConfig只需要实现update()接口，并不需要实现output()相关的接口。同理，MysqlConfig只需要实现output()相关接口，并需要实现update()接口。但第二种设计思路要求RedisConfig、KafkaConfig、MySqlConfig必须同时实现Config的所有接口函数（update、output、outputInPlainText）。除此之外，如果我们要往Config中继续添加一个新的接口，那所有的实现类都要改动。相反，如果我们的接口粒度比较小，那涉及改动的类就比较少。</p>
<h3 id="17-SOLID：依赖反转原则"><a href="#17-SOLID：依赖反转原则" class="headerlink" title="17. SOLID：依赖反转原则"></a>17. SOLID：依赖反转原则</h3><p>这个原则用起来比较简单，但概念理解起来比较难。比如，下面这几个问题，你看看能否清晰地回答出来：</p>
<ul>
<li>“依赖反转”这个概念指的是“谁跟谁”的“什么依赖”被反转了？“反转”两个字该如何理解？</li>
<li>我们还经常听到另外两个概念：“控制反转”和“依赖注入”。这两个概念跟“依赖反转”有什么区别和联系呢？它们说的是同一个事情吗？</li>
<li>如果你熟悉Java语言，那Spring框架中的IOC跟这些概念又有什么关系呢？</li>
</ul>
<p><strong>控制反转（IOC）</strong></p>
<p>在讲“依赖反转原则”之前，我们先讲一讲“控制反转”。控制反转的英文翻译是Inversion Of Control，缩写为IOC。此处我要强调一下，如果你是Java工程师的话，暂时别把这个“IOC”跟Spring框架的IOC联系在一起。关于Spring的IOC，我们待会儿还会讲到。</p>
<p>我们先通过一个例子来看一下，什么是控制反转。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">doTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;<span class="comment">//这部分逻辑可以放到框架中</span></span><br><span class="line">    <span class="keyword">if</span> (doTest()) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Test succeed.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Test failed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，所有的流程都由程序员来控制。如果我们抽象出一个下面这样一个框架，我们再来看，如何利用框架来实现同样的功能。具体的代码实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">TestCase</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (doTest()) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Test succeed.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Test failed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">doTest</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JunitApplication</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;TestCase&gt; testCases = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(TestCase testCase)</span> &#123;</span><br><span class="line">    testCases.add(testCase);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (TestCase <span class="keyword">case</span>: testCases) &#123;</span><br><span class="line">      <span class="keyword">case</span>.run();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>把这个简化版本的测试框架引入到工程中之后，我们只需要在框架预留的扩展点，也就是TestCase类中的doTest()抽象函数中，填充具体的测试代码就可以实现之前的功能了，完全不需要写负责执行流程的main()函数了。 具体的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceTest</span> <span class="keyword">extends</span> <span class="title class_">TestCase</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">doTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册操作还可以通过配置的方式来实现，不需要程序员显示调用register()</span></span><br><span class="line">JunitApplication.register(<span class="keyword">new</span> <span class="title class_">UserServiceTest</span>();</span><br></pre></td></tr></table></figure>

<p>刚刚举的这个例子，就是典型的通过框架来实现“控制反转”的例子。框架提供了一个可扩展的代码骨架，用来组装对象、管理整个执行流程。程序员利用框架进行开发的时候，只需要往预留的扩展点上，添加跟自己业务相关的代码，就可以利用框架来驱动整个程序流程的执行。</p>
<p><u>这里的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程可以通过框架来控制。流程的控制权从程序员“反转”到了框架。</u></p>
<p>实际上，实现控制反转的方法有很多，除了刚才例子中所示的类似于模板设计模式的方法之外，还有马上要讲到的依赖注入等方法，所以，控制反转并不是一种具体的实现技巧，而是一个比较笼统的设计思想，一般用来指导框架层面的设计。</p>
<p><strong>依赖注入（DI）</strong></p>
<p>接下来，我们再来看依赖注入。依赖注入跟控制反转恰恰相反，它是一种具体的编码技巧。依赖注入的英文翻译是Dependency Injection，缩写为DI。对于这个概念，有一个非常形象的说法，那就是：依赖注入是一个标价25美元，实际上只值5美分的概念。也就是说，这个概念听起来很“高大上”，实际上，理解、应用起来非常简单。</p>
<p>那到底<u>什么是依赖注入呢？我们用一句话来概括就是：不通过new()的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。</u></p>
<p>我们还是通过一个例子来解释一下。在这个例子中，Notification类负责消息推送，依赖MessageSender类实现推送商品促销、验证码等消息给用户。我们分别用依赖注入和非依赖注入两种方式来实现一下。具体的实现代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非依赖注入实现方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Notification</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> MessageSender messageSender;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Notification</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.messageSender = <span class="keyword">new</span> <span class="title class_">MessageSender</span>(); <span class="comment">//此处有点像hardcode</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String cellphone, String message)</span> &#123;</span><br><span class="line">    <span class="comment">//...省略校验逻辑等...</span></span><br><span class="line">    <span class="built_in">this</span>.messageSender.send(cellphone, message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageSender</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String cellphone, String message)</span> &#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用Notification</span></span><br><span class="line"><span class="type">Notification</span> <span class="variable">notification</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Notification</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依赖注入的实现方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Notification</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> MessageSender messageSender;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 通过构造函数将messageSender传递进来</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Notification</span><span class="params">(MessageSender messageSender)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.messageSender = messageSender;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String cellphone, String message)</span> &#123;</span><br><span class="line">    <span class="comment">//...省略校验逻辑等...</span></span><br><span class="line">    <span class="built_in">this</span>.messageSender.send(cellphone, message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用Notification</span></span><br><span class="line"><span class="type">MessageSender</span> <span class="variable">messageSender</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageSender</span>();</span><br><span class="line"><span class="type">Notification</span> <span class="variable">notification</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Notification</span>(messageSender);</span><br></pre></td></tr></table></figure>

<p>通过依赖注入的方式来将依赖的类对象传递进来，这样就提高了代码的扩展性，我们可以灵活地替换依赖的类。这一点在我们之前讲“开闭原则”的时候也提到过。当然，上面代码还有继续优化的空间，我们还可以把MessageSender定义成接口，基于接口而非实现编程。改造后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Notification</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> MessageSender messageSender;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Notification</span><span class="params">(MessageSender messageSender)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.messageSender = messageSender;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String cellphone, String message)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.messageSender.send(cellphone, message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MessageSender</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String cellphone, String message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 短信发送类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsSender</span> <span class="keyword">implements</span> <span class="title class_">MessageSender</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String cellphone, String message)</span> &#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 站内信发送类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InboxSender</span> <span class="keyword">implements</span> <span class="title class_">MessageSender</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String cellphone, String message)</span> &#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用Notification</span></span><br><span class="line"><span class="type">MessageSender</span> <span class="variable">messageSender</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmsSender</span>();</span><br><span class="line"><span class="type">Notification</span> <span class="variable">notification</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Notification</span>(messageSender);</span><br></pre></td></tr></table></figure>

<p>实际上，你只需要掌握刚刚举的这个例子，就等于完全掌握了依赖注入。尽管依赖注入非常简单，但却非常有用，在后面的章节中，我们会讲到，它<u>是编写可测试性代码最有效的手段</u>。</p>
<p><strong>依赖注入框架（DI Framework）</strong></p>
<p>弄懂了什么是“依赖注入”，我们再来看一下，什么是“依赖注入框架”。我们还是借用刚刚的例子来解释。</p>
<p>在采用依赖注入实现的Notification类中，虽然我们不需要用类似hard code的方式，在类内部通过new来创建MessageSender对象，但是，这个创建对象、组装（或注入）对象的工作仅仅是被移动到了更上层代码而已，还是需要我们程序员自己来实现。具体代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">    <span class="type">MessageSender</span> <span class="variable">sender</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmsSender</span>(); <span class="comment">//创建对象</span></span><br><span class="line">    <span class="type">Notification</span> <span class="variable">notification</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Notification</span>(sender);<span class="comment">//依赖注入</span></span><br><span class="line">    notification.sendMessage(<span class="string">&quot;13918942177&quot;</span>, <span class="string">&quot;短信验证码：2346&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实际的软件开发中，一些项目可能会涉及几十、上百、甚至几百个类，类对象的创建和依赖注入会变得非常复杂。如果这部分工作都是靠程序员自己写代码来完成，容易出错且开发成本也比较高。而对象创建和依赖注入的工作，本身跟具体的业务无关，我们完全可以抽象成框架来自动完成。</p>
<p>你可能已经猜到，这个框架就是“依赖注入框架”。我们只需要通过依赖注入框架提供的扩展点，简单配置一下所有需要创建的类对象、类与类之间的依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。</p>
<p>实际上，现成的依赖注入框架有很多，比如Google Guice、Java Spring、Pico Container、Butterfly Container等。不过，如果你熟悉Java Spring框架，你可能会说，Spring框架自己声称是<strong>控制反转容器</strong>（Inversion Of Control Container）。</p>
<p>实际上，这两种说法都没错。只是控制反转容器这种表述是一种非常宽泛的描述，DI依赖注入框架的表述更具体、更有针对性。因为我们前面讲到实现控制反转的方式有很多，除了依赖注入，还有模板模式等，而<u>Spring框架的控制反转主要是通过依赖注入来实现的</u>。不过这点区分并不是很明显，也不是很重要，你稍微了解一下就可以了。</p>
<p><strong>依赖反转原则（DIP）</strong></p>
<p>前面讲了控制反转、依赖注入、依赖注入框架，现在，我们来讲一讲今天的主角：依赖反转原则。依赖反转原则的英文翻译是Dependency Inversion Principle，缩写为DIP。中文翻译有时候也叫依赖倒置原则。</p>
<p>为了追本溯源，我先给出这条原则最原汁原味的英文描述：</p>
<blockquote>
<p>High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions.</p>
</blockquote>
<p>我们将它翻译成中文，大概意思就是：<u>高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。</u></p>
<p>所谓高层模块和低层模块的划分，简单来说就是，在调用链上，调用者属于高层，被调用者属于低层。在平时的业务代码开发中，高层模块依赖底层模块是没有任何问题的。实际上，这条原则主要还是用来指导框架层面的设计，跟前面讲到的控制反转类似。我们拿Tomcat这个Servlet容器作为例子来解释一下。</p>
<p>Tomcat是运行Java Web应用程序的容器。我们编写的Web应用程序代码只需要部署在Tomcat容器下，便可以被Tomcat容器调用执行。按照之前的划分原则，Tomcat就是高层模块，我们编写的Web应用程序代码就是低层模块。Tomcat和应用程序代码之间并没有直接的依赖关系，两者都依赖同一个“抽象”，也就是Servlet规范。Servlet规范不依赖具体的Tomcat容器和应用程序的实现细节，而Tomcat容器和应用程序依赖Servlet规范。</p>
<h3 id="18-KISS原则和YAGNI原则"><a href="#18-KISS原则和YAGNI原则" class="headerlink" title="18. KISS原则和YAGNI原则"></a>18. KISS原则和YAGNI原则</h3><p><strong>如何理解“KISS原则”？</strong></p>
<p>KISS原则的英文描述有好几个版本，比如下面这几个。</p>
<ul>
<li>Keep It Simple and Stupid.</li>
<li>Keep It Short and Simple.</li>
<li>Keep It Simple and Straightforward.</li>
</ul>
<p>不过，仔细看你就会发现，它们要表达的意思其实差不多，翻译成中文就是：尽量保持简单。</p>
<p>KISS原则算是一个万金油类型的设计原则，可以应用在很多场景中。它不仅经常用来指导软件开发，还经常用来指导更加广泛的系统设计、产品设计等，比如，冰箱、建筑、iPhone手机的设计等等。不过，咱们的专栏是讲代码设计的，所以，接下来，我还是重点讲解如何在编码开发中应用这条原则。</p>
<p>我们知道，代码的可读性和可维护性是衡量代码质量非常重要的两个标准。而KISS原则就是保持代码可读和可维护的重要手段。代码足够简单，也就意味着很容易读懂，bug比较难隐藏。即便出现bug，修复起来也比较简单。</p>
<p>不过，这条原则只是告诉我们，要保持代码“Simple and Stupid”，但并没有讲到，什么样的代码才是“Simple and Stupid”的，更没有给出特别明确的方法论，来指导如何开发出“Simple and Stupid”的代码。所以，看着非常简单，但不能落地，这就有点像我们常说的“心灵鸡汤”。哦，咱们这里应该叫“技术鸡汤”。</p>
<p>所以，接下来，为了能让这条原则切实地落地，能够指导实际的项目开发，我就针对刚刚的这些问题来进一步讲讲我的理解。</p>
<p><strong>代码行数越少就越“简单”吗？</strong></p>
<p>我们先一起看一个例子。下面这三段代码可以实现同样一个功能：检查输入的字符串ipAddress是否是合法的IP地址。</p>
<p>一个合法的IP地址由四个数字组成，并且通过“.”来进行分割。每组数字的取值范围是0~255。第一组数字比较特殊，不允许为0。对比这三段代码，你觉得哪一段代码最符合KISS原则呢？如果让你来实现这个功能，你会选择用哪种实现方法呢？你可以先自己思考一下，然后再看我下面的讲解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种实现方式: 使用正则表达式</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidIpAddressV1</span><span class="params">(String ipAddress)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (StringUtils.isBlank(ipAddress)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;^(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|[1-9])\\.&quot;</span></span><br><span class="line">          + <span class="string">&quot;(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\.&quot;</span></span><br><span class="line">          + <span class="string">&quot;(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\.&quot;</span></span><br><span class="line">          + <span class="string">&quot;(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)$&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> ipAddress.matches(regex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种实现方式: 使用现成的工具类</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidIpAddressV2</span><span class="params">(String ipAddress)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (StringUtils.isBlank(ipAddress)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  String[] ipUnits = StringUtils.split(ipAddress, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (ipUnits.length != <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> ipUnitIntValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ipUnitIntValue = Integer.parseInt(ipUnits[i]);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ipUnitIntValue &lt; <span class="number">0</span> || ipUnitIntValue &gt; <span class="number">255</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; ipUnitIntValue == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种实现方式: 不使用任何工具类</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidIpAddressV3</span><span class="params">(String ipAddress)</span> &#123;</span><br><span class="line">  <span class="type">char</span>[] ipChars = ipAddress.toCharArray();</span><br><span class="line">  <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> ipChars.length;</span><br><span class="line">  <span class="type">int</span> <span class="variable">ipUnitIntValue</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">isFirstUnit</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">unitsCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">    <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> ipChars[i];</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ipUnitIntValue &lt; <span class="number">0</span> || ipUnitIntValue &gt; <span class="number">255</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (isFirstUnit &amp;&amp; ipUnitIntValue == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (isFirstUnit) isFirstUnit = <span class="literal">false</span>;</span><br><span class="line">      ipUnitIntValue = -<span class="number">1</span>;</span><br><span class="line">      unitsCount++;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ipUnitIntValue == -<span class="number">1</span>) ipUnitIntValue = <span class="number">0</span>;</span><br><span class="line">    ipUnitIntValue = ipUnitIntValue * <span class="number">10</span> + (c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (ipUnitIntValue &lt; <span class="number">0</span> || ipUnitIntValue &gt; <span class="number">255</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (unitsCount != <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一种实现方式利用的是正则表达式，只用三行代码就把这个问题搞定了。它的代码行数最少，那是不是就最符合KISS原则呢？答案是否定的。虽然代码行数最少，看似最简单，实际上却很复杂。这正是因为它使用了正则表达式。</p>
<p>一方面，正则表达式本身是比较复杂的，写出完全没有bug的正则表达本身就比较有挑战；另一方面，并不是每个程序员都精通正则表达式。对于不怎么懂正则表达式的同事来说，看懂并且维护这段正则表达式是比较困难的。这种实现方式会导致代码的可读性和可维护性变差，所以，从KISS原则的设计初衷上来讲，这种实现方式并不符合KISS原则。</p>
<p>讲完了第一种实现方式，我们再来看下其他两种实现方式。</p>
<p>第二种实现方式使用了StringUtils类、Integer类提供的一些现成的工具函数，来处理IP地址字符串。第三种实现方式，不使用任何工具函数，而是通过逐一处理IP地址中的字符，来判断是否合法。从代码行数上来说，这两种方式差不多。但是，第三种要比第二种更加有难度，更容易写出bug。从可读性上来说，第二种实现方式的代码逻辑更清晰、更好理解。所以，在这两种实现方式中，第二种实现方式更加“简单”，更加符合KISS原则。</p>
<p>不过，你可能会说，第三种实现方式虽然实现起来稍微有点复杂，但性能要比第二种实现方式高一些啊。从性能的角度来说，选择第三种实现方式是不是更好些呢？</p>
<p>在回答这个问题之前，我先解释一下，为什么说第三种实现方式性能会更高一些。一般来说，工具类的功能都比较通用和全面，所以，在代码实现上，需要考虑和处理更多的细节，执行效率就会有所影响。而第三种实现方式，完全是自己操作底层字符，只针对IP地址这一种格式的数据输入来做处理，没有太多多余的函数调用和其他不必要的处理逻辑，所以，在执行效率上，这种类似定制化的处理代码方式肯定比通用的工具类要高些。</p>
<p>不过，尽管第三种实现方式性能更高些，但我还是更倾向于选择第二种实现方法。那是因为第三种实现方式实际上是一种过度优化。除非isValidIpAddress()函数是影响系统性能的瓶颈代码，否则，这样优化的投入产出比并不高，增加了代码实现的难度、牺牲了代码的可读性，性能上的提升却并不明显。</p>
<p><strong>代码逻辑复杂就违背KISS原则吗？</strong></p>
<p>刚刚我们提到，并不是代码行数越少就越“简单”，还要考虑逻辑复杂度、实现难度、代码的可读性等。那如果一段代码的逻辑复杂、实现难度大、可读性也不太好，是不是就一定违背KISS原则呢？在回答这个问题之前，我们先来看下面这段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// KMP algorithm: a, b分别是主串和模式串；n, m分别是主串和模式串的长度。</span><br><span class="line">public static int kmp(char[] a, int n, char[] b, int m) &#123;</span><br><span class="line">  int[] next = getNexts(b, m);</span><br><span class="line">  int j = 0;</span><br><span class="line">  for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">    while (j &gt; 0 &amp;&amp; a[i] != b[j]) &#123; // 一直找到a[i]和b[j]</span><br><span class="line">      j = next[j - 1] + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (a[i] == b[j]) &#123;</span><br><span class="line">      ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    if (j == m) &#123; // 找到匹配模式串的了</span><br><span class="line">      return i - m + 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// b表示模式串，m表示模式串的长度</span><br><span class="line">private static int[] getNexts(char[] b, int m) &#123;</span><br><span class="line">  int[] next = new int[m];</span><br><span class="line">  next[0] = -1;</span><br><span class="line">  int k = -1;</span><br><span class="line">  for (int i = 1; i &lt; m; ++i) &#123;</span><br><span class="line">    while (k != -1 &amp;&amp; b[k + 1] != b[i]) &#123;</span><br><span class="line">      k = next[k];</span><br><span class="line">    &#125;</span><br><span class="line">    if (b[k + 1] == b[i]) &#123;</span><br><span class="line">      ++k;</span><br><span class="line">    &#125;</span><br><span class="line">    next[i] = k;</span><br><span class="line">  &#125;</span><br><span class="line">  return next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码来自我的另一个专栏《数据结构与算法之美》中<a href="https://time.geekbang.org/column/article/71845">KMP字符串匹配算法</a>的代码实现。这段代码完全符合我们刚提到的逻辑复杂、实现难度大、可读性差的特点，但它并不违反KISS原则。为什么这么说呢？</p>
<p>KMP算法以快速高效著称。当我们需要处理长文本字符串匹配问题（几百MB大小文本内容的匹配），或者字符串匹配是某个产品的核心功能（比如Vim、Word等文本编辑器），又或者字符串匹配算法是系统性能瓶颈的时候，我们就应该选择尽可能高效的KMP算法。而KMP算法本身具有逻辑复杂、实现难度大、可读性差的特点。本身就复杂的问题，用复杂的方法解决，并不违背KISS原则。</p>
<p>不过，平时的项目开发中涉及的字符串匹配问题，大部分都是针对比较小的文本。在这种情况下，直接调用编程语言提供的现成的字符串匹配函数就足够了。如果非得用KMP算法、BM算法来实现字符串匹配，那就真的违背KISS原则了。也就是说，同样的代码，在某个业务场景下满足KISS原则，换一个应用场景可能就不满足了。</p>
<p><strong>如何写出满足KISS原则的代码？</strong></p>
<p>实际上，我们前面已经讲到了一些方法。这里我稍微总结一下。</p>
<ul>
<li><u>不要使用同事可能不懂的技术来实现代码</u>。比如前面例子中的正则表达式，还有一些编程语言中过于高级的语法等。</li>
<li><u>不要重复造轮子，要善于使用已经有的工具类库</u>。经验证明，自己去实现这些类库，出bug的概率会更高，维护的成本也比较高。</li>
<li><u>不要过度优化</u>。不要过度使用一些奇技淫巧（比如，位运算代替算术运算、复杂的条件语句代替if-else、使用一些过于底层的函数等）来优化代码，牺牲代码的可读性。</li>
</ul>
<p>实际上，代码是否足够简单是一个挺主观的评判。同样的代码，有的人觉得简单，有的人觉得不够简单。而往往自己编写的代码，自己都会觉得够简单。所以，评判代码是否简单，还有一个很有效的间接方法，那就是code review。如果在code review的时候，同事对你的代码有很多疑问，那就说明你的代码有可能不够“简单”，需要优化啦。</p>
<p>这里我还想多说两句，我们在做开发的时候，一定不要过度设计，不要觉得简单的东西就没有技术含量。实际上，越是能用简单的方法解决复杂的问题，越能体现一个人的能力。</p>
<p><strong>YAGNI跟KISS说的是一回事吗？</strong></p>
<p>YAGNI原则的英文全称是：You Ain’t Gonna Need It。直译就是：你不会需要它。这条原则也算是万金油了。<u>当用在软件开发中的时候，它的意思是：不要去设计当前用不到的功能；不要去编写当前用不到的代码。实际上，这条原则的核心思想就是：不要做过度设计。</u></p>
<p>比如，我们的系统暂时只用Redis存储配置信息，以后可能会用到ZooKeeper。根据YAGNI原则，在未用到ZooKeeper之前，我们没必要提前编写这部分代码。当然，这并不是说我们就不需要考虑代码的扩展性。我们还是要预留好扩展点，等到需要的时候，再去实现ZooKeeper存储配置信息这部分代码。</p>
<p>再比如，我们<u>不要在项目中提前引入不需要依赖的开发包</u>。对于Java程序员来说，我们经常使用Maven或者Gradle来管理依赖的类库（library）。我发现，有些同事为了避免开发中library包缺失而频繁地修改Maven或者Gradle配置文件，提前往项目里引入大量常用的library包。实际上，这样的做法也是违背YAGNI原则的。</p>
<p>从刚刚的分析我们可以看出，YAGNI原则跟KISS原则并非一回事儿。KISS原则讲的是“如何做”的问题（尽量保持简单），而YAGNI原则说的是“要不要做”的问题（当前不需要的就不要做）。</p>
<h3 id="19-DRY原则"><a href="#19-DRY原则" class="headerlink" title="19. DRY原则"></a>19. DRY原则</h3><p><strong>DRY原则（Don’t Repeat Yourself）</strong></p>
<p>DRY原则的定义非常简单，我就不再过度解读。今天，我们主要讲三种典型的代码重复情况，它们分别是：实现逻辑重复、功能语义重复和代码执行重复。这三种代码重复，有的看似违反DRY，实际上并不违反；有的看似不违反，实际上却违反了。</p>
<p><strong>实现逻辑重复</strong></p>
<p>我们先来看下面这样一段代码是否违反了DRY原则。如果违反了，你觉得应该如何重构，才能让它满足DRY原则？如果没有违反，那又是为什么呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserAuthenticator</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">authenticate</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isValidUsername(username)) &#123;</span><br><span class="line">      <span class="comment">// ...throw InvalidUsernameException...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isValidPassword(password)) &#123;</span><br><span class="line">      <span class="comment">// ...throw InvalidPasswordException...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...省略其他代码...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValidUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">    <span class="comment">// check not null, not empty</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(username)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// check length: 4~64</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> username.length();</span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="number">4</span> || length &gt; <span class="number">64</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// contains only lowcase characters</span></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isAllLowerCase(username)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// contains only a~z,0~9,dot</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">      <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> username.charAt(i);</span><br><span class="line">      <span class="keyword">if</span> (!(c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>) || (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) || c == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValidPassword</span><span class="params">(String password)</span> &#123;</span><br><span class="line">    <span class="comment">// check not null, not empty</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(password)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// check length: 4~64</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> password.length();</span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="number">4</span> || length &gt; <span class="number">64</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// contains only lowcase characters</span></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isAllLowerCase(password)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// contains only a~z,0~9,dot</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">      <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> password.charAt(i);</span><br><span class="line">      <span class="keyword">if</span> (!(c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>) || (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) || c == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很简单，我就不做过多解释了。在代码中，有两处非常明显的重复的代码片段：isValidUserName()函数和isValidPassword()函数。重复的代码被敲了两遍，或者简单copy-paste了一下，看起来明显违反DRY原则。为了移除重复的代码，我们对上面的代码做下重构，将isValidUserName()函数和isValidPassword()函数，合并为一个更通用的函数isValidUserNameOrPassword()。重构后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserAuthenticatorV2</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">authenticate</span><span class="params">(String userName, String password)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isValidUsernameOrPassword(userName)) &#123;</span><br><span class="line">      <span class="comment">// ...throw InvalidUsernameException...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isValidUsernameOrPassword(password)) &#123;</span><br><span class="line">      <span class="comment">// ...throw InvalidPasswordException...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValidUsernameOrPassword</span><span class="params">(String usernameOrPassword)</span> &#123;</span><br><span class="line">    <span class="comment">//省略实现逻辑</span></span><br><span class="line">    <span class="comment">//跟原来的isValidUsername()或isValidPassword()的实现逻辑一样...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过重构之后，代码行数减少了，也没有重复的代码了，是不是更好了呢？答案是否定的，这可能跟你预期的不一样，我来解释一下为什么。</p>
<p>单从名字上看，我们就能发现，合并之后的isValidUserNameOrPassword()函数，负责两件事情：验证用户名和验证密码，违反了“单一职责原则”和“接口隔离原则”。实际上，即便将两个函数合并成isValidUserNameOrPassword()，代码仍然存在问题。</p>
<p>因为isValidUserName()和isValidPassword()两个函数，虽然从代码实现逻辑上看起来是重复的，但是从语义上并不重复。所谓“语义不重复”指的是：从功能上来看，这两个函数干的是完全不重复的两件事情，一个是校验用户名，另一个是校验密码。尽管在目前的设计中，两个校验逻辑是完全一样的，但如果按照第二种写法，将两个函数的合并，那就会存在潜在的问题。在未来的某一天，如果我们修改了密码的校验逻辑，比如，允许密码包含大写字符，允许密码的长度为8到64个字符，那这个时候，isValidUserName()和isValidPassword()的实现逻辑就会不相同。我们就要把合并后的函数，重新拆成合并前的那两个函数。</p>
<p><u>尽管代码的实现逻辑是相同的，但语义不同，我们判定它并不违反DRY原则。对于包含重复代码的问题，我们可以通过抽象成更细粒度函数的方式来解决</u>。比如将校验只包含a<del>z、0</del>9、dot的逻辑封装成boolean onlyContains(String str, String charlist);函数。</p>
<p><strong>功能语义重复</strong></p>
<p>现在我们再来看另外一个例子。在同一个项目代码中有下面两个函数：isValidIp()和checkIfIpValid()。尽管两个函数的命名不同，实现逻辑不同，但功能是相同的，都是用来判定IP地址是否合法的。</p>
<p>之所以在同一个项目中会有两个功能相同的函数，那是因为这两个函数是由两个不同的同事开发的，其中一个同事在不知道已经有了isValidIp()的情况下，自己又定义并实现了同样用来校验IP地址是否合法的checkIfIpValid()函数。</p>
<p>那在同一项目代码中，存在如下两个函数，是否违反DRY原则呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidIp</span><span class="params">(String ipAddress)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (StringUtils.isBlank(ipAddress)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;^(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|[1-9])\\.&quot;</span></span><br><span class="line">          + <span class="string">&quot;(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\.&quot;</span></span><br><span class="line">          + <span class="string">&quot;(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\.&quot;</span></span><br><span class="line">          + <span class="string">&quot;(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)$&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> ipAddress.matches(regex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkIfIpValid</span><span class="params">(String ipAddress)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (StringUtils.isBlank(ipAddress)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  String[] ipUnits = StringUtils.split(ipAddress, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (ipUnits.length != <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> ipUnitIntValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ipUnitIntValue = Integer.parseInt(ipUnits[i]);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ipUnitIntValue &lt; <span class="number">0</span> || ipUnitIntValue &gt; <span class="number">255</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; ipUnitIntValue == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子跟上个例子正好相反。上一个例子是代码实现逻辑重复，但语义不重复，我们并不认为它违反了DRY原则。而<u>在这个例子中，尽管两段代码的实现逻辑不重复，但语义重复，也就是功能重复，我们认为它违反了DRY原则</u>。我们应该在项目中，统一一种实现思路，所有用到判断IP地址是否合法的地方，都统一调用同一个函数。</p>
<p>假设我们不统一实现思路，那有些地方调用了isValidIp()函数，有些地方又调用了checkIfIpValid()函数，这就会导致代码看起来很奇怪，相当于给代码“埋坑”，给不熟悉这部分代码的同事增加了阅读的难度。同事有可能研究了半天，觉得功能是一样的，但又有点疑惑，觉得是不是有更高深的考量，才定义了两个功能类似的函数，最终发现居然是代码设计的问题。</p>
<p>除此之外，如果哪天项目中IP地址是否合法的判定规则改变了，比如：255.255.255.255不再被判定为合法的了，相应地，我们对isValidIp()的实现逻辑做了相应的修改，但却忘记了修改checkIfIpValid()函数。又或者，我们压根就不知道还存在一个功能相同的checkIfIpValid()函数，这样就会导致有些代码仍然使用老的IP地址判断逻辑，导致出现一些莫名其妙的bug。</p>
<p><strong>代码执行重复</strong></p>
<p>前两个例子一个是实现逻辑重复，一个是语义重复，我们再来看第三个例子。其中，UserService中login()函数用来校验用户登录是否成功。如果失败，就返回异常；如果成功，就返回用户信息。具体代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> UserRepo userRepo;<span class="comment">//通过依赖注入或者IOC框架注入</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> User <span class="title function_">login</span><span class="params">(String email, String password)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">existed</span> <span class="operator">=</span> userRepo.checkIfUserExisted(email, password);</span><br><span class="line">    <span class="keyword">if</span> (!existed) &#123;</span><br><span class="line">      <span class="comment">// ... throw AuthenticationFailureException...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userRepo.getUserByEmail(email);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRepo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkIfUserExisted</span><span class="params">(String email, String password)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!EmailValidation.validate(email)) &#123;</span><br><span class="line">      <span class="comment">// ... throw InvalidEmailException...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!PasswordValidation.validate(password)) &#123;</span><br><span class="line">      <span class="comment">// ... throw InvalidPasswordException...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...query db to check if email&amp;password exists...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> User <span class="title function_">getUserByEmail</span><span class="params">(String email)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!EmailValidation.validate(email)) &#123;</span><br><span class="line">      <span class="comment">// ... throw InvalidEmailException...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...query db to get user by email...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码，既没有逻辑重复，也没有语义重复，但仍然违反了DRY原则。这是因为代码中存在“执行重复”。我们一块儿来看下，到底哪些代码被重复执行了？</p>
<p>重复执行最明显的一个地方，就是<u>在login()函数中，email的校验逻辑被执行了两次</u>。一次是在调用checkIfUserExisted()函数的时候，另一次是调用getUserByEmail()函数的时候。这个问题解决起来比较简单，我们只需要将校验逻辑从UserRepo中移除，统一放到UserService中就可以了。</p>
<p>除此之外，代码中还有一处比较隐蔽的执行重复，不知道你发现了没有？实际上，login()函数并不需要调用checkIfUserExisted()函数，只需要调用一次getUserByEmail()函数，从数据库中获取到用户的email、password等信息，然后跟用户输入的email、password信息做对比，依次判断是否登录成功。</p>
<p>实际上，这样的优化是很有必要的。因为checkIfUserExisted()函数和getUserByEmail()函数都需要查询数据库，而数据库这类的I&#x2F;O操作是比较耗时的。我们在写代码的时候，应当尽量减少这类I&#x2F;O操作。</p>
<p>按照刚刚的修改思路，我们把代码重构一下，移除“重复执行”的代码，只校验一次email和password，并且只查询一次数据库。重构之后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> UserRepo userRepo;<span class="comment">//通过依赖注入或者IOC框架注入</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> User <span class="title function_">login</span><span class="params">(String email, String password)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!EmailValidation.validate(email)) &#123;</span><br><span class="line">      <span class="comment">// ... throw InvalidEmailException...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!PasswordValidation.validate(password)) &#123;</span><br><span class="line">      <span class="comment">// ... throw InvalidPasswordException...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userRepo.getUserByEmail(email);</span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span> || !password.equals(user.getPassword()) &#123;</span><br><span class="line">      <span class="comment">// ... throw AuthenticationFailureException...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRepo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkIfUserExisted</span><span class="params">(String email, String password)</span> &#123;</span><br><span class="line">    <span class="comment">//...query db to check if email&amp;password exists</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> User <span class="title function_">getUserByEmail</span><span class="params">(String email)</span> &#123;</span><br><span class="line">    <span class="comment">//...query db to get user by email...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码复用性（Code Reusability）</strong></p>
<p>在专栏的最开始，我们有提到，代码的复用性是评判代码质量的一个非常重要的标准。当时只是点到为止，没有展开讲解，今天，我再带你深入地学习一下这个知识点。</p>
<p><strong>什么是代码的复用性？</strong></p>
<p>我们首先来区分三个概念：代码复用性（Code Reusability）、代码复用（Code Resue）和DRY原则。</p>
<p>代码复用表示一种行为：我们在开发新功能的时候，尽量复用已经存在的代码。代码的可复用性表示一段代码可被复用的特性或能力：我们在编写代码的时候，让代码尽量可复用。DRY原则是一条原则：不要写重复的代码。从定义描述上，它们好像有点类似，但深究起来，三者的区别还是蛮大的。</p>
<p><strong>首先，“不重复”并不代表“可复用”。</strong>在一个项目代码中，可能不存在任何重复的代码，但也并不表示里面有可复用的代码，不重复和可复用完全是两个概念。所以，从这个角度来说，DRY原则跟代码的可复用性讲的是两回事。</p>
<p><strong>其次，“复用”和“可复用性”关注角度不同。</strong>代码“可复用性”是从代码开发者的角度来讲的，“复用”是从代码使用者的角度来讲的。比如，A同事编写了一个UrlUtils类，代码的“可复用性”很好。B同事在开发新功能的时候，直接“复用”A同事编写的UrlUtils类。</p>
<p>尽管复用、可复用性、DRY原则这三者从理解上有所区别，但实际上要达到的目的都是类似的，都是为了减少代码量，提高代码的可读性、可维护性。除此之外，复用已经经过测试的老代码，bug会比从零重新开发要少。</p>
<p>“复用”这个概念不仅可以指导细粒度的模块、类、函数的设计开发，实际上，一些框架、类库、组件等的产生也都是为了达到复用的目的。比如，Spring框架、Google Guava类库、UI组件等等。</p>
<p><strong>怎么提高代码复用性？</strong></p>
<p>实际上，我们前面已经讲到过很多提高代码可复用性的手段，今天算是集中总结一下，我总结了7条，具体如下。</p>
<ul>
<li><u>减少代码耦合</u></li>
</ul>
<p>对于高度耦合的代码，当我们希望复用其中的一个功能，想把这个功能的代码抽取出来成为一个独立的模块、类或者函数的时候，往往会发现牵一发而动全身。移动一点代码，就要牵连到很多其他相关的代码。所以，高度耦合的代码会影响到代码的复用性，我们要尽量减少代码耦合。</p>
<ul>
<li><u>满足单一职责原则</u></li>
</ul>
<p>我们前面讲过，如果职责不够单一，模块、类设计得大而全，那依赖它的代码或者它依赖的代码就会比较多，进而增加了代码的耦合。根据上一点，也就会影响到代码的复用性。相反，越细粒度的代码，代码的通用性会越好，越容易被复用。</p>
<ul>
<li><u>模块化</u></li>
</ul>
<p>这里的“模块”，不单单指一组类构成的模块，还可以理解为单个类、函数。我们要善于将功能独立的代码，封装成模块。独立的模块就像一块一块的积木，更加容易复用，可以直接拿来搭建更加复杂的系统。</p>
<ul>
<li><u>业务与非业务逻辑分离</u></li>
</ul>
<p>越是跟业务无关的代码越是容易复用，越是针对特定业务的代码越难复用。所以，为了复用跟业务无关的代码，我们将业务和非业务逻辑代码分离，抽取成一些通用的框架、类库、组件等。</p>
<ul>
<li><u>通用代码下沉</u></li>
</ul>
<p>从分层的角度来看，越底层的代码越通用、会被越多的模块调用，越应该设计得足够可复用。一般情况下，在代码分层之后，为了避免交叉调用导致调用关系混乱，我们只允许上层代码调用下层代码及同层代码之间的调用，杜绝下层代码调用上层代码。所以，通用的代码我们尽量下沉到更下层。</p>
<ul>
<li><u>继承、多态、抽象、封装</u></li>
</ul>
<p>在讲面向对象特性的时候，我们讲到，利用继承，可以将公共的代码抽取到父类，子类复用父类的属性和方法。利用多态，我们可以动态地替换一段代码的部分逻辑，让这段代码可复用。除此之外，抽象和封装，从更加广义的层面、而非狭义的面向对象特性的层面来理解的话，越抽象、越不依赖具体的实现，越容易复用。代码封装成模块，隐藏可变的细节、暴露不变的接口，就越容易复用。</p>
<ul>
<li><u>应用模板等设计模式</u></li>
</ul>
<p>一些设计模式，也能提高代码的复用性。比如，模板模式利用了多态来实现，可以灵活地替换其中的部分代码，整个流程模板代码可复用。关于应用设计模式提高代码复用性这一部分，我们留在后面慢慢来讲解。</p>
<p>除了刚刚我们讲到的几点，还有一些跟编程语言相关的特性，也能提高代码的复用性，比如泛型编程等。实际上，除了上面讲到的这些方法之外，复用意识也非常重要。在写代码的时候，我们要多去思考一下，这个部分代码是否可以抽取出来，作为一个独立的模块、类或者函数供多处使用。在设计每个模块、类、函数的时候，要像设计一个外部API那样，去思考它的复用性。</p>
<p><strong>辩证思考和灵活应用</strong></p>
<p>实际上，编写可复用的代码并不简单。如果我们在编写代码的时候，已经有复用的需求场景，那根据复用的需求去开发可复用的代码，可能还不算难。但是，如果当下并没有复用的需求，我们只是希望现在编写的代码具有可复用的特点，能在未来某个同事开发某个新功能的时候复用得上。在这种没有具体复用需求的情况下，我们就需要去预测将来代码会如何复用，这就比较有挑战了。</p>
<p>实际上，除非有非常明确的复用需求，否则，为了暂时用不到的复用需求，花费太多的时间、精力，投入太多的开发成本，并不是一个值得推荐的做法。这也违反我们之前讲到的YAGNI原则。</p>
<p>除此之外，有一个著名的原则，叫作“Rule of Three”。这条原则可以用在很多行业和场景中，你可以自己去研究一下。如果把这个原则用在这里，那就是说，我们在第一次写代码的时候，如果当下没有复用的需求，而未来的复用需求也不是特别明确，并且开发可复用代码的成本比较高，那我们就不需要考虑代码的复用性。在之后我们开发新的功能的时候，发现可以复用之前写的这段代码，那我们就重构这段代码，让其变得更加可复用。</p>
<p>也就是说，第一次编写代码的时候，我们不考虑复用性；第二次遇到复用场景的时候，再进行重构使其复用。需要注意的是，“Rule of Three”中的“Three”并不是真的就指确切的“三”，这里就是指“二”。</p>
<h3 id="20-LOD法则"><a href="#20-LOD法则" class="headerlink" title="20. LOD法则"></a>20. LOD法则</h3><p>最后一个设计原则：<u>迪米特法则</u>。尽管它不像SOLID、KISS、DRY原则那样，人尽皆知，但它却非常实用。利用这个原则，能够帮我们实现代码的“高内聚、松耦合”。我们围绕下面几个问题，并结合两个代码实战案例，来深入地学习这个法则。</p>
<ul>
<li>什么是“高内聚、松耦合”？</li>
<li>如何利用迪米特法则来实现“高内聚、松耦合”？</li>
<li>有哪些代码设计是明显违背迪米特法则的？对此又该如何重构？</li>
</ul>
<p><strong>何为“高内聚、松耦合”？</strong></p>
<p>“高内聚、松耦合”是一个非常重要的设计思想，能够有效地提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。实际上，在前面的章节中，我们已经多次提到过这个设计思想。很多设计原则都以实现代码的“高内聚、松耦合”为目的，比如单一职责原则、基于接口而非实现编程等。</p>
<p>实际上，“高内聚、松耦合”是一个比较通用的设计思想，可以用来指导不同粒度代码的设计与开发，比如系统、模块、类，甚至是函数，也可以应用到不同的开发场景中，比如微服务、框架、组件、类库等。为了方便我讲解，接下来我以“类”作为这个设计思想的应用对象来展开讲解，其他应用场景你可以自行类比。</p>
<p>在这个设计思想中，<u>“高内聚”用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计</u>。不过，这两者并非完全独立不相干。高内聚有助于松耦合，松耦合又需要高内聚的支持。</p>
<p><strong>那到底什么是“高内聚”呢？</strong></p>
<p>所谓<u>高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一个类中</u>。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中，代码容易维护。实际上，我们前面讲过的单一职责原则是实现代码高内聚非常有效的设计原则。</p>
<p><strong>我们再来看一下，什么是“松耦合”？</strong></p>
<p>所谓<u>松耦合是说，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动不会或者很少导致依赖类的代码改动</u>。实际上，我们前面讲的依赖注入、接口隔离、基于接口而非实现编程，以及今天讲的迪米特法则，都是为了实现代码的松耦合。</p>
<p><strong>最后，我们来看一下，“内聚”和“耦合”之间的关系。</strong></p>
<p>前面也提到，“高内聚”有助于“松耦合”，同理，“低内聚”也会导致“紧耦合”。关于这一点，我画了一张对比图来解释。图中左边部分的代码结构是“高内聚、松耦合”；右边部分正好相反，是“低内聚、紧耦合”。</p>
<img src="https://static001.geekbang.org/resource/image/62/3c/62275095f1f5817cad8a9ca129a6ec3c.jpg" alt="img" style="zoom: 25%;" />

<p>图中左边部分的代码设计中，类的粒度比较小，每个类的职责都比较单一。相近的功能都放到了一个类中，不相近的功能被分割到了多个类中。这样类更加独立，代码的内聚性更好。因为职责单一，所以每个类被依赖的类就会比较少，代码低耦合。一个类的修改，只会影响到一个依赖类的代码改动。我们只需要测试这一个依赖类是否还能正常工作就行了。</p>
<p>图中右边部分的代码设计中，类粒度比较大，低内聚，功能大而全，不相近的功能放到了一个类中。这就导致很多其他类都依赖这个类。当我们修改这个类的某一个功能代码的时候，会影响依赖它的多个类。我们需要测试这三个依赖类，是否还能正常工作。这也就是所谓的“牵一发而动全身”。</p>
<p>除此之外，从图中我们也可以看出，高内聚、低耦合的代码结构更加简单、清晰，相应地，在可维护性和可读性上确实要好很多。</p>
<p><strong>“迪米特法则”理论描述</strong></p>
<p>迪米特法则的英文翻译是：Law of Demeter，缩写是LOD。单从这个名字上来看，我们完全猜不出这个原则讲的是什么。不过，它还有另外一个更加达意的名字，叫作<u>最小知识原则</u>，英文翻译为：The Least Knowledge Principle。</p>
<p>关于这个设计原则，我们先来看一下它最原汁原味的英文定义：</p>
<blockquote>
<p>Each unit should have only limited knowledge about other units: only units “closely” related to the current unit. Or: Each unit should only talk to its friends; Don’t talk to strangers.</p>
</blockquote>
<p>我们把它直译成中文，就是下面这个样子：</p>
<blockquote>
<p>每个模块（unit）只应该了解那些与它关系密切的模块（units: only units “closely” related to the current unit）的有限知识（knowledge）。或者说，每个模块只和自己的朋友“说话”（talk），不和陌生人“说话”（talk）。</p>
</blockquote>
<p>我们之前讲过，大部分设计原则和思想都非常抽象，有各种各样的解读，要想灵活地应用到实际的开发中，需要有实战经验的积累。迪米特法则也不例外。所以，我结合我自己的理解和经验，对刚刚的定义重新描述一下。注意，为了统一讲解，我把定义描述中的“模块”替换成了“类”。</p>
<blockquote>
<p>不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口（也就是定义中的“有限知识”）。</p>
</blockquote>
<p>从上面的描述中，我们可以看出，迪米特法则包含前后两部分，这两部分讲的是两件事情，我用两个实战案例分别来解读一下。</p>
<p><strong>理论解读与代码实战一</strong></p>
<p>我们先来看这条原则中的前半部分，<strong>“不该有直接依赖关系的类之间，不要有依赖”。</strong>我举个例子解释一下。</p>
<p>这个例子实现了简化版的搜索引擎爬取网页的功能。代码中包含三个主要的类。其中，NetworkTransporter类负责底层网络通信，根据请求获取数据；HtmlDownloader类用来通过URL获取网页；Document表示网页文档，后续的网页内容抽取、分词、索引都是以此为处理对象。具体的代码实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NetworkTransporter</span> &#123;</span><br><span class="line">    <span class="comment">// 省略属性和其他方法...</span></span><br><span class="line">    <span class="keyword">public</span> Byte[] send(HtmlRequest htmlRequest) &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HtmlDownloader</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> NetworkTransporter transporter;<span class="comment">//通过构造函数或IOC注入</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> Html <span class="title function_">downloadHtml</span><span class="params">(String url)</span> &#123;</span><br><span class="line">    Byte[] rawHtml = transporter.send(<span class="keyword">new</span> <span class="title class_">HtmlRequest</span>(url));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Html</span>(rawHtml);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Document</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Html html;</span><br><span class="line">  <span class="keyword">private</span> String url;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Document</span><span class="params">(String url)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.url = url;</span><br><span class="line">    <span class="type">HtmlDownloader</span> <span class="variable">downloader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HtmlDownloader</span>();</span><br><span class="line">    <span class="built_in">this</span>.html = downloader.downloadHtml(url);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码虽然“能用”，能实现我们想要的功能，但是它不够“好用”，有比较多的设计缺陷。你可以先试着思考一下，看看都有哪些缺陷，然后再来看我下面的讲解。</p>
<p><strong>首先，我们来看NetworkTransporter类。</strong>作为一个底层网络通信类，我们希望它的功能尽可能通用，而不只是服务于下载HTML，所以，我们<u>不应该直接依赖太具体的发送对象HtmlRequest</u>。从这一点上讲，NetworkTransporter类的设计违背迪米特法则，依赖了不该有直接依赖关系的HtmlRequest类。</p>
<p>我们应该如何进行重构，让NetworkTransporter类满足迪米特法则呢？我这里有个形象的比喻。假如你现在要去商店买东西，你肯定不会直接把钱包给收银员，让收银员自己从里面拿钱，而是你从钱包里把钱拿出来交给收银员。这里的HtmlRequest对象就相当于钱包，HtmlRequest里的address和content对象就相当于钱。我们应该把address和content交给NetworkTransporter，而非是直接把HtmlRequest交给NetworkTransporter。根据这个思路，NetworkTransporter重构之后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NetworkTransporter</span> &#123;</span><br><span class="line">    <span class="comment">// 省略属性和其他方法...</span></span><br><span class="line">    <span class="keyword">public</span> Byte[] send(String address, Byte[] data) &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们再来看HtmlDownloader类。</strong>这个类的设计没有问题。不过，我们修改了NetworkTransporter的send()函数的定义，而这个类用到了send()函数，所以我们需要对它做相应的修改，修改后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HtmlDownloader</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> NetworkTransporter transporter;<span class="comment">//通过构造函数或IOC注入</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// HtmlDownloader这里也要有相应的修改</span></span><br><span class="line">  <span class="keyword">public</span> Html <span class="title function_">downloadHtml</span><span class="params">(String url)</span> &#123;</span><br><span class="line">    <span class="type">HtmlRequest</span> <span class="variable">htmlRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HtmlRequest</span>(url);</span><br><span class="line">    Byte[] rawHtml = transporter.send(</span><br><span class="line">      htmlRequest.getAddress(), htmlRequest.getContent().getBytes());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Html</span>(rawHtml);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最后，我们来看下Document类。</strong>这个类的问题比较多，主要有三点。</p>
<ul>
<li>第一，<u>构造函数中的downloader.downloadHtml()逻辑复杂，耗时长，不应该放到构造函数中，会影响代码的可测试性</u>。代码的可测试性我们后面会讲到，这里你先知道有这回事就可以了。</li>
<li>第二，HtmlDownloader对象在构造函数中通过new来创建，违反了基于接口而非实现编程的设计思想，也会影响到代码的可测试性。</li>
<li>第三，从业务含义上来讲，Document网页文档没必要依赖HtmlDownloader类，违背了迪米特法则。</li>
</ul>
<p>虽然Document类的问题很多，但修改起来比较简单，只要一处改动就可以解决所有问题。修改之后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Document</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Html html;</span><br><span class="line">  <span class="keyword">private</span> String url;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Document</span><span class="params">(String url, Html html)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.html = html;</span><br><span class="line">    <span class="built_in">this</span>.url = url;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过一个工厂方法来创建Document</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DocumentFactory</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> HtmlDownloader downloader;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">DocumentFactory</span><span class="params">(HtmlDownloader downloader)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.downloader = downloader;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> Document <span class="title function_">createDocument</span><span class="params">(String url)</span> &#123;</span><br><span class="line">    <span class="type">Html</span> <span class="variable">html</span> <span class="operator">=</span> downloader.downloadHtml(url);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Document</span>(url, html);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>理论解读与代码实战二</strong></p>
<p>现在，我们再来看一下这条原则中的后半部分：“有依赖关系的类之间，尽量只依赖必要的接口”。我们还是结合一个例子来讲解。下面这段代码非常简单，Serialization类负责对象的序列化和反序列化。提醒你一下，有个类似的例子在之前讲过，你可以结合着一块儿看一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Serialization</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">serializedResult</span> <span class="operator">=</span> ...;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> serializedResult;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">deserialize</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">deserializedResult</span> <span class="operator">=</span> ...;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> deserializedResult;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单看这个类的设计，没有一点问题。不过，如果我们把它放到一定的应用场景里，那就还有继续优化的空间。假设在我们的项目中，有些类只用到了序列化操作，而另一些类只用到反序列化操作。那基于迪米特法则后半部分“有依赖关系的类之间，尽量只依赖必要的接口”，只用到序列化操作的那部分类不应该依赖反序列化接口。同理，只用到反序列化操作的那部分类不应该依赖序列化接口。</p>
<p>根据这个思路，我们<u>应该将Serialization类拆分为两个更小粒度的类，一个只负责序列化（Serializer类），一个只负责反序列化（Deserializer类）</u>。拆分之后，使用序列化操作的类只需要依赖Serializer类，使用反序列化操作的类只需要依赖Deserializer类。拆分之后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Serializer</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">serializedResult</span> <span class="operator">=</span> ...;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> serializedResult;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Deserializer</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">deserialize</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">deserializedResult</span> <span class="operator">=</span> ...;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> deserializedResult;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不知道你有没有看出来，尽管拆分之后的代码更能满足迪米特法则，但却违背了高内聚的设计思想。高内聚要求相近的功能要放到同一个类中，这样可以方便功能修改的时候，修改的地方不至于过于分散。对于刚刚这个例子来说，如果我们修改了序列化的实现方式，比如从JSON换成了XML，那反序列化的实现逻辑也需要一并修改。在未拆分的情况下，我们只需要修改一个类即可。在拆分之后，我们需要修改两个类。显然，这种设计思路的代码改动范围变大了。</p>
<p>如果我们既不想违背高内聚的设计思想，也不想违背迪米特法则，那我们该如何解决这个问题呢？实际上，通过引入两个接口就能轻松解决这个问题，具体的代码如下所示。实际上，我们在讲到“接口隔离原则”的时候，第三个例子就使用了类似的实现思路，你可以结合着一块儿来看。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">  String <span class="title function_">serialize</span><span class="params">(Object object)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Deserializable</span> &#123;</span><br><span class="line">  Object <span class="title function_">deserialize</span><span class="params">(String text)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Serialization</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>, Deserializable &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">serializedResult</span> <span class="operator">=</span> ...;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> serializedResult;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">deserialize</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">deserializedResult</span> <span class="operator">=</span> ...;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> deserializedResult;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoClass_1</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Serializable serializer;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Demo</span><span class="params">(Serializable serializer)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.serializer = serializer;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoClass_2</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Deserializable deserializer;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Demo</span><span class="params">(Deserializable deserializer)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.deserializer = deserializer;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽管我们还是要往DemoClass_1的构造函数中，传入包含序列化和反序列化的Serialization实现类，但是，我们依赖的Serializable接口只包含序列化操作，DemoClass_1无法使用Serialization类中的反序列化接口，对反序列化操作无感知，这也就符合了迪米特法则后半部分所说的“依赖有限接口”的要求。</p>
<p>实际上，上面的的代码实现思路，也体现了“基于接口而非实现编程”的设计原则，结合迪米特法则，我们可以总结出一条新的设计原则，那就是“基于最小接口而非最大实现编程”。有些同学之前问，新的设计模式和设计原则是怎么创造出来的，实际上，就是在大量的实践中，针对开发痛点总结归纳出来的套路。</p>
<p><strong>辩证思考与灵活应用</strong></p>
<p>对于实战二最终的设计思路，你有没有什么不同的观点呢？</p>
<p>整个类只包含序列化和反序列化两个操作，只用到序列化操作的使用者，即便能够感知到仅有的一个反序列化函数，问题也不大。那为了满足迪米特法则，我们将一个非常简单的类，拆分出两个接口，是否有点过度设计的意思呢？</p>
<p>设计原则本身没有对错，只有能否用对之说。不要为了应用设计原则而应用设计原则，我们在应用设计原则的时候，一定要具体问题具体分析。</p>
<p>对于刚刚这个Serialization类来说，只包含两个操作，确实没有太大必要拆分成两个接口。但是，如果我们对Serialization类添加更多的功能，实现更多更好用的序列化、反序列化函数，我们来重新考虑一下这个问题。修改之后的具体的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Serializer</span> &#123; <span class="comment">// 参看JSON的接口定义</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(Object object)</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">serializeMap</span><span class="params">(Map map)</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">serializeList</span><span class="params">(List list)</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">deserialize</span><span class="params">(String objectString)</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">  <span class="keyword">public</span> Map <span class="title function_">deserializeMap</span><span class="params">(String mapString)</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">  <span class="keyword">public</span> List <span class="title function_">deserializeList</span><span class="params">(String listString)</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这种场景下，第二种设计思路要更好些。因为基于之前的应用场景来说，大部分代码只需要用到序列化的功能。对于这部分使用者，没必要了解反序列化的“知识”，而修改之后的Serialization类，反序列化的“知识”，从一个函数变成了三个。一旦任一反序列化操作有代码改动，我们都需要检查、测试所有依赖Serialization类的代码是否还能正常工作。为了减少耦合和测试工作量，我们应该按照迪米特法则，将反序列化和序列化的功能隔离开来。</p>
<h3 id="21-重构的目的、对象、时机和方法"><a href="#21-重构的目的、对象、时机和方法" class="headerlink" title="21. 重构的目的、对象、时机和方法"></a>21. 重构的目的、对象、时机和方法</h3><p>重构代码对一个工程师能力的要求，要比单纯写代码高得多。重构需要你能洞察出代码存在的坏味道或者设计上的不足，并且能合理、熟练地利用设计思想、原则、模式、编程规范等理论知识解决这些问题。</p>
<p>另一方面，很多工程师对为什么要重构、到底重构什么、什么时候重构、又该如何重构等相关问题理解不深，对重构没有系统性、全局性的认识，面对一堆烂代码，没有重构技巧的指导，只能想到哪改到哪，并不能全面地改善代码质量。</p>
<p><strong>重构的目的：为什么要重构（why）？</strong></p>
<p>虽然对于你来说，重构这个词可能不需要过多解释，但我们还是简单来看一下，大师是怎么描述它的。软件设计大师Martin Fowler 是这样定义重构的：“重构是一种对软件内部结构的改善，目的是在不改变软件的可见行为的情况下，使其更易理解，修改成本更低。”</p>
<p>实际上，当讲到重构的时候，很多书籍都会引用这个定义。这个定义中有一个值得强调的点：“重构不改变外部的可见行为”。我们<u>可以把重构理解为，在保持功能不变的前提下，利用设计思想、原则、模式、编程规范等理论来优化代码，修改设计上的不足，提高代码质量</u>。</p>
<p><strong>为什么要进行代码重构？</strong></p>
<p>首先，重构是时刻保证代码质量的一个极其有效的手段，不至于让代码腐化到无可救药的地步。项目在演进，代码不停地在堆砌。如果没有人为代码的质量负责任，代码总是会往越来越混乱的方向演进。当混乱到一定程度之后，量变引起质变，项目的维护成本已经高过重新开发一套新代码的成本，想要再去重构，已经没有人能做到了。</p>
<p>其次，优秀的代码或架构不是一开始就能完全设计好的，就像优秀的公司和产品也都是迭代出来的。我们无法100%遇见未来的需求，也没有足够的精力、时间、资源为遥远的未来买单，所以，随着系统的演进，重构代码也是不可避免的。</p>
<p>最后，重构是避免过度设计的有效手段。在我们维护代码的过程中，真正遇到问题的时候，再对代码进行重构，能有效避免前期投入太多时间做过度的设计，做到有的放矢。</p>
<p><strong>除此之外，重构对一个工程师本身技术的成长也有重要的意义。</strong></p>
<p>从前面我给出的重构的定义来看，重构实际上是对我们学习的经典设计思想、设计原则、设计模式、编程规范的一种应用。重构实际上就是将这些理论知识，应用到实践的一个很好的场景，能够锻炼我们熟练使用这些理论知识的能力。除此之外，平时堆砌业务逻辑，你可能总觉得没啥成长，而将一个比较烂的代码重构成一个比较好的代码，会让你很有成就感。</p>
<p>除此之外，重构能力也是衡量一个工程师代码能力的有效手段。所谓“初级工程师在维护代码，高级工程师在设计代码，资深工程师在重构代码”，这句话的意思是说，初级工程师在已有代码框架下修改bug、修改添加功能代码；高级工程师从零开始设计代码结构、搭建代码框架；而资深工程师为代码质量负责，需要发觉代码存在的问题，重构代码，时刻保证代码质量处于一个可控的状态（当然这里的初级、高级、资深只是一个相对概念，并不是一个确定的职级）。</p>
<p><strong>重构的对象：到底重构什么（what）？</strong></p>
<p>根据重构的规模，我们可以笼统地分为大规模高层次重构（以下简称为“大型重构”）和小规模低层次的重构（以下简称为“小型重构”）。</p>
<p><u>大型重构指的是对顶层代码设计的重构，包括：系统、模块、代码结构、类与类之间的关系等的重构，重构的手段有：分层、模块化、解耦、抽象可复用组件等等</u>。这类重构的工具就是我们学习过的那些设计思想、原则和模式。这类重构涉及的代码改动会比较多，影响面会比较大，所以难度也较大，耗时会比较长，引入bug的风险也会相对比较大。</p>
<p><u>小型重构指的是对代码细节的重构，主要是针对类、函数、变量等代码级别的重构，比如规范命名、规范注释、消除超大类或函数、提取重复代码等等</u>。小型重构更多的是利用我们能后面要讲到的编码规范。这类重构要修改的地方比较集中，比较简单，可操作性较强，耗时会比较短，引入bug的风险相对来说也会比较小。你只需要熟练掌握各种编码规范，就可以做到得心应手。</p>
<p>关于具体如何来做大型重构和小型重构，我会在后面的课程中详细讲解。</p>
<p><strong>重构的时机：什么时候重构（when）？</strong></p>
<p>搞清楚了为什么重构，到底重构什么，我们再来看一下，什么时候重构？是代码烂到一定程度之后才去重构吗？当然不是。因为当代码真的烂到出现“开发效率低，招了很多人，天天加班，出活却不多，线上bug频发，领导发飙，中层束手无策，工程师抱怨不断，查找bug困难”的时候，基本上重构也无法解决问题了。</p>
<p>我个人比较反对，平时不注重代码质量，堆砌烂代码，实在维护不了了就大刀阔斧地重构、甚至重写的行为。有时候项目代码太多了，重构很难做得彻底，最后又搞出来一个“四不像的怪物”，这就更麻烦了！所以，寄希望于在代码烂到一定程度之后，集中重构解决所有问题是不现实的，我们必须探索一条<strong>可持续、可演进</strong>的方式。</p>
<p>所以，我特别提倡的重构策略是持续重构。这也是我在工作中特别喜欢干的事情。平时没有事情的时候，你可以看看项目中有哪些写得不够好的、可以优化的代码，主动去重构一下。或者，在修改、添加某个功能代码的时候，你也可以顺手把不符合编码规范、不好的设计重构一下。总之，就像把单元测试、Code Review作为开发的一部分，我们如果能把持续重构也作为开发的一部分，成为一种开发习惯，对项目、对自己都会很有好处。</p>
<p>尽管我们说重构能力很重要，但持续重构意识更重要。我们要正确地看待代码质量和重构这件事情。技术在更新、需求在变化、人员在流动，代码质量总会在下降，代码总会存在不完美，重构就会持续在进行。时刻具有持续重构意识，才能避免开发初期就过度设计，避免代码维护的过程中质量的下降。而那些看到别人代码有点瑕疵就一顿乱骂，或者花尽心思去构思一个完美设计的人，往往都是因为没有树立正确的代码质量观，没有持续重构意识。</p>
<p><strong>重构的方法：又该如何重构（how）？</strong></p>
<p>前面我们讲到，按照重构的规模，重构可以笼统地分为大型重构和小型重构。对于这两种不同规模的重构，我们要区别对待。</p>
<p>对于大型重构来说，因为涉及的模块、代码会比较多，如果项目代码质量又比较差，耦合比较严重，往往会牵一发而动全身，本来觉得一天就能完成的重构，你会发现越改越多、越改越乱，没一两个礼拜都搞不定。而新的业务开发又与重构相冲突，最后只能半途而废，revert掉所有的改动，很失落地又去堆砌烂代码了。</p>
<p>在进行大型重构的时候，我们要提前做好完善的重构计划，有条不紊地分阶段来进行。每个阶段完成一小部分代码的重构，然后提交、测试、运行，发现没有问题之后，再继续进行下一阶段的重构，保证代码仓库中的代码一直处于可运行、逻辑正确的状态。每个阶段，我们都要控制好重构影响到的代码范围，考虑好如何兼容老的代码逻辑，必要的时候还需要写一些兼容过渡代码。只有这样，我们才能让每一阶段的重构都不至于耗时太长（最好一天就能完成），不至于与新的功能开发相冲突。</p>
<p>大规模高层次的重构一定是有组织、有计划，并且非常谨慎的，需要有经验、熟悉业务的资深同事来主导。而小规模低层次的重构，因为影响范围小，改动耗时短，所以，只要你愿意并且有时间，随时都可以去做。实际上，除了人工去发现低层次的质量问题，我们还可以借助很多成熟的静态代码分析工具（比如CheckStyle、FindBugs、PMD），来自动发现代码中的问题，然后针对性地进行重构优化。</p>
<p>对于重构这件事情，资深的工程师、项目leader要负起责任来，没事就重构一下代码，时刻保证代码质量处在一个良好的状态。否则，一旦出现“破窗效应”，一个人往里堆了一些烂代码，之后就会有更多的人往里堆更烂的代码。毕竟往项目里堆砌烂代码的成本太低了。不过，保持代码质量最好的方法还是打造一种好的技术氛围，以此来驱动大家主动去关注代码质量，持续重构代码。</p>
<h3 id="22-单元测试"><a href="#22-单元测试" class="headerlink" title="22. 单元测试"></a>22. 单元测试</h3><p>如何保证重构不出错呢？你需要熟练掌握各种设计原则、思想、模式，还需要对所重构的业务和代码有足够的了解。除了这些个人能力因素之外，最可落地执行、最有效的保证重构不出错的手段应该就是<strong>单元测试</strong>（Unit Testing）了。当重构完成之后，如果新的代码仍然能通过单元测试，那就说明代码原有逻辑的正确性未被破坏，原有的外部可见行为未变，符合上一节课中我们对重构的定义。</p>
<p><strong>什么是单元测试？</strong></p>
<p>单元测试由研发工程师自己来编写，用来测试自己写的代码的正确性。我们常常将它跟集成测试放到一块来对比。单元测试相对于集成测试（Integration Testing）来说，测试的粒度更小一些。集成测试的测试对象是整个系统或者某个功能模块，比如测试用户注册、登录功能是否正常，是一种端到端（end to end）的测试。而单元测试的测试对象是类或者函数，用来测试一个类和函数是否都按照预期的逻辑执行。这是代码层级的测试。</p>
<p>这么说比较理论，我举个例子来解释一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Text</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Text</span><span class="params">(String content)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.content = content;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 将字符串转化成数字，忽略字符串中的首尾空格；</span></span><br><span class="line"><span class="comment">   * 如果字符串中包含除首尾空格之外的非数字字符，则返回null。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> Integer <span class="title function_">toNumber</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (content == <span class="literal">null</span> || content.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...省略代码实现...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们要测试Text类中的toNumber()函数的正确性，应该如何编写单元测试呢？</p>
<p>实际上，写单元测试本身不需要什么高深技术。它更多的是考验程序员思维的缜密程度，看能否设计出覆盖各种正常及异常情况的测试用例，来保证代码在任何预期或非预期的情况下都能正确运行。</p>
<p>为了保证测试的全面性，针对toNumber()函数，我们需要设计下面这样几个测试用例。</p>
<ul>
<li>如果字符串只包含数字：“123”，toNumber()函数输出对应的整数：123。</li>
<li>如果字符串是空或者null，toNumber()函数返回：null。</li>
<li>如果字符串包含首尾空格：“ 123”，“123 ”，“ 123 ”，toNumber()返回对应的整数：123。</li>
<li>如果字符串包含多个首尾空格：“ 123 ”，toNumber()返回对应的整数：123；</li>
<li>如果字符串包含非数字字符：“123a4”，“123 4”，toNumber()返回null；</li>
</ul>
<p>当我们设计好测试用例之后，剩下的就是将其翻译成代码了。翻译成代码的过程非常简单，我把代码贴在下面了，你可以参考一下（注意，我们这里没有使用任何测试框架）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Assert</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">assertEquals</span><span class="params">(Integer expectedValue, Integer actualValue)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (actualValue != expectedValue) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> String.format(</span><br><span class="line">              <span class="string">&quot;Test failed, expected: %d, actual: %d.&quot;</span>, expectedValue, actualValue);</span><br><span class="line">      System.out.println(message);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Test succeeded.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">assertNull</span><span class="params">(Integer actualValue)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isNull</span> <span class="operator">=</span> actualValue == <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (isNull) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Test succeeded.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Test failed, the value is not null:&quot;</span> + actualValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isNull;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCaseRunner</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Run testToNumber()&quot;</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">TextTest</span>().testToNumber();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;Run testToNumber_nullorEmpty()&quot;</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">TextTest</span>().testToNumber_nullorEmpty();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;Run testToNumber_containsLeadingAndTrailingSpaces()&quot;</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">TextTest</span>().testToNumber_containsLeadingAndTrailingSpaces();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;Run testToNumber_containsMultiLeadingAndTrailingSpaces()&quot;</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">TextTest</span>().testToNumber_containsMultiLeadingAndTrailingSpaces();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;Run testToNumber_containsInvalidCharaters()&quot;</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">TextTest</span>().testToNumber_containsInvalidCharaters();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TextTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testToNumber</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Text</span> <span class="variable">text</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Text</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    Assert.assertEquals(<span class="number">123</span>, text.toNumber());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testToNumber_nullorEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Text</span> <span class="variable">text1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Text</span>(<span class="literal">null</span>);</span><br><span class="line">    Assert.assertNull(text1.toNumber());</span><br><span class="line"></span><br><span class="line">    <span class="type">Text</span> <span class="variable">text2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Text</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    Assert.assertNull(text2.toNumber());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testToNumber_containsLeadingAndTrailingSpaces</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Text</span> <span class="variable">text1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Text</span>(<span class="string">&quot; 123&quot;</span>);</span><br><span class="line">    Assert.assertEquals(<span class="number">123</span>, text1.toNumber());</span><br><span class="line"></span><br><span class="line">    <span class="type">Text</span> <span class="variable">text2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Text</span>(<span class="string">&quot;123 &quot;</span>);</span><br><span class="line">    Assert.assertEquals(<span class="number">123</span>, text2.toNumber());</span><br><span class="line"></span><br><span class="line">    <span class="type">Text</span> <span class="variable">text3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Text</span>(<span class="string">&quot; 123 &quot;</span>);</span><br><span class="line">    Assert.assertEquals(<span class="number">123</span>, text3.toNumber());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testToNumber_containsMultiLeadingAndTrailingSpaces</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Text</span> <span class="variable">text1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Text</span>(<span class="string">&quot;  123&quot;</span>);</span><br><span class="line">    Assert.assertEquals(<span class="number">123</span>, text1.toNumber());</span><br><span class="line"></span><br><span class="line">    <span class="type">Text</span> <span class="variable">text2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Text</span>(<span class="string">&quot;123  &quot;</span>);</span><br><span class="line">    Assert.assertEquals(<span class="number">123</span>, text2.toNumber());</span><br><span class="line"></span><br><span class="line">    <span class="type">Text</span> <span class="variable">text3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Text</span>(<span class="string">&quot;  123  &quot;</span>);</span><br><span class="line">    Assert.assertEquals(<span class="number">123</span>, text3.toNumber());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testToNumber_containsInvalidCharaters</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Text</span> <span class="variable">text1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Text</span>(<span class="string">&quot;123a4&quot;</span>);</span><br><span class="line">    Assert.assertNull(text1.toNumber());</span><br><span class="line"></span><br><span class="line">    <span class="type">Text</span> <span class="variable">text2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Text</span>(<span class="string">&quot;123 4&quot;</span>);</span><br><span class="line">    Assert.assertNull(text2.toNumber());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么要写单元测试？</strong></p>
<p>单元测试除了能有效地为重构保驾护航之外，也是保证代码质量最有效的两个手段之一（另一个是Code Review）。我在Google工作的时候，写了大量的单元测试代码，结合我的这些开发经验，我总结了以下几点单元测试的好处。尽管有些听起来有点“务虚”，但如果你认真写过一些单元测试的话，应该会很有共鸣。</p>
<p><u>1.单元测试能有效地帮你发现代码中的bug</u></p>
<p>能否写出bug free的代码，是判断工程师编码能力的重要标准之一，也是很多大厂面试考察的重点，特别是像FLAG这样的外企。通过单元测试也常常会发现代码中的很多考虑不全面的地方。</p>
<p>在离开Google之后，尽管我就职的很多公司，其开发模式都是“快、糙、猛”，对单元测试根本没有要求，但我还是坚持为自己提交的每一份代码，都编写完善的单元测试。得益于此，我写的代码几乎是bug free的。这也节省了我很多fix低级bug的时间，能够有时间去做其他更有意义的事情，我也因此在工作上赢得了很多人的认可。可以这么说，坚持写单元测试是保证我的代码质量的一个“杀手锏”，也是帮助我拉开与其他人差距的一个“小秘密”。</p>
<p><u>2.写单元测试能帮你发现代码设计上的问题</u></p>
<p>前面我们提到，代码的可测试性是评判代码质量的一个重要标准。对于一段代码，如果很难为其编写单元测试，或者单元测试写起来很吃力，需要依靠单元测试框架里很高级的特性才能完成，那往往就意味着代码设计得不够合理，比如，没有使用依赖注入、大量使用静态函数、全局变量、代码高度耦合等。</p>
<p><u>3.单元测试是对集成测试的有力补充</u></p>
<p>程序运行的bug往往出现在一些边界条件、异常情况下，比如，除数未判空、网络超时。而大部分异常情况都比较难在测试环境中模拟。而单元测试可以利用下一节课中讲到的mock的方式，控制mock的对象返回我们需要模拟的异常，来测试代码在这些异常情况的表现。</p>
<p>除此之外，对于一些复杂系统来说，集成测试也无法覆盖得很全面。复杂系统往往有很多模块。每个模块都有各种输入、输出、异常情况，组合起来，整个系统就有无数测试场景需要模拟，无数的测试用例需要设计，再强大的测试团队也无法穷举完备。</p>
<p>尽管单元测试无法完全替代集成测试，但如果我们能保证每个类、每个函数都能按照我们的预期来执行，底层bug少了，那组装起来的整个系统，出问题的概率也就相应减少了。</p>
<p><u>4.写单元测试的过程本身就是代码重构的过程</u></p>
<p>上一节课中，我们提到，要把持续重构作为开发的一部分来执行，那写单元测试实际上就是落地执行持续重构的一个有效途径。设计和实现代码的时候，我们很难把所有的问题都想清楚。而编写单元测试就相当于对代码的一次自我Code Review，在这个过程中，我们可以发现一些设计上的问题（比如代码设计的不可测试）以及代码编写方面的问题（比如一些边界条件处理不当）等，然后针对性的进行重构。</p>
<p><u>5.阅读单元测试能帮助你快速熟悉代码</u></p>
<p>阅读代码最有效的手段，就是先了解它的业务背景和设计思路，然后再去看代码，这样代码读起来就会轻松很多。但据我了解，程序员都不怎么喜欢写文档和注释，而大部分程序员写的代码又很难做到“不言自明”。在没有文档和注释的情况下，单元测试就起了替代性作用。单元测试用例实际上就是用户用例，反映了代码的功能和如何使用。借助单元测试，我们不需要深入的阅读代码，便能知道代码实现了什么功能，有哪些特殊情况需要考虑，有哪些边界条件需要处理。</p>
<p><u>6.单元测试是TDD可落地执行的改进方案</u></p>
<p>测试驱动开发（Test-Driven Development，简称TDD）是一个经常被提及但很少被执行的开发模式。它的核心指导思想就是测试用例先于代码编写。不过，要让程序员能彻底地接受和习惯这种开发模式还是挺难的，毕竟很多程序员连单元测试都懒得写，更何况在编写代码之前先写好测试用例了。</p>
<p>我个人觉得，单元测试正好是对TDD的一种改进方案，先写代码，紧接着写单元测试，最后根据单元测试反馈出来问题，再回过头去重构代码。这个开发流程更加容易被接受，更加容易落地执行，而且又兼顾了TDD的优点。</p>
<p><strong>如何编写单元测试？</strong></p>
<p>前面在讲什么是单元测试的时候，我们举了一个给toNumber()函数写单元测试的例子。根据那个例子，我们可以总结得出，写单元测试就是针对代码设计覆盖各种输入、异常、边界条件的测试用例，并将这些测试用例翻译成代码的过程。</p>
<p>在把测试用例翻译成代码的时候，我们可以利用单元测试框架，来简化测试代码的编写。比如，Java中比较出名的单元测试框架有Junit、TestNG、Spring Test等。这些框架提供了通用的执行流程（比如执行测试用例的TestCaseRunner）和工具类库（比如各种Assert判断函数）等。借助它们，我们在编写测试代码的时候，只需要关注测试用例本身的编写即可。</p>
<p>针对toNumber()函数的测试用例，我们利用Junit单元测试框架重新实现一下，具体代码如下所示。你可以拿它跟之前没有利用测试框架的实现方式对比一下，看是否简化了很多呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TextTest</span> &#123;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testToNumber</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Text</span> <span class="variable">text</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Text</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    Assert.assertEquals(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>), text.toNumber());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testToNumber_nullorEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Text</span> <span class="variable">text1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Text</span>(<span class="literal">null</span>);</span><br><span class="line">    Assert.assertNull(text1.toNumber());</span><br><span class="line"></span><br><span class="line">    <span class="type">Text</span> <span class="variable">text2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Text</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    Assert.assertNull(text2.toNumber());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testToNumber_containsLeadingAndTrailingSpaces</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Text</span> <span class="variable">text1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Text</span>(<span class="string">&quot; 123&quot;</span>);</span><br><span class="line">    Assert.assertEquals(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>), text1.toNumber());</span><br><span class="line"></span><br><span class="line">    <span class="type">Text</span> <span class="variable">text2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Text</span>(<span class="string">&quot;123 &quot;</span>);</span><br><span class="line">    Assert.assertEquals(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>), text2.toNumber());</span><br><span class="line"></span><br><span class="line">    <span class="type">Text</span> <span class="variable">text3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Text</span>(<span class="string">&quot; 123 &quot;</span>);</span><br><span class="line">    Assert.assertEquals(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>), text3.toNumber());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testToNumber_containsMultiLeadingAndTrailingSpaces</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Text</span> <span class="variable">text1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Text</span>(<span class="string">&quot;  123&quot;</span>);</span><br><span class="line">    Assert.assertEquals(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>), text1.toNumber());</span><br><span class="line"></span><br><span class="line">    <span class="type">Text</span> <span class="variable">text2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Text</span>(<span class="string">&quot;123  &quot;</span>);</span><br><span class="line">    Assert.assertEquals(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>), text2.toNumber());</span><br><span class="line"></span><br><span class="line">    <span class="type">Text</span> <span class="variable">text3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Text</span>(<span class="string">&quot;  123  &quot;</span>);</span><br><span class="line">    Assert.assertEquals(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>), text3.toNumber());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testToNumber_containsInvalidCharaters</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Text</span> <span class="variable">text1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Text</span>(<span class="string">&quot;123a4&quot;</span>);</span><br><span class="line">    Assert.assertNull(text1.toNumber());</span><br><span class="line"></span><br><span class="line">    <span class="type">Text</span> <span class="variable">text2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Text</span>(<span class="string">&quot;123 4&quot;</span>);</span><br><span class="line">    Assert.assertNull(text2.toNumber());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于如何使用这些单元测试框架，大部分框架都给出了非常详细的官方文档，你可以自行查阅。这些东西理解和掌握起来没有太大难度，所以这不是专栏要讲解的重点。关于如何编写单元测试，我更希望传达给你一些我的经验总结。具体包括以下几点。</p>
<p><u>1.写单元测试真的是件很耗时的事情吗？</u></p>
<p>尽管单元测试的代码量可能是被测代码本身的1～2倍，写的过程很繁琐，但并不是很耗时。毕竟我们不需要考虑太多代码设计上的问题，测试代码实现起来也比较简单。不同测试用例之间的代码差别可能并不是很大，简单copy-paste改改就行。</p>
<p><u>2.对单元测试的代码质量有什么要求吗？</u></p>
<p>单元测试毕竟不会在产线上运行，而且每个类的测试代码也比较独立，基本不互相依赖。所以，相对于被测代码，我们对单元测试代码的质量可以放低一些要求。命名稍微有些不规范，代码稍微有些重复，也都是没有问题的。</p>
<p><u>3.单元测试只要覆盖率高就够了吗？</u></p>
<p>单元测试覆盖率是比较容易量化的指标，常常作为单元测试写得好坏的评判标准。有很多现成的工具专门用来做覆盖率统计，比如，JaCoCo、Cobertura、Emma、Clover。覆盖率的计算方式有很多种，比较简单的是语句覆盖，稍微高级点的有：条件覆盖、判定覆盖、路径覆盖。</p>
<p>不管覆盖率的计算方式如何高级，将覆盖率作为衡量单元测试质量的唯一标准是不合理的。实际上，更重要的是要看测试用例是否覆盖了所有可能的情况，特别是一些corner case。我来举个简单的例子解释一下。</p>
<p>像下面这段代码，我们只需要一个测试用例就可以做到100%覆盖率，比如cal(10.0, 2.0)，但并不代表测试足够全面了，我们还需要考虑，当除数等于０的情况下，代码执行是否符合预期。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cal</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，过度关注单元测试的覆盖率会导致开发人员为了提高覆盖率，写很多没有必要的测试代码，比如get、set方法非常简单，没有必要测试。从过往的经验上来讲，一个项目的单元测试覆盖率在60～70%即可上线。如果项目对代码质量要求比较高，可以适当提高单元测试覆盖率的要求。</p>
<p><u>4.写单元测试需要了解代码的实现逻辑吗？</u></p>
<p>单元测试不要依赖被测试函数的具体实现逻辑，它只关心被测函数实现了什么功能。我们切不可为了追求覆盖率，逐行阅读代码，然后针对实现逻辑编写单元测试。否则，一旦对代码进行重构，在代码的外部行为不变的情况下，对代码的实现逻辑进行了修改，那原本的单元测试都会运行失败，也就起不到为重构保驾护航的作用了，也违背了我们写单元测试的初衷。</p>
<p><u>5.如何选择单元测试框架？</u></p>
<p>写单元测试本身不需要太复杂的技术，大部分单元测试框架都能满足。在公司内部，起码团队内部需要统一单元测试框架。如果自己写的代码用已经选定的单元测试框架无法测试，那多半是代码写得不够好，代码的可测试性不够好。这个时候，我们要重构自己的代码，让其更容易测试，而不是去找另一个更加高级的单元测试框架。</p>
<p><strong>单元测试为何难落地执行？</strong></p>
<p>虽然很多书籍中都会讲到，单元测试是保证重构不出错的有效手段；也有非常多人已经认识到单元测试的重要性。但是有多少项目有完善的、高质量的单元测试呢？据我了解，真的非常非常少，包括BAT这样级别公司的项目。如果不相信的话，你可以去看一下国内很多大厂开源的项目，有很多项目完全没有单元测试，还有很多项目的单元测试写得非常不完备，仅仅测试了逻辑是否运行正确而已。所以，100%落实执行单元测试是件“知易行难”的事。</p>
<p>写单元测试确实是一件考验耐心的活儿。一般情况下，单元测试的代码量要大于被测试代码量，甚至是要多出好几倍。很多人往往会觉得写单元测试比较繁琐，并且没有太多挑战，而不愿意去做。有很多团队和项目在刚开始推行单元测试的时候，还比较认真，执行得比较好。但当开发任务紧了之后，就开始放低对单元测试的要求，一旦出现<a href="https://wiki.mbalib.com/wiki/%E7%A0%B4%E7%AA%97%E6%95%88%E5%BA%94">破窗效应</a>，慢慢的，大家就都不写了，这种情况很常见。</p>
<p>还有一种情况就是，由于历史遗留问题，原来的代码都没有写单元测试，代码已经堆砌了十几万行了，不可能再一个一个去补单元测试。这种情况下，我们首先要保证新写的代码都要有单元测试，其次，每次在改动到某个类时，如果没有单元测试就顺便补上，不过这要求工程师们有足够强的主人翁意识（ownership），毕竟光靠leader督促，很多事情是很难执行到位的。</p>
<p>除此之外，还有人觉得，有了测试团队，写单元测试就是浪费时间，没有必要。程序员这一行业本该是智力密集型的，但现在很多公司把它搞成劳动密集型的，包括一些大厂，在开发过程中，既没有单元测试，也没有Code Review流程。即便有，做的也是差强人意。写好代码直接提交，然后丢给黑盒测试狠命去测，测出问题就反馈给开发团队再修改，测不出的问题就留在线上出了问题再修复。</p>
<p>在这样的开发模式下，团队往往觉得没有必要写单元测试，但如果我们把单元测试写好、做好Code Review，重视起代码质量，其实可以很大程度上减少黑盒测试的投入。我在Google的时候，很多项目几乎没有测试团队参与，代码的正确性完全靠开发团队来保障，线上bug反倒非常少。</p>
<p>以上是我对单元测试的认知和实践心得。现在互联网信息如此的公开透明，网上有很多文章可以参考，对于程序员这个具有很强学习能力的群体来说，学会如何写单元测试并不是一件难事，难的是能够真正感受到它的作用，并且打心底认可、能100%落地执行。这也是我今天的课程特别想传达给你的一点。</p>
<h3 id="23-解耦代码"><a href="#23-解耦代码" class="headerlink" title="23. 解耦代码"></a>23. 解耦代码</h3><p><strong>“解耦”为何如此重要？</strong></p>
<p>软件设计与开发最重要的工作之一就是应对复杂性。人处理复杂性的能力是有限的。过于复杂的代码往往在可读性、可维护性上都不友好。那如何来控制代码的复杂性呢？手段有很多，我个人认为，最关键的就是解耦，保证代码松耦合、高内聚。如果说重构是保证代码质量不至于腐化到无可救药地步的有效手段，那么利用解耦的方法对代码重构，就是保证代码不至于复杂到无法控制的有效手段。</p>
<p>“高内聚、松耦合”是一个比较通用的设计思想，不仅可以指导细粒度的类和类之间关系的设计，还能指导粗粒度的系统、架构、模块的设计。相对于编码规范，它能够在更高层次上提高代码的可读性和可维护性。</p>
<p>不管是阅读代码还是修改代码，“高内聚、松耦合”的特性可以让我们聚焦在某一模块或类中，不需要了解太多其他模块或类的代码，让我们的焦点不至于过于发散，降低了阅读和修改代码的难度。而且，因为依赖关系简单，耦合小，修改代码不至于牵一发而动全身，代码改动比较集中，引入bug的风险也就减少了很多。同时，“高内聚、松耦合”的代码可测试性也更加好，容易mock或者很少需要mock外部依赖的模块或者类。</p>
<p>除此之外，代码“高内聚、松耦合”，也就意味着，代码结构清晰、分层和模块化合理、依赖关系简单、模块或类之间的耦合小，那代码整体的质量就不会差。即便某个具体的类或者模块设计得不怎么合理，代码质量不怎么高，影响的范围是非常有限的。我们可以聚焦于这个模块或者类，做相应的小型重构。而相对于代码结构的调整，这种改动范围比较集中的小型重构的难度就容易多了。</p>
<p><strong>代码是否需要“解耦”？</strong></p>
<p>那现在问题来了，我们该怎么判断代码的耦合程度呢？或者说，怎么判断代码是否符合“高内聚、松耦合”呢？再或者说，如何判断系统是否需要解耦重构呢？</p>
<p>间接的衡量标准有很多，前面我们讲到了一些，比如，看修改代码会不会牵一发而动全身。除此之外，还有一个直接的衡量标准，也是我在阅读源码的时候经常会用到的，那就是把模块与模块之间、类与类之间的依赖关系画出来，根据依赖关系图的复杂性来判断是否需要解耦重构。</p>
<p>如果依赖关系复杂、混乱，那从代码结构上来讲，可读性和可维护性肯定不是太好，那我们就需要考虑是否可以通过解耦的方法，让依赖关系变得清晰、简单。当然，这种判断还是有比较强的主观色彩，但是可以作为一种参考和梳理依赖的手段，配合间接的衡量标准一块来使用。</p>
<p><strong>如何给代码“解耦”？</strong></p>
<p>前面我们能讲了解耦的重要性，以及如何判断是否需要解耦，接下来，我们再来看一下，如何进行解耦。</p>
<p><u>1.封装与抽象</u></p>
<p>封装和抽象作为两个非常通用的设计思想，可以应用在很多设计场景中，比如系统、模块、lib、组件、接口、类等等的设计。封装和抽象可以有效地隐藏实现的复杂性，隔离实现的易变性，给依赖的模块提供稳定且易用的抽象接口。</p>
<p>比如，Unix系统提供的open()文件操作函数，我们用起来非常简单，但是底层实现却非常复杂，涉及权限控制、并发控制、物理存储等等。我们通过将其封装成一个抽象的open()函数，能够有效控制代码复杂性的蔓延，将复杂性封装在局部代码中。除此之外，因为open()函数基于抽象而非具体的实现来定义，所以我们在改动open()函数的底层实现的时候，并不需要改动依赖它的上层代码，也符合我们前面提到的“高内聚、松耦合”代码的评判标准。</p>
<p><u>2.中间层</u></p>
<p>引入中间层能简化模块或类之间的依赖关系。下面这张图是引入中间层前后的依赖关系对比图。在引入数据存储中间层之前，A、B、C三个模块都要依赖内存一级缓存、Redis二级缓存、DB持久化存储三个模块。在引入中间层之后，三个模块只需要依赖数据存储一个模块即可。从图上可以看出，中间层的引入明显地简化了依赖关系，让代码结构更加清晰。</p>
<img src="https://static001.geekbang.org/resource/image/cb/52/cbcefa78026fd1d0cb9837dde9adae52.jpg" alt="img" style="zoom:33%;" />

<p>除此之外，我们在进行重构的时候，引入中间层可以起到过渡的作用，能够让开发和重构同步进行，不互相干扰。比如，某个接口设计得有问题，我们需要修改它的定义，同时，所有调用这个接口的代码都要做相应的改动。如果新开发的代码也用到这个接口，那开发就跟重构冲突了。为了让重构能小步快跑，我们可以分下面四个阶段来完成接口的修改。</p>
<ul>
<li>第一阶段：引入一个中间层，包裹老的接口，提供新的接口定义。</li>
<li>第二阶段：新开发的代码依赖中间层提供的新接口。</li>
<li>第三阶段：将依赖老接口的代码改为调用新接口。</li>
<li>第四阶段：确保所有的代码都调用新接口之后，删除掉老的接口。</li>
</ul>
<p>这样，每个阶段的开发工作量都不会很大，都可以在很短的时间内完成。重构跟开发冲突的概率也变小了。</p>
<p><u>3.模块化</u></p>
<p>模块化是构建复杂系统常用的手段。不仅在软件行业，在建筑、机械制造等行业，这个手段也非常有用。对于一个大型复杂系统来说，没有人能掌控所有的细节。之所以我们能搭建出如此复杂的系统，并且能维护得了，最主要的原因就是将系统划分成各个独立的模块，让不同的人负责不同的模块，这样即便在不了解全部细节的情况下，管理者也能协调各个模块，让整个系统有效运转。</p>
<p>聚焦到软件开发上面，很多大型软件（比如Windows）之所以能做到几百、上千人有条不紊地协作开发，也归功于模块化做得好。不同的模块之间通过API来进行通信，每个模块之间耦合很小，每个小的团队聚焦于一个独立的高内聚模块来开发，最终像搭积木一样将各个模块组装起来，构建成一个超级复杂的系统。</p>
<p>我们再聚焦到代码层面。合理地划分模块能有效地解耦代码，提高代码的可读性和可维护性。所以，我们在开发代码的时候，一定要有模块化意识，将每个模块都当作一个独立的lib一样来开发，只提供封装了内部实现细节的接口给其他模块使用，这样可以减少不同模块之间的耦合度。</p>
<p>实际上，从刚刚的讲解中我们也可以发现，模块化的思想无处不在，像SOA、微服务、lib库、系统内模块划分，甚至是类、函数的设计，都体现了模块化思想。如果追本溯源，模块化思想更加本质的东西就是分而治之。</p>
<p><u>4.其他设计思想和原则</u></p>
<p>“高内聚、松耦合”是一个非常重要的设计思想，能够有效提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。实际上，在前面的章节中，我们已经多次提到过这个设计思想。很多设计原则都以实现代码的“高内聚、松耦合”为目的。我们来一块总结回顾一下都有哪些原则。</p>
<ul>
<li>单一职责原则</li>
</ul>
<p>我们前面提到，内聚性和耦合性并非独立的。高内聚会让代码更加松耦合，而实现高内聚的重要指导原则就是单一职责原则。模块或者类的职责设计得单一，而不是大而全，那依赖它的类和它依赖的类就会比较少，代码耦合也就相应的降低了。</p>
<ul>
<li>基于接口而非实现编程</li>
</ul>
<p>基于接口而非实现编程能通过接口这样一个中间层，隔离变化和具体的实现。这样做的好处是，在有依赖关系的两个模块或类之间，一个模块或者类的改动，不会影响到另一个模块或类。实际上，这就相当于将一种强依赖关系（强耦合）解耦为了弱依赖关系（弱耦合）。</p>
<ul>
<li>依赖注入</li>
</ul>
<p>跟基于接口而非实现编程思想类似，依赖注入也是将代码之间的强耦合变为弱耦合。尽管依赖注入无法将本应该有依赖关系的两个类，解耦为没有依赖关系，但可以让耦合关系没那么紧密，容易做到插拔替换。</p>
<ul>
<li>多用组合少用继承</li>
</ul>
<p>我们知道，继承是一种强依赖关系，父类与子类高度耦合，且这种耦合关系非常脆弱，牵一发而动全身，父类的每一次改动都会影响所有的子类。相反，组合关系是一种弱依赖关系，这种关系更加灵活，所以，对于继承结构比较复杂的代码，利用组合来替换继承，也是一种解耦的有效手段。</p>
<ul>
<li>迪米特法则</li>
</ul>
<p>迪米特法则讲的是，不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。从定义上，我们明显可以看出，这条原则的目的就是为了实现代码的松耦合。至于如何应用这条原则来解耦代码，你可以回过头去阅读一下第22讲，这里我就不赘述了。</p>
<p>除了上面讲到的这些设计思想和原则之外，还有一些设计模式也是为了解耦依赖，比如观察者模式，有关这一部分的内容，我们留在设计模式模块中慢慢讲解。</p>
<h3 id="24-创建型：单例模式（1）"><a href="#24-创建型：单例模式（1）" class="headerlink" title="24. 创建型：单例模式（1）"></a>24. 创建型：单例模式（1）</h3><p><strong>为什么要使用单例？</strong></p>
<p><strong>单例设计模式</strong>（Singleton Design Pattern）理解起来非常简单。一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。</p>
<p>对于单例的概念，我觉得没必要解释太多，你一看就能明白。我们重点看一下，为什么我们需要单例这种设计模式？它能解决哪些问题？接下来我通过两个实战案例来讲解。</p>
<p><strong>实战案例一：处理资源访问冲突</strong></p>
<p>我们先来看第一个例子。在这个例子中，我们自定义实现了一个往文件中打印日志的Logger类。具体的代码实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> FileWriter writer;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Logger</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/Users/wangzheng/log.txt&quot;</span>);</span><br><span class="line">    writer = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file, <span class="literal">true</span>); <span class="comment">//true表示追加写入</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String message)</span> &#123;</span><br><span class="line">    writer.write(mesasge);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Logger类的应用示例：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Logger</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">    <span class="comment">// ...省略业务逻辑代码...</span></span><br><span class="line">    logger.log(username + <span class="string">&quot; logined!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderController</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Logger</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(OrderVo order)</span> &#123;</span><br><span class="line">    <span class="comment">// ...省略业务逻辑代码...</span></span><br><span class="line">    logger.log(<span class="string">&quot;Created an order: &quot;</span> + order.toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们注意到，所有的日志都写入到同一个文件&#x2F;Users&#x2F;wangzheng&#x2F;log.txt中。在UserController和OrderController中，我们分别创建两个Logger对象。在Web容器的Servlet多线程环境下，<u>如果两个Servlet线程同时分别执行login()和create()两个函数，并且同时写日志到log.txt文件中，那就有可能存在日志信息互相覆盖的情况。</u></p>
<p>为什么会出现互相覆盖呢？我们可以这么类比着理解。在多线程环境下，如果两个线程同时给同一个共享变量加1，因为共享变量是竞争资源，所以，共享变量最后的结果有可能并不是加了2，而是只加了1。同理，这里的log.txt文件也是竞争资源，两个线程同时往里面写数据，就有可能存在互相覆盖的情况。</p>
<p><img src="https://static001.geekbang.org/resource/image/2b/c2/2b0e6141d10399430c59169af4edc3c2.jpg" alt="img"></p>
<p>那如何来解决这个问题呢？我们最先想到的就是通过加锁的方式：给log()函数加互斥锁（Java中可以通过synchronized的关键字），同一时刻只允许一个线程调用执行log()函数。具体的代码实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> FileWriter writer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Logger</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/Users/wangzheng/log.txt&quot;</span>);</span><br><span class="line">    writer = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file, <span class="literal">true</span>); <span class="comment">//true表示追加写入</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String message)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">      writer.write(mesasge);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过，你仔细想想，这真的能解决多线程写入日志时互相覆盖的问题吗？答案是否定的。这是因为，这种锁是一个对象级别的锁，一个对象在不同的线程下同时调用log()函数，会被强制要求顺序执行。但是，不同的对象之间并不共享同一把锁。在不同的线程下，通过不同的对象调用执行log()函数，锁并不会起作用，仍然有可能存在写入日志互相覆盖的问题。</p>
<p><img src="https://static001.geekbang.org/resource/image/20/29/203eb5070c3820b48500d4ab95732f29.jpg" alt="img"></p>
<p>我这里稍微补充一下，在刚刚的讲解和给出的代码中，我故意“隐瞒”了一个事实：我们给log()函数加不加对象级别的锁，其实都没有关系。因为FileWriter本身就是线程安全的，它的内部实现中本身就加了对象级别的锁，因此，在外层调用write()函数的时候，再加对象级别的锁实际上是多此一举。因为不同的Logger对象不共享FileWriter对象，所以，FileWriter对象级别的锁也解决不了数据写入互相覆盖的问题。</p>
<p>那我们该怎么解决这个问题呢？实际上，要想解决这个问题也不难，我们只需要把对象级别的锁，换成类级别的锁就可以了。让所有的对象都共享同一把锁。这样就避免了不同对象之间同时调用log()函数，而导致的日志覆盖问题。具体的代码实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> FileWriter writer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Logger</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/Users/wangzheng/log.txt&quot;</span>);</span><br><span class="line">    writer = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file, <span class="literal">true</span>); <span class="comment">//true表示追加写入</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String message)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(Logger.class) &#123; <span class="comment">// 类级别的锁</span></span><br><span class="line">      writer.write(mesasge);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了使用类级别锁之外，实际上，解决资源竞争问题的办法还有很多，分布式锁是最常听到的一种解决方案。不过，实现一个安全可靠、无bug、高性能的分布式锁，并不是件容易的事情。除此之外，<u>并发队列（比如Java中的BlockingQueue）也可以解决这个问题：多个线程同时往并发队列里写日志，一个单独的线程负责将并发队列中的数据，写入到日志文件</u>。这种方式实现起来也稍微有点复杂。</p>
<p>相对于这两种解决方案，单例模式的解决思路就简单一些了。单例模式相对于之前类级别锁的好处是，不用创建那么多Logger对象，一方面节省内存空间，另一方面节省系统文件句柄（对于操作系统来说，文件句柄也是一种资源，不能随便浪费）。</p>
<p>我们将Logger设计成一个单例类，<u>程序中只允许创建一个Logger对象，所有的线程共享使用的这一个Logger对象</u>，共享一个FileWriter对象，而FileWriter本身是对象级别线程安全的，也就避免了多线程情况下写日志会互相覆盖的问题。</p>
<p>按照这个设计思路，我们实现了Logger单例类。具体代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> FileWriter writer;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Logger</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Logger</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/Users/wangzheng/log.txt&quot;</span>);</span><br><span class="line">    writer = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file, <span class="literal">true</span>); <span class="comment">//true表示追加写入</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Logger <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String message)</span> &#123;</span><br><span class="line">    writer.write(mesasge);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Logger类的应用示例：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">    <span class="comment">// ...省略业务逻辑代码...</span></span><br><span class="line">    Logger.getInstance().log(username + <span class="string">&quot; logined!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderController</span> &#123;  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(OrderVo order)</span> &#123;</span><br><span class="line">    <span class="comment">// ...省略业务逻辑代码...</span></span><br><span class="line">    Logger.getInstance().log(<span class="string">&quot;Created a order: &quot;</span> + order.toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实战案例二：表示全局唯一类</strong></p>
<p>从业务概念上，如果有些数据在系统中只应保存一份，那就比较适合设计为单例类。</p>
<p>比如，配置信息类。在系统中，我们只有一个配置文件，当配置文件被加载到内存之后，以对象的形式存在，也理所应当只有一份。</p>
<p>再比如，唯一递增ID号码生成器，如果程序中有两个对象，那就会存在生成重复ID的情况，所以，我们应该将ID生成器类设计为单例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicLong;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdGenerator</span> &#123;</span><br><span class="line">  <span class="comment">// AtomicLong是一个Java并发库中提供的一个原子变量类型,</span></span><br><span class="line">  <span class="comment">// 它将一些线程不安全需要加锁的复合操作封装为了线程安全的原子操作，</span></span><br><span class="line">  <span class="comment">// 比如下面会用到的incrementAndGet().</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">AtomicLong</span> <span class="variable">id</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">IdGenerator</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IdGenerator</span>();</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">IdGenerator</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> IdGenerator <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getId</span><span class="params">()</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IdGenerator使用举例</span></span><br><span class="line"><span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> IdGenerator.getInstance().getId();</span><br></pre></td></tr></table></figure>

<p>实际上，今天讲到的两个代码实例（Logger、IdGenerator），设计的都并不优雅，还存在一些问题。</p>
<p><strong>如何实现一个单例？</strong></p>
<p>尽管介绍如何实现一个单例模式的文章已经有很多了，但为了保证内容的完整性，我这里还是简单介绍一下几种经典实现方式。概括起来，要实现一个单例，我们需要关注的点无外乎下面几个：</p>
<ul>
<li><u>构造函数需要是private访问权限的，这样才能避免外部通过new创建实例；</u></li>
<li><u>考虑对象创建时的线程安全问题；</u></li>
<li><u>考虑是否支持延迟加载；</u></li>
<li><u>考虑getInstance()性能是否高（是否加锁）。</u></li>
</ul>
<p>如果你对这块已经很熟悉了，你可以当作复习。注意，下面的几种单例实现方式是针对Java语言语法的，如果你熟悉的是其他语言，不妨对比Java的这几种实现方式，自己试着总结一下，利用你熟悉的语言，该如何实现。</p>
<p><u>1.饿汉式</u></p>
<p>饿汉式的实现方式比较简单。在类加载的时候，instance静态实例就已经创建并初始化好了，所以，instance实例的创建过程是线程安全的。不过，这样的实现方式<u>不支持延迟加载</u>（在真正用到IdGenerator的时候，再创建实例），从名字中我们也可以看出这一点。具体的代码实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdGenerator</span> &#123; </span><br><span class="line">  <span class="keyword">private</span> <span class="type">AtomicLong</span> <span class="variable">id</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">IdGenerator</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IdGenerator</span>();</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">IdGenerator</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> IdGenerator <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getId</span><span class="params">()</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有人觉得这种实现方式不好，因为不支持延迟加载，如果实例占用资源多（比如占用内存多）或初始化耗时长（比如需要加载各种配置文件），提前初始化实例是一种浪费资源的行为。最好的方法应该在用到的时候再去初始化。不过，我个人并不认同这样的观点。</p>
<p>如果初始化耗时长，那我们最好不要等到真正要用它的时候，才去执行这个耗时长的初始化过程，这会影响到系统的性能（比如，在响应客户端接口请求的时候，做这个初始化操作，会导致此请求的响应时间变长，甚至超时）。采用饿汉式实现方式，将耗时的初始化操作，提前到程序启动的时候完成，这样就能避免在程序运行的时候，再去初始化导致的性能问题。</p>
<p>如果实例占用资源多，按照fail-fast的设计原则（有问题及早暴露），那我们也希望在程序启动时就将这个实例初始化好。如果资源不够，就会在程序启动的时候触发报错（比如Java中的 PermGen Space OOM），我们可以立即去修复。这样也能避免在程序运行一段时间后，突然因为初始化这个实例占用资源过多，导致系统崩溃，影响系统的可用性。</p>
<p><u>2.懒汉式</u></p>
<p>有饿汉式，对应的，就有懒汉式。懒汉式相对于饿汉式的优势是支持延迟加载。具体的代码实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdGenerator</span> &#123; </span><br><span class="line">  <span class="keyword">private</span> <span class="type">AtomicLong</span> <span class="variable">id</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> IdGenerator instance;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">IdGenerator</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> IdGenerator <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> <span class="title class_">IdGenerator</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getId</span><span class="params">()</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过懒汉式的缺点也很明显，我们给getInstance()这个方法加了一把大锁（synchronzed），导致这个函数的并发度很低。量化一下的话，并发度是1，也就相当于串行操作了。而这个函数是在单例使用期间，一直会被调用。如果这个单例类偶尔会被用到，那这种实现方式还可以接受。但是，如果频繁地用到，那频繁加锁、释放锁及并发度低等问题，会导致性能瓶颈，这种实现方式就不可取了。</p>
<p><u>3.双重检测</u></p>
<p>饿汉式不支持延迟加载，懒汉式有性能问题，不支持高并发。那我们再来看一种既支持延迟加载、又支持高并发的单例实现方式，也就是双重检测实现方式。</p>
<p>在这种实现方式中，只要instance被创建之后，即便再调用getInstance()函数也不会再进入到加锁逻辑中了。所以，这种实现方式解决了懒汉式并发度低的问题。具体的代码实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdGenerator</span> &#123; </span><br><span class="line">  <span class="keyword">private</span> <span class="type">AtomicLong</span> <span class="variable">id</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> IdGenerator instance;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">IdGenerator</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> IdGenerator <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(IdGenerator.class) &#123; <span class="comment">// 此处为类级别的锁</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">          instance = <span class="keyword">new</span> <span class="title class_">IdGenerator</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getId</span><span class="params">()</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>网上有人说，这种实现方式有些问题。因为指令重排序，可能会导致IdGenerator对象被new出来，并且赋值给instance之后，还没来得及初始化（执行构造函数中的代码逻辑），就被另一个线程使用了。</p>
<p>要解决这个问题，我们需要给instance成员变量加上volatile关键字，禁止指令重排序才行。实际上，只有很低版本的Java才会有这个问题。我们现在用的高版本的Java已经在JDK内部实现中解决了这个问题（解决的方法很简单，只要把对象new操作和初始化操作设计为原子操作，就自然能禁止重排序）。关于这点的详细解释，跟特定语言有关，我就不展开讲了，感兴趣的同学可以自行研究一下。</p>
<p><u>4.静态内部类</u></p>
<p>我们再来看一种比双重检测更加简单的实现方法，那就是利用Java的静态内部类。它有点类似饿汉式，但又能做到了延迟加载。具体是怎么做到的呢？我们先来看它的代码实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdGenerator</span> &#123; </span><br><span class="line">  <span class="keyword">private</span> <span class="type">AtomicLong</span> <span class="variable">id</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">IdGenerator</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">IdGenerator</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IdGenerator</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> IdGenerator <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getId</span><span class="params">()</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SingletonHolder 是一个静态内部类，当外部类IdGenerator被加载的时候，并不会创建SingletonHolder实例对象。只有当调用getInstance()方法时，SingletonHolder才会被加载，这个时候才会创建instance。instance的唯一性、创建过程的线程安全性，都由JVM来保证。所以，这种实现方法既保证了线程安全，又能做到延迟加载。</p>
<p><u>5.枚举</u></p>
<p>最后，我们介绍一种最简单的实现方式，基于枚举类型的单例实现。这种实现方式通过Java枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。具体的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">IdGenerator</span> &#123;</span><br><span class="line">  INSTANCE;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">AtomicLong</span> <span class="variable">id</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getId</span><span class="params">()</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="25-创建型：单例模式（2）"><a href="#25-创建型：单例模式（2）" class="headerlink" title="25. 创建型：单例模式（2）"></a>25. 创建型：单例模式（2）</h3><p><strong>单例存在哪些问题?</strong></p>
<p>大部分情况下，我们在项目中使用单例，都是用它来表示一些全局唯一类，比如配置信息类、连接池类、ID生成器类。单例模式书写简洁、使用方便，在代码中，我们不需要创建对象，直接通过类似IdGenerator.getInstance().getId()这样的方法来调用就可以了。但是，这种使用方法有点类似硬编码（hard code），会带来诸多问题。接下来，我们就具体看看到底有哪些问题。</p>
<p><u>1.单例对OOP特性的支持不友好</u></p>
<p>我们知道，OOP的四大特性是封装、抽象、继承、多态。单例这种设计模式对于其中的抽象、继承、多态都支持得不好。为什么这么说呢？我们还是通过IdGenerator这个例子来讲解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(...)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> IdGenerator.getInstance().getId();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(...)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> IdGenerator.getInstance().getId();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IdGenerator的使用方式违背了基于接口而非实现的设计原则，也就违背了广义上理解的OOP的抽象特性。如果未来某一天，我们希望针对不同的业务采用不同的ID生成算法。比如，订单ID和用户ID采用不同的ID生成器来生成。为了应对这个需求变化，我们需要修改所有用到IdGenerator类的地方，这样代码的改动就会比较大。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(...)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> IdGenerator.getInstance().getId();</span><br><span class="line">    <span class="comment">// 需要将上面一行代码，替换为下面一行代码</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> OrderIdGenerator.getIntance().getId();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(...)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> IdGenerator.getInstance().getId();</span><br><span class="line">    <span class="comment">// 需要将上面一行代码，替换为下面一行代码</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> UserIdGenerator.getIntance().getId();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外，单例对继承、多态特性的支持也不友好。这里我之所以会用“不友好”这个词，而非“完全不支持”，是因为从理论上来讲，单例类也可以被继承、也可以实现多态，只是实现起来会非常奇怪，会导致代码的可读性变差。不明白设计意图的人，看到这样的设计，会觉得莫名其妙。所以，一旦你选择将某个类设计成到单例类，也就意味着放弃了继承和多态这两个强有力的面向对象特性，也就相当于损失了可以应对未来需求变化的扩展性。</p>
<p><u>2.单例会隐藏类之间的依赖关系</u></p>
<p>我们知道，代码的可读性非常重要。在阅读代码的时候，我们希望一眼就能看出类与类之间的依赖关系，搞清楚这个类依赖了哪些外部类。</p>
<p>通过构造函数、参数传递等方式声明的类之间的依赖关系，我们通过查看函数的定义，就能很容易识别出来。但是，单例类不需要显示创建、不需要依赖参数传递，在函数中直接调用就可以了。如果代码比较复杂，这种调用关系就会非常隐蔽。在阅读代码的时候，我们就需要仔细查看每个函数的代码实现，才能知道这个类到底依赖了哪些单例类。</p>
<p><u>3.单例对代码的扩展性不友好</u></p>
<p>我们知道，单例类只能有一个对象实例。如果未来某一天，我们需要在代码中创建两个实例或多个实例，那就要对代码有比较大的改动。你可能会说，会有这样的需求吗？既然单例类大部分情况下都用来表示全局类，怎么会需要两个或者多个实例呢？</p>
<p>实际上，这样的需求并不少见。我们拿数据库连接池来举例解释一下。</p>
<p>在系统设计初期，我们觉得系统中只应该有一个数据库连接池，这样能方便我们控制对数据库连接资源的消耗。所以，我们把数据库连接池类设计成了单例类。但之后我们发现，系统中有些SQL语句运行得非常慢。这些SQL语句在执行的时候，长时间占用数据库连接资源，导致其他SQL请求无法响应。为了解决这个问题，我们希望将慢SQL与其他SQL隔离开来执行。为了实现这样的目的，我们可以在系统中创建两个数据库连接池，慢SQL独享一个数据库连接池，其他SQL独享另外一个数据库连接池，这样就能避免慢SQL影响到其他SQL的执行。</p>
<p>如果我们将数据库连接池设计成单例类，显然就无法适应这样的需求变更，也就是说，单例类在某些情况下会影响代码的扩展性、灵活性。所以，数据库连接池、线程池这类的资源池，最好还是不要设计成单例类。实际上，一些开源的数据库连接池、线程池也确实没有设计成单例类。</p>
<p><u>4.单例对代码的可测试性不友好</u></p>
<p>单例模式的使用会影响到代码的可测试性。如果单例类依赖比较重的外部资源，比如DB，我们在写单元测试的时候，希望能通过mock的方式将它替换掉。而单例类这种硬编码式的使用方式，导致无法实现mock替换。</p>
<p>除此之外，如果单例类持有成员变量（比如IdGenerator中的id成员变量），那它实际上相当于一种全局变量，被所有的代码共享。如果这个全局变量是一个可变全局变量，也就是说，它的成员变量是可以被修改的，那我们在编写单元测试的时候，还需要注意不同测试用例之间，修改了单例类中的同一个成员变量的值，从而导致测试结果互相影响的问题。</p>
<p><u>5.单例不支持有参数的构造函数</u></p>
<p>单例不支持有参数的构造函数，比如我们创建一个连接池的单例对象，我们没法通过参数来指定连接池的大小。针对这个问题，我们来看下都有哪些解决方案。</p>
<p>第一种解决思路是：创建完实例之后，再调用init()函数传递参数。需要注意的是，我们在使用这个单例类的时候，要先调用init()方法，然后才能调用getInstance()方法，否则代码会抛出异常。具体的代码实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> paramA;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> paramB;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">(<span class="type">int</span> paramA, <span class="type">int</span> paramB)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.paramA = paramA;</span><br><span class="line">    <span class="built_in">this</span>.paramB = paramB;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Run init() first.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Singleton <span class="title function_">init</span><span class="params">(<span class="type">int</span> paramA, <span class="type">int</span> paramB)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (instance != <span class="literal">null</span>)&#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Singleton has been created!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>(paramA, paramB);</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Singleton.init(<span class="number">10</span>, <span class="number">50</span>); <span class="comment">// 先init，再使用</span></span><br><span class="line"><span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> Singleton.getInstance();</span><br></pre></td></tr></table></figure>

<p>第二种解决思路是：将参数放到getIntance()方法中。具体的代码实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> paramA;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> paramB;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">(<span class="type">int</span> paramA, <span class="type">int</span> paramB)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.paramA = paramA;</span><br><span class="line">    <span class="built_in">this</span>.paramB = paramB;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">(<span class="type">int</span> paramA, <span class="type">int</span> paramB)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>(paramA, paramB);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> Singleton.getInstance(<span class="number">10</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure>

<p>不知道你有没有发现，上面的代码实现稍微有点问题。如果我们如下两次执行getInstance()方法，那获取到的singleton1和signleton2的paramA和paramB都是10和50。也就是说，第二次的参数（20，30）没有起作用，而构建的过程也没有给与提示，这样就会误导用户。这个问题如何解决呢？留给你自己思考，你可以在留言区说说你的解决思路。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Singleton</span> <span class="variable">singleton1</span> <span class="operator">=</span> Singleton.getInstance(<span class="number">10</span>, <span class="number">50</span>);</span><br><span class="line"><span class="type">Singleton</span> <span class="variable">singleton2</span> <span class="operator">=</span> Singleton.getInstance(<span class="number">20</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<p><u>第三种解决思路是：将参数放到另外一个全局变量中</u>。具体的代码实现如下。Config是一个存储了paramA和paramB值的全局变量。里面的值既可以像下面的代码那样通过静态常量来定义，也可以从配置文件中加载得到。实际上，这种方式是最值得推荐的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PARAM_A</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PARAM_B</span> <span class="operator">=</span> <span class="number">245</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> paramA;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> paramB;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.paramA = Config.PARAM_A;</span><br><span class="line">    <span class="built_in">this</span>.paramB = Config.PARAM_B;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>有何替代解决方案？</strong></p>
<p>刚刚我们提到了单例的很多问题，你可能会说，即便单例有这么多问题，但我不用不行啊。我业务上有表示全局唯一类的需求，如果不用单例，我怎么才能保证这个类的对象全局唯一呢？</p>
<p><u>为了保证全局唯一，除了使用单例，我们还可以用静态方法来实现。</u>这也是项目开发中经常用到的一种实现思路。比如，上一节课中讲的ID唯一递增生成器的例子，用静态方法实现一下，就是下面这个样子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态方法实现方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdGenerator</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicLong</span> <span class="variable">id</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">getId</span><span class="params">()</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用举例</span></span><br><span class="line"><span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> IdGenerator.getId();</span><br></pre></td></tr></table></figure>

<p>不过，静态方法这种实现思路，并不能解决我们之前提到的问题。实际上，它比单例更加不灵活，比如，它无法支持延迟加载。我们再来看看有没有其他办法。实际上，单例除了我们之前讲到的使用方法之外，还有另外一种使用方法。具体的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 老的使用方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">demofunction</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> IdGenerator.getInstance().getId();</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 新的使用方式：依赖注入</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">demofunction</span><span class="params">(IdGenerator idGenerator)</span> &#123;</span><br><span class="line">  <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> idGenerator.getId();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 外部调用demofunction()的时候，传入idGenerator</span></span><br><span class="line"><span class="type">IdGenerator</span> <span class="variable">idGenerator</span> <span class="operator">=</span> IdGenerator.getInsance();</span><br><span class="line">demofunction(idGenerator);</span><br></pre></td></tr></table></figure>

<p>基于新的使用方式，我们将单例生成的对象，作为参数传递给函数（也可以通过构造函数传递给类的成员变量），可以解决单例隐藏类之间依赖关系的问题。不过，对于单例存在的其他问题，比如对OOP特性、扩展性、可测性不友好等问题，还是无法解决。</p>
<p>所以，如果要完全解决这些问题，我们可能要从根上，寻找其他方式来实现全局唯一类。实际上，类对象的全局唯一性可以通过多种不同的方式来保证。我们既可以通过单例模式来强制保证，也可以通过工厂模式、IOC容器（比如Spring IOC容器）来保证，还可以通过程序员自己来保证（自己在编写代码的时候自己保证不要创建两个类对象）。这就类似Java中内存对象的释放由JVM来负责，而C++中由程序员自己负责，道理是一样的。</p>
<p>对于替代方案工厂模式、IOC容器的详细讲解，我们放到后面的章节中讲解。</p>
<h3 id="26-创建型：单例模式（3）"><a href="#26-创建型：单例模式（3）" class="headerlink" title="26. 创建型：单例模式（3）"></a>26. 创建型：单例模式（3）</h3><p><strong>如何理解单例模式中的唯一性？</strong></p>
<p>首先，我们重新看一下单例的定义：“一个类只允许创建唯一一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。”</p>
<p>定义中提到，“一个类只允许创建唯一一个对象”。那对象的唯一性的作用范围是什么呢？是指线程内只允许创建一个对象，还是指进程内只允许创建一个对象？答案是后者，也就是说，单例模式创建的对象是进程唯一的。这里有点不好理解，我来详细地解释一下。</p>
<p>我们编写的代码，通过编译、链接，组织在一起，就构成了一个操作系统可以执行的文件，也就是我们平时所说的“可执行文件”（比如Windows下的exe文件）。可执行文件实际上就是代码被翻译成操作系统可理解的一组指令，你完全可以简单地理解为就是代码本身。</p>
<p>当我们使用命令行或者双击运行这个可执行文件的时候，操作系统会启动一个进程，将这个执行文件从磁盘加载到自己的进程地址空间（可以理解操作系统为进程分配的内存存储区，用来存储代码和数据）。接着，进程就一条一条地执行可执行文件中包含的代码。比如，当进程读到代码中的User user &#x3D; new User();这条语句的时候，它就在自己的地址空间中创建一个user临时变量和一个User对象。</p>
<p><u>进程之间是不共享地址空间的</u>，如果我们在一个进程中创建另外一个进程（比如，代码中有一个fork()语句，进程执行到这条语句的时候会创建一个新的进程），操作系统会给新进程分配新的地址空间，并且将老进程地址空间的所有内容，重新拷贝一份到新进程的地址空间中，这些内容包括代码、数据（比如user临时变量、User对象）。</p>
<p>所以，单例类在老进程中存在且只能存在一个对象，在新进程中也会存在且只能存在一个对象。而且，这两个对象并不是同一个对象，这也就说，<u>单例类中对象的唯一性的作用范围是进程内的，在进程间是不唯一的</u>。</p>
<p><strong>如何实现线程唯一的单例？</strong></p>
<p>刚刚我们讲了单例类对象是进程唯一的，一个进程只能有一个单例对象。那如何实现一个线程唯一的单例呢？</p>
<p>我们先来看一下，什么是线程唯一的单例，以及“线程唯一”和“进程唯一”的区别。</p>
<p>“进程唯一”指的是进程内唯一，进程间不唯一。类比一下，“线程唯一”指的是线程内唯一，线程间可以不唯一。实际上，“进程唯一”还代表了线程内、线程间都唯一，这也是“进程唯一”和“线程唯一”的区别之处。这段话听起来有点像绕口令，我举个例子来解释一下。</p>
<p>假设IdGenerator是一个线程唯一的单例类。在线程A内，我们可以创建一个单例对象a。因为线程内唯一，在线程A内就不能再创建新的IdGenerator对象了，而线程间可以不唯一，所以，在另外一个线程B内，我们还可以重新创建一个新的单例对象b。</p>
<p>尽管概念理解起来比较复杂，但线程唯一单例的代码实现很简单，如下所示。在代码中，我们通过一个HashMap来存储对象，其中key是线程ID，value是对象。<u>这样我们就可以做到，不同的线程对应不同的对象，同一个线程只能对应一个对象。</u>实际上，Java语言本身提供了ThreadLocal工具类，可以更加轻松地实现线程唯一单例。不过，ThreadLocal底层实现原理也是基于下面代码中所示的HashMap。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdGenerator</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">AtomicLong</span> <span class="variable">id</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//key-线程Id，value-对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;Long, IdGenerator&gt; instances</span><br><span class="line">          = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">IdGenerator</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> IdGenerator <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">currentThreadId</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line">    instances.putIfAbsent(currentThreadId, <span class="keyword">new</span> <span class="title class_">IdGenerator</span>());</span><br><span class="line">    <span class="keyword">return</span> instances.get(currentThreadId);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如何实现集群环境下的单例？</strong></p>
<p>刚刚我们讲了“进程唯一”的单例和“线程唯一”的单例，现在，我们再来看下，“集群唯一”的单例。</p>
<p>首先，我们还是先来解释一下，什么是“集群唯一”的单例。</p>
<p>我们还是将它跟“进程唯一”“线程唯一”做个对比。“进程唯一”指的是进程内唯一、进程间不唯一。“线程唯一”指的是线程内唯一、线程间不唯一。<u>集群相当于多个进程构成的一个集合，“集群唯一”就相当于是进程内唯一、进程间也唯一。也就是说，不同的进程间共享同一个对象，不能创建同一个类的多个对象。</u></p>
<p>我们知道，经典的单例模式是进程内唯一的，那如何实现一个进程间也唯一的单例呢？如果严格按照不同的进程间共享同一个对象来实现，那集群唯一的单例实现起来就有点难度了。</p>
<p>具体来说，我们<u>需要把这个单例对象序列化并存储到外部共享存储区（比如文件）。进程在使用这个单例对象的时候，需要先从外部共享存储区中将它读取到内存，并反序列化成对象，然后再使用，使用完成之后还需要再存储回外部共享存储区</u>。</p>
<p>为了保证任何时刻，在进程间都只有一份对象存在，一个进程在获取到对象之后，需要对对象加锁，避免其他进程再将其获取。在进程使用完这个对象之后，还需要显式地将对象从内存中删除，并且释放对对象的加锁。</p>
<p>按照这个思路，我用伪代码实现了一下这个过程，具体如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdGenerator</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">AtomicLong</span> <span class="variable">id</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> IdGenerator instance;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SharedObjectStorage</span> <span class="variable">storage</span> <span class="operator">=</span> FileSharedObjectStorage(<span class="comment">/*入参省略，比如文件地址*/</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">DistributedLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DistributedLock</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">IdGenerator</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> IdGenerator <span class="title function_">getInstance</span><span class="params">()</span> </span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      instance = storage.load(IdGenerator.class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> synchroinzed <span class="keyword">void</span> <span class="title function_">freeInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    storage.save(<span class="built_in">this</span>, IdGeneator.class);</span><br><span class="line">    instance = <span class="literal">null</span>; <span class="comment">//释放对象</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getId</span><span class="params">()</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IdGenerator使用举例</span></span><br><span class="line"><span class="type">IdGenerator</span> <span class="variable">idGeneator</span> <span class="operator">=</span> IdGenerator.getInstance();</span><br><span class="line"><span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> idGenerator.getId();</span><br><span class="line">IdGenerator.freeInstance();</span><br></pre></td></tr></table></figure>

<p><strong>如何实现一个多例模式？</strong></p>
<p>跟单例模式概念相对应的还有一个多例模式。那如何实现一个多例模式呢？</p>
<p>“单例”指的是，一个类只能创建一个对象。对应地，<u>“多例”指的就是，一个类可以创建多个对象，但是个数是有限制的</u>，比如只能创建3个对象。如果用代码来简单示例一下的话，就是下面这个样子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BackendServer</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> serverNo;</span><br><span class="line">  <span class="keyword">private</span> String serverAddress;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SERVER_COUNT</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Long, BackendServer&gt; serverInstances = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    serverInstances.put(<span class="number">1L</span>, <span class="keyword">new</span> <span class="title class_">BackendServer</span>(<span class="number">1L</span>, <span class="string">&quot;192.134.22.138:8080&quot;</span>));</span><br><span class="line">    serverInstances.put(<span class="number">2L</span>, <span class="keyword">new</span> <span class="title class_">BackendServer</span>(<span class="number">2L</span>, <span class="string">&quot;192.134.22.139:8080&quot;</span>));</span><br><span class="line">    serverInstances.put(<span class="number">3L</span>, <span class="keyword">new</span> <span class="title class_">BackendServer</span>(<span class="number">3L</span>, <span class="string">&quot;192.134.22.140:8080&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">BackendServer</span><span class="params">(<span class="type">long</span> serverNo, String serverAddress)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.serverNo = serverNo;</span><br><span class="line">    <span class="built_in">this</span>.serverAddress = serverAddress;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> BackendServer <span class="title function_">getInstance</span><span class="params">(<span class="type">long</span> serverNo)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> serverInstances.get(serverNo);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> BackendServer <span class="title function_">getRandomInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">no</span> <span class="operator">=</span> r.nextInt(SERVER_COUNT)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> serverInstances.get(no);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，对于多例模式，还有一种理解方式：同一类型的只能创建一个对象，不同类型的可以创建多个对象。这里的“类型”如何理解呢？</p>
<p>我们还是通过一个例子来解释一下，具体代码如下所示。在代码中，logger name就是刚刚说的“类型”，同一个logger name获取到的对象实例是相同的，不同的logger name获取到的对象实例是不同的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, Logger&gt; instances</span><br><span class="line">          = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Logger</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Logger <span class="title function_">getInstance</span><span class="params">(String loggerName)</span> &#123;</span><br><span class="line">    instances.putIfAbsent(loggerName, <span class="keyword">new</span> <span class="title class_">Logger</span>());</span><br><span class="line">    <span class="keyword">return</span> instances.get(loggerName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//l1==l2, l1!=l3</span></span><br><span class="line"><span class="type">Logger</span> <span class="variable">l1</span> <span class="operator">=</span> Logger.getInstance(<span class="string">&quot;User.class&quot;</span>);</span><br><span class="line"><span class="type">Logger</span> <span class="variable">l2</span> <span class="operator">=</span> Logger.getInstance(<span class="string">&quot;User.class&quot;</span>);</span><br><span class="line"><span class="type">Logger</span> <span class="variable">l3</span> <span class="operator">=</span> Logger.getInstance(<span class="string">&quot;Order.class&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这种多例模式的理解方式有点类似工厂模式。它跟工厂模式的不同之处是，<u>多例模式创建的对象都是同一个类的对象，而工厂模式创建的是不同子类的对象</u>，关于这一点，下一节课中就会讲到。实际上，它还有点类似享元模式，两者的区别等到我们讲到享元模式的时候再来分析。除此之外，实际上，枚举类型也相当于多例模式，一个类型只能对应一个对象，一个类可以创建多个对象。</p>
<h3 id="27-创建型：工厂模式（1）"><a href="#27-创建型：工厂模式（1）" class="headerlink" title="27. 创建型：工厂模式（1）"></a>27. 创建型：工厂模式（1）</h3><p>再来讲另外一个比较常用的创建型模式：工厂模式（Factory Design Pattern）。</p>
<p>一般情况下，工厂模式分为三种更加细分的类型：简单工厂、工厂方法和抽象工厂。不过，在GoF的《设计模式》一书中，它将简单工厂模式看作是工厂方法模式的一种特例，所以工厂模式只被分成了工厂方法和抽象工厂两类。实际上，前面一种分类方法更加常见，所以，在今天的讲解中，我们沿用第一种分类方法。</p>
<p>在这三种细分的工厂模式中，简单工厂、工厂方法原理比较简单，在实际的项目中也比较常用。而抽象工厂的原理稍微复杂点，在实际的项目中相对也不常用。所以，我们今天讲解的重点是前两种工厂模式。对于抽象工厂，你稍微了解一下即可。</p>
<p>除此之外，我们讲解的重点也不是原理和实现，因为这些都很简单，重点还是带你搞清楚应用场景：什么时候该用工厂模式？相对于直接new来创建对象，用工厂模式来创建究竟有什么好处呢？</p>
<p><strong>简单工厂（Simple Factory）</strong></p>
<p>首先，我们来看，什么是简单工厂模式。我们通过一个例子来解释一下。</p>
<p>在下面这段代码中，我们根据配置文件的后缀（json、xml、yaml、properties），选择不同的解析器（JsonRuleConfigParser、XmlRuleConfigParser……），将存储在文件中的配置解析成内存对象RuleConfig。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuleConfigSource</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> RuleConfig <span class="title function_">load</span><span class="params">(String ruleConfigFilePath)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ruleConfigFileExtension</span> <span class="operator">=</span> getFileExtension(ruleConfigFilePath);</span><br><span class="line">    <span class="type">IRuleConfigParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;json&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> <span class="title class_">JsonRuleConfigParser</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;xml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> <span class="title class_">XmlRuleConfigParser</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;yaml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> <span class="title class_">YamlRuleConfigParser</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;properties&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> <span class="title class_">PropertiesRuleConfigParser</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidRuleConfigException</span>(</span><br><span class="line">             <span class="string">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">configText</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//从ruleConfigFilePath文件中读取配置文本到configText中</span></span><br><span class="line">    <span class="type">RuleConfig</span> <span class="variable">ruleConfig</span> <span class="operator">=</span> parser.parse(configText);</span><br><span class="line">    <span class="keyword">return</span> ruleConfig;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String <span class="title function_">getFileExtension</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">    <span class="comment">//...解析文件名获取扩展名，比如rule.json，返回json</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;json&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在“规范和重构”那一部分中，我们有讲到，为了让代码逻辑更加清晰，可读性更好，我们要善于将功能独立的代码块封装成函数。按照这个设计思路，我们可以<u>将代码中涉及parser创建的部分逻辑剥离出来，抽象成createParser()函数</u>。重构之后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">public</span> RuleConfig <span class="title function_">load</span><span class="params">(String ruleConfigFilePath)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ruleConfigFileExtension</span> <span class="operator">=</span> getFileExtension(ruleConfigFilePath);</span><br><span class="line">    <span class="type">IRuleConfigParser</span> <span class="variable">parser</span> <span class="operator">=</span> createParser(ruleConfigFileExtension);</span><br><span class="line">    <span class="keyword">if</span> (parser == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidRuleConfigException</span>(</span><br><span class="line">              <span class="string">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">configText</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//从ruleConfigFilePath文件中读取配置文本到configText中</span></span><br><span class="line">    <span class="type">RuleConfig</span> <span class="variable">ruleConfig</span> <span class="operator">=</span> parser.parse(configText);</span><br><span class="line">    <span class="keyword">return</span> ruleConfig;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String <span class="title function_">getFileExtension</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">    <span class="comment">//...解析文件名获取扩展名，比如rule.json，返回json</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;json&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> IRuleConfigParser <span class="title function_">createParser</span><span class="params">(String configFormat)</span> &#123;</span><br><span class="line">    <span class="type">IRuleConfigParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;json&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> <span class="title class_">JsonRuleConfigParser</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;xml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> <span class="title class_">XmlRuleConfigParser</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;yaml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> <span class="title class_">YamlRuleConfigParser</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;properties&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> <span class="title class_">PropertiesRuleConfigParser</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parser;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了让类的职责更加单一、代码更加清晰，我们<u>还可以进一步将createParser()函数剥离到一个独立的类中，让这个类只负责对象的创建。而这个类就是我们现在要讲的简单工厂模式类。</u>具体的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuleConfigSource</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> RuleConfig <span class="title function_">load</span><span class="params">(String ruleConfigFilePath)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ruleConfigFileExtension</span> <span class="operator">=</span> getFileExtension(ruleConfigFilePath);</span><br><span class="line">    <span class="type">IRuleConfigParser</span> <span class="variable">parser</span> <span class="operator">=</span> RuleConfigParserFactory.createParser(ruleConfigFileExtension);</span><br><span class="line">    <span class="keyword">if</span> (parser == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidRuleConfigException</span>(</span><br><span class="line">              <span class="string">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">configText</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//从ruleConfigFilePath文件中读取配置文本到configText中</span></span><br><span class="line">    <span class="type">RuleConfig</span> <span class="variable">ruleConfig</span> <span class="operator">=</span> parser.parse(configText);</span><br><span class="line">    <span class="keyword">return</span> ruleConfig;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String <span class="title function_">getFileExtension</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">    <span class="comment">//...解析文件名获取扩展名，比如rule.json，返回json</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;json&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuleConfigParserFactory</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> IRuleConfigParser <span class="title function_">createParser</span><span class="params">(String configFormat)</span> &#123;</span><br><span class="line">    <span class="type">IRuleConfigParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;json&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> <span class="title class_">JsonRuleConfigParser</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;xml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> <span class="title class_">XmlRuleConfigParser</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;yaml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> <span class="title class_">YamlRuleConfigParser</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;properties&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> <span class="title class_">PropertiesRuleConfigParser</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parser;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大部分工厂类都是以“Factory”这个单词结尾的，但也不是必须的，比如Java中的DateFormat、Calender。除此之外，工厂类中创建对象的方法一般都是create开头，比如代码中的createParser()，但有的也命名为getInstance()、createInstance()、newInstance()，有的甚至命名为valueOf()（比如Java String类的valueOf()函数）等等，这个我们根据具体的场景和习惯来命名就好。</p>
<p>在上面的代码实现中，我们每次调用RuleConfigParserFactory的createParser()的时候，都要创建一个新的parser。实际上，如果parser可以复用，为了节省内存和对象创建的时间，我们可以将parser事先创建好缓存起来。当调用createParser()函数的时候，我们从缓存中取出parser对象直接使用。</p>
<p>这有点类似单例模式和简单工厂模式的结合，具体的代码实现如下所示。在接下来的讲解中，我们把上一种实现方法叫作简单工厂模式的第一种实现方法，把下面这种实现方法叫作简单工厂模式的第二种实现方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuleConfigParserFactory</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, RuleConfigParser&gt; cachedParsers = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    cachedParsers.put(<span class="string">&quot;json&quot;</span>, <span class="keyword">new</span> <span class="title class_">JsonRuleConfigParser</span>());</span><br><span class="line">    cachedParsers.put(<span class="string">&quot;xml&quot;</span>, <span class="keyword">new</span> <span class="title class_">XmlRuleConfigParser</span>());</span><br><span class="line">    cachedParsers.put(<span class="string">&quot;yaml&quot;</span>, <span class="keyword">new</span> <span class="title class_">YamlRuleConfigParser</span>());</span><br><span class="line">    cachedParsers.put(<span class="string">&quot;properties&quot;</span>, <span class="keyword">new</span> <span class="title class_">PropertiesRuleConfigParser</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> IRuleConfigParser <span class="title function_">createParser</span><span class="params">(String configFormat)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (configFormat == <span class="literal">null</span> || configFormat.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//返回null还是IllegalArgumentException全凭你自己说了算</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">IRuleConfigParser</span> <span class="variable">parser</span> <span class="operator">=</span> cachedParsers.get(configFormat.toLowerCase());</span><br><span class="line">    <span class="keyword">return</span> parser;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上面两种简单工厂模式的实现方法，如果我们要添加新的parser，那势必要改动到RuleConfigParserFactory的代码，那这是不是违反开闭原则呢？实际上，如果不是需要频繁地添加新的parser，只是偶尔修改一下RuleConfigParserFactory代码，稍微不符合开闭原则，也是完全可以接受的。</p>
<p>除此之外，在RuleConfigParserFactory的第一种代码实现中，有一组if分支判断逻辑，是不是应该用多态或其他设计模式来替代呢？实际上，如果if分支并不是很多，代码中有if分支也是完全可以接受的。应用多态或设计模式来替代if分支判断逻辑，也并不是没有任何缺点的，它虽然提高了代码的扩展性，更加符合开闭原则，但也增加了类的个数，牺牲了代码的可读性。关于这一点，我们在后面章节中会详细讲到。</p>
<p>总结一下，尽管简单工厂模式的代码实现中，有多处if分支判断逻辑，违背开闭原则，但权衡扩展性和可读性，这样的代码实现在大多数情况下（比如，不需要频繁地添加parser，也没有太多的parser）是没有问题的。</p>
<p><strong>工厂方法（Factory Method）</strong></p>
<p>如果我们非得要将if分支逻辑去掉，那该怎么办呢？比较经典处理方法就是利用多态。按照多态的实现思路，对上面的代码进行重构。重构之后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IRuleConfigParserFactory</span> &#123;</span><br><span class="line">  IRuleConfigParser <span class="title function_">createParser</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JsonRuleConfigParserFactory</span> <span class="keyword">implements</span> <span class="title class_">IRuleConfigParserFactory</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> IRuleConfigParser <span class="title function_">createParser</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JsonRuleConfigParser</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XmlRuleConfigParserFactory</span> <span class="keyword">implements</span> <span class="title class_">IRuleConfigParserFactory</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> IRuleConfigParser <span class="title function_">createParser</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">XmlRuleConfigParser</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YamlRuleConfigParserFactory</span> <span class="keyword">implements</span> <span class="title class_">IRuleConfigParserFactory</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> IRuleConfigParser <span class="title function_">createParser</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">YamlRuleConfigParser</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertiesRuleConfigParserFactory</span> <span class="keyword">implements</span> <span class="title class_">IRuleConfigParserFactory</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> IRuleConfigParser <span class="title function_">createParser</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PropertiesRuleConfigParser</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，这就是工厂方法模式的典型代码实现。这样当我们新增一种parser的时候，只需要新增一个实现了IRuleConfigParserFactory接口的Factory类即可。所以，<strong>工厂方法模式比起简单工厂模式更加符合开闭原则。</strong></p>
<p>从上面的工厂方法的实现来看，一切都很完美，但是实际上存在挺大的问题。问题存在于这些工厂类的使用上。接下来，我们看一下，如何用这些工厂类来实现RuleConfigSource的load()函数。具体的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuleConfigSource</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> RuleConfig <span class="title function_">load</span><span class="params">(String ruleConfigFilePath)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ruleConfigFileExtension</span> <span class="operator">=</span> getFileExtension(ruleConfigFilePath);</span><br><span class="line"></span><br><span class="line">    <span class="type">IRuleConfigParserFactory</span> <span class="variable">parserFactory</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;json&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">      parserFactory = <span class="keyword">new</span> <span class="title class_">JsonRuleConfigParserFactory</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;xml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">      parserFactory = <span class="keyword">new</span> <span class="title class_">XmlRuleConfigParserFactory</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;yaml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">      parserFactory = <span class="keyword">new</span> <span class="title class_">YamlRuleConfigParserFactory</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;properties&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">      parserFactory = <span class="keyword">new</span> <span class="title class_">PropertiesRuleConfigParserFactory</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidRuleConfigException</span>(<span class="string">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">IRuleConfigParser</span> <span class="variable">parser</span> <span class="operator">=</span> parserFactory.createParser();</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">configText</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//从ruleConfigFilePath文件中读取配置文本到configText中</span></span><br><span class="line">    <span class="type">RuleConfig</span> <span class="variable">ruleConfig</span> <span class="operator">=</span> parser.parse(configText);</span><br><span class="line">    <span class="keyword">return</span> ruleConfig;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String <span class="title function_">getFileExtension</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">    <span class="comment">//...解析文件名获取扩展名，比如rule.json，返回json</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;json&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码实现来看，工厂类对象的创建逻辑又耦合进了load()函数中，跟我们最初的代码版本非常相似，引入工厂方法非但没有解决问题，反倒让设计变得更加复杂了。那怎么来解决这个问题呢？</p>
<p><strong>我们可以为工厂类再创建一个简单工厂，也就是工厂的工厂，用来创建工厂类对象。</strong>这段话听起来有点绕，我把代码实现出来了，你一看就能明白了。其中，RuleConfigParserFactoryMap类是创建工厂对象的工厂类，getParserFactory()返回的是缓存好的单例工厂对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuleConfigSource</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> RuleConfig <span class="title function_">load</span><span class="params">(String ruleConfigFilePath)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ruleConfigFileExtension</span> <span class="operator">=</span> getFileExtension(ruleConfigFilePath);</span><br><span class="line"></span><br><span class="line">    <span class="type">IRuleConfigParserFactory</span> <span class="variable">parserFactory</span> <span class="operator">=</span> RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);</span><br><span class="line">    <span class="keyword">if</span> (parserFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidRuleConfigException</span>(<span class="string">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">IRuleConfigParser</span> <span class="variable">parser</span> <span class="operator">=</span> parserFactory.createParser();</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">configText</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//从ruleConfigFilePath文件中读取配置文本到configText中</span></span><br><span class="line">    <span class="type">RuleConfig</span> <span class="variable">ruleConfig</span> <span class="operator">=</span> parser.parse(configText);</span><br><span class="line">    <span class="keyword">return</span> ruleConfig;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String <span class="title function_">getFileExtension</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">    <span class="comment">//...解析文件名获取扩展名，比如rule.json，返回json</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;json&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为工厂类只包含方法，不包含成员变量，完全可以复用，</span></span><br><span class="line"><span class="comment">//不需要每次都创建新的工厂类对象，所以，简单工厂模式的第二种实现思路更加合适。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuleConfigParserFactoryMap</span> &#123; <span class="comment">//工厂的工厂</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, IRuleConfigParserFactory&gt; cachedFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    cachedFactories.put(<span class="string">&quot;json&quot;</span>, <span class="keyword">new</span> <span class="title class_">JsonRuleConfigParserFactory</span>());</span><br><span class="line">    cachedFactories.put(<span class="string">&quot;xml&quot;</span>, <span class="keyword">new</span> <span class="title class_">XmlRuleConfigParserFactory</span>());</span><br><span class="line">    cachedFactories.put(<span class="string">&quot;yaml&quot;</span>, <span class="keyword">new</span> <span class="title class_">YamlRuleConfigParserFactory</span>());</span><br><span class="line">    cachedFactories.put(<span class="string">&quot;properties&quot;</span>, <span class="keyword">new</span> <span class="title class_">PropertiesRuleConfigParserFactory</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> IRuleConfigParserFactory <span class="title function_">getParserFactory</span><span class="params">(String type)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="literal">null</span> || type.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">IRuleConfigParserFactory</span> <span class="variable">parserFactory</span> <span class="operator">=</span> cachedFactories.get(type.toLowerCase());</span><br><span class="line">    <span class="keyword">return</span> parserFactory;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们需要添加新的规则配置解析器的时候，我们只需要创建新的parser类和parser factory类，并且在RuleConfigParserFactoryMap类中，将新的parser factory对象添加到cachedFactories中即可。代码的改动非常少，基本上符合开闭原则。</p>
<p>实际上，对于规则配置文件解析这个应用场景来说，工厂模式需要额外创建诸多Factory类，也会增加代码的复杂性，而且，每个Factory类只是做简单的new操作，功能非常单薄（只有一行代码），也没必要设计成独立的类，所以，在这个应用场景下，简单工厂模式简单好用，比工厂方法模式更加合适。</p>
<p><strong>那什么时候该用工厂方法模式，而非简单工厂模式呢？</strong></p>
<p>我们前面提到，之所以将某个代码块剥离出来，独立为函数或者类，原因是这个代码块的逻辑过于复杂，剥离之后能让代码更加清晰，更加可读、可维护。但是，如果代码块本身并不复杂，就几行代码而已，我们完全没必要将它拆分成单独的函数或者类。</p>
<p>基于这个设计思想，<u>当对象的创建逻辑比较复杂，不只是简单的new一下就可以，而是要组合其他类对象，做各种初始化操作的时候，我们推荐使用工厂方法模式，将复杂的创建逻辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂</u>。而使用简单工厂模式，将所有的创建逻辑都放到一个工厂类中，会导致这个工厂类变得很复杂。</p>
<p>除此之外，在某些场景下，如果对象不可复用，那工厂类每次都要返回不同的对象。如果我们使用简单工厂模式来实现，就只能选择第一种包含if分支逻辑的实现方式。如果我们还想避免烦人的if-else分支逻辑，这个时候，我们就推荐使用工厂方法模式。</p>
<p><strong>抽象工厂（Abstract Factory）</strong></p>
<p>讲完了简单工厂、工厂方法，我们再来看抽象工厂模式。抽象工厂模式的应用场景比较特殊，没有前两种常用，所以不是我们本节课学习的重点，你简单了解一下就可以了。</p>
<p>在简单工厂和工厂方法中，类只有一种分类方式。比如，在规则配置解析那个例子中，解析器类只会根据配置文件格式（Json、Xml、Yaml……）来分类。但是，如果类有两种分类方式，比如，我们既可以按照配置文件格式来分类，也可以按照解析的对象（Rule规则配置还是System系统配置）来分类，那就会对应下面这8个parser类。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">针对规则配置的解析器：基于接口IRuleConfigParser</span><br><span class="line">JsonRuleConfigParser</span><br><span class="line">XmlRuleConfigParser</span><br><span class="line">YamlRuleConfigParser</span><br><span class="line">PropertiesRuleConfigParser</span><br><span class="line"></span><br><span class="line">针对系统配置的解析器：基于接口ISystemConfigParser</span><br><span class="line">JsonSystemConfigParser</span><br><span class="line">XmlSystemConfigParser</span><br><span class="line">YamlSystemConfigParser</span><br><span class="line">PropertiesSystemConfigParser</span><br></pre></td></tr></table></figure>

<p>针对这种特殊的场景，如果还是继续用工厂方法来实现的话，我们要针对每个parser都编写一个工厂类，也就是要编写8个工厂类。如果我们未来还需要增加针对业务配置的解析器（比如IBizConfigParser），那就要再对应地增加4个工厂类。而我们知道，过多的类也会让系统难维护。这个问题该怎么解决呢？</p>
<p>抽象工厂就是针对这种非常特殊的场景而诞生的。我们可以让一个工厂负责创建多个不同类型的对象（IRuleConfigParser、ISystemConfigParser等），而不是只创建一种parser对象。这样就可以有效地减少工厂类的个数。具体的代码实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IConfigParserFactory</span> &#123;</span><br><span class="line">  IRuleConfigParser <span class="title function_">createRuleParser</span><span class="params">()</span>;</span><br><span class="line">  ISystemConfigParser <span class="title function_">createSystemParser</span><span class="params">()</span>;</span><br><span class="line">  <span class="comment">//此处可以扩展新的parser类型，比如IBizConfigParser</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JsonConfigParserFactory</span> <span class="keyword">implements</span> <span class="title class_">IConfigParserFactory</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> IRuleConfigParser <span class="title function_">createRuleParser</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JsonRuleConfigParser</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> ISystemConfigParser <span class="title function_">createSystemParser</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JsonSystemConfigParser</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XmlConfigParserFactory</span> <span class="keyword">implements</span> <span class="title class_">IConfigParserFactory</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> IRuleConfigParser <span class="title function_">createRuleParser</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">XmlRuleConfigParser</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> ISystemConfigParser <span class="title function_">createSystemParser</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">XmlSystemConfigParser</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略YamlConfigParserFactory和PropertiesConfigParserFactory代码</span></span><br></pre></td></tr></table></figure>

<h3 id="28-创建型：工厂模式（2）"><a href="#28-创建型：工厂模式（2）" class="headerlink" title="28. 创建型：工厂模式（2）"></a>28. 创建型：工厂模式（2）</h3><p>当创建对象是一个“大工程”的时候，我们一般会选择使用工厂模式，来封装对象复杂的创建过程，将对象的创建和使用分离，让代码更加清晰。那何为“大工程”呢？上面我们讲了两种情况，一种是创建过程涉及复杂的if-else分支判断，另一种是对象创建需要组装多个其他类对象或者需要复杂的初始化过程。</p>
<p>今天，我们再来讲一个创建对象的“大工程”，依赖注入框架，或者叫<u>依赖注入容器（Dependency Injection Container），简称DI容器</u>。在今天的讲解中，我会带你一块搞清楚这样几个问题：DI容器跟我们讲的工厂模式又有何区别和联系？DI容器的核心功能有哪些，以及如何实现一个简单的DI容器？</p>
<p>话不多说，让我们正式开始今天的学习吧！</p>
<p><strong>工厂模式和DI容器有何区别？</strong></p>
<p>实际上，DI容器底层最基本的设计思路就是基于工厂模式的。DI容器相当于一个大的工厂类，负责在程序启动的时候，根据配置（要创建哪些类对象，每个类对象的创建需要依赖哪些其他类对象）事先创建好对象。当应用程序需要使用某个类对象的时候，直接从容器中获取即可。正是因为它持有一堆对象，所以这个框架才被称为“容器”。</p>
<p>DI容器相对于我们上节课讲的工厂模式的例子来说，它处理的是更大的对象创建工程。上节课讲的工厂模式中，一个工厂类只负责某个类对象或者某一组相关类对象（继承自同一抽象类或者接口的子类）的创建，而DI容器负责的是整个应用中所有类对象的创建。</p>
<p>除此之外，<u>DI容器负责的事情要比单纯的工厂模式要多。比如，它还包括配置的解析、对象生命周期的管理</u>。接下来，我们就详细讲讲，一个简单的DI容器应该包含哪些核心功能。</p>
<p><strong>DI容器的核心功能有哪些？</strong></p>
<p>总结一下，一个简单的<u>DI容器的核心功能一般有三个：配置解析、对象创建和对象生命周期管理</u>。</p>
<p><strong>首先，我们来看配置解析。</strong></p>
<p>在上节课讲的工厂模式中，工厂类要创建哪个类对象是事先确定好的，并且是写死在工厂类代码中的。作为一个通用的框架来说，框架代码跟应用代码应该是高度解耦的，DI容器事先并不知道应用会创建哪些对象，不可能把某个应用要创建的对象写死在框架代码中。所以，<u>我们需要通过一种形式，让应用告知DI容器要创建哪些对象。这种形式就是我们要讲的配置</u>。</p>
<p>我们将需要由DI容器来创建的类对象和创建类对象的必要信息（使用哪个构造函数以及对应的构造函数参数都是什么等等），放到配置文件中。容器读取配置文件，根据配置文件提供的信息来创建对象。</p>
<p>下面是一个典型的Spring容器的配置文件。Spring容器读取这个配置文件，解析出要创建的两个对象：rateLimiter和redisCounter，并且得到两者的依赖关系：rateLimiter依赖redisCounter。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">public class RateLimiter &#123;</span><br><span class="line">  private RedisCounter redisCounter;</span><br><span class="line">  public RateLimiter(RedisCounter redisCounter) &#123;</span><br><span class="line">    this.redisCounter = redisCounter;</span><br><span class="line">  &#125;</span><br><span class="line">  public void test() &#123;</span><br><span class="line">    System.out.println(&quot;Hello World!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RedisCounter &#123;</span><br><span class="line">  private String ipAddress;</span><br><span class="line">  private int port;</span><br><span class="line">  public RedisCounter(String ipAddress, int port) &#123;</span><br><span class="line">    this.ipAddress = ipAddress;</span><br><span class="line">    this.port = port;</span><br><span class="line">  &#125;</span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">配置文件beans.xml：</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;rateLimiter&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xzg.RateLimiter&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;redisCounter&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;redisCounter&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xzg.redisCounter&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;127.0.0.1&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;int&quot;</span> <span class="attr">value</span>=<span class="string">1234</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>其次，我们再来看对象创建。</strong></p>
<p>在DI容器中，如果我们给每个类都对应创建一个工厂类，那项目中类的个数会成倍增加，这会增加代码的维护成本。要解决这个问题并不难。我们只需要将所有类对象的创建都放到一个工厂类中完成就可以了，比如BeansFactory。</p>
<p>你可能会说，如果要创建的类对象非常多，BeansFactory中的代码会不会线性膨胀（代码量跟创建对象的个数成正比）呢？实际上并不会。待会讲到DI容器的具体实现的时候，我们会讲“反射”这种机制，它能在程序运行的过程中，动态地加载类、创建对象，不需要事先在代码中写死要创建哪些对象。所以，不管是创建一个对象还是十个对象，BeansFactory工厂类代码都是一样的。</p>
<p><strong>最后，我们来看对象的生命周期管理。</strong></p>
<p>上一节课我们讲到，简单工厂模式有两种实现方式，一种是每次都返回新创建的对象，另一种是每次都返回同一个事先创建好的对象，也就是所谓的单例对象。<u>在Spring框架中，我们可以通过配置scope属性，来区分这两种不同类型的对象。scope&#x3D;prototype表示返回新创建的对象，scope&#x3D;singleton表示返回单例对象</u>。</p>
<p>除此之外，我们还可以配置对象是否支持懒加载。如果lazy-init&#x3D;true，对象在真正被使用到的时候（比如：BeansFactory.getBean(“userService”)）才被被创建；如果lazy-init&#x3D;false，对象在应用启动的时候就事先创建好。</p>
<p>不仅如此，我们还可以配置对象的init-method和destroy-method方法，比如init-method&#x3D;loadProperties()，destroy-method&#x3D;updateConfigFile()。<u>DI容器在创建好对象之后，会主动调用init-method属性指定的方法来初始化对象。在对象被最终销毁之前，DI容器会主动调用destroy-method属性指定的方法来做一些清理工作，比如释放数据库连接池、关闭文件。</u></p>
<p><strong>如何实现一个简单的DI容器？</strong></p>
<p>实际上，用Java语言来实现一个简单的DI容器，核心逻辑只需要包括这样两个部分：配置文件解析、根据配置文件通过“反射”语法来创建对象。</p>
<p><u>1.最小原型设计</u></p>
<p>因为我们主要是讲解设计模式，所以，在今天的讲解中，我们只实现一个DI容器的最小原型。像Spring框架这样的DI容器，它支持的配置格式非常灵活和复杂。为了简化代码实现，重点讲解原理，在最小原型中，我们只支持下面配置文件中涉及的配置语法。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">配置文件beans.xml</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;rateLimiter&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xzg.RateLimiter&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;redisCounter&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;redisCounter&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xzg.redisCounter&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span> <span class="attr">lazy-init</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;127.0.0.1&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;int&quot;</span> <span class="attr">value</span>=<span class="string">1234</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">&lt;/bean</span><br></pre></td></tr></table></figure>

<p>最小原型的使用方式跟Spring框架非常类似，示例代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(</span><br><span class="line">            <span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">    <span class="type">RateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> (RateLimiter) applicationContext.getBean(<span class="string">&quot;rateLimiter&quot;</span>);</span><br><span class="line">    rateLimiter.test();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u>2.提供执行入口</u></p>
<p>前面我们讲到，面向对象设计的最后一步是：组装类并提供执行入口。在这里，执行入口就是一组暴露给外部使用的接口和类。</p>
<p>通过刚刚的最小原型使用示例代码，我们可以看出，执行入口主要包含两部分：ApplicationContext和ClassPathXmlApplicationContext。其中，ApplicationContext是接口，ClassPathXmlApplicationContext是接口的实现类。两个类具体实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationContext</span> &#123;</span><br><span class="line">  Object <span class="title function_">getBean</span><span class="params">(String beanId)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassPathXmlApplicationContext</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContext</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> BeansFactory beansFactory;</span><br><span class="line">  <span class="keyword">private</span> BeanConfigParser beanConfigParser;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ClassPathXmlApplicationContext</span><span class="params">(String configLocation)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.beansFactory = <span class="keyword">new</span> <span class="title class_">BeansFactory</span>();</span><br><span class="line">    <span class="built_in">this</span>.beanConfigParser = <span class="keyword">new</span> <span class="title class_">XmlBeanConfigParser</span>();</span><br><span class="line">    loadBeanDefinitions(configLocation);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(String configLocation)</span> &#123;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      in = <span class="built_in">this</span>.getClass().getResourceAsStream(<span class="string">&quot;/&quot;</span> + configLocation);</span><br><span class="line">      <span class="keyword">if</span> (in == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Can not find config file: &quot;</span> + configLocation);</span><br><span class="line">      &#125;</span><br><span class="line">      List&lt;BeanDefinition&gt; beanDefinitions = beanConfigParser.parse(in);</span><br><span class="line">      beansFactory.addBeanDefinitions(beanDefinitions);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (in != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          in.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          <span class="comment">// <span class="doctag">TODO:</span> log error</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String beanId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> beansFactory.getBean(beanId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中，我们可以看出，ClassPathXmlApplicationContext负责组装BeansFactory和BeanConfigParser两个类，串联执行流程：从classpath中加载XML格式的配置文件，通过BeanConfigParser解析为统一的BeanDefinition格式，然后，BeansFactory根据BeanDefinition来创建对象。</p>
<p><u>3.配置文件解析</u></p>
<p>配置文件解析主要包含BeanConfigParser接口和XmlBeanConfigParser实现类，负责将配置文件解析为BeanDefinition结构，以便BeansFactory根据这个结构来创建对象。</p>
<p>配置文件的解析比较繁琐，不涉及我们专栏要讲的理论知识，不是我们讲解的重点，所以这里我只给出两个类的大致设计思路，并未给出具体的实现代码。如果感兴趣的话，你可以自行补充完整。具体的代码框架如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanConfigParser</span> &#123;</span><br><span class="line">  List&lt;BeanDefinition&gt; <span class="title function_">parse</span><span class="params">(InputStream inputStream)</span>;</span><br><span class="line">  List&lt;BeanDefinition&gt; <span class="title function_">parse</span><span class="params">(String configContent)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XmlBeanConfigParser</span> <span class="keyword">implements</span> <span class="title class_">BeanConfigParser</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> List&lt;BeanDefinition&gt; <span class="title function_">parse</span><span class="params">(InputStream inputStream)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span>...</span></span><br><span class="line">    <span class="keyword">return</span> parse(content);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> List&lt;BeanDefinition&gt; <span class="title function_">parse</span><span class="params">(String configContent)</span> &#123;</span><br><span class="line">    List&lt;BeanDefinition&gt; beanDefinitions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span>...</span></span><br><span class="line">    <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanDefinition</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String id;</span><br><span class="line">  <span class="keyword">private</span> String className;</span><br><span class="line">  <span class="keyword">private</span> List&lt;ConstructorArg&gt; constructorArgs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Scope</span> <span class="variable">scope</span> <span class="operator">=</span> Scope.SINGLETON;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">lazyInit</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 省略必要的getter/setter/constructors</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> scope.equals(Scope.SINGLETON);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">enum</span> <span class="title class_">Scope</span> &#123;</span><br><span class="line">    SINGLETON,</span><br><span class="line">    PROTOTYPE</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ConstructorArg</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> isRef;</span><br><span class="line">    <span class="keyword">private</span> Class type;</span><br><span class="line">    <span class="keyword">private</span> Object arg;</span><br><span class="line">    <span class="comment">// 省略必要的getter/setter/constructors</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u>4.核心工厂类设计</u></p>
<p>最后，我们来看，BeansFactory是如何设计和实现的。这也是我们这个DI容器最核心的一个类了。它负责根据从配置文件解析得到的BeanDefinition来创建对象。</p>
<p><u>如果对象的scope属性是singleton，那对象创建之后会缓存在singletonObjects这样一个map中，下次再请求此对象的时候，直接从map中取出返回，不需要重新创建。如果对象的scope属性是prototype，那每次请求对象，BeansFactory都会创建一个新的对象返回</u>。</p>
<p>实际上，BeansFactory创建对象用到的主要技术点就是Java中的反射语法：一种动态加载类和创建对象的机制。我们知道，JVM在启动的时候会根据代码自动地加载类、创建对象。至于都要加载哪些类、创建哪些对象，这些都是在代码中写死的，或者说提前写好的。但是，如果某个对象的创建并不是写死在代码中，而是放到配置文件中，我们需要在程序运行期间，动态地根据配置文件来加载类、创建对象，那这部分工作就没法让JVM帮我们自动完成了，我们需要利用Java提供的反射语法自己去编写代码。</p>
<p>搞清楚了反射的原理，BeansFactory的代码就不难看懂了。具体代码实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeansFactory</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> ConcurrentHashMap&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> ConcurrentHashMap&lt;String, BeanDefinition&gt; beanDefinitions = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBeanDefinitions</span><span class="params">(List&lt;BeanDefinition&gt; beanDefinitionList)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (BeanDefinition beanDefinition : beanDefinitionList) &#123;</span><br><span class="line">      <span class="built_in">this</span>.beanDefinitions.putIfAbsent(beanDefinition.getId(), beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (BeanDefinition beanDefinition : beanDefinitionList) &#123;</span><br><span class="line">      <span class="keyword">if</span> (beanDefinition.isLazyInit() == <span class="literal">false</span> &amp;&amp; beanDefinition.isSingleton()) &#123;</span><br><span class="line">        createBean(beanDefinition);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String beanId)</span> &#123;</span><br><span class="line">    <span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> beanDefinitions.get(beanId);</span><br><span class="line">    <span class="keyword">if</span> (beanDefinition == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchBeanDefinitionException</span>(<span class="string">&quot;Bean is not defined: &quot;</span> + beanId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> createBean(beanDefinition);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@VisibleForTesting</span></span><br><span class="line">  <span class="keyword">protected</span> Object <span class="title function_">createBean</span><span class="params">(BeanDefinition beanDefinition)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (beanDefinition.isSingleton() &amp;&amp; singletonObjects.contains(beanDefinition.getId())) &#123;</span><br><span class="line">      <span class="keyword">return</span> singletonObjects.get(beanDefinition.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">Class</span> <span class="variable">beanClass</span> <span class="operator">=</span> Class.forName(beanDefinition.getClassName());</span><br><span class="line">      List&lt;BeanDefinition.ConstructorArg&gt; args = beanDefinition.getConstructorArgs();</span><br><span class="line">      <span class="keyword">if</span> (args.isEmpty()) &#123;</span><br><span class="line">        bean = beanClass.newInstance();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Class[] argClasses = <span class="keyword">new</span> <span class="title class_">Class</span>[args.size()];</span><br><span class="line">        Object[] argObjects = <span class="keyword">new</span> <span class="title class_">Object</span>[args.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.size(); ++i) &#123;</span><br><span class="line">          BeanDefinition.<span class="type">ConstructorArg</span> <span class="variable">arg</span> <span class="operator">=</span> args.get(i);</span><br><span class="line">          <span class="keyword">if</span> (!arg.getIsRef()) &#123;</span><br><span class="line">            argClasses[i] = arg.getType();</span><br><span class="line">            argObjects[i] = arg.getArg();</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">BeanDefinition</span> <span class="variable">refBeanDefinition</span> <span class="operator">=</span> beanDefinitions.get(arg.getArg());</span><br><span class="line">            <span class="keyword">if</span> (refBeanDefinition == <span class="literal">null</span>) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchBeanDefinitionException</span>(<span class="string">&quot;Bean is not defined: &quot;</span> + arg.getArg());</span><br><span class="line">            &#125;</span><br><span class="line">            argClasses[i] = Class.forName(refBeanDefinition.getClassName());</span><br><span class="line">            argObjects[i] = createBean(refBeanDefinition);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bean = beanClass.getConstructor(argClasses).newInstance(argObjects);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException | IllegalAccessException</span><br><span class="line">            | InstantiationException | NoSuchMethodException | InvocationTargetException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationFailureException</span>(<span class="string">&quot;&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bean != <span class="literal">null</span> &amp;&amp; beanDefinition.isSingleton()) &#123;</span><br><span class="line">      singletonObjects.putIfAbsent(beanDefinition.getId(), bean);</span><br><span class="line">      <span class="keyword">return</span> singletonObjects.get(beanDefinition.getId());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="29-创建型：建造者模式"><a href="#29-创建型：建造者模式" class="headerlink" title="29. 创建型：建造者模式"></a>29. 创建型：建造者模式</h3><p>再来学习另外一个比较常用的创建型设计模式，<strong>Builder模式</strong>，中文翻译为<strong>建造者模式</strong>或者<strong>构建者模式</strong>，也有人叫它<strong>生成器模式</strong>。</p>
<p>实际上，建造者模式的原理和代码实现非常简单，掌握起来并不难，难点在于应用场景。比如，你有没有考虑过这样几个问题：直接使用构造函数或者配合set方法就能创建对象，为什么还需要建造者模式来创建呢？建造者模式和工厂模式都可以创建对象，那它们两个的区别在哪里呢？</p>
<p><strong>为什么需要建造者模式？</strong></p>
<p>在平时的开发中，创建一个对象最常用的方式是，使用new关键字调用类的构造函数来完成。我的问题是，什么情况下这种方式就不适用了，就需要采用建造者模式来创建对象呢？你可以先思考一下，下面我通过一个例子来带你看一下。</p>
<p>假设有这样一道设计面试题：我们需要定义一个资源池配置类ResourcePoolConfig。这里的资源池，你可以简单理解为线程池、连接池、对象池等。在这个资源池配置类中，有以下几个成员变量，也就是可配置项。现在，请你编写代码实现这个ResourcePoolConfig类。</p>
<img src="https://static001.geekbang.org/resource/image/21/59/21f970b7c0d6b5afa6aa09ca14f55059.jpg" alt="img" style="zoom: 33%;" />

<p>只要你稍微有点开发经验，那实现这样一个类对你来说并不是件难事。最常见、最容易想到的实现思路如下代码所示。因为maxTotal、maxIdle、minIdle不是必填变量，所以在创建ResourcePoolConfig对象的时候，我们通过往构造函数中，给这几个参数传递null值，来表示使用默认值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResourcePoolConfig</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_MAX_TOTAL</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_MAX_IDLE</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_MIN_IDLE</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxTotal</span> <span class="operator">=</span> DEFAULT_MAX_TOTAL;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxIdle</span> <span class="operator">=</span> DEFAULT_MAX_IDLE;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">minIdle</span> <span class="operator">=</span> DEFAULT_MIN_IDLE;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ResourcePoolConfig</span><span class="params">(String name, Integer maxTotal, Integer maxIdle, Integer minIdle)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(name)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;name should not be empty.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (maxTotal != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (maxTotal &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;maxTotal should be positive.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.maxTotal = maxTotal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (maxIdle != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (maxIdle &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;maxIdle should not be negative.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.maxIdle = maxIdle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minIdle != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (minIdle &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;minIdle should not be negative.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.minIdle = minIdle;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...省略getter方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，ResourcePoolConfig只有4个可配置项，对应到构造函数中，也只有4个参数，参数的个数不多。但是，如果可配置项逐渐增多，变成了8个、10个，甚至更多，那继续沿用现在的设计思路，构造函数的参数列表会变得很长，代码在可读性和易用性上都会变差。在使用构造函数的时候，我们就容易搞错各参数的顺序，传递进错误的参数值，导致非常隐蔽的bug。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数太多，导致可读性差、参数可能传递错误</span></span><br><span class="line"><span class="type">ResourcePoolConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResourcePoolConfig</span>(<span class="string">&quot;dbconnectionpool&quot;</span>, <span class="number">16</span>, <span class="literal">null</span>, <span class="number">8</span>, <span class="literal">null</span>, <span class="literal">false</span> , <span class="literal">true</span>, <span class="number">10</span>, <span class="number">20</span>，<span class="literal">false</span>， <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>解决这个问题的办法你应该也已经想到了，那就是用set()函数来给成员变量赋值，以替代冗长的构造函数。我们直接看代码，具体如下所示。其中，配置项name是必填的，所以我们把它放到构造函数中设置，强制创建类对象的时候就要填写。其他配置项maxTotal、maxIdle、minIdle都不是必填的，所以我们通过set()函数来设置，让使用者自主选择填写或者不填写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResourcePoolConfig</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_MAX_TOTAL</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_MAX_IDLE</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_MIN_IDLE</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxTotal</span> <span class="operator">=</span> DEFAULT_MAX_TOTAL;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxIdle</span> <span class="operator">=</span> DEFAULT_MAX_IDLE;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">minIdle</span> <span class="operator">=</span> DEFAULT_MIN_IDLE;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ResourcePoolConfig</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(name)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;name should not be empty.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMaxTotal</span><span class="params">(<span class="type">int</span> maxTotal)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (maxTotal &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;maxTotal should be positive.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.maxTotal = maxTotal;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMaxIdle</span><span class="params">(<span class="type">int</span> maxIdle)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (maxIdle &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;maxIdle should not be negative.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.maxIdle = maxIdle;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMinIdle</span><span class="params">(<span class="type">int</span> minIdle)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (minIdle &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;minIdle should not be negative.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.minIdle = minIdle;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...省略getter方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们来看新的ResourcePoolConfig类该如何使用。我写了一个示例代码，如下所示。没有了冗长的函数调用和参数列表，代码在可读性和易用性上提高了很多。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ResourcePoolConfig使用举例</span></span><br><span class="line"><span class="type">ResourcePoolConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResourcePoolConfig</span>(<span class="string">&quot;dbconnectionpool&quot;</span>);</span><br><span class="line">config.setMaxTotal(<span class="number">16</span>);</span><br><span class="line">config.setMaxIdle(<span class="number">8</span>);</span><br></pre></td></tr></table></figure>

<p>至此，我们仍然没有用到建造者模式，通过构造函数设置必填项，通过set()方法设置可选配置项，就能实现我们的设计需求。如果我们把问题的难度再加大点，比如，还需要解决下面这三个问题，那现在的设计思路就不能满足了。</p>
<ul>
<li>我们刚刚讲到，name是必填的，所以，我们把它放到构造函数中，强制创建对象的时候就设置。如果必填的配置项有很多，把这些必填配置项都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填项也通过set()方法设置，那校验这些必填项是否已经填写的逻辑就无处安放了。</li>
<li>除此之外，假设配置项之间有一定的依赖关系，比如，如果用户设置了maxTotal、maxIdle、minIdle其中一个，就必须显式地设置另外两个；或者配置项之间有一定的约束条件，比如，maxIdle和minIdle要小于等于maxTotal。如果我们继续使用现在的设计思路，那这些配置项之间的依赖关系或者约束条件的校验逻辑就无处安放了。</li>
<li>如果我们希望ResourcePoolConfig类对象是不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值。要实现这个功能，我们就不能在ResourcePoolConfig类中暴露set()方法。</li>
</ul>
<p>为了解决这些问题，建造者模式就派上用场了。</p>
<p>我们<u>可以把校验逻辑放置到Builder类中，先创建建造者，并且通过set()方法设置建造者的变量值，然后在使用build()方法真正创建对象之前，做集中的校验，校验通过之后才会创建对象</u>。除此之外，我们把ResourcePoolConfig的构造函数改为private私有权限。这样我们就只能通过建造者来创建ResourcePoolConfig类对象。并且，ResourcePoolConfig没有提供任何set()方法，这样我们创建出来的对象就是不可变对象了。</p>
<p>我们用建造者模式重新实现了上面的需求，具体的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResourcePoolConfig</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> maxTotal;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> maxIdle;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> minIdle;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">ResourcePoolConfig</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = builder.name;</span><br><span class="line">    <span class="built_in">this</span>.maxTotal = builder.maxTotal;</span><br><span class="line">    <span class="built_in">this</span>.maxIdle = builder.maxIdle;</span><br><span class="line">    <span class="built_in">this</span>.minIdle = builder.minIdle;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...省略getter方法...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//我们将Builder类设计成了ResourcePoolConfig的内部类。</span></span><br><span class="line">  <span class="comment">//我们也可以将Builder类设计成独立的非内部类ResourcePoolConfigBuilder。</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_MAX_TOTAL</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_MAX_IDLE</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_MIN_IDLE</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxTotal</span> <span class="operator">=</span> DEFAULT_MAX_TOTAL;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxIdle</span> <span class="operator">=</span> DEFAULT_MAX_IDLE;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">minIdle</span> <span class="operator">=</span> DEFAULT_MIN_IDLE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ResourcePoolConfig <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等</span></span><br><span class="line">      <span class="keyword">if</span> (StringUtils.isBlank(name)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (maxIdle &gt; maxTotal) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (minIdle &gt; maxTotal || minIdle &gt; maxIdle) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResourcePoolConfig</span>(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Builder <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.isBlank(name)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Builder <span class="title function_">setMaxTotal</span><span class="params">(<span class="type">int</span> maxTotal)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (maxTotal &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.maxTotal = maxTotal;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Builder <span class="title function_">setMaxIdle</span><span class="params">(<span class="type">int</span> maxIdle)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (maxIdle &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.maxIdle = maxIdle;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Builder <span class="title function_">setMinIdle</span><span class="params">(<span class="type">int</span> minIdle)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (minIdle &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.minIdle = minIdle;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这段代码会抛出IllegalArgumentException，因为minIdle&gt;maxIdle</span></span><br><span class="line"><span class="type">ResourcePoolConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResourcePoolConfig</span>.Builder()</span><br><span class="line">        .setName(<span class="string">&quot;dbconnectionpool&quot;</span>)</span><br><span class="line">        .setMaxTotal(<span class="number">16</span>)</span><br><span class="line">        .setMaxIdle(<span class="number">10</span>)</span><br><span class="line">        .setMinIdle(<span class="number">12</span>)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>

<p>实际上，使用建造者模式创建对象，还能避免对象存在无效状态。我再举个例子解释一下。比如我们定义了一个长方形类，如果不使用建造者模式，采用先创建后set的方式，那就会导致在第一个set之后，对象处于无效状态。具体代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Rectangle r = new Rectange(); // r is invalid</span><br><span class="line">r.setWidth(2); // r is invalid</span><br><span class="line">r.setHeight(3); // r is valid</span><br></pre></td></tr></table></figure>

<p>为了避免这种无效状态的存在，我们就需要<u>使用构造函数一次性初始化好所有的成员变量。如果构造函数参数过多，我们就需要考虑使用建造者模式，先设置建造者的变量，然后再一次性地创建对象，让对象一直处于有效状态</u>。</p>
<p>实际上，如果我们并不是很关心对象是否有短暂的无效状态，也不是太在意对象是否是可变的。比如，对象只是用来映射数据库读出来的数据，那我们直接暴露set()方法来设置类的成员变量值是完全没问题的。而且，使用建造者模式来构建对象，代码实际上是有点重复的，ResourcePoolConfig类中的成员变量，要在Builder类中重新再定义一遍。</p>
<p><strong>与工厂模式有何区别？</strong></p>
<p>从上面的讲解中，我们可以看出，建造者模式是让建造者类来负责对象的创建工作。上一节课中讲到的工厂模式，是由工厂类来负责对象创建的工作。那它们之间有什么区别呢？</p>
<p>实际上，工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象。</p>
<p>网上有一个经典的例子很好地解释了两者的区别。</p>
<p>顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作披萨。</p>
<p>实际上，我们也不要太学院派，非得把工厂模式、建造者模式分得那么清楚，我们需要知道的是，每个模式为什么这么设计，能解决什么问题。<strong>只有了解了这些最本质的东西，我们才能不生搬硬套，才能灵活应用，甚至可以混用各种模式创造出新的模式，来解决特定场景的问题。</strong></p>
<h3 id="30-创建型：原型模式"><a href="#30-创建型：原型模式" class="headerlink" title="30. 创建型：原型模式"></a>30. 创建型：原型模式</h3><p>对于熟悉JavaScript语言的前端程序员来说，原型模式是一种比较常用的开发模式。这是因为，有别于Java、C++等基于类的面向对象编程语言，JavaScript是一种基于原型的面向对象编程语言。即便JavaScript现在也引入了类的概念，但它也只是基于原型的语法糖而已。不过，如果你熟悉的是Java、C++等这些编程语言，那在实际的开发中，就很少用到原型模式了。</p>
<p>今天的讲解跟具体某一语言的语法机制无关，而是通过一个clone散列表的例子带你搞清楚：原型模式的应用场景，以及它的两种实现方式：深拷贝和浅拷贝。</p>
<p><strong>原型模式的原理与应用</strong></p>
<p>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作<strong>原型设计模式</strong>（Prototype Design Pattern），简称<strong>原型模式</strong>。</p>
<p><strong>那何为“对象的创建成本比较大”？</strong></p>
<p>实际上，创建对象包含的申请内存、给成员变量赋值这一过程，本身并不会花费太多时间，或者说对于大部分业务系统来说，这点时间完全是可以忽略的。应用一个复杂的模式，只得到一点点的性能提升，这就是所谓的过度设计，得不偿失。</p>
<p>但是，<u>如果对象中的数据需要经过复杂的计算才能得到（比如排序、计算哈希值），或者需要从RPC、网络、数据库、文件系统等非常慢速的IO中读取，这种情况下，我们就可以利用原型模式，从其他已有对象中直接拷贝得到，而不用每次在创建新对象的时候，都重复执行这些耗时的操作</u>。</p>
<p><strong>这么说还是比较理论，接下来，我们通过一个例子来解释一下刚刚这段话。</strong></p>
<p>假设数据库中存储了大约10万条“搜索关键词”信息，每条信息包含关键词、关键词被搜索的次数、信息最近被更新的时间等。系统A在启动的时候会加载这份数据到内存中，用于处理某些其他的业务需求。为了方便快速地查找某个关键词对应的信息，我们给关键词建立一个散列表索引。</p>
<p>如果你熟悉的是Java语言，可以直接使用语言中提供的HashMap容器来实现。其中，HashMap的key为搜索关键词，value为关键词详细信息（比如搜索次数）。我们只需要将数据从数据库中读取出来，放入HashMap就可以了。</p>
<p>不过，我们还有另外一个系统B，专门用来分析搜索日志，定期（比如间隔10分钟）批量地更新数据库中的数据，并且标记为新的数据版本。比如，在下面的示例图中，我们对v2版本的数据进行更新，得到v3版本的数据。这里我们假设只有更新和新添关键词，没有删除关键词的行为。</p>
<img src="https://static001.geekbang.org/resource/image/05/0e/05233c28ddda51b81dfd946ffdef640e.jpg" alt="img" style="zoom:33%;" />

<p>为了保证系统A中数据的实时性（不一定非常实时，但数据也不能太旧），系统A需要定期根据数据库中的数据，更新内存中的索引和数据。</p>
<p>我们该如何实现这个需求呢？</p>
<p>实际上，也不难。我们只需要在系统A中，记录当前数据的版本Va对应的更新时间Ta，从数据库中捞出更新时间大于Ta的所有搜索关键词，也就是找出Va版本与最新版本数据的“差集”，然后针对差集中的每个关键词进行处理。如果它已经在散列表中存在了，我们就更新相应的搜索次数、更新时间等信息；如果它在散列表中不存在，我们就将它插入到散列表中。</p>
<p>按照这个设计思路，我给出的示例代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> ConcurrentHashMap&lt;String, SearchWord&gt; currentKeywords = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> <span class="variable">lastUpdateTime</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到currentKeywords中</span></span><br><span class="line">    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);</span><br><span class="line">    <span class="type">long</span> <span class="variable">maxNewUpdatedTime</span> <span class="operator">=</span> lastUpdateTime;</span><br><span class="line">    <span class="keyword">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;</span><br><span class="line">      <span class="keyword">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;</span><br><span class="line">        maxNewUpdatedTime = searchWord.getLastUpdateTime();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (currentKeywords.containsKey(searchWord.getKeyword())) &#123;</span><br><span class="line">        currentKeywords.replace(searchWord.getKeyword(), searchWord);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        currentKeywords.put(searchWord.getKeyword(), searchWord);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastUpdateTime = maxNewUpdatedTime;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> List&lt;SearchWord&gt; <span class="title function_">getSearchWords</span><span class="params">(<span class="type">long</span> lastUpdateTime)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 从数据库中取出更新时间&gt;lastUpdateTime的数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过，现在，我们有一个特殊的要求：任何时刻，系统A中的所有数据都必须是同一个版本的，要么都是版本a，要么都是版本b，不能有的是版本a，有的是版本b。那刚刚的更新方式就不能满足这个要求了。除此之外，我们还要求：在更新内存数据的时候，系统A不能处于不可用状态，也就是不能停机更新数据。</p>
<p>那我们该如何实现现在这个需求呢？</p>
<p>实际上，也不难。我们把正在使用的数据的版本定义为“服务版本”，当我们要更新内存中的数据的时候，我们并不是直接在服务版本（假设是版本a数据）上更新，而是重新创建另一个版本数据（假设是版本b数据），等新的版本数据建好之后，再一次性地将服务版本从版本a切换到版本b。这样既保证了数据一直可用，又避免了中间状态的存在。</p>
<p>按照这个设计思路，我给出的示例代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> &#123;</span><br><span class="line">    HashMap&lt;String, SearchWord&gt; newKeywords = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从数据库中取出所有的数据，放入到newKeywords中</span></span><br><span class="line">    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords();</span><br><span class="line">    <span class="keyword">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;</span><br><span class="line">      newKeywords.put(searchWord.getKeyword(), searchWord);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    currentKeywords = newKeywords;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> List&lt;SearchWord&gt; <span class="title function_">getSearchWords</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 从数据库中取出所有的数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过，在上面的代码实现中，newKeywords构建的成本比较高。我们需要将这10万条数据从数据库中读出，然后计算哈希值，构建newKeywords。这个过程显然是比较耗时。为了提高效率，原型模式就派上用场了。</p>
<p>我们拷贝currentKeywords数据到newKeywords中，然后从数据库中只捞出新增或者有更新的关键词，更新到newKeywords中。而相对于10万条数据来说，每次新增或者更新的关键词个数是比较少的，所以，这种策略大大提高了数据更新的效率。</p>
<p>按照这个设计思路，我给出的示例代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> <span class="variable">lastUpdateTime</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 原型模式就这么简单，拷贝已有对象的数据，更新少量差值</span></span><br><span class="line">    HashMap&lt;String, SearchWord&gt; newKeywords = (HashMap&lt;String, SearchWord&gt;) currentKeywords.clone();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中</span></span><br><span class="line">    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);</span><br><span class="line">    <span class="type">long</span> <span class="variable">maxNewUpdatedTime</span> <span class="operator">=</span> lastUpdateTime;</span><br><span class="line">    <span class="keyword">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;</span><br><span class="line">      <span class="keyword">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;</span><br><span class="line">        maxNewUpdatedTime = searchWord.getLastUpdateTime();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (newKeywords.containsKey(searchWord.getKeyword())) &#123;</span><br><span class="line">        <span class="type">SearchWord</span> <span class="variable">oldSearchWord</span> <span class="operator">=</span> newKeywords.get(searchWord.getKeyword());</span><br><span class="line">        oldSearchWord.setCount(searchWord.getCount());</span><br><span class="line">        oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newKeywords.put(searchWord.getKeyword(), searchWord);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastUpdateTime = maxNewUpdatedTime;</span><br><span class="line">    currentKeywords = newKeywords;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> List&lt;SearchWord&gt; <span class="title function_">getSearchWords</span><span class="params">(<span class="type">long</span> lastUpdateTime)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 从数据库中取出更新时间&gt;lastUpdateTime的数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们利用了Java中的clone()语法来复制一个对象。如果你熟悉的语言没有这个语法，那把数据从currentKeywords中一个个取出来，然后再重新计算哈希值，放入到newKeywords中也是可以接受的。毕竟，最耗时的还是从数据库中取数据的操作。相对于数据库的IO操作来说，内存操作和CPU计算的耗时都是可以忽略的。</p>
<p>不过，不知道你有没有发现，实际上，刚刚的代码实现是有问题的。要弄明白到底有什么问题，我们需要先了解另外两个概念：深拷贝（Deep Copy）和浅拷贝（Shallow Copy）。</p>
<p><strong>原型模式的实现方式：深拷贝和浅拷贝</strong></p>
<p>我们来看，在内存中，用散列表组织的搜索关键词信息是如何存储的。我画了一张示意图，大致结构如下所示。从图中我们可以发现，散列表索引中，每个结点存储的key是搜索关键词，value是SearchWord对象的内存地址。SearchWord对象本身存储在散列表之外的内存空间中。</p>
<img src="https://static001.geekbang.org/resource/image/f5/d2/f5ba85952b27a569687e2d44352216d2.jpg" alt="img" style="zoom:33%;" />

<p>浅拷贝和深拷贝的区别在于，浅拷贝只会复制图中的索引（散列表），不会复制数据（SearchWord对象）本身。相反，深拷贝不仅仅会复制索引，还会复制数据本身。浅拷贝得到的对象（newKeywords）跟原始对象（currentKeywords）共享数据（SearchWord对象），而深拷贝得到的是一份完完全全独立的对象。具体的对比如下图所示：</p>
<p><img src="https://static001.geekbang.org/resource/image/74/82/74bceb7a0736957daaa4abeba6826182.jpg" alt="img"></p>
<p><img src="https://static001.geekbang.org/resource/image/b9/1b/b978d054ab3183b9e0ae461e6abac81b.jpg" alt="img"></p>
<p><u>在Java语言中，Object类的clone()方法执行的就是我们刚刚说的浅拷贝。它只会拷贝对象中的基本数据类型的数据（比如，int、long），以及引用对象（SearchWord）的内存地址，不会递归地拷贝引用对象本身</u>。</p>
<p>在上面的代码中，我们通过调用HashMap上的clone()浅拷贝方法来实现原型模式。当我们通过newKeywords更新SearchWord对象的时候（比如，更新“设计模式”这个搜索关键词的访问次数），newKeywords和currentKeywords因为指向相同的一组SearchWord对象，就会导致currentKeywords中指向的SearchWord，有的是老版本的，有的是新版本的，就没法满足我们之前的需求：currentKeywords中的数据在任何时刻都是同一个版本的，不存在介于老版本与新版本之间的中间状态。</p>
<p>现在，我们又该如何来解决这个问题呢？</p>
<p>我们可以将浅拷贝替换为深拷贝。newKeywords不仅仅复制currentKeywords的索引，还把SearchWord对象也复制一份出来，这样newKeywords和currentKeywords就指向不同的SearchWord对象，也就不存在更新newKeywords的数据会导致currentKeywords的数据也被更新的问题了。</p>
<p>那如何实现深拷贝呢？总结一下的话，有下面两种方法。</p>
<p>第一种方法：递归拷贝对象、对象的引用对象以及引用对象的引用对象……直到要拷贝的对象只包含基本数据类型数据，没有引用对象为止。根据这个思路对之前的代码进行重构。重构之后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> <span class="variable">lastUpdateTime</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Deep copy</span></span><br><span class="line">    HashMap&lt;String, SearchWord&gt; newKeywords = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (HashMap.Entry&lt;String, SearchWord&gt; e : currentKeywords.entrySet()) &#123;</span><br><span class="line">      <span class="type">SearchWord</span> <span class="variable">searchWord</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">      <span class="type">SearchWord</span> <span class="variable">newSearchWord</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchWord</span>(</span><br><span class="line">              searchWord.getKeyword(), searchWord.getCount(), searchWord.getLastUpdateTime());</span><br><span class="line">      newKeywords.put(e.getKey(), newSearchWord);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中</span></span><br><span class="line">    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);</span><br><span class="line">    <span class="type">long</span> <span class="variable">maxNewUpdatedTime</span> <span class="operator">=</span> lastUpdateTime;</span><br><span class="line">    <span class="keyword">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;</span><br><span class="line">      <span class="keyword">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;</span><br><span class="line">        maxNewUpdatedTime = searchWord.getLastUpdateTime();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (newKeywords.containsKey(searchWord.getKeyword())) &#123;</span><br><span class="line">        <span class="type">SearchWord</span> <span class="variable">oldSearchWord</span> <span class="operator">=</span> newKeywords.get(searchWord.getKeyword());</span><br><span class="line">        oldSearchWord.setCount(searchWord.getCount());</span><br><span class="line">        oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newKeywords.put(searchWord.getKeyword(), searchWord);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastUpdateTime = maxNewUpdatedTime;</span><br><span class="line">    currentKeywords = newKeywords;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> List&lt;SearchWord&gt; <span class="title function_">getSearchWords</span><span class="params">(<span class="type">long</span> lastUpdateTime)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 从数据库中取出更新时间&gt;lastUpdateTime的数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种方法：先将对象序列化，然后再反序列化成新的对象。具体的示例代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">deepCopy</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">  <span class="type">ByteArrayOutputStream</span> <span class="variable">bo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">  <span class="type">ObjectOutputStream</span> <span class="variable">oo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bo);</span><br><span class="line">  oo.writeObject(object);</span><br><span class="line">  </span><br><span class="line">  <span class="type">ByteArrayInputStream</span> <span class="variable">bi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bo.toByteArray());</span><br><span class="line">  <span class="type">ObjectInputStream</span> <span class="variable">oi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bi);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> oi.readObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>刚刚的两种实现方法，不管采用哪种，深拷贝都要比浅拷贝耗时、耗内存空间。针对我们这个应用场景，有没有更快、更省内存的实现方式呢？</p>
<p>我们<u>可以先采用浅拷贝的方式创建newKeywords。对于需要更新的SearchWord对象，我们再使用深度拷贝的方式创建一份新的对象，替换newKeywords中的老对象</u>。毕竟需要更新的数据是很少的。这种方式即利用了浅拷贝节省时间、空间的优点，又能保证currentKeywords中的中数据都是老版本的数据。具体的代码实现如下所示。这也是标题中讲到的，在我们这个应用场景下，最快速clone散列表的方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> <span class="variable">lastUpdateTime</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Shallow copy</span></span><br><span class="line">    HashMap&lt;String, SearchWord&gt; newKeywords = (HashMap&lt;String, SearchWord&gt;) currentKeywords.clone();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中</span></span><br><span class="line">    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);</span><br><span class="line">    <span class="type">long</span> <span class="variable">maxNewUpdatedTime</span> <span class="operator">=</span> lastUpdateTime;</span><br><span class="line">    <span class="keyword">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;</span><br><span class="line">      <span class="keyword">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;</span><br><span class="line">        maxNewUpdatedTime = searchWord.getLastUpdateTime();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (newKeywords.containsKey(searchWord.getKeyword())) &#123;</span><br><span class="line">        newKeywords.remove(searchWord.getKeyword());</span><br><span class="line">      &#125;</span><br><span class="line">      newKeywords.put(searchWord.getKeyword(), searchWord);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastUpdateTime = maxNewUpdatedTime;</span><br><span class="line">    currentKeywords = newKeywords;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> List&lt;SearchWord&gt; <span class="title function_">getSearchWords</span><span class="params">(<span class="type">long</span> lastUpdateTime)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 从数据库中取出更新时间&gt;lastUpdateTime的数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="31-结构型：代理模式"><a href="#31-结构型：代理模式" class="headerlink" title="31. 结构型：代理模式"></a>31. 结构型：代理模式</h3><p>结构型模式主要总结了一些类或对象组合在一起的经典结构，这些经典的结构可以解决特定应用场景的问题。结构型模式包括：代理模式、桥接模式、装饰器模式、适配器模式、门面模式、组合模式、享元模式。今天我们要讲其中的代理模式。它也是在实际开发中经常被用到的一种设计模式。</p>
<p><strong>代理模式的原理解析</strong></p>
<p><strong>代理模式</strong>（Proxy Design Pattern）的原理和代码实现都不难掌握。它<u>在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能</u>。我们通过一个简单的例子来解释一下这段话。</p>
<p>这个例子来自性能计数器。当时我们开发了一个MetricsCollector类，用来收集接口请求的原始数据，比如访问时间、处理时长等。在业务系统中，我们采用如下方式来使用这个MetricsCollector类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">  <span class="comment">//...省略其他属性和方法...</span></span><br><span class="line">  <span class="keyword">private</span> MetricsCollector metricsCollector; <span class="comment">// 依赖注入</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> UserVo <span class="title function_">login</span><span class="params">(String telephone, String password)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTimestamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略login逻辑...</span></span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">endTimeStamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">long</span> <span class="variable">responseTime</span> <span class="operator">=</span> endTimeStamp - startTimestamp;</span><br><span class="line">    <span class="type">RequestInfo</span> <span class="variable">requestInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestInfo</span>(<span class="string">&quot;login&quot;</span>, responseTime, startTimestamp);</span><br><span class="line">    metricsCollector.recordRequest(requestInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...返回UserVo数据...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> UserVo <span class="title function_">register</span><span class="params">(String telephone, String password)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTimestamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略register逻辑...</span></span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">endTimeStamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">long</span> <span class="variable">responseTime</span> <span class="operator">=</span> endTimeStamp - startTimestamp;</span><br><span class="line">    <span class="type">RequestInfo</span> <span class="variable">requestInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestInfo</span>(<span class="string">&quot;register&quot;</span>, responseTime, startTimestamp);</span><br><span class="line">    metricsCollector.recordRequest(requestInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...返回UserVo数据...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显，上面的写法有两个问题。第一，性能计数器框架代码侵入到业务代码中，跟业务代码高度耦合。如果未来需要替换这个框架，那替换的成本会比较大。第二，收集接口请求的代码跟业务代码无关，本就不应该放到一个类中。业务类最好职责更加单一，只聚焦业务处理。</p>
<p>为了将框架代码和业务代码解耦，代理模式就派上用场了。代理类UserControllerProxy和原始类UserController实现相同的接口IUserController。UserController类只负责业务功能。<u>代理类UserControllerProxy负责在业务代码执行前后附加其他逻辑代码，并通过委托的方式调用原始类来执行业务代码</u>。具体的代码实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUserController</span> &#123;</span><br><span class="line">  UserVo <span class="title function_">login</span><span class="params">(String telephone, String password)</span>;</span><br><span class="line">  UserVo <span class="title function_">register</span><span class="params">(String telephone, String password)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> <span class="keyword">implements</span> <span class="title class_">IUserController</span> &#123;</span><br><span class="line">  <span class="comment">//...省略其他属性和方法...</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> UserVo <span class="title function_">login</span><span class="params">(String telephone, String password)</span> &#123;</span><br><span class="line">    <span class="comment">//...省略login逻辑...</span></span><br><span class="line">    <span class="comment">//...返回UserVo数据...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> UserVo <span class="title function_">register</span><span class="params">(String telephone, String password)</span> &#123;</span><br><span class="line">    <span class="comment">//...省略register逻辑...</span></span><br><span class="line">    <span class="comment">//...返回UserVo数据...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserControllerProxy</span> <span class="keyword">implements</span> <span class="title class_">IUserController</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> MetricsCollector metricsCollector;</span><br><span class="line">  <span class="keyword">private</span> UserController userController;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">UserControllerProxy</span><span class="params">(UserController userController)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.userController = userController;</span><br><span class="line">    <span class="built_in">this</span>.metricsCollector = <span class="keyword">new</span> <span class="title class_">MetricsCollector</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> UserVo <span class="title function_">login</span><span class="params">(String telephone, String password)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTimestamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 委托</span></span><br><span class="line">    <span class="type">UserVo</span> <span class="variable">userVo</span> <span class="operator">=</span> userController.login(telephone, password);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">endTimeStamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">long</span> <span class="variable">responseTime</span> <span class="operator">=</span> endTimeStamp - startTimestamp;</span><br><span class="line">    <span class="type">RequestInfo</span> <span class="variable">requestInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestInfo</span>(<span class="string">&quot;login&quot;</span>, responseTime, startTimestamp);</span><br><span class="line">    metricsCollector.recordRequest(requestInfo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> userVo;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> UserVo <span class="title function_">register</span><span class="params">(String telephone, String password)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTimestamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="type">UserVo</span> <span class="variable">userVo</span> <span class="operator">=</span> userController.register(telephone, password);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">endTimeStamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">long</span> <span class="variable">responseTime</span> <span class="operator">=</span> endTimeStamp - startTimestamp;</span><br><span class="line">    <span class="type">RequestInfo</span> <span class="variable">requestInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestInfo</span>(<span class="string">&quot;register&quot;</span>, responseTime, startTimestamp);</span><br><span class="line">    metricsCollector.recordRequest(requestInfo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> userVo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//UserControllerProxy使用举例</span></span><br><span class="line"><span class="comment">//因为原始类和代理类实现相同的接口，是基于接口而非实现编程</span></span><br><span class="line"><span class="comment">//将UserController类对象替换为UserControllerProxy类对象，不需要改动太多代码</span></span><br><span class="line"><span class="type">IUserController</span> <span class="variable">userController</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserControllerProxy</span>(<span class="keyword">new</span> <span class="title class_">UserController</span>());</span><br></pre></td></tr></table></figure>

<p>参照基于接口而非实现编程的设计思想，将原始类对象替换为代理类对象的时候，为了让代码改动尽量少，在刚刚的代理模式的代码实现中，代理类和原始类需要实现相同的接口。但是，如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的（比如它来自一个第三方的类库），我们也没办法直接修改原始类，给它重新定义一个接口。在这种情况下，我们该如何实现代理模式呢？</p>
<p><u>对于这种外部类的扩展，我们一般都是采用继承的方式</u>。这里也不例外。我们让代理类继承原始类，然后扩展附加功能。原理很简单，不需要过多解释，你直接看代码就能明白。具体代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserControllerProxy</span> <span class="keyword">extends</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> MetricsCollector metricsCollector;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">UserControllerProxy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.metricsCollector = <span class="keyword">new</span> <span class="title class_">MetricsCollector</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> UserVo <span class="title function_">login</span><span class="params">(String telephone, String password)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTimestamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="type">UserVo</span> <span class="variable">userVo</span> <span class="operator">=</span> <span class="built_in">super</span>.login(telephone, password);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">endTimeStamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">long</span> <span class="variable">responseTime</span> <span class="operator">=</span> endTimeStamp - startTimestamp;</span><br><span class="line">    <span class="type">RequestInfo</span> <span class="variable">requestInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestInfo</span>(<span class="string">&quot;login&quot;</span>, responseTime, startTimestamp);</span><br><span class="line">    metricsCollector.recordRequest(requestInfo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> userVo;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> UserVo <span class="title function_">register</span><span class="params">(String telephone, String password)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTimestamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="type">UserVo</span> <span class="variable">userVo</span> <span class="operator">=</span> <span class="built_in">super</span>.register(telephone, password);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">endTimeStamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">long</span> <span class="variable">responseTime</span> <span class="operator">=</span> endTimeStamp - startTimestamp;</span><br><span class="line">    <span class="type">RequestInfo</span> <span class="variable">requestInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestInfo</span>(<span class="string">&quot;register&quot;</span>, responseTime, startTimestamp);</span><br><span class="line">    metricsCollector.recordRequest(requestInfo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> userVo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//UserControllerProxy使用举例</span></span><br><span class="line"><span class="type">UserController</span> <span class="variable">userController</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserControllerProxy</span>();</span><br></pre></td></tr></table></figure>

<p><strong>动态代理的原理解析</strong></p>
<p>不过，刚刚的代码实现还是有点问题。一方面，我们需要在代理类中，将原始类中的所有的方法，都重新实现一遍，并且为每个方法都附加相似的代码逻辑。另一方面，如果要添加的附加功能的类有不止一个，我们需要针对每个类都创建一个代理类。</p>
<p>如果有50个要添加附加功能的原始类，那我们就要创建50个对应的代理类。这会导致项目中类的个数成倍增加，增加了代码维护成本。并且，每个代理类中的代码都有点像模板式的“重复”代码，也增加了不必要的开发成本。那这个问题怎么解决呢？</p>
<p>我们可以使用动态代理来解决这个问题。所谓<strong>动态代理</strong>（Dynamic Proxy），就是我们不事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。那如何实现动态代理呢？</p>
<p>如果你熟悉的是Java语言，实现动态代理就是件很简单的事情。因为Java语言本身就已经提供了动态代理的语法（实际上，动态代理底层依赖的就是Java的反射语法）。我们来看一下，如何用Java的动态代理来实现刚刚的功能。具体的代码如下所示。其中，MetricsCollectorProxy作为一个动态代理类，<u>动态地给每个需要收集接口请求信息的类创建代理类</u>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MetricsCollectorProxy</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> MetricsCollector metricsCollector;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MetricsCollectorProxy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.metricsCollector = <span class="keyword">new</span> <span class="title class_">MetricsCollector</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">createProxy</span><span class="params">(Object proxiedObject)</span> &#123;</span><br><span class="line">    Class&lt;?&gt;[] interfaces = proxiedObject.getClass().getInterfaces();</span><br><span class="line">    <span class="type">DynamicProxyHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DynamicProxyHandler</span>(proxiedObject);</span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(proxiedObject.getClass().getClassLoader(), interfaces, handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">DynamicProxyHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object proxiedObject;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DynamicProxyHandler</span><span class="params">(Object proxiedObject)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.proxiedObject = proxiedObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">      <span class="type">long</span> <span class="variable">startTimestamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">      <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(proxiedObject, args);</span><br><span class="line">      <span class="type">long</span> <span class="variable">endTimeStamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">      <span class="type">long</span> <span class="variable">responseTime</span> <span class="operator">=</span> endTimeStamp - startTimestamp;</span><br><span class="line">      <span class="type">String</span> <span class="variable">apiName</span> <span class="operator">=</span> proxiedObject.getClass().getName() + <span class="string">&quot;:&quot;</span> + method.getName();</span><br><span class="line">      <span class="type">RequestInfo</span> <span class="variable">requestInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestInfo</span>(apiName, responseTime, startTimestamp);</span><br><span class="line">      metricsCollector.recordRequest(requestInfo);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MetricsCollectorProxy使用举例</span></span><br><span class="line"><span class="type">MetricsCollectorProxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MetricsCollectorProxy</span>();</span><br><span class="line"><span class="type">IUserController</span> <span class="variable">userController</span> <span class="operator">=</span> (IUserController) proxy.createProxy(<span class="keyword">new</span> <span class="title class_">UserController</span>());</span><br></pre></td></tr></table></figure>

<p>实际上，<u>Spring AOP底层的实现原理就是基于动态代理</u>。用户配置好需要给哪些类创建代理，并定义好在执行原始类的业务代码前后执行哪些附加功能。Spring为这些类创建动态代理对象，并在JVM中替代原始类对象。原本在代码中执行的原始类的方法，被换作执行代理类的方法，也就实现了给原始类添加附加功能的目的。</p>
<p><strong>代理模式的应用场景</strong></p>
<p>代理模式的应用场景非常多，我这里列举一些比较常见的用法，希望你能举一反三地应用在你的项目开发中。</p>
<p><u>1.业务系统的非功能性需求开发</u></p>
<p>代理模式最常用的一个应用场景就是，在<u>业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。</u>我们将这些附加功能与业务功能解耦，放到代理类中统一处理，让程序员只需要关注业务方面的开发。实际上，前面举的搜集接口请求信息的例子，就是这个应用场景的一个典型例子。</p>
<p>如果你熟悉Java语言和Spring开发框架，这部分工作都是可以在Spring AOP切面中完成的。前面我们也提到，Spring AOP底层的实现原理就是基于动态代理。</p>
<p><u>2.代理模式在RPC、缓存中的应用</u></p>
<p><strong>实际上，RPC框架也可以看作一种代理模式</strong>，GoF的《设计模式》一书中把它称作远程代理。通过远程代理，将网络通信、数据编解码等细节隐藏起来。客户端在使用RPC服务的时候，就像使用本地函数一样，无需了解跟服务器交互的细节。除此之外，RPC服务的开发者也只需要开发业务逻辑，就像开发本地使用的函数一样，不需要关注跟客户端的交互细节。</p>
<p>关于远程代理的代码示例，我自己实现了一个简单的RPC框架Demo，放到了GitHub中，你可以点击这里的<a href="https://github.com/wangzheng0822/codedesign/tree/master/com/xzg/cd/rpc">链接</a>查看。</p>
<p><strong>我们再来看代理模式在缓存中的应用。</strong>假设我们要开发一个接口请求的缓存功能，对于某些接口请求，如果入参相同，在设定的过期时间内，直接返回缓存结果，而不用重新进行逻辑处理。比如，针对获取用户个人信息的需求，我们可以开发两个接口，一个支持缓存，一个支持实时查询。对于需要实时数据的需求，我们让其调用实时查询接口，对于不需要实时数据的需求，我们让其调用支持缓存的接口。那如何来实现接口请求的缓存功能呢？</p>
<p>最简单的实现方法就是刚刚我们讲到的，给每个需要支持缓存的查询需求都开发两个不同的接口，一个支持缓存，一个支持实时查询。但是，这样做显然增加了开发成本，而且会让代码看起来非常臃肿（接口个数成倍增加），也不方便缓存接口的集中管理（增加、删除缓存接口）、集中配置（比如配置每个接口缓存过期时间）。</p>
<p>针对这些问题，代理模式就能派上用场了，确切地说，应该是动态代理。如果是基于Spring框架来开发的话，那就可以在AOP切面中完成接口缓存的功能。在应用启动的时候，我们从配置文件中加载需要支持缓存的接口，以及相应的缓存策略（比如过期时间）等。当请求到来的时候，我们在AOP切面中拦截请求，如果请求中带有支持缓存的字段（比如http:&#x2F;&#x2F;…?..&amp;cached&#x3D;true），我们便从缓存（内存缓存或者Redis缓存等）中获取数据直接返回。</p>
<h3 id="32-结构型：桥接模式"><a href="#32-结构型：桥接模式" class="headerlink" title="32. 结构型：桥接模式"></a>32. 结构型：桥接模式</h3><p>再学习另外一种结构型模式：桥接模式。桥接模式的代码实现非常简单，但是理解起来稍微有点难度，并且应用场景也比较局限，所以，相当于代理模式来说，桥接模式在实际的项目中并没有那么常用，你只需要简单了解，见到能认识就可以，并不是我们学习的重点。</p>
<p><strong>桥接模式的原理解析</strong></p>
<p><strong>桥接模式</strong>，也叫作<strong>桥梁模式</strong>，英文是<strong>Bridge Design Pattern</strong>。这个模式可以说是23种设计模式中最难理解的模式之一了。我查阅了比较多的书籍和资料之后发现，对于这个模式有两种不同的理解方式。</p>
<p>当然，这其中“最纯正”的理解方式，当属GoF的《设计模式》一书中对桥接模式的定义。毕竟，这23种经典的设计模式，最初就是由这本书总结出来的。在GoF的《设计模式》一书中，桥接模式是这么定义的：“Decouple an abstraction from its implementation so that the two can vary independently。”翻译成中文就是：“将抽象和实现解耦，让它们可以独立变化。”</p>
<p>关于桥接模式，很多书籍、资料中，还有另外一种理解方式：“一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。”通过组合关系来替代继承关系，避免继承层次的指数级爆炸。这种理解方式非常类似于，我们之前讲过的“组合优于继承”设计原则，所以，这里我就不多解释了。我们重点看下GoF的理解方式。</p>
<p>GoF给出的定义非常的简短，单凭这一句话，估计没几个人能看懂是什么意思。所以，我们通过JDBC驱动的例子来解释一下。JDBC驱动是桥接模式的经典应用。我们先来看一下，如何利用JDBC驱动来查询数据库。具体的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);<span class="comment">//加载及注册JDBC驱动程序</span></span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/sample_db?user=root&amp;password=your_password&quot;</span>;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> DriverManager.getConnection(url);</span><br><span class="line"><span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> con.createStatement()；</span><br><span class="line"><span class="type">String</span> <span class="variable">query</span> <span class="operator">=</span> <span class="string">&quot;select * from test&quot;</span>;</span><br><span class="line">ResultSet rs=stmt.executeQuery(query);</span><br><span class="line"><span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">  rs.getString(<span class="number">1</span>);</span><br><span class="line">  rs.getInt(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们想要把MySQL数据库换成Oracle数据库，只需要把第一行代码中的com.mysql.jdbc.Driver换成oracle.jdbc.driver.OracleDriver就可以了。当然，也有更灵活的实现方式，我们可以把需要加载的Driver类写到配置文件中，当程序启动的时候，自动从配置文件中加载，这样在切换数据库的时候，我们都不需要修改代码，只需要修改配置文件就可以了。</p>
<p>不管是改代码还是改配置，在项目中，从一个数据库切换到另一种数据库，都只需要改动很少的代码，或者完全不需要改动代码，那如此优雅的数据库切换是如何实现的呢？</p>
<p>源码之下无秘密。要弄清楚这个问题，我们先从com.mysql.jdbc.Driver这个类的代码看起。我摘抄了部分相关代码，放到了这里，你可以看一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mysql.jdbc;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Driver</span> <span class="keyword">extends</span> <span class="title class_">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title class_">java</span>.sql.Driver &#123;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			java.sql.DriverManager.registerDriver(<span class="keyword">new</span> <span class="title class_">Driver</span>());</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException E) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Can&#x27;t register driver!&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Construct a new driver and register it with DriverManager</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> SQLException if a database error occurs.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">		<span class="comment">// Required for Class.forName().newInstance()</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合com.mysql.jdbc.Drive+r的代码实现，我们可以发现，当执行Class.forName(“com.mysql.jdbc.Driver”)这条语句的时候，实际上是做了两件事情。第一件事情是要求JVM查找并加载指定的Driver类，第二件事情是执行该类的静态代码，也就是将MySQL Driver注册到DriverManager类中。</p>
<p>现在，我们再来看一下，DriverManager类是干什么用的。具体的代码如下所示。当我们把具体的Driver实现类（比如，com.mysql.jdbc.Driver）注册到DriverManager之后，后续所有对JDBC接口的调用，都会委派到对具体的Driver实现类来执行。而Driver实现类都实现了相同的接口（java.sql.Driver ），这也是可以灵活切换Driver的原因。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DriverManager</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;DriverInfo&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    loadInitialDrivers();</span><br><span class="line">    println(<span class="string">&quot;JDBC DriverManager initialized&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">registerDriver</span><span class="params">(java.sql.Driver driver)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="keyword">if</span> (driver != <span class="literal">null</span>) &#123;</span><br><span class="line">      registeredDrivers.addIfAbsent(<span class="keyword">new</span> <span class="title class_">DriverInfo</span>(driver));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">(String url, String user, String password)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    java.util.<span class="type">Properties</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.util.Properties();</span><br><span class="line">    <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">      info.put(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (password != <span class="literal">null</span>) &#123;</span><br><span class="line">      info.put(<span class="string">&quot;password&quot;</span>, password);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (getConnection(url, info, Reflection.getCallerClass()));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>桥接模式的定义是“将抽象和实现解耦，让它们可以独立变化”。那弄懂定义中“抽象”和“实现”两个概念，就是理解桥接模式的关键。那在JDBC这个例子中，什么是“抽象”？什么是“实现”呢？</p>
<p>实际上，JDBC本身就相当于“抽象”。注意，这里所说的“抽象”，指的并非“抽象类”或“接口”，而是跟具体的数据库无关的、被抽象出来的一套“类库”。具体的Driver（比如，com.mysql.jdbc.Driver）就相当于“实现”。注意，这里所说的“实现”，也并非指“接口的实现类”，而是跟具体数据库相关的一套“类库”。JDBC和Driver独立开发，通过对象之间的组合关系，组装在一起。JDBC的所有逻辑操作，最终都委托给Driver来执行。</p>
<p>我画了一张图帮助你理解，你可以结合着我刚才的讲解一块看。</p>
<img src="https://static001.geekbang.org/resource/image/81/40/812234b0717043a67c2d62ea8e783b40.jpg" alt="img" style="zoom:33%;" />

<p><strong>桥接模式的应用举例</strong></p>
<p>我们讲过一个API接口监控告警的例子：根据不同的告警规则，触发不同类型的告警。告警支持多种通知渠道，包括：邮件、短信、微信、自动语音电话。通知的紧急程度有多种类型，包括：SEVERE（严重）、URGENCY（紧急）、NORMAL（普通）、TRIVIAL（无关紧要）。不同的紧急程度对应不同的通知渠道。比如，SERVE（严重）级别的消息会通过“自动语音电话”告知相关人员。</p>
<p>在当时的代码实现中，关于发送告警信息那部分代码，我们只给出了粗略的设计，现在我们来一块实现一下。我们先来看最简单、最直接的一种实现方式。代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">NotificationEmergencyLevel</span> &#123;</span><br><span class="line">  SEVERE, URGENCY, NORMAL, TRIVIAL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Notification</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> List&lt;String&gt; emailAddresses;</span><br><span class="line">  <span class="keyword">private</span> List&lt;String&gt; telephones;</span><br><span class="line">  <span class="keyword">private</span> List&lt;String&gt; wechatIds;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Notification</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEmailAddress</span><span class="params">(List&lt;String&gt; emailAddress)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.emailAddresses = emailAddress;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTelephones</span><span class="params">(List&lt;String&gt; telephones)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.telephones = telephones;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWechatIds</span><span class="params">(List&lt;String&gt; wechatIds)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.wechatIds = wechatIds;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">(NotificationEmergencyLevel level, String message)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (level.equals(NotificationEmergencyLevel.SEVERE)) &#123;</span><br><span class="line">      <span class="comment">//...自动语音电话</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (level.equals(NotificationEmergencyLevel.URGENCY)) &#123;</span><br><span class="line">      <span class="comment">//...发微信</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (level.equals(NotificationEmergencyLevel.NORMAL)) &#123;</span><br><span class="line">      <span class="comment">//...发邮件</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (level.equals(NotificationEmergencyLevel.TRIVIAL)) &#123;</span><br><span class="line">      <span class="comment">//...发邮件</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在API监控告警的例子中，我们如下方式来使用Notification类：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorAlertHandler</span> <span class="keyword">extends</span> <span class="title class_">AlertHandler</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ErrorAlertHandler</span><span class="params">(AlertRule rule, Notification notification)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>(rule, notification);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">(ApiStatInfo apiStatInfo)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (apiStatInfo.getErrorCount() &gt; rule.getMatchedRule(apiStatInfo.getApi()).getMaxErrorCount()) &#123;</span><br><span class="line">      notification.notify(NotificationEmergencyLevel.SEVERE, <span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Notification类的代码实现有一个最明显的问题，那就是有很多if-else分支逻辑。实际上，如果每个分支中的代码都不复杂，后期也没有无限膨胀的可能（增加更多if-else分支判断），那这样的设计问题并不大，没必要非得一定要摒弃if-else分支逻辑。</p>
<p>不过，Notification的代码显然不符合这个条件。因为每个if-else分支中的代码逻辑都比较复杂，发送通知的所有逻辑都扎堆在Notification类中。我们知道，类的代码越多，就越难读懂，越难修改，维护的成本也就越高。很多设计模式都是试图将庞大的类拆分成更细小的类，然后再通过某种更合理的结构组装在一起。</p>
<p>针对Notification的代码，我们将不同渠道的发送逻辑剥离出来，形成独立的消息发送类（MsgSender相关类）。其中，Notification类相当于抽象，MsgSender类相当于实现，两者可以独立开发，通过组合关系（也就是桥梁）任意组合在一起。所谓任意组合的意思就是，不同紧急程度的消息和发送渠道之间的对应关系，不是在代码中固定写死的，我们可以动态地去指定（比如，通过读取配置来获取对应关系）。</p>
<p>按照这个设计思路，我们对代码进行重构。重构之后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MsgSender</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TelephoneMsgSender</span> <span class="keyword">implements</span> <span class="title class_">MsgSender</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> List&lt;String&gt; telephones;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">TelephoneMsgSender</span><span class="params">(List&lt;String&gt; telephones)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.telephones = telephones;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailMsgSender</span> <span class="keyword">implements</span> <span class="title class_">MsgSender</span> &#123;</span><br><span class="line">  <span class="comment">// 与TelephoneMsgSender代码结构类似，所以省略...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WechatMsgSender</span> <span class="keyword">implements</span> <span class="title class_">MsgSender</span> &#123;</span><br><span class="line">  <span class="comment">// 与TelephoneMsgSender代码结构类似，所以省略...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Notification</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> MsgSender msgSender;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Notification</span><span class="params">(MsgSender msgSender)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.msgSender = msgSender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SevereNotification</span> <span class="keyword">extends</span> <span class="title class_">Notification</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SevereNotification</span><span class="params">(MsgSender msgSender)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(msgSender);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">(String message)</span> &#123;</span><br><span class="line">    msgSender.send(message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UrgencyNotification</span> <span class="keyword">extends</span> <span class="title class_">Notification</span> &#123;</span><br><span class="line">  <span class="comment">// 与SevereNotification代码结构类似，所以省略...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NormalNotification</span> <span class="keyword">extends</span> <span class="title class_">Notification</span> &#123;</span><br><span class="line">  <span class="comment">// 与SevereNotification代码结构类似，所以省略...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrivialNotification</span> <span class="keyword">extends</span> <span class="title class_">Notification</span> &#123;</span><br><span class="line">  <span class="comment">// 与SevereNotification代码结构类似，所以省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="33-结构型：装饰器模式"><a href="#33-结构型：装饰器模式" class="headerlink" title="33. 结构型：装饰器模式"></a>33. 结构型：装饰器模式</h3><p>通过剖析Java IO类的设计思想，再学习一种新的结构型模式，装饰器模式。它的代码结构跟桥接模式非常相似，不过，要解决的问题却大不相同。</p>
<p><strong>Java IO类的“奇怪”用法</strong></p>
<p>Java IO类库非常庞大和复杂，有几十个类，负责IO数据的读取和写入。如果对Java IO类做一下分类，我们可以从下面两个维度将它划分为四类。具体如下所示：</p>
<img src="https://static001.geekbang.org/resource/image/50/05/507526c2e4b255a45c60722df14f9a05.jpg" alt="img" style="zoom:33%;" />

<p>针对不同的读取和写入场景，Java IO又在这四个父类基础之上，扩展出了很多子类。具体如下所示：</p>
<img src="https://static001.geekbang.org/resource/image/50/13/5082df8e7d5a4d44a34811b9f562d613.jpg" alt="img" style="zoom: 33%;" />

<p>在我初学Java的时候，曾经对Java IO的一些用法产生过很大疑惑，比如下面这样一段代码。我们打开文件test.txt，从中读取数据。其中，InputStream是一个抽象类，FileInputStream是专门用来读取文件流的子类。BufferedInputStream是一个支持带缓存功能的数据读取类，可以提高数据读取的效率。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;/user/wangzheng/test.txt&quot;</span>);</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">bin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(in);</span><br><span class="line"><span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">128</span>];</span><br><span class="line"><span class="keyword">while</span> (bin.read(data) != -<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初看上面的代码，我们会觉得Java IO的用法比较麻烦，需要先创建一个FileInputStream对象，然后再传递给BufferedInputStream对象来使用。我在想，Java IO为什么不设计一个继承FileInputStream并且支持缓存的BufferedFileInputStream类呢？这样我们就可以像下面的代码中这样，直接创建一个BufferedFileInputStream类对象，打开文件读取数据，用起来岂不是更加简单？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">bin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedFileInputStream</span>(<span class="string">&quot;/user/wangzheng/test.txt&quot;</span>);</span><br><span class="line"><span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">128</span>];</span><br><span class="line"><span class="keyword">while</span> (bin.read(data) != -<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>基于继承的设计方案</strong></p>
<p>如果InputStream只有一个子类FileInputStream的话，那我们在FileInputStream基础之上，再设计一个孙子类BufferedFileInputStream，也算是可以接受的，毕竟继承结构还算简单。但实际上，继承InputStream的子类有很多。我们需要给每一个InputStream的子类，再继续派生支持缓存读取的子类。</p>
<p>除了支持缓存读取之外，如果我们还需要对功能进行其他方面的增强，比如下面的DataInputStream类，支持按照基本数据类型（int、boolean、long等）来读取数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;/user/wangzheng/test.txt&quot;</span>);</span><br><span class="line"><span class="type">DataInputStream</span> <span class="variable">din</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(in);</span><br><span class="line"><span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> din.readInt();</span><br></pre></td></tr></table></figure>

<p>在这种情况下，如果我们继续按照继承的方式来实现的话，就需要再继续派生出DataFileInputStream、DataPipedInputStream等类。如果我们还需要既支持缓存、又支持按照基本类型读取数据的类，那就要再继续派生出BufferedDataFileInputStream、BufferedDataPipedInputStream等n多类。这还只是附加了两个增强功能，如果我们需要附加更多的增强功能，那就会导致组合爆炸，类继承结构变得无比复杂，代码既不好扩展，也不好维护。这也是我们在<a href="https://time.geekbang.org/column/article/169593">第10节</a>中讲的不推荐使用继承的原因。</p>
<p><strong>基于装饰器模式的设计方案</strong></p>
<p>我们讲到“组合优于继承”，可以“使用组合来替代继承”。针对刚刚的继承结构过于复杂的问题，我们可以通过将继承关系改为组合关系来解决。下面的代码展示了Java IO的这种设计思路。不过，我对代码做了简化，只抽象出了必要的代码结构，如果你感兴趣的话，可以直接去查看JDK源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意是抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InputStream</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span> b[])</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">return</span> read(b, <span class="number">0</span>, b.length);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span> b[], <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">skip</span><span class="params">(<span class="type">long</span> n)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">available</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">mark</span><span class="params">(<span class="type">int</span> readlimit)</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">reset</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;mark/reset not supported&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">markSupported</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedInputStream</span> <span class="keyword">extends</span> <span class="title class_">InputStream</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">volatile</span> InputStream in;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">BufferedInputStream</span><span class="params">(InputStream in)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.in = in;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//...实现基于缓存的读数据接口...  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataInputStream</span> <span class="keyword">extends</span> <span class="title class_">InputStream</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">volatile</span> InputStream in;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">DataInputStream</span><span class="params">(InputStream in)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.in = in;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//...实现读取基本类型数据的接口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看了上面的代码，你可能会问，那装饰器模式就是简单的“用组合替代继承”吗？当然不是。从Java IO的设计来看，装饰器模式相对于简单的组合关系，还有两个比较特殊的地方。</p>
<p><strong>第一个比较特殊的地方是：装饰器类和原始类继承同样的父类，这样我们可以对原始类“嵌套”多个装饰器类。</strong>比如，下面这样一段代码，我们对FileInputStream嵌套了两个装饰器类：BufferedInputStream和DataInputStream，让它既支持缓存读取，又支持按照基本数据类型来读取数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;/user/wangzheng/test.txt&quot;</span>);</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">bin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(in);</span><br><span class="line"><span class="type">DataInputStream</span> <span class="variable">din</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(bin);</span><br><span class="line"><span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> din.readInt();</span><br></pre></td></tr></table></figure>

<p><strong>第二个比较特殊的地方是：装饰器类是对功能的增强，这也是装饰器模式应用场景的一个重要特点。</strong>实际上，符合“组合关系”这种代码结构的设计模式有很多，比如之前讲过的代理模式、桥接模式，还有现在的装饰器模式。尽管它们的代码结构很相似，但是每种设计模式的意图是不同的。就拿比较相似的代理模式和装饰器模式来说吧，<u>代理模式中，代理类附加的是跟原始类无关的功能，而在装饰器模式中，装饰器类附加的是跟原始类相关的增强功能</u>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代理模式的代码结构(下面的接口也可以替换成抽象类)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IA</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> impelements IA &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AProxy</span> <span class="keyword">implements</span> <span class="title class_">IA</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> IA a;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">AProxy</span><span class="params">(IA a)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.a = a;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 新添加的代理逻辑</span></span><br><span class="line">    a.f();</span><br><span class="line">    <span class="comment">// 新添加的代理逻辑</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 装饰器模式的代码结构(下面的接口也可以替换成抽象类)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IA</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">IA</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ADecorator</span> <span class="keyword">implements</span> <span class="title class_">IA</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> IA a;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ADecorator</span><span class="params">(IA a)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.a = a;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 功能增强代码</span></span><br><span class="line">    a.f();</span><br><span class="line">    <span class="comment">// 功能增强代码</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，如果去查看JDK的源码，你会发现，BufferedInputStream、DataInputStream并非继承自InputStream，而是另外一个叫FilterInputStream的类。那这又是出于什么样的设计意图，才引入这样一个类呢？</p>
<p>我们再重新来看一下BufferedInputStream类的代码。InputStream是一个抽象类而非接口，而且它的大部分函数（比如read()、available()）都有默认实现，按理来说，我们只需要在BufferedInputStream类中重新实现那些需要增加缓存功能的函数就可以了，其他函数继承InputStream的默认实现。但实际上，这样做是行不通的（抽象类的非抽象子类必须重新实现抽象类的所有方法）。</p>
<p>对于即便是不需要增加缓存功能的函数来说，BufferedInputStream还是必须把它重新实现一遍，简单包裹对InputStream对象的函数调用。具体的代码示例如下所示。如果不重新实现，那BufferedInputStream类就无法将最终读取数据的任务，委托给传递进来的InputStream对象来完成。这一部分稍微有点不好理解，你自己多思考一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedInputStream</span> <span class="keyword">extends</span> <span class="title class_">InputStream</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">volatile</span> InputStream in;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">BufferedInputStream</span><span class="params">(InputStream in)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.in = in;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// f()函数不需要增强，只是重新调用一下InputStream in对象的f()</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    in.f();</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，DataInputStream也存在跟BufferedInputStream同样的问题。为了避免代码重复，Java IO抽象出了一个装饰器父类FilterInputStream，代码实现如下所示。InputStream的所有的装饰器类（BufferedInputStream、DataInputStream）都继承自这个装饰器父类。这样，装饰器类只需要实现它需要增强的方法就可以了，其他方法继承装饰器父类的默认实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterInputStream</span> <span class="keyword">extends</span> <span class="title class_">InputStream</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">volatile</span> InputStream in;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">FilterInputStream</span><span class="params">(InputStream in)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.in = in;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">return</span> in.read();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span> b[])</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">return</span> read(b, <span class="number">0</span>, b.length);</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span> b[], <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">return</span> in.read(b, off, len);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">skip</span><span class="params">(<span class="type">long</span> n)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">return</span> in.skip(n);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">available</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">return</span> in.available();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    in.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">mark</span><span class="params">(<span class="type">int</span> readlimit)</span> &#123;</span><br><span class="line">    in.mark(readlimit);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">reset</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    in.reset();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">markSupported</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> in.markSupported();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="34-结构型：适配器模式"><a href="#34-结构型：适配器模式" class="headerlink" title="34. 结构型：适配器模式"></a>34. 结构型：适配器模式</h3><p><strong>适配器模式的原理与实现</strong></p>
<p><strong>适配器模式</strong>的英文翻译是<strong>Adapter Design Pattern</strong>。顾名思义，这个模式就是用来做适配的，它<u>将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作</u>。对于这个模式，有一个经常被拿来解释它的例子，就是USB转接头充当适配器，把两种不兼容的接口，通过转接变得可以一起工作。</p>
<p>原理很简单，我们再来看下它的代码实现。<u>适配器模式有两种实现方式：类适配器和对象适配器</u>。其中，<u>类适配器使用继承关系来实现，对象适配器使用组合关系来实现</u>。具体的代码实现如下所示。其中，ITarget表示要转化成的接口定义。Adaptee是一组不兼容ITarget接口定义的接口，Adaptor将Adaptee转化成一组符合ITarget接口定义的接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类适配器: 基于继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ITarget</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">fc</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adaptee</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fa</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fb</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fc</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adaptor</span> <span class="keyword">extends</span> <span class="title class_">Adaptee</span> <span class="keyword">implements</span> <span class="title class_">ITarget</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.fa();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...重新实现f2()...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象适配器：基于组合</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ITarget</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">fc</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adaptee</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fa</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fb</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fc</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adaptor</span> <span class="keyword">implements</span> <span class="title class_">ITarget</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Adaptor</span><span class="params">(Adaptee adaptee)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.adaptee = adaptee;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> &#123;</span><br><span class="line">    adaptee.fa(); <span class="comment">//委托给Adaptee</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...重新实现f2()...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fc</span><span class="params">()</span> &#123;</span><br><span class="line">    adaptee.fc();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对这两种实现方式，在实际的开发中，到底该如何选择使用哪一种呢？判断的标准主要有两个，一个是Adaptee接口的个数，另一个是Adaptee和ITarget的契合程度。</p>
<ul>
<li>如果Adaptee接口并不多，那两种实现方式都可以。</li>
<li>如果Adaptee接口很多，而且Adaptee和ITarget接口定义大部分都相同，那我们推荐使用类适配器，因为Adaptor复用父类Adaptee的接口，比起对象适配器的实现方式，Adaptor的代码量要少一些。</li>
<li>如果Adaptee接口很多，而且Adaptee和ITarget接口定义大部分都不相同，那我们推荐使用对象适配器，因为组合结构相对于继承更加灵活。</li>
</ul>
<p><strong>适配器模式应用场景总结</strong></p>
<p>原理和实现讲完了，都不复杂。我们再来看，到底什么时候会用到适配器模式呢？</p>
<p>一般来说，适配器模式可以看作一种“补偿模式”，用来补救设计上的缺陷。应用这种模式算是“无奈之举”。如果在设计初期，我们就能协调规避接口不兼容的问题，那这种模式就没有应用的机会了。</p>
<p>前面我们反复提到，适配器模式的应用场景是“接口不兼容”。那在实际的开发中，什么情况下才会出现接口不兼容呢？我建议你先自己思考一下这个问题，然后再来看我下面的总结 。</p>
<p><u>1.封装有缺陷的接口设计</u></p>
<p>假设我们依赖的外部系统在接口设计方面有缺陷（比如包含大量静态方法），引入之后会影响到我们自身代码的可测试性。为了隔离设计上的缺陷，我们希望对外部系统提供的接口进行二次封装，抽象出更好的接口设计，这个时候就可以使用适配器模式了。</p>
<p>具体我还是举个例子来解释一下，你直接看代码应该会更清晰。具体代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CD</span> &#123; <span class="comment">//这个类来自外部sdk，我们无权修改它的代码</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticFunction1</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uglyNamingFunction2</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tooManyParamsFunction3</span><span class="params">(<span class="type">int</span> paramA, <span class="type">int</span> paramB, ...)</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">  </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lowPerformanceFunction4</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用适配器模式进行重构</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ITarget</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">function1</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">function2</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">fucntion3</span><span class="params">(ParamsWrapperDefinition paramsWrapper)</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">function4</span><span class="params">()</span>;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意：适配器类的命名不一定非得末尾带Adaptor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CDAdaptor</span> <span class="keyword">extends</span> <span class="title class_">CD</span> <span class="keyword">implements</span> <span class="title class_">ITarget</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">function1</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="built_in">super</span>.staticFunction1();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">function2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.uglyNamingFucntion2();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">function3</span><span class="params">(ParamsWrapperDefinition paramsWrapper)</span> &#123;</span><br><span class="line">     <span class="built_in">super</span>.tooManyParamsFunction3(paramsWrapper.getParamA(), ...);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">function4</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...reimplement it...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u>2.统一多个类的接口设计</u></p>
<p>某个功能的实现依赖多个外部系统（或者说类）。通过适配器模式，将它们的接口适配为统一的接口定义，然后我们就可以使用多态的特性来复用代码逻辑。具体我还是举个例子来解释一下。</p>
<p>假设我们的系统要对用户输入的文本内容做敏感词过滤，为了提高过滤的召回率，我们引入了多款第三方敏感词过滤系统，依次对用户输入的内容进行过滤，过滤掉尽可能多的敏感词。但是，每个系统提供的过滤接口都是不同的。这就意味着我们没法复用一套逻辑来调用各个系统。这个时候，我们就可以使用适配器模式，将所有系统的接口适配为统一的接口定义，这样我们可以复用调用敏感词过滤的代码。</p>
<p>你可以配合着下面的代码示例，来理解我刚才举的这个例子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ASensitiveWordsFilter</span> &#123; <span class="comment">// A敏感词过滤系统提供的接口</span></span><br><span class="line">  <span class="comment">//text是原始文本，函数输出用***替换敏感词之后的文本</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">filterSexyWords</span><span class="params">(String text)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">filterPoliticalWords</span><span class="params">(String text)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BSensitiveWordsFilter</span>  &#123; <span class="comment">// B敏感词过滤系统提供的接口</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">filter</span><span class="params">(String text)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CSensitiveWordsFilter</span> &#123; <span class="comment">// C敏感词过滤系统提供的接口</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">filter</span><span class="params">(String text, String mask)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 未使用适配器模式之前的代码：代码的可测试性、扩展性不好</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RiskManagement</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">ASensitiveWordsFilter</span> <span class="variable">aFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ASensitiveWordsFilter</span>();</span><br><span class="line">  <span class="keyword">private</span> <span class="type">BSensitiveWordsFilter</span> <span class="variable">bFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BSensitiveWordsFilter</span>();</span><br><span class="line">  <span class="keyword">private</span> <span class="type">CSensitiveWordsFilter</span> <span class="variable">cFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CSensitiveWordsFilter</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">filterSensitiveWords</span><span class="params">(String text)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">maskedText</span> <span class="operator">=</span> aFilter.filterSexyWords(text);</span><br><span class="line">    maskedText = aFilter.filterPoliticalWords(maskedText);</span><br><span class="line">    maskedText = bFilter.filter(maskedText);</span><br><span class="line">    maskedText = cFilter.filter(maskedText, <span class="string">&quot;***&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> maskedText;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用适配器模式进行改造</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ISensitiveWordsFilter</span> &#123; <span class="comment">// 统一接口定义</span></span><br><span class="line">  String <span class="title function_">filter</span><span class="params">(String text)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ASensitiveWordsFilterAdaptor</span> <span class="keyword">implements</span> <span class="title class_">ISensitiveWordsFilter</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> ASensitiveWordsFilter aFilter;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">filter</span><span class="params">(String text)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">maskedText</span> <span class="operator">=</span> aFilter.filterSexyWords(text);</span><br><span class="line">    maskedText = aFilter.filterPoliticalWords(maskedText);</span><br><span class="line">    <span class="keyword">return</span> maskedText;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...省略BSensitiveWordsFilterAdaptor、CSensitiveWordsFilterAdaptor...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展性更好，更加符合开闭原则，如果添加一个新的敏感词过滤系统，</span></span><br><span class="line"><span class="comment">// 这个类完全不需要改动；而且基于接口而非实现编程，代码的可测试性更好。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RiskManagement</span> &#123; </span><br><span class="line">  <span class="keyword">private</span> List&lt;ISensitiveWordsFilter&gt; filters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSensitiveWordsFilter</span><span class="params">(ISensitiveWordsFilter filter)</span> &#123;</span><br><span class="line">    filters.add(filter);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">filterSensitiveWords</span><span class="params">(String text)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">maskedText</span> <span class="operator">=</span> text;</span><br><span class="line">    <span class="keyword">for</span> (ISensitiveWordsFilter filter : filters) &#123;</span><br><span class="line">      maskedText = filter.filter(maskedText);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maskedText;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u>3.替换依赖的外部系统</u></p>
<p>当我们把项目中依赖的一个外部系统替换为另一个外部系统的时候，利用适配器模式，可以减少对代码的改动。具体的代码示例如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 外部系统A</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IA</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">fa</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">IA</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fa</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在我们的项目中，外部系统A的使用示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> IA a;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Demo</span><span class="params">(IA a)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.a = a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Demo</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>(<span class="keyword">new</span> <span class="title class_">A</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将外部系统A替换成外部系统B</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BAdaptor</span> implemnts IA &#123;</span><br><span class="line">  <span class="keyword">private</span> B b;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">BAdaptor</span><span class="params">(B b)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.b= b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fa</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    b.fb();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 借助BAdaptor，Demo的代码中，调用IA接口的地方都无需改动，</span></span><br><span class="line"><span class="comment">// 只需要将BAdaptor如下注入到Demo即可。</span></span><br><span class="line"><span class="type">Demo</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>(<span class="keyword">new</span> <span class="title class_">BAdaptor</span>(<span class="keyword">new</span> <span class="title class_">B</span>()));</span><br></pre></td></tr></table></figure>

<p><u>4.兼容老版本接口</u></p>
<p>在做版本升级的时候，对于一些要废弃的接口，我们不直接将其删除，而是暂时保留，并且标注为deprecated，并将内部实现逻辑委托为新的接口实现。这样做的好处是，让使用它的项目有个过渡期，而不是强制进行代码修改。这也可以粗略地看作适配器模式的一个应用场景。同样，我还是通过一个例子，来进一步解释一下。</p>
<p>JDK1.0中包含一个遍历集合容器的类Enumeration。JDK2.0对这个类进行了重构，将它改名为Iterator类，并且对它的代码实现做了优化。但是考虑到如果将Enumeration直接从JDK2.0中删除，那使用JDK1.0的项目如果切换到JDK2.0，代码就会编译不通过。为了避免这种情况的发生，我们必须把项目中所有使用到Enumeration的地方，都修改为使用Iterator才行。</p>
<p>单独一个项目做Enumeration到Iterator的替换，勉强还能接受。但是，使用Java开发的项目太多了，一次JDK的升级，导致所有的项目不做代码修改就会编译报错，这显然是不合理的。这就是我们经常所说的不兼容升级。为了做到兼容使用低版本JDK的老代码，我们可以暂时保留Enumeration类，并将其实现替换为直接调用Itertor。代码示例如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Collections</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Emueration <span class="title function_">emumeration</span><span class="params">(<span class="keyword">final</span> Collection c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Enumeration</span>() &#123;</span><br><span class="line">      <span class="type">Iterator</span> <span class="variable">i</span> <span class="operator">=</span> c.iterator();</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasMoreElments</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i.hashNext();</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">public</span> Object <span class="title function_">nextElement</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i.next():</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u>5.适配不同格式的数据</u></p>
<p>前面我们讲到，适配器模式主要用于接口的适配，实际上，它还可以用在不同格式的数据之间的适配。比如，把从不同征信系统拉取的不同格式的征信数据，统一为相同的格式，以方便存储和使用。再比如，Java中的Arrays.asList()也可以看作一种数据适配器，将数组类型的数据转化为集合容器类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; stooges = Arrays.asList(<span class="string">&quot;Larry&quot;</span>, <span class="string">&quot;Moe&quot;</span>, <span class="string">&quot;Curly&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>剖析适配器模式在Java日志中的应用</strong></p>
<p>Java中有很多日志框架，在项目开发中，我们常常用它们来打印日志信息。其中，比较常用的有log4j、logback，以及JDK提供的JUL(java.util.logging)和Apache的JCL(Jakarta Commons Logging)等。</p>
<p>大部分日志框架都提供了相似的功能，比如按照不同级别（debug、info、warn、erro……）打印日志等，但它们却并没有实现统一的接口。这主要可能是历史的原因，它不像JDBC那样，一开始就制定了数据库操作的接口规范。</p>
<p>如果我们只是开发一个自己用的项目，那用什么日志框架都可以，log4j、logback随便选一个就好。但是，如果我们开发的是一个集成到其他系统的组件、框架、类库等，那日志框架的选择就没那么随意了。</p>
<p>比如，项目中用到的某个组件使用log4j来打印日志，而我们项目本身使用的是logback。将组件引入到项目之后，我们的项目就相当于有了两套日志打印框架。每种日志框架都有自己特有的配置方式。所以，我们要针对每种日志框架编写不同的配置文件（比如，日志存储的文件地址、打印日志的格式）。如果引入多个组件，每个组件使用的日志框架都不一样，那日志本身的管理工作就变得非常复杂。所以，为了解决这个问题，我们需要统一日志打印框架。</p>
<p>如果你是做Java开发的，那<u>Slf4j这个日志框架</u>你肯定不陌生，它相当于JDBC规范，提供了一套打印日志的统一接口规范。不过，它只定义了接口，并没有提供具体的实现，需要配合其他日志框架（log4j、logback……）来使用。</p>
<p>不仅如此，Slf4j的出现晚于JUL、JCL、log4j等日志框架，所以，这些日志框架也不可能牺牲掉版本兼容性，将接口改造成符合Slf4j接口规范。Slf4j也事先考虑到了这个问题，所以，它不仅仅提供了统一的接口定义，还提供了针对不同日志框架的适配器。对不同日志框架的接口进行二次封装，适配成统一的Slf4j接口定义。具体的代码示例如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// slf4j统一的接口定义</span></span><br><span class="line"><span class="keyword">package</span> org.slf4j;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isTraceEnabled</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trace</span><span class="params">(String msg)</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trace</span><span class="params">(String format, Object arg)</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trace</span><span class="params">(String format, Object arg1, Object arg2)</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trace</span><span class="params">(String format, Object[] argArray)</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trace</span><span class="params">(String msg, Throwable t)</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDebugEnabled</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debug</span><span class="params">(String msg)</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debug</span><span class="params">(String format, Object arg)</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debug</span><span class="params">(String format, Object arg1, Object arg2)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debug</span><span class="params">(String format, Object[] argArray)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debug</span><span class="params">(String msg, Throwable t)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...省略info、warn、error等一堆接口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// log4j日志框架的适配器</span></span><br><span class="line"><span class="comment">// Log4jLoggerAdapter实现了LocationAwareLogger接口，</span></span><br><span class="line"><span class="comment">// 其中LocationAwareLogger继承自Logger接口，</span></span><br><span class="line"><span class="comment">// 也就相当于Log4jLoggerAdapter实现了Logger接口。</span></span><br><span class="line"><span class="keyword">package</span> org.slf4j.impl;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Log4jLoggerAdapter</span> <span class="keyword">extends</span> <span class="title class_">MarkerIgnoringBase</span></span><br><span class="line">  <span class="keyword">implements</span> <span class="title class_">LocationAwareLogger</span>, Serializable &#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">transient</span> org.apache.log4j.Logger logger; <span class="comment">// log4j</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDebugEnabled</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> logger.isDebugEnabled();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debug</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    logger.log(FQCN, Level.DEBUG, msg, <span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debug</span><span class="params">(String format, Object arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      <span class="type">FormattingTuple</span> <span class="variable">ft</span> <span class="operator">=</span> MessageFormatter.format(format, arg);</span><br><span class="line">      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debug</span><span class="params">(String format, Object arg1, Object arg2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      <span class="type">FormattingTuple</span> <span class="variable">ft</span> <span class="operator">=</span> MessageFormatter.format(format, arg1, arg2);</span><br><span class="line">      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debug</span><span class="params">(String format, Object[] argArray)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      <span class="type">FormattingTuple</span> <span class="variable">ft</span> <span class="operator">=</span> MessageFormatter.arrayFormat(format, argArray);</span><br><span class="line">      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debug</span><span class="params">(String msg, Throwable t)</span> &#123;</span><br><span class="line">    logger.log(FQCN, Level.DEBUG, msg, t);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...省略一堆接口的实现...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，在开发业务系统或者开发框架、组件的时候，我们统一使用Slf4j提供的接口来编写打印日志的代码，具体使用哪种日志框架实现（log4j、logback……），是可以动态地指定的（使用Java的SPI技术，这里我不多解释，你自行研究吧），只需要将相应的SDK导入到项目中即可。</p>
<p>不过，你可能会说，如果一些老的项目没有使用Slf4j，而是直接使用比如JCL来打印日志，那如果想要替换成其他日志框架，比如log4j，该怎么办呢？实际上，Slf4j不仅仅提供了从其他日志框架到Slf4j的适配器，还提供了反向适配器，也就是从Slf4j到其他日志框架的适配。我们可以先将JCL切换为Slf4j，然后再将Slf4j切换为log4j。经过两次适配器的转换，我们就能成功将log4j切换为了logback。</p>
<p><strong>代理、桥接、装饰器、适配器4种设计模式的区别</strong></p>
<p>代理、桥接、装饰器、适配器，这4种模式是比较常用的结构型设计模式。它们的代码结构非常相似。<u>笼统来说，它们都可以称为Wrapper模式，也就是通过Wrapper类二次封装原始类</u>。</p>
<p>尽管代码结构相似，但这4种设计模式的用意完全不同，也就是说要解决的问题、应用场景不同，这也是它们的主要区别。这里我就简单说一下它们之间的区别。</p>
<ul>
<li><strong>代理模式：</strong>代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。</li>
<li><strong>桥接模式：</strong>桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。</li>
<li><strong>装饰器模式：</strong>装饰者模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。</li>
<li><strong>适配器模式：</strong>适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口</li>
</ul>
<h3 id="35-结构型：门面模式"><a href="#35-结构型：门面模式" class="headerlink" title="35. 结构型：门面模式"></a>35. 结构型：门面模式</h3><p>门面模式原理和实现都特别简单，应用场景也比较明确，主要在接口设计方面使用。</p>
<p>如果你平时的工作涉及接口开发，不知道你有没有遇到关于接口粒度的问题呢？</p>
<p>为了保证接口的可复用性（或者叫通用性），我们需要将接口尽量设计得细粒度一点，职责单一一点。但是，如果接口的粒度过小，在接口的使用者开发一个业务功能时，就会导致需要调用n多细粒度的接口才能完成。调用者肯定会抱怨接口不好用。</p>
<p>相反，如果接口粒度设计得太大，一个接口返回n多数据，要做n多事情，就会导致接口不够通用、可复用性不好。接口不可复用，那针对不同的调用者的业务需求，我们就需要开发不同的接口来满足，这就会导致系统的接口无限膨胀。</p>
<p>那如何来解决接口的可复用性（通用性）和易用性之间的矛盾呢？</p>
<p><strong>门面模式的原理与实现</strong></p>
<p>门面模式，也叫外观模式，英文全称是Facade Design Pattern。在GoF的《设计模式》一书中，门面模式是这样定义的：</p>
<blockquote>
<p>Provide a unified interface to a set of interfaces in a subsystem. Facade Pattern defines a higher-level interface that makes the subsystem easier to use.</p>
</blockquote>
<p>翻译成中文就是：门面模式为子系统提供一组统一的接口，定义一组高层接口让子系统更易用。</p>
<p>这个定义很简洁，我再进一步解释一下。</p>
<p>假设有一个系统A，提供了a、b、c、d四个接口。系统B完成某个业务功能，需要调用A系统的a、b、d接口。利用门面模式，我们提供一个包裹a、b、d接口调用的门面接口x，给系统B直接使用。</p>
<p>不知道你会不会有这样的疑问，让系统B直接调用a、b、d感觉没有太大问题呀，为什么还要提供一个包裹a、b、d的接口x呢？关于这个问题，我通过一个具体的例子来解释一下。</p>
<p>假设我们刚刚提到的系统A是一个后端服务器，系统B是App客户端。App客户端通过后端服务器提供的接口来获取数据。我们知道，App和服务器之间是通过移动网络通信的，网络通信耗时比较多，为了提高App的响应速度，我们要尽量减少App与服务器之间的网络通信次数。</p>
<p>假设，完成某个业务功能（比如显示某个页面信息）需要“依次”调用a、b、d三个接口，因自身业务的特点，不支持并发调用这三个接口。</p>
<p>如果我们现在发现App客户端的响应速度比较慢，排查之后发现，是因为过多的接口调用过多的网络通信。针对这种情况，我们就可以利用门面模式，让后端服务器提供一个包裹a、b、d三个接口调用的接口x。App客户端调用一次接口x，来获取到所有想要的数据，将网络通信的次数从3次减少到1次，也就提高了App的响应速度。</p>
<p>这里举的例子只是应用门面模式的其中一个意图，也就是解决性能问题。实际上，不同的应用场景下，使用门面模式的意图也不同。接下来，我们就来看一下门面模式的各种应用场景。</p>
<p><strong>门面模式的应用场景举例</strong></p>
<p>在GoF给出的定义中提到，“门面模式让子系统更加易用”，实际上，它除了解决易用性问题之外，还能解决其他很多方面的问题。关于这一点，我总结罗列了3个常用的应用场景，你可以参考一下，举一反三地借鉴到自己的项目中。</p>
<p>除此之外，我还要强调一下，门面模式定义中的“子系统（subsystem）”也可以有多种理解方式。它既可以是一个完整的系统，也可以是更细粒度的类或者模块。关于这一点，在下面的讲解中也会有体现。</p>
<p><u>1.解决易用性问题</u></p>
<p>门面模式可以用来封装系统的底层实现，隐藏系统的复杂性，提供一组更加简单易用、更高层的接口。比如，<u>Linux系统调用函数就可以看作一种“门面”</u>。它是Linux操作系统暴露给开发者的一组“特殊”的编程接口，它封装了底层更基础的Linux内核调用。再比如，Linux的Shell命令，实际上也可以看作一种门面模式的应用。它继续封装系统调用，提供更加友好、简单的命令，让我们可以直接通过执行命令来跟操作系统交互。</p>
<p>我们前面也多次讲过，设计原则、思想、模式很多都是相通的，是同一个道理不同角度的表述。实际上，从隐藏实现复杂性，提供更易用接口这个意图来看，门面模式有点类似之前讲到的迪米特法则（最少知识原则）和接口隔离原则：两个有交互的系统，只暴露有限的必要的接口。除此之外，门面模式还有点类似之前提到封装、抽象的设计思想，提供更抽象的接口，封装底层实现细节。</p>
<p><u>2.解决性能问题</u></p>
<p>关于利用门面模式解决性能问题这一点，刚刚我们已经讲过了。我们通过将多个接口调用替换为一个门面接口调用，减少网络通信成本，提高App客户端的响应速度。所以，关于这点，我就不再举例说明了。我们来讨论一下这样一个问题：从代码实现的角度来看，该如何组织门面接口和非门面接口？</p>
<p>如果门面接口不多，我们完全可以将它跟非门面接口放到一块，也不需要特殊标记，当作普通接口来用即可。如果门面接口很多，我们可以在已有的接口之上，再重新抽象出一层，专门放置门面接口，从类、包的命名上跟原来的接口层做区分。如果门面接口特别多，并且很多都是跨多个子系统的，我们可以将门面接口放到一个新的子系统中。</p>
<p><u>3.解决分布式事务问题</u></p>
<p>关于利用门面模式来解决分布式事务问题，我们通过一个例子来解释一下。</p>
<p>在一个金融系统中，有两个业务领域模型，用户和钱包。这两个业务领域模型都对外暴露了一系列接口，比如用户的增删改查接口、钱包的增删改查接口。假设有这样一个业务场景：在用户注册的时候，我们不仅会创建用户（在数据库User表中），还会给用户创建一个钱包（在数据库的Wallet表中）。</p>
<p>对于这样一个简单的业务需求，我们可以通过依次调用用户的创建接口和钱包的创建接口来完成。但是，用户注册需要支持事务，也就是说，创建用户和钱包的两个操作，要么都成功，要么都失败，不能一个成功、一个失败。</p>
<p>要支持两个接口调用在一个事务中执行，是比较难实现的，这涉及分布式事务问题。虽然我们可以通过引入分布式事务框架或者事后补偿的机制来解决，但代码实现都比较复杂。而最简单的解决方案是，利用数据库事务或者Spring框架提供的事务（如果是Java语言的话），在一个事务中，执行创建用户和创建钱包这两个SQL操作。这就要求两个SQL操作要在一个接口中完成，所以，我们可以借鉴门面模式的思想，再设计一个包裹这两个操作的新接口，让新接口在一个事务中执行两个SQL操作。</p>
<h3 id="36-结构型：组合模式"><a href="#36-结构型：组合模式" class="headerlink" title="36. 结构型：组合模式"></a>36. 结构型：组合模式</h3><p>组合模式跟我们之前讲的面向对象设计中的“组合关系（通过组合来组装两个类）”，完全是两码事。这里讲的“组合模式”，主要是用来处理树形结构数据。这里的“数据”，你可以简单理解为一组对象集合，待会我们会详细讲解。</p>
<p>正因为其应用场景的特殊性，数据必须能表示成树形结构，这也导致了这种模式在实际的项目开发中并不那么常用。但是，一旦数据满足树形结构，应用这种模式就能发挥很大的作用，能让代码变得非常简洁。</p>
<p>话不多说，让我们正式开始今天的学习吧！</p>
<p><strong>组合模式的原理与实现</strong></p>
<p>在GoF的《设计模式》一书中，组合模式是这样定义的：</p>
<blockquote>
<p>Compose objects into tree structure to represent part-whole hierarchies.Composite lets client treat individual objects and compositions of objects uniformly.</p>
</blockquote>
<p>翻译成中文就是：将一组对象组织（Compose）成树形结构，以表示一种“部分-整体”的层次结构。组合让客户端（在很多设计模式书籍中，“客户端”代指代码的使用者。）可以统一单个对象和组合对象的处理逻辑。</p>
<p>接下来，对于组合模式，我举个例子来给你解释一下。</p>
<p>假设我们有这样一个需求：设计一个类来表示文件系统中的目录，能方便地实现下面这些功能：</p>
<ul>
<li>动态地添加、删除某个目录下的子目录或文件；</li>
<li>统计指定目录下的文件个数；</li>
<li>统计指定目录下的文件总大小。</li>
</ul>
<p>我这里给出了这个类的骨架代码，如下所示。其中的核心逻辑并未实现，你可以试着自己去补充完整，再来看我的讲解。在下面的代码实现中，我们把文件和目录统一用FileSystemNode类来表示，并且通过isFile属性来区分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileSystemNode</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String path;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> isFile;</span><br><span class="line">  <span class="keyword">private</span> List&lt;FileSystemNode&gt; subNodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">FileSystemNode</span><span class="params">(String path, <span class="type">boolean</span> isFile)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.path = path;</span><br><span class="line">    <span class="built_in">this</span>.isFile = isFile;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNumOfFiles</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span>...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">countSizeOfFiles</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span>...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getPath</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSubNode</span><span class="params">(FileSystemNode fileOrDir)</span> &#123;</span><br><span class="line">    subNodes.add(fileOrDir);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeSubNode</span><span class="params">(FileSystemNode fileOrDir)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> subNodes.size();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; size; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; size) &#123;</span><br><span class="line">      subNodes.remove(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，如果你看过我的《数据结构与算法之美》专栏，想要补全其中的countNumOfFiles()和countSizeOfFiles()这两个函数，并不是件难事，实际上这就是树上的递归遍历算法。对于文件，我们直接返回文件的个数（返回1）或大小。对于目录，我们遍历目录中每个子目录或者文件，递归计算它们的个数或大小，然后求和，就是这个目录下的文件个数和文件大小。</p>
<p>我把两个函数的代码实现贴在下面了，你可以对照着看一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNumOfFiles</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (isFile) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> <span class="variable">numOfFiles</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (FileSystemNode fileOrDir : subNodes) &#123;</span><br><span class="line">    numOfFiles += fileOrDir.countNumOfFiles();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> numOfFiles;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">countSizeOfFiles</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (isFile) &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path);</span><br><span class="line">    <span class="keyword">if</span> (!file.exists()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> file.length();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">long</span> <span class="variable">sizeofFiles</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (FileSystemNode fileOrDir : subNodes) &#123;</span><br><span class="line">    sizeofFiles += fileOrDir.countSizeOfFiles();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sizeofFiles;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单纯从功能实现角度来说，上面的代码没有问题，已经实现了我们想要的功能。但是，如果我们开发的是一个大型系统，从扩展性（文件或目录可能会对应不同的操作）、业务建模（文件和目录从业务上是两个概念）、代码的可读性（文件和目录区分对待更加符合人们对业务的认知）的角度来说，我们最好对文件和目录进行区分设计，定义为File和Directory两个类。</p>
<p>按照这个设计思路，我们对代码进行重构。重构之后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">FileSystemNode</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> String path;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">FileSystemNode</span><span class="params">(String path)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.path = path;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">countNumOfFiles</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">long</span> <span class="title function_">countSizeOfFiles</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getPath</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">File</span> <span class="keyword">extends</span> <span class="title class_">FileSystemNode</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">File</span><span class="params">(String path)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(path);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNumOfFiles</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">countSizeOfFiles</span><span class="params">()</span> &#123;</span><br><span class="line">    java.io.<span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.io.File(path);</span><br><span class="line">    <span class="keyword">if</span> (!file.exists()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> file.length();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Directory</span> <span class="keyword">extends</span> <span class="title class_">FileSystemNode</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> List&lt;FileSystemNode&gt; subNodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Directory</span><span class="params">(String path)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(path);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNumOfFiles</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">numOfFiles</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (FileSystemNode fileOrDir : subNodes) &#123;</span><br><span class="line">      numOfFiles += fileOrDir.countNumOfFiles();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numOfFiles;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">countSizeOfFiles</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">sizeofFiles</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (FileSystemNode fileOrDir : subNodes) &#123;</span><br><span class="line">      sizeofFiles += fileOrDir.countSizeOfFiles();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sizeofFiles;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSubNode</span><span class="params">(FileSystemNode fileOrDir)</span> &#123;</span><br><span class="line">    subNodes.add(fileOrDir);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeSubNode</span><span class="params">(FileSystemNode fileOrDir)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> subNodes.size();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; size; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; size) &#123;</span><br><span class="line">      subNodes.remove(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文件和目录类都设计好了，我们来看，如何用它们来表示一个文件系统中的目录树结构。具体的代码示例如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    /**</span><br><span class="line">     * /</span><br><span class="line">     * /wz/</span><br><span class="line">     * /wz/a.txt</span><br><span class="line">     * /wz/b.txt</span><br><span class="line">     * /wz/movies/</span><br><span class="line">     * /wz/movies/c.avi</span><br><span class="line">     * /xzg/</span><br><span class="line">     * /xzg/docs/</span><br><span class="line">     * /xzg/docs/d.txt</span><br><span class="line">     */</span><br><span class="line">    Directory fileSystemTree = new Directory(&quot;/&quot;);</span><br><span class="line">    Directory node_wz = new Directory(&quot;/wz/&quot;);</span><br><span class="line">    Directory node_xzg = new Directory(&quot;/xzg/&quot;);</span><br><span class="line">    fileSystemTree.addSubNode(node_wz);</span><br><span class="line">    fileSystemTree.addSubNode(node_xzg);</span><br><span class="line"></span><br><span class="line">    File node_wz_a = new File(&quot;/wz/a.txt&quot;);</span><br><span class="line">    File node_wz_b = new File(&quot;/wz/b.txt&quot;);</span><br><span class="line">    Directory node_wz_movies = new Directory(&quot;/wz/movies/&quot;);</span><br><span class="line">    node_wz.addSubNode(node_wz_a);</span><br><span class="line">    node_wz.addSubNode(node_wz_b);</span><br><span class="line">    node_wz.addSubNode(node_wz_movies);</span><br><span class="line"></span><br><span class="line">    File node_wz_movies_c = new File(&quot;/wz/movies/c.avi&quot;);</span><br><span class="line">    node_wz_movies.addSubNode(node_wz_movies_c);</span><br><span class="line"></span><br><span class="line">    Directory node_xzg_docs = new Directory(&quot;/xzg/docs/&quot;);</span><br><span class="line">    node_xzg.addSubNode(node_xzg_docs);</span><br><span class="line"></span><br><span class="line">    File node_xzg_docs_d = new File(&quot;/xzg/docs/d.txt&quot;);</span><br><span class="line">    node_xzg_docs.addSubNode(node_xzg_docs_d);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;/ files num:&quot; + fileSystemTree.countNumOfFiles());</span><br><span class="line">    System.out.println(&quot;/wz/ files num:&quot; + node_wz.countNumOfFiles());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们对照着这个例子，再重新看一下组合模式的定义：“将一组对象（文件和目录）组织成树形结构，以表示一种‘部分-整体’的层次结构（目录与子目录的嵌套结构）。组合模式让客户端可以统一单个对象（文件）和组合对象（目录）的处理逻辑（递归遍历）。”</p>
<p>实际上，刚才讲的这种组合模式的设计思路，与其说是一种设计模式，倒不如说是对业务场景的一种数据结构和算法的抽象。其中，数据可以表示成树这种数据结构，业务需求可以通过在树上的递归遍历算法来实现。</p>
<p><strong>组合模式的应用场景举例</strong></p>
<p>刚刚我们讲了文件系统的例子，对于组合模式，我这里再举一个例子。搞懂了这两个例子，你基本上就算掌握了组合模式。在实际的项目中，遇到类似的可以表示成树形结构的业务场景，你只要“照葫芦画瓢”去设计就可以了。</p>
<p>假设我们在开发一个OA系统（办公自动化系统）。公司的组织结构包含部门和员工两种数据类型。其中，部门又可以包含子部门和员工。在数据库中的表结构如下所示：</p>
<img src="https://static001.geekbang.org/resource/image/5b/8b/5b19dc0c296f728328794eab1f16a38b.jpg" alt="img" style="zoom:33%;" />

<p>我们希望在内存中构建整个公司的人员架构图（部门、子部门、员工的隶属关系），并且提供接口计算出部门的薪资成本（隶属于这个部门的所有员工的薪资和）。</p>
<p>部门包含子部门和员工，这是一种嵌套结构，可以表示成树这种数据结构。计算每个部门的薪资开支这样一个需求，也可以通过在树上的遍历算法来实现。所以，从这个角度来看，这个应用场景可以使用组合模式来设计和实现。</p>
<p>这个例子的代码结构跟上一个例子的很相似，代码实现我直接贴在了下面，你可以对比着看一下。其中，HumanResource是部门类（Department）和员工类（Employee）抽象出来的父类，为的是能统一薪资的处理逻辑。Demo中的代码负责从数据库中读取数据并在内存中构建组织架构图。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">HumanResource</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="type">long</span> id;</span><br><span class="line">  <span class="keyword">protected</span> <span class="type">double</span> salary;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">HumanResource</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.id = id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">calculateSalary</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">extends</span> <span class="title class_">HumanResource</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(<span class="type">long</span> id, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(id);</span><br><span class="line">    <span class="built_in">this</span>.salary = salary;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculateSalary</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> salary;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Department</span> <span class="keyword">extends</span> <span class="title class_">HumanResource</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> List&lt;HumanResource&gt; subNodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Department</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(id);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculateSalary</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">totalSalary</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (HumanResource hr : subNodes) &#123;</span><br><span class="line">      totalSalary += hr.calculateSalary();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.salary = totalSalary;</span><br><span class="line">    <span class="keyword">return</span> totalSalary;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSubNode</span><span class="params">(HumanResource hr)</span> &#123;</span><br><span class="line">    subNodes.add(hr);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建组织架构的代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ORGANIZATION_ROOT_ID</span> <span class="operator">=</span> <span class="number">1001</span>;</span><br><span class="line">  <span class="keyword">private</span> DepartmentRepo departmentRepo; <span class="comment">// 依赖注入</span></span><br><span class="line">  <span class="keyword">private</span> EmployeeRepo employeeRepo; <span class="comment">// 依赖注入</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildOrganization</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Department</span> <span class="variable">rootDepartment</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Department</span>(ORGANIZATION_ROOT_ID);</span><br><span class="line">    buildOrganization(rootDepartment);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildOrganization</span><span class="params">(Department department)</span> &#123;</span><br><span class="line">    List&lt;Long&gt; subDepartmentIds = departmentRepo.getSubDepartmentIds(department.getId());</span><br><span class="line">    <span class="keyword">for</span> (Long subDepartmentId : subDepartmentIds) &#123;</span><br><span class="line">      <span class="type">Department</span> <span class="variable">subDepartment</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Department</span>(subDepartmentId);</span><br><span class="line">      department.addSubNode(subDepartment);</span><br><span class="line">      buildOrganization(subDepartment);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Long&gt; employeeIds = employeeRepo.getDepartmentEmployeeIds(department.getId());</span><br><span class="line">    <span class="keyword">for</span> (Long employeeId : employeeIds) &#123;</span><br><span class="line">      <span class="type">double</span> <span class="variable">salary</span> <span class="operator">=</span> employeeRepo.getEmployeeSalary(employeeId);</span><br><span class="line">      department.addSubNode(<span class="keyword">new</span> <span class="title class_">Employee</span>(employeeId, salary));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再拿组合模式的定义跟这个例子对照一下：“将一组对象（员工和部门）组织成树形结构，以表示一种‘部分-整体’的层次结构（部门与子部门的嵌套结构）。组合模式让客户端可以统一单个对象（员工）和组合对象（部门）的处理逻辑（递归遍历）。”</p>
<h3 id="37-结构型：享元模式（1）"><a href="#37-结构型：享元模式（1）" class="headerlink" title="37. 结构型：享元模式（1）"></a>37. 结构型：享元模式（1）</h3><p>再来学习一个不那么常用的模式，<strong>享元模式</strong>（Flyweight Design Pattern）。这也是我们要学习的最后一个结构型模式。</p>
<p>跟其他所有的设计模式类似，享元模式的原理和实现也非常简单。今天，我会通过棋牌游戏和文本编辑器两个实际的例子来讲解。除此之外，我还会讲到它跟单例、缓存、对象池的区别和联系。在下一节课中，我会带你剖析一下享元模式在Java Integer、String中的应用。</p>
<p><strong>享元模式原理与实现</strong></p>
<p>所谓“享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。</p>
<p>具体来讲，当一个系统中存在大量重复对象的时候，如果这些重复的对象是不可变对象，我们就可以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码引用。这样可以减少内存中对象的数量，起到节省内存的目的。实际上，不仅仅相同对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分（字段）提取出来，设计成享元，让这些大量相似对象引用这些享元。</p>
<p>这里我稍微解释一下，定义中的“不可变对象”指的是，一旦通过构造函数初始化完成之后，它的状态（对象的成员变量或者属性）就不会再被修改了。所以，不可变对象不能暴露任何set()等修改内部状态的方法。之所以要求享元是不可变对象，那是因为它会被多处代码共享使用，避免一处代码对享元进行了修改，影响到其他使用它的代码。</p>
<p>接下来，我们通过一个简单的例子解释一下享元模式。</p>
<p>假设我们在开发一个棋牌游戏（比如象棋）。一个游戏厅中有成千上万个“房间”，每个房间对应一个棋局。棋局要保存每个棋子的数据，比如：棋子类型（将、相、士、炮等）、棋子颜色（红方、黑方）、棋子在棋局中的位置。利用这些数据，我们就能显示一个完整的棋盘给玩家。具体的代码如下所示。其中，ChessPiece类表示棋子，ChessBoard类表示一个棋局，里面保存了象棋中30个棋子的信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChessPiece</span> &#123;<span class="comment">//棋子</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">  <span class="keyword">private</span> String text;</span><br><span class="line">  <span class="keyword">private</span> Color color;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> positionX;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> positionY;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ChessPiece</span><span class="params">(<span class="type">int</span> id, String text, Color color, <span class="type">int</span> positionX, <span class="type">int</span> positionY)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.id = id;</span><br><span class="line">    <span class="built_in">this</span>.text = text;</span><br><span class="line">    <span class="built_in">this</span>.color = color;</span><br><span class="line">    <span class="built_in">this</span>.positionX = positionX;</span><br><span class="line">    <span class="built_in">this</span>.positionY = positionX;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    RED, BLACK</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...省略其他属性和getter/setter方法...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChessBoard</span> &#123;<span class="comment">//棋局</span></span><br><span class="line">  <span class="keyword">private</span> Map&lt;Integer, ChessPiece&gt; chessPieces = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ChessBoard</span><span class="params">()</span> &#123;</span><br><span class="line">    init();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    chessPieces.put(<span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">ChessPiece</span>(<span class="number">1</span>, <span class="string">&quot;車&quot;</span>, ChessPiece.Color.BLACK, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    chessPieces.put(<span class="number">2</span>, <span class="keyword">new</span> <span class="title class_">ChessPiece</span>(<span class="number">2</span>,<span class="string">&quot;馬&quot;</span>, ChessPiece.Color.BLACK, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="comment">//...省略摆放其他棋子的代码...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">(<span class="type">int</span> chessPieceId, <span class="type">int</span> toPositionX, <span class="type">int</span> toPositionY)</span> &#123;</span><br><span class="line">    <span class="comment">//...省略...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了记录每个房间当前的棋局情况，我们需要给每个房间都创建一个ChessBoard棋局对象。因为游戏大厅中有成千上万的房间（实际上，百万人同时在线的游戏大厅也有很多），那保存这么多棋局对象就会消耗大量的内存。有没有什么办法来节省内存呢？</p>
<p>这个时候，享元模式就可以派上用场了。像刚刚的实现方式，在内存中会有大量的相似对象。这些相似对象的id、text、color都是相同的，唯独positionX、positionY不同。实际上，我们可以<u>将棋子的id、text、color属性拆分出来，设计成独立的类，并且作为享元供多个棋盘复用</u>。这样，棋盘只需要记录每个棋子的位置信息就可以了。具体的代码实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 享元类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChessPieceUnit</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">  <span class="keyword">private</span> String text;</span><br><span class="line">  <span class="keyword">private</span> Color color;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ChessPieceUnit</span><span class="params">(<span class="type">int</span> id, String text, Color color)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.id = id;</span><br><span class="line">    <span class="built_in">this</span>.text = text;</span><br><span class="line">    <span class="built_in">this</span>.color = color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    RED, BLACK</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...省略其他属性和getter方法...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChessPieceUnitFactory</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Integer, ChessPieceUnit&gt; pieces = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    pieces.put(<span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">ChessPieceUnit</span>(<span class="number">1</span>, <span class="string">&quot;車&quot;</span>, ChessPieceUnit.Color.BLACK));</span><br><span class="line">    pieces.put(<span class="number">2</span>, <span class="keyword">new</span> <span class="title class_">ChessPieceUnit</span>(<span class="number">2</span>,<span class="string">&quot;馬&quot;</span>, ChessPieceUnit.Color.BLACK));</span><br><span class="line">    <span class="comment">//...省略摆放其他棋子的代码...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> ChessPieceUnit <span class="title function_">getChessPiece</span><span class="params">(<span class="type">int</span> chessPieceId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pieces.get(chessPieceId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChessPiece</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> ChessPieceUnit chessPieceUnit;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> positionX;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> positionY;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ChessPiece</span><span class="params">(ChessPieceUnit unit, <span class="type">int</span> positionX, <span class="type">int</span> positionY)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.chessPieceUnit = unit;</span><br><span class="line">    <span class="built_in">this</span>.positionX = positionX;</span><br><span class="line">    <span class="built_in">this</span>.positionY = positionY;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 省略getter、setter方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChessBoard</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Map&lt;Integer, ChessPiece&gt; chessPieces = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ChessBoard</span><span class="params">()</span> &#123;</span><br><span class="line">    init();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    chessPieces.put(<span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">ChessPiece</span>(</span><br><span class="line">            ChessPieceUnitFactory.getChessPiece(<span class="number">1</span>), <span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">    chessPieces.put(<span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">ChessPiece</span>(</span><br><span class="line">            ChessPieceUnitFactory.getChessPiece(<span class="number">2</span>), <span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="comment">//...省略摆放其他棋子的代码...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">(<span class="type">int</span> chessPieceId, <span class="type">int</span> toPositionX, <span class="type">int</span> toPositionY)</span> &#123;</span><br><span class="line">    <span class="comment">//...省略...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码实现中，我们利用工厂类来缓存ChessPieceUnit信息（也就是id、text、color）。通过工厂类获取到的ChessPieceUnit就是享元。所有的ChessBoard对象共享这30个ChessPieceUnit对象（因为象棋中只有30个棋子）。在使用享元模式之前，记录1万个棋局，我们要创建30万（30*1万）个棋子的ChessPieceUnit对象。利用享元模式，我们只需要创建30个享元对象供所有棋局共享使用即可，大大节省了内存。</p>
<p>那享元模式的原理讲完了，我们来总结一下它的代码结构。实际上，它的代码实现非常简单，主要是<u>通过工厂模式，在工厂类中，通过一个Map来缓存已经创建过的享元对象，来达到复用的目的</u>。</p>
<p><strong>享元模式在文本编辑器中的应用</strong></p>
<p>弄懂了享元模式的原理和实现之后，我们再来看另外一个例子，也就是文章标题中给出的：如何利用享元模式来优化文本编辑器的内存占用？</p>
<p>你可以把这里提到的文本编辑器想象成Office的Word。不过，为了简化需求背景，我们假设这个文本编辑器只实现了文字编辑功能，不包含图片、表格等复杂的编辑功能。对于简化之后的文本编辑器，我们要在内存中表示一个文本文件，只需要记录文字和格式两部分信息就可以了，其中，格式又包括文字的字体、大小、颜色等信息。</p>
<p>尽管在实际的文档编写中，我们一般都是按照文本类型（标题、正文……）来设置文字的格式，标题是一种格式，正文是另一种格式等等。但是，从理论上讲，我们可以给文本文件中的每个文字都设置不同的格式。为了实现如此灵活的格式设置，并且代码实现又不过于太复杂，我们<u>把每个文字都当作一个独立的对象来看待，并且在其中包含它的格式信息</u>。具体的代码示例如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Character</span> &#123;<span class="comment">//文字</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Font font;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> colorRGB;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Character</span><span class="params">(<span class="type">char</span> c, Font font, <span class="type">int</span> size, <span class="type">int</span> colorRGB)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.c = c;</span><br><span class="line">    <span class="built_in">this</span>.font = font;</span><br><span class="line">    <span class="built_in">this</span>.size = size;</span><br><span class="line">    <span class="built_in">this</span>.colorRGB = colorRGB;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Editor</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Character&gt; chars = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">appendCharacter</span><span class="params">(<span class="type">char</span> c, Font font, <span class="type">int</span> size, <span class="type">int</span> colorRGB)</span> &#123;</span><br><span class="line">    <span class="type">Character</span> <span class="variable">character</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Character</span>(c, font, size, colorRGB);</span><br><span class="line">    chars.add(character);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在文本编辑器中，我们每敲一个文字，都会调用Editor类中的appendCharacter()方法，创建一个新的Character对象，保存到chars数组中。如果一个文本文件中，有上万、十几万、几十万的文字，那我们就要在内存中存储这么多Character对象。那有没有办法可以节省一点内存呢？</p>
<p>实际上，在一个文本文件中，用到的字体格式不会太多，毕竟不大可能有人把每个文字都设置成不同的格式。所以，对于字体格式，我们可以将它设计成享元，让不同的文字共享使用。按照这个设计思路，我们对上面的代码进行重构。重构后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CharacterStyle</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Font font;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> colorRGB;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">CharacterStyle</span><span class="params">(Font font, <span class="type">int</span> size, <span class="type">int</span> colorRGB)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.font = font;</span><br><span class="line">    <span class="built_in">this</span>.size = size;</span><br><span class="line">    <span class="built_in">this</span>.colorRGB = colorRGB;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="type">CharacterStyle</span> <span class="variable">otherStyle</span> <span class="operator">=</span> (CharacterStyle) o;</span><br><span class="line">    <span class="keyword">return</span> font.equals(otherStyle.font)</span><br><span class="line">            &amp;&amp; size == otherStyle.size</span><br><span class="line">            &amp;&amp; colorRGB == otherStyle.colorRGB;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CharacterStyleFactory</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;CharacterStyle&gt; styles = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> CharacterStyle <span class="title function_">getStyle</span><span class="params">(Font font, <span class="type">int</span> size, <span class="type">int</span> colorRGB)</span> &#123;</span><br><span class="line">    <span class="type">CharacterStyle</span> <span class="variable">newStyle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharacterStyle</span>(font, size, colorRGB);</span><br><span class="line">    <span class="keyword">for</span> (CharacterStyle style : styles) &#123;</span><br><span class="line">      <span class="keyword">if</span> (style.equals(newStyle)) &#123;</span><br><span class="line">        <span class="keyword">return</span> style;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    styles.add(newStyle);</span><br><span class="line">    <span class="keyword">return</span> newStyle;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Character</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">char</span> c;</span><br><span class="line">  <span class="keyword">private</span> CharacterStyle style;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Character</span><span class="params">(<span class="type">char</span> c, CharacterStyle style)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.c = c;</span><br><span class="line">    <span class="built_in">this</span>.style = style;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Editor</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Character&gt; chars = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">appendCharacter</span><span class="params">(<span class="type">char</span> c, Font font, <span class="type">int</span> size, <span class="type">int</span> colorRGB)</span> &#123;</span><br><span class="line">    <span class="type">Character</span> <span class="variable">character</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Character</span>(c, CharacterStyleFactory.getStyle(font, size, colorRGB));</span><br><span class="line">    chars.add(character);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>享元模式vs单例、缓存、对象池</strong></p>
<p>在上面的讲解中，我们多次提到“共享”“缓存”“复用”这些字眼，那它跟单例、缓存、对象池这些概念有什么区别呢？我们来简单对比一下。</p>
<p><u>我们先来看享元模式跟单例的区别。</u></p>
<p>在单例模式中，一个类只能创建一个对象，而在享元模式中，一个类可以创建多个对象，每个对象被多处代码引用共享。实际上，享元模式有点类似于之前讲到的单例的变体：多例。</p>
<p>我们前面也多次提到，区别两种设计模式，不能光看代码实现，而是要看设计意图，也就是要解决的问题。尽管从代码实现上来看，享元模式和多例有很多相似之处，但从设计意图上来看，它们是完全不同的。应用享元模式是为了对象复用，节省内存，而应用多例模式是为了限制对象的个数。</p>
<p><u>我们再来看享元模式跟缓存的区别。</u></p>
<p>在享元模式的实现中，我们通过工厂类来“缓存”已经创建好的对象。这里的“缓存”实际上是“存储”的意思，跟我们平时所说的“数据库缓存”“CPU缓存”“MemCache缓存”是两回事。我们平时所讲的缓存，主要是为了提高访问效率，而非复用。</p>
<p><u>最后我们来看享元模式跟对象池的区别。</u></p>
<p>对象池、连接池（比如数据库连接池）、线程池等也是为了复用，那它们跟享元模式有什么区别呢？</p>
<p>你可能对连接池、线程池比较熟悉，对对象池比较陌生，所以，这里我简单解释一下对象池。像C++这样的编程语言，内存的管理是由程序员负责的。为了避免频繁地进行对象创建和释放导致内存碎片，我们可以预先申请一片连续的内存空间，也就是这里说的对象池。每次创建对象时，我们从对象池中直接取出一个空闲对象来使用，对象使用完成之后，再放回到对象池中以供后续复用，而非直接释放掉。</p>
<p>虽然对象池、连接池、线程池、享元模式都是为了复用，但是，如果我们再细致地抠一抠“复用”这个字眼的话，对象池、连接池、线程池等池化技术中的“复用”和享元模式中的“复用”实际上是不同的概念。</p>
<p><u>池化技术中的“复用”可以理解为“重复使用”，主要目的是节省时间（比如从数据库池中取一个连接，不需要重新创建）</u>。在任意时刻，每一个对象、连接、线程，并不会被多处使用，而是被一个使用者独占，当使用完成之后，放回到池中，再由其他使用者重复利用。<u>享元模式中的“复用”可以理解为“共享使用”，在整个生命周期中，都是被所有使用者共享的，主要目的是节省空间</u>。</p>
<h3 id="38-结构型：享元模式（2）"><a href="#38-结构型：享元模式（2）" class="headerlink" title="38. 结构型：享元模式（2）"></a>38. 结构型：享元模式（2）</h3><p><strong>享元模式在Java Integer中的应用</strong></p>
<p>我们先来看下面这样一段代码。你可以先思考下，这段代码会输出什么样的结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">56</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">56</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">129</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="number">129</span>;</span><br><span class="line">System.out.println(i1 == i2);</span><br><span class="line">System.out.println(i3 == i4);</span><br></pre></td></tr></table></figure>

<p>如果不熟悉Java语言，你可能会觉得，i1和i2值都是56，i3和i4值都是129，i1跟i2值相等，i3跟i4值相等，所以输出结果应该是两个true。这样的分析是不对的，主要还是因为你对Java语法不熟悉。要正确地分析上面的代码，我们需要弄清楚下面两个问题：</p>
<ul>
<li>如何判定两个Java对象是否相等（也就代码中的“&#x3D;&#x3D;”操作符的含义）？</li>
<li>什么是自动装箱（Autoboxing）和自动拆箱（Unboxing）？</li>
</ul>
<p>Java为基本数据类型提供了对应的包装器类型。具体如下所示：</p>
<img src="https://static001.geekbang.org/resource/image/5f/a0/5f93c0412c9ee8b563383c3583693ba0.jpg" alt="img" style="zoom:33%;" />

<p>所谓的自动装箱，就是自动将基本数据类型转换为包装器类型。所谓的自动拆箱，也就是自动将包装器类型转化为基本数据类型。具体的代码示例如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">56</span>; <span class="comment">//自动装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; <span class="comment">//自动拆箱</span></span><br></pre></td></tr></table></figure>

<p>数值56是基本数据类型int，当赋值给包装器类型（Integer）变量的时候，触发自动装箱操作，创建一个Integer类型的对象，并且赋值给变量i。其底层相当于执行了下面这条语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">59</span>;<span class="comment">//底层执行了：Integer i = Integer.valueOf(59);</span></span><br></pre></td></tr></table></figure>

<p>反过来，当把包装器类型的变量i，赋值给基本数据类型变量j的时候，触发自动拆箱操作，将i中的数据取出，赋值给j。其底层相当于执行了下面这条语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; <span class="comment">//底层执行了：int j = i.intValue();</span></span><br></pre></td></tr></table></figure>

<p>弄清楚了自动装箱和自动拆箱，我们再来看，如何判定两个对象是否相等？不过，在此之前，我们先要搞清楚，Java对象在内存中是如何存储的。我们通过下面这个例子来说明一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">123</span>, <span class="number">23</span>); <span class="comment">// id=123, age=23</span></span><br></pre></td></tr></table></figure>

<p>针对这条语句，我画了一张内存存储结构图，如下所示。a存储的值是User对象的内存地址，在图中就表现为a指向User对象。</p>
<img src="https://static001.geekbang.org/resource/image/04/dc/04f879d7d72b96965f4e06a21ff13bdc.jpg" alt="img" style="zoom:33%;" />

<p>当我们通过“&#x3D;&#x3D;”来判定两个对象是否相等的时候，实际上是在判断两个局部变量存储的地址是否相同，换句话说，是在判断两个局部变量是否指向相同的对象。</p>
<p>了解了Java的这几个语法之后，我们重新看一下开头的那段代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">56</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">56</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">129</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="number">129</span>;</span><br><span class="line">System.out.println(i1 == i2);</span><br><span class="line">System.out.println(i3 == i4);</span><br></pre></td></tr></table></figure>

<p>前4行赋值语句都会触发自动装箱操作，也就是会创建Integer对象并且赋值给i1、i2、i3、i4这四个变量。根据刚刚的讲解，i1、i2尽管存储的数值相同，都是56，但是指向不同的Integer对象，所以通过“&#x3D;&#x3D;”来判定是否相同的时候，会返回false。同理，i3&#x3D;&#x3D;i4判定语句也会返回false。</p>
<p>不过，上面的分析还是不对，答案并非是两个false，而是一个true，一个false。看到这里，你可能会比较纳闷了。实际上，这正是因为Integer用到了享元模式来复用对象，才导致了这样的运行结果。当我们通过自动装箱，也就是调用valueOf()来创建Integer对象的时候，<u>如果要创建的Integer对象的值在-128到127之间，会从IntegerCache类中直接返回，否则才调用new方法创建</u>。看代码更加清晰一些，Integer类的valueOf()函数的具体代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static Integer valueOf(int i) &#123;</span><br><span class="line">    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    return new Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，这里的IntegerCache相当于，我们上一节课中讲的生成享元对象的工厂类，只不过名字不叫xxxFactory而已。我们来看它的具体代码实现。这个类是Integer的内部类，你也可以自行查看JDK源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Cache to support the object identity semantics of autoboxing for values between</span></span><br><span class="line"><span class="comment"> * -128 and 127 (inclusive) as required by JLS.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The cache is initialized on first usage.  The size of the cache</span></span><br><span class="line"><span class="comment"> * may be controlled by the &#123;<span class="doctag">@code</span> -XX:AutoBoxCacheMax=&lt;size&gt;&#125; option.</span></span><br><span class="line"><span class="comment"> * During VM initialization, java.lang.Integer.IntegerCache.high property</span></span><br><span class="line"><span class="comment"> * may be set and saved in the private system properties in the</span></span><br><span class="line"><span class="comment"> * sun.misc.VM class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">integerCacheHighPropValue</span> <span class="operator">=</span></span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> <span class="title class_">Integer</span>[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> <span class="title class_">Integer</span>(j++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">IntegerCache</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么IntegerCache只缓存-128到127之间的整型值呢？</p>
<p>在IntegerCache的代码实现中，当这个类被加载的时候，缓存的享元对象会被集中一次性创建好。毕竟整型值太多了，我们不可能在IntegerCache类中预先创建好所有的整型值，这样既占用太多内存，也使得加载IntegerCache类的时间过长。所以，我们只能选择缓存对于大部分应用来说最常用的整型值，也就是一个字节的大小（-128到127之间的数据）。</p>
<p>实际上，JDK也提供了方法来让我们可以自定义缓存的最大值，有下面两种方式。如果你通过分析应用的JVM内存占用情况，发现-128到255之间的数据占用的内存比较多，你就可以用如下方式，将缓存的最大值从127调整到255。不过，这里注意一下，JDK并没有提供设置最小值的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法一：</span></span><br><span class="line">-Djava.lang.Integer.IntegerCache.high=<span class="number">255</span></span><br><span class="line"><span class="comment">//方法二：</span></span><br><span class="line">-XX:AutoBoxCacheMax=<span class="number">255</span></span><br></pre></td></tr></table></figure>

<p>现在，让我们再回到最开始的问题，因为56处于-128和127之间，i1和i2会指向相同的享元对象，所以i1&#x3D;&#x3D;i2返回true。而129大于127，并不会被缓存，每次都会创建一个全新的对象，也就是说，i3和i4指向不同的Integer对象，所以i3&#x3D;&#x3D;i4返回false。</p>
<p>实际上，除了Integer类型之外，其他包装器类型，比如Long、Short、Byte等，也都利用了享元模式来缓存-128到127之间的数据。比如，Long类型对应的LongCache享元工厂类及valueOf()函数代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LongCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LongCache</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Long cache[] = <span class="keyword">new</span> <span class="title class_">Long</span>[-(-<span class="number">128</span>) + <span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line">            cache[i] = <span class="keyword">new</span> <span class="title class_">Long</span>(i - <span class="number">128</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title function_">valueOf</span><span class="params">(<span class="type">long</span> l)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= -<span class="number">128</span> &amp;&amp; l &lt;= <span class="number">127</span>) &#123; <span class="comment">// will cache</span></span><br><span class="line">        <span class="keyword">return</span> LongCache.cache[(<span class="type">int</span>)l + offset];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Long</span>(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在我们平时的开发中，对于下面这样三种创建整型对象的方式，我们优先使用后两种。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> Integer.valueOf(<span class="number">123</span>);</span><br></pre></td></tr></table></figure>

<p>第一种创建方式并不会使用到IntegerCache，而后面两种创建方法可以利用IntegerCache缓存，返回共享的对象，以达到节省内存的目的。举一个极端一点的例子，假设程序需要创建1万个-128到127之间的Integer对象。使用第一种创建方式，我们需要分配1万个Integer对象的内存空间；使用后两种创建方式，我们最多只需要分配256个Integer对象的内存空间。</p>
<p><strong>享元模式在Java String中的应用</strong></p>
<p>刚刚我们讲了享元模式在Java Integer类中的应用，现在，我们再来看下，享元模式在Java String类中的应用。同样，我们还是先来看一段代码，你觉得这段代码输出的结果是什么呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;小争哥&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;小争哥&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;小争哥&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2);</span><br><span class="line">System.out.println(s1 == s3);</span><br></pre></td></tr></table></figure>

<p>上面代码的运行结果是：一个true，一个false。跟Integer类的设计思路相似，String类利用享元模式来复用相同的字符串常量（也就是代码中的“小争哥”）。JVM会专门开辟一块存储区来存储字符串常量，这块存储区叫作“字符串常量池”。上面代码对应的内存存储结构如下所示：</p>
<img src="https://static001.geekbang.org/resource/image/2d/2d/2dfc18575c22efccca191c566b24a22d.jpg" alt="img" style="zoom:33%;" />

<p>不过，String类的享元模式的设计，跟Integer类稍微有些不同。Integer类中要共享的对象，是在类加载的时候，就集中一次性创建好的。但是，对于字符串来说，我们没法事先知道要共享哪些字符串常量，所以没办法事先创建好，只能<u>在某个字符串常量第一次被用到的时候，存储到常量池中，当之后再用到的时候，直接引用常量池中已经存在的即可，就不需要再重新创建了</u>。</p>
<h3 id="39-行为型：观察者模式（1）"><a href="#39-行为型：观察者模式（1）" class="headerlink" title="39. 行为型：观察者模式（1）"></a>39. 行为型：观察者模式（1）</h3><p>开始学习行为型设计模式。我们知道，创建型设计模式主要解决“对象的创建”问题，结构型设计模式主要解决“类或对象的组合或组装”问题，那行为型设计模式主要解决的就是“类或对象之间的交互”问题。</p>
<p>行为型设计模式比较多，有11个，几乎占了23种经典设计模式的一半。它们分别是：<u>观察者模式、模板模式、策略模式、职责链模式、状态模式、迭代器模式、访问者模式、备忘录模式、命令模式、解释器模式、中介模式</u>。</p>
<p>今天，我们学习第一个行为型设计模式，也是在实际的开发中用得比较多的一种模式：观察者模式。根据应用场景的不同，观察者模式会对应不同的代码实现方式：<u>有同步阻塞的实现方式，也有异步非阻塞的实现方式；有进程内的实现方式，也有跨进程的实现方式</u>。今天我会重点讲解原理、实现、应用场景。下一节课，我会带你一块实现一个基于观察者模式的异步非阻塞的EventBus，加深你对这个模式的理解。</p>
<p><strong>原理及应用场景剖析</strong></p>
<p><strong>观察者模式</strong>（Observer Design Pattern）也被称为<strong>发布订阅模式</strong>（Publish-Subscribe Design Pattern）。在GoF的《设计模式》一书中，它的定义是这样的：</p>
<blockquote>
<p>Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.</p>
</blockquote>
<p>翻译成中文就是：<u>在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知</u>。</p>
<p>一般情况下，被依赖的对象叫作<strong>被观察者</strong>（Observable），依赖的对象叫作<strong>观察者</strong>（Observer）。不过，在实际的项目开发中，这两种对象的称呼是比较灵活的，有各种不同的叫法，比如：Subject-Observer、Publisher-Subscriber、Producer-Consumer、EventEmitter-EventListener、Dispatcher-Listener。不管怎么称呼，只要应用场景符合刚刚给出的定义，都可以看作观察者模式。</p>
<p>实际上，观察者模式是一个比较抽象的模式，根据不同的应用场景和需求，有完全不同的实现方式，待会我们会详细地讲到。现在，我们先来看其中最经典的一种实现方式。这也是在讲到这种模式的时候，很多书籍或资料给出的最常见的实现方式。具体的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer observer)</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer observer)</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">(Message message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Message message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteSubject</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">    observers.add(observer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">    observers.remove(observer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">      observer.update(message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteObserverOne</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> 获取消息通知，执行自己的逻辑...</span></span><br><span class="line">    System.out.println(<span class="string">&quot;ConcreteObserverOne is notified.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteObserverTwo</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> 获取消息通知，执行自己的逻辑...</span></span><br><span class="line">    System.out.println(<span class="string">&quot;ConcreteObserverTwo is notified.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ConcreteSubject</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteSubject</span>();</span><br><span class="line">    subject.registerObserver(<span class="keyword">new</span> <span class="title class_">ConcreteObserverOne</span>());</span><br><span class="line">    subject.registerObserver(<span class="keyword">new</span> <span class="title class_">ConcreteObserverTwo</span>());</span><br><span class="line">    subject.notifyObservers(<span class="keyword">new</span> <span class="title class_">Message</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，上面的代码算是观察者模式的“模板代码”，只能反映大体的设计思路。在真实的软件开发中，并不需要照搬上面的模板代码。观察者模式的实现方法各式各样，函数、类的命名等会根据业务场景的不同有很大的差别，比如register函数还可以叫作attach，remove函数还可以叫作detach等等。不过，万变不离其宗，设计思路都是差不多的。</p>
<p>原理和代码实现都非常简单，也比较好理解，不需要我过多的解释。我们还是通过一个具体的例子来重点讲一下，什么情况下需要用到这种设计模式？或者说，这种设计模式能解决什么问题呢？</p>
<p>假设我们在开发一个P2P投资理财系统，用户注册成功之后，我们会给用户发放投资体验金。代码实现大致是下面这个样子的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> UserService userService; <span class="comment">// 依赖注入</span></span><br><span class="line">  <span class="keyword">private</span> PromotionService promotionService; <span class="comment">// 依赖注入</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Long <span class="title function_">register</span><span class="params">(String telephone, String password)</span> &#123;</span><br><span class="line">    <span class="comment">//省略输入参数的校验代码</span></span><br><span class="line">    <span class="comment">//省略userService.register()异常的try-catch代码</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">userId</span> <span class="operator">=</span> userService.register(telephone, password);</span><br><span class="line">    promotionService.issueNewUserExperienceCash(userId);</span><br><span class="line">    <span class="keyword">return</span> userId;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然注册接口做了两件事情，注册和发放体验金，违反单一职责原则，但是，如果没有扩展和修改的需求，现在的代码实现是可以接受的。如果非得用观察者模式，就需要引入更多的类和更加复杂的代码结构，反倒是一种过度设计。</p>
<p>相反，如果需求频繁变动，比如，用户注册成功之后，不再发放体验金，而是改为发放优惠券，并且还要给用户发送一封“欢迎注册成功”的站内信。这种情况下，我们就需要频繁地修改register()函数中的代码，违反开闭原则。而且，如果注册成功之后需要执行的后续操作越来越多，那register()函数的逻辑会变得越来越复杂，也就影响到代码的可读性和可维护性。</p>
<p>这个时候，观察者模式就能派上用场了。利用观察者模式，我对上面的代码进行了重构。重构之后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RegObserver</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">handleRegSuccess</span><span class="params">(<span class="type">long</span> userId)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegPromotionObserver</span> <span class="keyword">implements</span> <span class="title class_">RegObserver</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> PromotionService promotionService; <span class="comment">// 依赖注入</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRegSuccess</span><span class="params">(<span class="type">long</span> userId)</span> &#123;</span><br><span class="line">    promotionService.issueNewUserExperienceCash(userId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegNotificationObserver</span> <span class="keyword">implements</span> <span class="title class_">RegObserver</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> NotificationService notificationService;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRegSuccess</span><span class="params">(<span class="type">long</span> userId)</span> &#123;</span><br><span class="line">    notificationService.sendInboxMessage(userId, <span class="string">&quot;Welcome...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> UserService userService; <span class="comment">// 依赖注入</span></span><br><span class="line">  <span class="keyword">private</span> List&lt;RegObserver&gt; regObservers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一次性设置好，之后也不可能动态的修改</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRegObservers</span><span class="params">(List&lt;RegObserver&gt; observers)</span> &#123;</span><br><span class="line">    regObservers.addAll(observers);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Long <span class="title function_">register</span><span class="params">(String telephone, String password)</span> &#123;</span><br><span class="line">    <span class="comment">//省略输入参数的校验代码</span></span><br><span class="line">    <span class="comment">//省略userService.register()异常的try-catch代码</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">userId</span> <span class="operator">=</span> userService.register(telephone, password);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (RegObserver observer : regObservers) &#123;</span><br><span class="line">      observer.handleRegSuccess(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> userId;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们需要添加新的观察者的时候，比如，用户注册成功之后，推送用户注册信息给大数据征信系统，基于观察者模式的代码实现，UserController类的register()函数完全不需要修改，只需要再添加一个实现了RegObserver接口的类，并且通过setRegObservers()函数将它注册到UserController类中即可。</p>
<p>不过，你可能会说，当我们把发送体验金替换为发送优惠券的时候，需要修改RegPromotionObserver类中handleRegSuccess()函数的代码，这还是违反开闭原则呀？你说得没错，不过，相对于register()函数来说，handleRegSuccess()函数的逻辑要简单很多，修改更不容易出错，引入bug的风险更低。</p>
<p>前面我们已经学习了很多设计模式，不知道你有没有发现，实际上，<strong>设计模式要干的事情就是解耦。创建型模式是将创建和使用代码解耦，结构型模式是将不同功能代码解耦，行为型模式是将不同的行为代码解耦，具体到观察者模式，它是将观察者和被观察者代码解耦。</strong>借助设计模式，我们利用更好的代码结构，将一大坨代码拆分成职责更单一的小类，让其满足开闭原则、高内聚松耦合等特性，以此来控制和应对代码的复杂性，提高代码的可扩展性。</p>
<p><strong>基于不同应用场景的不同实现方式</strong></p>
<p>观察者模式的应用场景非常广泛，小到代码层面的解耦，大到架构层面的系统解耦，再或者一些产品的设计思路，都有这种模式的影子，比如，邮件订阅、RSS Feeds，本质上都是观察者模式。</p>
<p>不同的应用场景和需求下，这个模式也有截然不同的实现方式，开篇的时候我们也提到，有同步阻塞的实现方式，也有异步非阻塞的实现方式；有进程内的实现方式，也有跨进程的实现方式。</p>
<p>之前讲到的实现方式，从刚刚的分类方式上来看，它是一种同步阻塞的实现方式。观察者和被观察者代码在同一个线程内执行，被观察者一直阻塞，直到所有的观察者代码都执行完成之后，才执行后续的代码。对照上面讲到的用户注册的例子，register()函数依次调用执行每个观察者的handleRegSuccess()函数，等到都执行完成之后，才会返回结果给客户端。</p>
<p>如果注册接口是一个调用比较频繁的接口，对性能非常敏感，希望接口的响应时间尽可能短，那我们可以将同步阻塞的实现方式改为异步非阻塞的实现方式，以此来减少响应时间。具体来讲，当userService.register()函数执行完成之后，我们启动一个新的线程来执行观察者的handleRegSuccess()函数，这样userController.register()函数就不需要等到所有的handleRegSuccess()函数都执行完成之后才返回结果给客户端。userController.register()函数从执行3个SQL语句才返回，减少到只需要执行1个SQL语句就返回，响应时间粗略来讲减少为原来的1&#x2F;3。</p>
<p>那如何实现一个异步非阻塞的观察者模式呢？简单一点的做法是，在每个handleRegSuccess()函数中，创建一个新的线程执行代码。不过，我们还有更加优雅的实现方式，那就是基于EventBus来实现。今天，我们就不展开讲解了。在下一讲中，我会用一节课的时间，借鉴Google Guava EventBus框架的设计思想，手把手带你开发一个支持异步非阻塞的EventBus框架。它可以复用在任何需要异步非阻塞观察者模式的应用场景中。</p>
<p>刚刚讲到的两个场景，不管是同步阻塞实现方式还是异步非阻塞实现方式，都是进程内的实现方式。如果用户注册成功之后，我们需要发送用户信息给大数据征信系统，而大数据征信系统是一个独立的系统，跟它之间的交互是跨不同进程的，那如何实现一个跨进程的观察者模式呢？</p>
<p>如果大数据征信系统提供了发送用户注册信息的RPC接口，我们仍然可以沿用之前的实现思路，在handleRegSuccess()函数中调用RPC接口来发送数据。但是，我们还有更加优雅、更加常用的一种实现方式，那就是基于消息队列（Message Queue，比如ActiveMQ）来实现。</p>
<p>当然，这种实现方式也有弊端，那就是需要引入一个新的系统（消息队列），增加了维护成本。不过，它的好处也非常明显。在原来的实现方式中，观察者需要注册到被观察者中，被观察者需要依次遍历观察者来发送消息。而基于消息队列的实现方式，被观察者和观察者解耦更加彻底，两部分的耦合更小。被观察者完全不感知观察者，同理，观察者也完全不感知被观察者。被观察者只管发送消息到消息队列，观察者只管从消息队列中读取消息来执行相应的逻辑。</p>
<h3 id="40-行为型：观察者模式（2）"><a href="#40-行为型：观察者模式（2）" class="headerlink" title="40. 行为型：观察者模式（2）"></a>40. 行为型：观察者模式（2）</h3><p>上一节课中，我们学习了观察者模式的原理、实现、应用场景，重点介绍了不同应用场景下，几种不同的实现方式，包括：同步阻塞、异步非阻塞、进程内、进程间的实现方式。</p>
<p>同步阻塞是最经典的实现方式，主要是为了代码解耦；异步非阻塞除了能实现代码解耦之外，还能提高代码的执行效率；进程间的观察者模式解耦更加彻底，一般是基于消息队列来实现，用来实现不同进程间的被观察者和观察者之间的交互。</p>
<p>今天，我们聚焦于异步非阻塞的观察者模式，带你实现一个类似Google Guava EventBus的通用框架。</p>
<p><strong>异步非阻塞观察者模式的简易实现</strong></p>
<p>上一节课中，我们讲到，对于异步非阻塞观察者模式，如果只是实现一个简易版本，不考虑任何通用性、复用性，实际上是非常容易的。</p>
<p>我们有两种实现方式。其中一种是：在每个handleRegSuccess()函数中创建一个新的线程执行代码逻辑；另一种是：在UserController的register()函数中使用线程池来执行每个观察者的handleRegSuccess()函数。两种实现方式的具体代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种实现方式，其他类代码不变，就没有再重复罗列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegPromotionObserver</span> <span class="keyword">implements</span> <span class="title class_">RegObserver</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> PromotionService promotionService; <span class="comment">// 依赖注入</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRegSuccess</span><span class="params">(Long userId)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        promotionService.issueNewUserExperienceCash(userId);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种实现方式，其他类代码不变，就没有再重复罗列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> UserService userService; <span class="comment">// 依赖注入</span></span><br><span class="line">  <span class="keyword">private</span> List&lt;RegObserver&gt; regObservers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> Executor executor;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">UserController</span><span class="params">(Executor executor)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.executor = executor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRegObservers</span><span class="params">(List&lt;RegObserver&gt; observers)</span> &#123;</span><br><span class="line">    regObservers.addAll(observers);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Long <span class="title function_">register</span><span class="params">(String telephone, String password)</span> &#123;</span><br><span class="line">    <span class="comment">//省略输入参数的校验代码</span></span><br><span class="line">    <span class="comment">//省略userService.register()异常的try-catch代码</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">userId</span> <span class="operator">=</span> userService.register(telephone, password);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (RegObserver observer : regObservers) &#123;</span><br><span class="line">      executor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">          observer.handleRegSuccess(userId);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> userId;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于第一种实现方式，频繁地创建和销毁线程比较耗时，并且并发线程数无法控制，创建过多的线程会导致堆栈溢出。第二种实现方式，尽管利用了线程池解决了第一种实现方式的问题，但线程池、异步执行逻辑都耦合在了register()函数中，增加了这部分业务代码的维护成本。</p>
<p>如果我们的需求更加极端一点，需要在同步阻塞和异步非阻塞之间灵活切换，那就要不停地修改UserController的代码。除此之外，如果在项目中，不止一个业务模块需要用到异步非阻塞观察者模式，那这样的代码实现也无法做到复用。</p>
<p>我们知道，框架的作用有：隐藏实现细节，降低开发难度，做到代码复用，解耦业务与非业务代码，让程序员聚焦业务开发。针对异步非阻塞观察者模式，我们也可以将它抽象成框架来达到这样的效果，而这个框架就是我们这节课要讲的EventBus。</p>
<p><strong>EventBus框架功能需求介绍</strong></p>
<p>EventBus翻译为“事件总线”，它提供了实现观察者模式的骨架代码。我们可以基于此框架，非常容易地在自己的业务场景中实现观察者模式，不需要从零开始开发。其中，Google Guava EventBus就是一个比较著名的EventBus框架，它不仅仅支持异步非阻塞模式，同时也支持同步阻塞模式</p>
<p>现在，我们就通过例子来看一下，Guava EventBus具有哪些功能。还是上节课那个用户注册的例子，我们用Guava EventBus重新实现一下，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> UserService userService; <span class="comment">// 依赖注入</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> EventBus eventBus;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_EVENTBUS_THREAD_POOL_SIZE</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">UserController</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//eventBus = new EventBus(); // 同步阻塞模式</span></span><br><span class="line">    eventBus = <span class="keyword">new</span> <span class="title class_">AsyncEventBus</span>(Executors.newFixedThreadPool(DEFAULT_EVENTBUS_THREAD_POOL_SIZE)); <span class="comment">// 异步非阻塞模式</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRegObservers</span><span class="params">(List&lt;Object&gt; observers)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Object observer : observers) &#123;</span><br><span class="line">      eventBus.register(observer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Long <span class="title function_">register</span><span class="params">(String telephone, String password)</span> &#123;</span><br><span class="line">    <span class="comment">//省略输入参数的校验代码</span></span><br><span class="line">    <span class="comment">//省略userService.register()异常的try-catch代码</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">userId</span> <span class="operator">=</span> userService.register(telephone, password);</span><br><span class="line"></span><br><span class="line">    eventBus.post(userId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> userId;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegPromotionObserver</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> PromotionService promotionService; <span class="comment">// 依赖注入</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Subscribe</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRegSuccess</span><span class="params">(Long userId)</span> &#123;</span><br><span class="line">    promotionService.issueNewUserExperienceCash(userId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegNotificationObserver</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> NotificationService notificationService;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Subscribe</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRegSuccess</span><span class="params">(Long userId)</span> &#123;</span><br><span class="line">    notificationService.sendInboxMessage(userId, <span class="string">&quot;...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用EventBus框架实现的观察者模式，跟从零开始编写的观察者模式相比，从大的流程上来说，实现思路大致一样，都需要定义Observer，并且通过register()函数注册Observer，也都需要通过调用某个函数（比如，EventBus中的post()函数）来给Observer发送消息（在EventBus中消息被称作事件event）。</p>
<p>但在实现细节方面，它们又有些区别。基于EventBus，我们不需要定义Observer接口，任意类型的对象都可以注册到EventBus中，通过@Subscribe注解来标明类中哪个函数可以接收被观察者发送的消息。</p>
<p>接下来，我们详细地讲一下，Guava EventBus的几个主要的类和函数。</p>
<ul>
<li>EventBus、AsyncEventBus</li>
</ul>
<p>Guava EventBus对外暴露的所有可调用接口，都封装在EventBus类中。其中，EventBus实现了同步阻塞的观察者模式，AsyncEventBus继承自EventBus，提供了异步非阻塞的观察者模式。具体使用方式如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">EventBus</span> <span class="variable">eventBus</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EventBus</span>(); <span class="comment">// 同步阻塞模式</span></span><br><span class="line"><span class="type">EventBus</span> <span class="variable">eventBus</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AsyncEventBus</span>(Executors.newFixedThreadPool(<span class="number">8</span>))；<span class="comment">// 异步阻塞模式</span></span><br></pre></td></tr></table></figure>

<ul>
<li>register()函数</li>
</ul>
<p>EventBus类提供了register()函数用来注册观察者。具体的函数定义如下所示。它可以接受任何类型（Object）的观察者。而在经典的观察者模式的实现中，register()函数必须接受实现了同一Observer接口的类对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Object object)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>unregister()函数</li>
</ul>
<p>相对于register()函数，unregister()函数用来从EventBus中删除某个观察者。我就不多解释了，具体的函数定义如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unregister</span><span class="params">(Object object)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>post()函数</li>
</ul>
<p>EventBus类提供了post()函数，用来给观察者发送消息。具体的函数定义如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">post</span><span class="params">(Object event)</span>;</span><br></pre></td></tr></table></figure>

<p>跟经典的观察者模式的不同之处在于，当我们调用post()函数发送消息的时候，并非把消息发送给所有的观察者，而是发送给可匹配的观察者。所谓可匹配指的是，能接收的消息类型是发送消息（post函数定义中的event）类型的父类。我举个例子来解释一下。</p>
<p>比如，AObserver能接收的消息类型是XMsg，BObserver能接收的消息类型是YMsg，CObserver能接收的消息类型是ZMsg。其中，XMsg是YMsg的父类。当我们如下发送消息的时候，相应能接收到消息的可匹配观察者如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">XMsg</span> <span class="variable">xMsg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMsg</span>();</span><br><span class="line"><span class="type">YMsg</span> <span class="variable">yMsg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">YMsg</span>();</span><br><span class="line"><span class="type">ZMsg</span> <span class="variable">zMsg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZMsg</span>();</span><br><span class="line">post(xMsg); =&gt; AObserver接收到消息</span><br><span class="line">post(yMsg); =&gt; AObserver、BObserver接收到消息</span><br><span class="line">post(zMsg); =&gt; CObserver接收到消息</span><br></pre></td></tr></table></figure>

<p>你可能会问，每个Observer能接收的消息类型是在哪里定义的呢？我们来看下Guava EventBus最特别的一个地方，那就是@Subscribe注解。</p>
<ul>
<li>@Subscribe注解</li>
</ul>
<p>EventBus通过@Subscribe注解来标明，某个函数能接收哪种类型的消息。具体的使用代码如下所示。在DObserver类中，我们通过@Subscribe注解了两个函数f1()、f2()。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> DObserver &#123;</span><br><span class="line">  <span class="comment">//...省略其他属性和方法...</span></span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Subscribe</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">(PMsg event)</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Subscribe</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">(QMsg event)</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当通过register()函数将DObserver 类对象注册到EventBus的时候，EventBus会根据@Subscribe注解找到f1()和f2()，并且将两个函数能接收的消息类型记录下来（PMsg-&gt;f1，QMsg-&gt;f2）。当我们通过post()函数发送消息（比如QMsg消息）的时候，EventBus会通过之前的记录（QMsg-&gt;f2），调用相应的函数（f2）。</p>
<p><strong>手把手实现一个EventBus框架</strong></p>
<p>Guava EventBus的功能我们已经讲清楚了，总体上来说，还是比较简单的。接下来，我们就重复造轮子，“山寨”一个EventBus出来。</p>
<p>我们重点来看，EventBus中两个核心函数register()和post()的实现原理。弄懂了它们，基本上就弄懂了整个EventBus框架。下面两张图是这两个函数的实现原理图。</p>
<img src="https://static001.geekbang.org/resource/image/ce/c6/ce842666fa3dc92bb8f4f2d8e75d12c6.jpg" alt="img" style="zoom:33%;" />

<img src="https://static001.geekbang.org/resource/image/bf/45/bf7ef52a40b1e35b18f369265caca645.jpg" alt="img" style="zoom:33%;" />

<p>从图中我们可以看出，最关键的一个数据结构是Observer注册表，记录了消息类型和可接收消息函数的对应关系。当调用register()函数注册观察者的时候，EventBus通过解析@Subscribe注解，生成Observer注册表。当调用post()函数发送消息的时候，EventBus通过注册表找到相应的可接收消息的函数，然后通过Java的反射语法来动态地创建对象、执行函数。对于同步阻塞模式，EventBus在一个线程内依次执行相应的函数。对于异步非阻塞模式，EventBus通过一个线程池来执行相应的函数。</p>
<p>弄懂了原理，实现起来就简单多了。整个小框架的代码实现包括5个类：EventBus、AsyncEventBus、Subscribe、ObserverAction、ObserverRegistry。接下来，我们依次来看下这5个类。</p>
<p><u>1.Subscribe</u></p>
<p>Subscribe是一个注解，用于标明观察者中的哪个函数可以接收消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Beta</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Subscribe &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><u>2.ObserverAction</u></p>
<p>ObserverAction类用来表示@Subscribe注解的方法，其中，target表示观察者类，method表示方法。它主要用在ObserverRegistry观察者注册表中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObserverAction</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Object target;</span><br><span class="line">  <span class="keyword">private</span> Method method;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ObserverAction</span><span class="params">(Object target, Method method)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.target = Preconditions.checkNotNull(target);</span><br><span class="line">    <span class="built_in">this</span>.method = method;</span><br><span class="line">    <span class="built_in">this</span>.method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Object event)</span> &#123; <span class="comment">// event是method方法的参数</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      method.invoke(target, event);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException | IllegalAccessException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u>3.ObserverRegistry</u></p>
<p>ObserverRegistry类就是前面讲到的Observer注册表，是最复杂的一个类，框架中几乎所有的核心逻辑都在这个类中。这个类大量使用了Java的反射语法，不过代码整体来说都不难理解，其中，一个比较有技巧的地方是CopyOnWriteArraySet的使用。</p>
<p>CopyOnWriteArraySet，顾名思义，在写入数据的时候，会创建一个新的set，并且将原始数据clone到新的set中，在新的set中写入数据完成之后，再用新的set替换老的set。这样就能保证在写入数据的时候，不影响数据的读取操作，以此来解决读写并发问题。除此之外，CopyOnWriteSet还通过加锁的方式，避免了并发写冲突。具体的作用你可以去查看一下CopyOnWriteSet类的源码，一目了然。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObserverRegistry</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> ConcurrentMap&lt;Class&lt;?&gt;, CopyOnWriteArraySet&lt;ObserverAction&gt;&gt; registry = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Object observer)</span> &#123;</span><br><span class="line">    Map&lt;Class&lt;?&gt;, Collection&lt;ObserverAction&gt;&gt; observerActions = findAllObserverActions(observer);</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Collection&lt;ObserverAction&gt;&gt; entry : observerActions.entrySet()) &#123;</span><br><span class="line">      Class&lt;?&gt; eventType = entry.getKey();</span><br><span class="line">      Collection&lt;ObserverAction&gt; eventActions = entry.getValue();</span><br><span class="line">      CopyOnWriteArraySet&lt;ObserverAction&gt; registeredEventActions = registry.get(eventType);</span><br><span class="line">      <span class="keyword">if</span> (registeredEventActions == <span class="literal">null</span>) &#123;</span><br><span class="line">        registry.putIfAbsent(eventType, <span class="keyword">new</span> <span class="title class_">CopyOnWriteArraySet</span>&lt;&gt;());</span><br><span class="line">        registeredEventActions = registry.get(eventType);</span><br><span class="line">      &#125;</span><br><span class="line">      registeredEventActions.addAll(eventActions);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> List&lt;ObserverAction&gt; <span class="title function_">getMatchedObserverActions</span><span class="params">(Object event)</span> &#123;</span><br><span class="line">    List&lt;ObserverAction&gt; matchedObservers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Class&lt;?&gt; postedEventType = event.getClass();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, CopyOnWriteArraySet&lt;ObserverAction&gt;&gt; entry : registry.entrySet()) &#123;</span><br><span class="line">      Class&lt;?&gt; eventType = entry.getKey();</span><br><span class="line">      Collection&lt;ObserverAction&gt; eventActions = entry.getValue();</span><br><span class="line">      <span class="keyword">if</span> (postedEventType.isAssignableFrom(eventType)) &#123;</span><br><span class="line">        matchedObservers.addAll(eventActions);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matchedObservers;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Map&lt;Class&lt;?&gt;, Collection&lt;ObserverAction&gt;&gt; findAllObserverActions(Object observer) &#123;</span><br><span class="line">    Map&lt;Class&lt;?&gt;, Collection&lt;ObserverAction&gt;&gt; observerActions = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Class&lt;?&gt; clazz = observer.getClass();</span><br><span class="line">    <span class="keyword">for</span> (Method method : getAnnotatedMethods(clazz)) &#123;</span><br><span class="line">      Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">      Class&lt;?&gt; eventType = parameterTypes[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">if</span> (!observerActions.containsKey(eventType)) &#123;</span><br><span class="line">        observerActions.put(eventType, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">      &#125;</span><br><span class="line">      observerActions.get(eventType).add(<span class="keyword">new</span> <span class="title class_">ObserverAction</span>(observer, method));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> observerActions;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> List&lt;Method&gt; <span class="title function_">getAnnotatedMethods</span><span class="params">(Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">    List&lt;Method&gt; annotatedMethods = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Method method : clazz.getDeclaredMethods()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">        Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">        Preconditions.checkArgument(parameterTypes.length == <span class="number">1</span>,</span><br><span class="line">                <span class="string">&quot;Method %s has @Subscribe annotation but has %s parameters.&quot;</span></span><br><span class="line">                        + <span class="string">&quot;Subscriber methods must have exactly 1 parameter.&quot;</span>,</span><br><span class="line">                method, parameterTypes.length);</span><br><span class="line">        annotatedMethods.add(method);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> annotatedMethods;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u>4.EventBus</u></p>
<p>EventBus实现的是阻塞同步的观察者模式。看代码你可能会有些疑问，这明明就用到了线程池Executor啊。实际上，MoreExecutors.directExecutor()是Google Guava提供的工具类，看似是多线程，实际上是单线程。之所以要这么实现，主要还是为了跟AsyncEventBus统一代码逻辑，做到代码复用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventBus</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Executor executor;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">ObserverRegistry</span> <span class="variable">registry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObserverRegistry</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">EventBus</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(MoreExecutors.directExecutor());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">EventBus</span><span class="params">(Executor executor)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.executor = executor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">    registry.register(object);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">post</span><span class="params">(Object event)</span> &#123;</span><br><span class="line">    List&lt;ObserverAction&gt; observerActions = registry.getMatchedObserverActions(event);</span><br><span class="line">    <span class="keyword">for</span> (ObserverAction observerAction : observerActions) &#123;</span><br><span class="line">      executor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">          observerAction.execute(event);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u>5.AsyncEventBus</u></p>
<p>有了EventBus，AsyncEventBus的实现就非常简单了。为了实现异步非阻塞的观察者模式，它就不能再继续使用MoreExecutors.directExecutor()了，而是需要在构造函数中，由调用者注入线程池。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncEventBus</span> <span class="keyword">extends</span> <span class="title class_">EventBus</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">AsyncEventBus</span><span class="params">(Executor executor)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(executor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们用了不到200行代码，就实现了一个还算凑活能用的EventBus，从功能上来讲，它跟Google Guava EventBus几乎一样。不过，如果去查看<a href="https://github.com/google/guava">Google Guava EventBus的源码</a>，你会发现，在实现细节方面，相比我们现在的实现，它其实做了很多优化，比如优化了在注册表中查找消息可匹配函数的算法。如果有时间的话，建议你去读一下它的源码。</p>
<h3 id="41-行为型：模板模式（1）"><a href="#41-行为型：模板模式（1）" class="headerlink" title="41. 行为型：模板模式（1）"></a>41. 行为型：模板模式（1）</h3><p>模板模式主要是用来解决复用和扩展两个问题。我们今天会结合Java Servlet、JUnit TestCase、Java InputStream、Java AbstractList四个例子来具体讲解这两个作用。</p>
<p><strong>模板模式的原理与实现</strong></p>
<p>模板模式，全称是模板方法设计模式，英文是Template Method Design Pattern。在GoF的《设计模式》一书中，它是这么定义的：</p>
<blockquote>
<p>Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure.</p>
</blockquote>
<p>翻译成中文就是：模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。</p>
<p>这里的“算法”，我们可以理解为广义上的“业务逻辑”，并不特指数据结构和算法中的“算法”。这里的算法骨架就是“模板”，包含算法骨架的方法就是“模板方法”，这也是模板方法模式名字的由来。</p>
<p>原理很简单，代码实现就更加简单，我写了一个示例代码，如下所示。templateMethod()函数定义为final，是为了避免子类重写它。method1()和method2()定义为abstract，是为了强迫子类去实现。不过，这些都不是必须的，在实际的项目开发中，模板模式的代码实现比较灵活，待会儿讲到应用场景的时候，我们会有具体的体现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">templateMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    method1();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    method2();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClass1</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClass2</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">AbstractClass</span> <span class="variable">demo</span> <span class="operator">=</span> ConcreteClass1();</span><br><span class="line">demo.templateMethod();</span><br></pre></td></tr></table></figure>

<p><strong>模板模式作用一：复用</strong></p>
<p>开篇的时候，我们讲到模板模式有两大作用：复用和扩展。我们先来看它的第一个作用：复用。</p>
<p>模板模式把一个算法中不变的流程抽象到父类的模板方法templateMethod()中，将可变的部分method1()、method2()留给子类ContreteClass1和ContreteClass2来实现。所有的子类都可以复用父类中模板方法定义的流程代码。我们通过两个小例子来更直观地体会一下。</p>
<p><u>1.Java InputStream</u></p>
<p>Java IO类库中，有很多类的设计用到了模板模式，比如InputStream、OutputStream、Reader、Writer。我们拿InputStream来举例说明一下。</p>
<p>我把InputStream部分相关代码贴在了下面。在代码中，read()函数是一个模板方法，定义了读取数据的整个流程，并且暴露了一个可以由子类来定制的抽象方法。不过这个方法也被命名为了read()，只是参数跟模板方法不同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InputStream</span> <span class="keyword">implements</span> <span class="title class_">Closeable</span> &#123;</span><br><span class="line">  <span class="comment">//...省略其他代码...</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span> b[], <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (off &lt; <span class="number">0</span> || len &lt; <span class="number">0</span> || len &gt; b.length - off) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> read();</span><br><span class="line">    <span class="keyword">if</span> (c == -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    b[off] = (<span class="type">byte</span>)c;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (; i &lt; len ; i++) &#123;</span><br><span class="line">        c = read();</span><br><span class="line">        <span class="keyword">if</span> (c == -<span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        b[off + i] = (<span class="type">byte</span>)c;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ee) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ByteArrayInputStream</span> <span class="keyword">extends</span> <span class="title class_">InputStream</span> &#123;</span><br><span class="line">  <span class="comment">//...省略其他代码...</span></span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (pos &lt; count) ? (buf[pos++] &amp; <span class="number">0xff</span>) : -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u>2.Java AbstractList</u></p>
<p>在Java AbstractList类中，addAll()函数可以看作模板方法，add()是子类需要重写的方法，尽管没有声明为abstract的，但函数实现直接抛出了UnsupportedOperationException异常。前提是，如果子类不重写是不能使用的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">modified</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (E e : c) &#123;</span><br><span class="line">        add(index++, e);</span><br><span class="line">        modified = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>模板模式作用二：扩展</strong></p>
<p>模板模式的第二大作用的是扩展。这里所说的扩展，并不是指代码的扩展性，而是指框架的扩展性，有点类似我们之前讲到的控制反转。基于这个作用，模板模式常用在框架的开发中，让框架用户可以在不修改框架源码的情况下，定制化框架的功能。我们通过Junit TestCase、Java Servlet两个例子来解释一下。</p>
<p><u>1.Java Servlet</u></p>
<p>对于Java Web项目开发来说，常用的开发框架是SpringMVC。利用它，我们只需要关注业务代码的编写，底层的原理几乎不会涉及。但是，如果我们抛开这些高级框架来开发Web项目，必然会用到Servlet。实际上，使用比较底层的Servlet来开发Web项目也不难。我们只需要定义一个继承HttpServlet的类，并且重写其中的doGet()或doPost()方法，来分别处理get和post请求。具体的代码示例如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="built_in">this</span>.doPost(req, resp);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    resp.getWriter().write(<span class="string">&quot;Hello World.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外，我们还需要在配置文件web.xml中做如下配置。Tomcat、Jetty等Servlet容器在启动的时候，会自动加载这个配置文件中的URL和Servlet之间的映射关系。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.xzg.cd.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当我们在浏览器中输入网址（比如，<a href="http://127.0.0.1:8080/hello">http://127.0.0.1:8080/hello</a> ）的时候，Servlet容器会接收到相应的请求，并且根据URL和Servlet之间的映射关系，找到相应的Servlet（HelloServlet），然后执行它的service()方法。service()方法定义在父类HttpServlet中，它会调用doGet()或doPost()方法，然后输出数据（“Hello world”）到网页。</p>
<p>我们现在来看，HttpServlet的service()函数长什么样子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req, ServletResponse res)</span></span><br><span class="line">    <span class="keyword">throws</span> ServletException, IOException</span><br><span class="line">&#123;</span><br><span class="line">    HttpServletRequest  request;</span><br><span class="line">    HttpServletResponse response;</span><br><span class="line">    <span class="keyword">if</span> (!(req <span class="keyword">instanceof</span> HttpServletRequest &amp;&amp;</span><br><span class="line">            res <span class="keyword">instanceof</span> HttpServletResponse)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(<span class="string">&quot;non-HTTP request or response&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    request = (HttpServletRequest) req;</span><br><span class="line">    response = (HttpServletResponse) res;</span><br><span class="line">    service(request, response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span><br><span class="line">    <span class="keyword">throws</span> ServletException, IOException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> req.getMethod();</span><br><span class="line">    <span class="keyword">if</span> (method.equals(METHOD_GET)) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> getLastModified(req);</span><br><span class="line">        <span class="keyword">if</span> (lastModified == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// servlet doesn&#x27;t support if-modified-since, no reason</span></span><br><span class="line">            <span class="comment">// to go through further expensive logic</span></span><br><span class="line">            doGet(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">ifModifiedSince</span> <span class="operator">=</span> req.getDateHeader(HEADER_IFMODSINCE);</span><br><span class="line">            <span class="keyword">if</span> (ifModifiedSince &lt; lastModified) &#123;</span><br><span class="line">                <span class="comment">// If the servlet mod time is later, call doGet()</span></span><br><span class="line">                <span class="comment">// Round down to the nearest second for a proper compare</span></span><br><span class="line">                <span class="comment">// A ifModifiedSince of -1 will always be less</span></span><br><span class="line">                maybeSetLastModified(resp, lastModified);</span><br><span class="line">                doGet(req, resp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_HEAD)) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> getLastModified(req);</span><br><span class="line">        maybeSetLastModified(resp, lastModified);</span><br><span class="line">        doHead(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_POST)) &#123;</span><br><span class="line">        doPost(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_PUT)) &#123;</span><br><span class="line">        doPut(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_DELETE)) &#123;</span><br><span class="line">        doDelete(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_OPTIONS)) &#123;</span><br><span class="line">        doOptions(req,resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_TRACE)) &#123;</span><br><span class="line">        doTrace(req,resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">errMsg</span> <span class="operator">=</span> lStrings.getString(<span class="string">&quot;http.method_not_implemented&quot;</span>);</span><br><span class="line">        Object[] errArgs = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">1</span>];</span><br><span class="line">        errArgs[<span class="number">0</span>] = method;</span><br><span class="line">        errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class="line">        resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中我们可以看出，HttpServlet的service()方法就是一个模板方法，它实现了整个HTTP请求的执行流程，doGet()、doPost()是模板中可以由子类来定制的部分。实际上，这就相当于Servlet框架提供了一个扩展点（doGet()、doPost()方法），让框架用户在不用修改Servlet框架源码的情况下，将业务代码通过扩展点镶嵌到框架中执行。</p>
<p><u>2.JUnit TestCase</u></p>
<p>跟Java Servlet类似，JUnit框架也通过模板模式提供了一些功能扩展点（setUp()、tearDown()等），让框架用户可以在这些扩展点上扩展功能。</p>
<p>在使用JUnit测试框架来编写单元测试的时候，我们编写的测试类都要继承框架提供的TestCase类。<u>在TestCase类中，runBare()函数是模板方法，它定义了执行测试用例的整体流程：先执行setUp()做些准备工作，然后执行runTest()运行真正的测试代码，最后执行tearDown()做扫尾工作</u>。</p>
<p>TestCase类的具体代码如下所示。尽管setUp()、tearDown()并不是抽象函数，还提供了默认的实现，不强制子类去重新实现，但这部分也是可以在子类中定制的，所以也符合模板模式的定义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">TestCase</span> <span class="keyword">extends</span> <span class="title class_">Assert</span> <span class="keyword">implements</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runBare</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">Throwable</span> <span class="variable">exception</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    setUp();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      runTest();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable running) &#123;</span><br><span class="line">      exception = running;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        tearDown();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable tearingDown) &#123;</span><br><span class="line">        <span class="keyword">if</span> (exception == <span class="literal">null</span>) exception = tearingDown;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (exception != <span class="literal">null</span>) <span class="keyword">throw</span> exception;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Sets up the fixture, for example, open a network connection.</span></span><br><span class="line"><span class="comment">  * This method is called before a test is executed.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Tears down the fixture, for example, close a network connection.</span></span><br><span class="line"><span class="comment">  * This method is called after a test is executed.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="42-行为型：模板模式（2）"><a href="#42-行为型：模板模式（2）" class="headerlink" title="42. 行为型：模板模式（2）"></a>42. 行为型：模板模式（2）</h3><p>复用和扩展是模板模式的两大作用，实际上，还有另外一个技术概念，也能起到跟模板模式相同的作用，那就是<strong>回调</strong>（Callback）。今天我们今天就来看一下，回调的原理、实现和应用，以及它跟模板模式的区别和联系。</p>
<p><strong>回调的原理解析</strong></p>
<p>相对于普通的函数调用来说，回调是一种双向调用关系。A类事先注册某个函数F到B类，A类在调用B类的P函数的时候，B类反过来调用A类注册给它的F函数。这里的F函数就是“回调函数”。A调用B，B反过来又调用A，这种调用机制就叫作“回调”。</p>
<p>A类如何将回调函数传递给B类呢？不同的编程语言，有不同的实现方法。C语言可以使用函数指针，Java则需要使用包裹了回调函数的类对象，我们简称为回调对象。这里我用Java语言举例说明一下。代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ICallback</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">methodToCallback</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BClass</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(ICallback callback)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    callback.methodToCallback();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AClass</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">BClass</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BClass</span>();</span><br><span class="line">    b.process(<span class="keyword">new</span> <span class="title class_">ICallback</span>() &#123; <span class="comment">//回调对象</span></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodToCallback</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Call back me.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面就是Java语言中回调的典型代码实现。从代码实现中，我们可以看出，回调跟模板模式一样，也具有复用和扩展的功能。除了回调函数之外，BClass类的process()函数中的逻辑都可以复用。如果ICallback、BClass类是框架代码，AClass是使用框架的客户端代码，我们可以通过ICallback定制process()函数，也就是说，框架因此具有了扩展的能力。</p>
<p>实际上，回调不仅可以应用在代码设计上，在更高层次的架构设计上也比较常用。比如，通过三方支付系统来实现支付功能，用户在发起支付请求之后，一般不会一直阻塞到支付结果返回，而是注册回调接口（类似回调函数，一般是一个回调用的URL）给三方支付系统，等三方支付系统执行完成之后，将结果通过回调接口返回给用户。</p>
<p>回调可以分为同步回调和异步回调（或者延迟回调）。同步回调指在函数返回之前执行回调函数；异步回调指的是在函数返回之后执行回调函数。上面的代码实际上是同步回调的实现方式，在process()函数返回之前，执行完回调函数methodToCallback()。而上面支付的例子是异步回调的实现方式，发起支付之后不需要等待回调接口被调用就直接返回。从应用场景上来看，同步回调看起来更像模板模式，异步回调看起来更像观察者模式。</p>
<p><strong>应用举例一：JdbcTemplate</strong></p>
<p>Spring提供了很多Template类，比如，JdbcTemplate、RedisTemplate、RestTemplate。尽管都叫作xxxTemplate，但它们并非基于模板模式来实现的，而是基于回调来实现的，确切地说应该是同步回调。而同步回调从应用场景上很像模板模式，所以，在命名上，这些类使用Template（模板）这个单词作为后缀。</p>
<p>这些Template类的设计思路都很相近，所以，我们只拿其中的JdbcTemplate来举例分析一下。对于其他Template类，你可以阅读源码自行分析。</p>
<p>在前面的章节中，我们也多次提到，Java提供了JDBC类库来封装不同类型的数据库操作。不过，直接使用JDBC来编写操作数据库的代码，还是有点复杂的。比如，下面这段是使用JDBC来查询用户信息的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcDemo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> User <span class="title function_">queryUser</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//1.加载驱动</span></span><br><span class="line">      Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">      conn = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/demo&quot;</span>, <span class="string">&quot;xzg&quot;</span>, <span class="string">&quot;xzg&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//2.创建statement类对象，用来执行SQL语句</span></span><br><span class="line">      stmt = conn.createStatement();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//3.ResultSet类，用来存放获取的结果集</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where id=&quot;</span> + id;</span><br><span class="line">      <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> stmt.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">      <span class="type">String</span> <span class="variable">eid</span> <span class="operator">=</span> <span class="literal">null</span>, ename = <span class="literal">null</span>, price = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setId(resultSet.getLong(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        user.setName(resultSet.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        user.setTelephone(resultSet.getString(<span class="string">&quot;telephone&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> log...</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> log...</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (conn != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          conn.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">          <span class="comment">// <span class="doctag">TODO:</span> log...</span></span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">if</span> (stmt != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          stmt.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">          <span class="comment">// <span class="doctag">TODO:</span> log...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>queryUser()函数包含很多流程性质的代码，跟业务无关，比如，加载驱动、创建数据库连接、创建statement、关闭连接、关闭statement、处理异常。针对不同的SQL执行请求，这些流程性质的代码是相同的、可以复用的，我们不需要每次都重新敲一遍。</p>
<p>针对这个问题，Spring提供了JdbcTemplate，对JDBC进一步封装，来简化数据库编程。使用JdbcTemplate查询用户信息，我们只需要编写跟这个业务有关的代码，其中包括，查询用户的SQL语句、查询结果与User对象之间的映射关系。其他流程性质的代码都封装在了JdbcTemplate类中，不需要我们每次都重新编写。我用JdbcTemplate重写了上面的例子，代码简单了很多，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcTemplateDemo</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> User <span class="title function_">queryUser</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where id=&quot;</span>+id;</span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.query(sql, <span class="keyword">new</span> <span class="title class_">UserRowMapper</span>()).get(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">UserRowMapper</span> <span class="keyword">implements</span> <span class="title class_">RowMapper</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">mapRow</span><span class="params">(ResultSet rs, <span class="type">int</span> rowNum)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">      <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">      user.setId(rs.getLong(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">      user.setName(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">      user.setTelephone(rs.getString(<span class="string">&quot;telephone&quot;</span>));</span><br><span class="line">      <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那JdbcTemplate底层具体是如何实现的呢？我们来看一下它的源码。因为JdbcTemplate代码比较多，我只摘抄了部分相关代码，贴到了下面。其中，JdbcTemplate通过回调的机制，将不变的执行流程抽离出来，放到模板方法execute()中，将可变的部分设计成回调StatementCallback，由用户来定制。query()函数是对execute()函数的二次封装，让接口用起来更加方便。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">query</span><span class="params">(String sql, RowMapper&lt;T&gt; rowMapper)</span> <span class="keyword">throws</span> DataAccessException &#123;</span><br><span class="line"> <span class="keyword">return</span> query(sql, <span class="keyword">new</span> <span class="title class_">RowMapperResultSetExtractor</span>&lt;T&gt;(rowMapper));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">query</span><span class="params">(<span class="keyword">final</span> String sql, <span class="keyword">final</span> ResultSetExtractor&lt;T&gt; rse)</span> <span class="keyword">throws</span> DataAccessException &#123;</span><br><span class="line"> Assert.notNull(sql, <span class="string">&quot;SQL must not be null&quot;</span>);</span><br><span class="line"> Assert.notNull(rse, <span class="string">&quot;ResultSetExtractor must not be null&quot;</span>);</span><br><span class="line"> <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">  logger.debug(<span class="string">&quot;Executing SQL query [&quot;</span> + sql + <span class="string">&quot;]&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">QueryStatementCallback</span> <span class="keyword">implements</span> <span class="title class_">StatementCallback</span>&lt;T&gt;, SqlProvider &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> T <span class="title function_">doInStatement</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">   <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">    rs = stmt.executeQuery(sql);</span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">rsToUse</span> <span class="operator">=</span> rs;</span><br><span class="line">    <span class="keyword">if</span> (nativeJdbcExtractor != <span class="literal">null</span>) &#123;</span><br><span class="line">     rsToUse = nativeJdbcExtractor.getNativeResultSet(rs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rse.extractData(rsToUse);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">    JdbcUtils.closeResultSet(rs);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getSql</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> sql;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> execute(<span class="keyword">new</span> <span class="title class_">QueryStatementCallback</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">execute</span><span class="params">(StatementCallback&lt;T&gt; action)</span> <span class="keyword">throws</span> DataAccessException &#123;</span><br><span class="line"> Assert.notNull(action, <span class="string">&quot;Callback object must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line"> <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> DataSourceUtils.getConnection(getDataSource());</span><br><span class="line"> <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="type">Connection</span> <span class="variable">conToUse</span> <span class="operator">=</span> con;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.nativeJdbcExtractor != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">    <span class="built_in">this</span>.nativeJdbcExtractor.isNativeConnectionNecessaryForNativeStatements()) &#123;</span><br><span class="line">   conToUse = <span class="built_in">this</span>.nativeJdbcExtractor.getNativeConnection(con);</span><br><span class="line">  &#125;</span><br><span class="line">  stmt = conToUse.createStatement();</span><br><span class="line">  applyStatementSettings(stmt);</span><br><span class="line">  <span class="type">Statement</span> <span class="variable">stmtToUse</span> <span class="operator">=</span> stmt;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.nativeJdbcExtractor != <span class="literal">null</span>) &#123;</span><br><span class="line">   stmtToUse = <span class="built_in">this</span>.nativeJdbcExtractor.getNativeStatement(stmt);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> action.doInStatement(stmtToUse);</span><br><span class="line">  handleWarnings(stmt);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">  <span class="comment">// Release Connection early, to avoid potential connection pool deadlock</span></span><br><span class="line">  <span class="comment">// in the case when the exception translator hasn&#x27;t been initialized yet.</span></span><br><span class="line">  JdbcUtils.closeStatement(stmt);</span><br><span class="line">  stmt = <span class="literal">null</span>;</span><br><span class="line">  DataSourceUtils.releaseConnection(con, getDataSource());</span><br><span class="line">  con = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">throw</span> getExceptionTranslator().translate(<span class="string">&quot;StatementCallback&quot;</span>, getSql(action), ex);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">finally</span> &#123;</span><br><span class="line">  JdbcUtils.closeStatement(stmt);</span><br><span class="line">  DataSourceUtils.releaseConnection(con, getDataSource());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>应用举例二：setClickListener(）</strong></p>
<p>在客户端开发中，我们经常给控件注册事件监听器，比如下面这段代码，就是在Android应用开发中，给Button控件的点击事件注册监听器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Button</span> <span class="variable">button</span> <span class="operator">=</span> (Button)findViewById(R.id.button);</span><br><span class="line">button.setOnClickListener(<span class="keyword">new</span> <span class="title class_">OnClickListener</span>() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;I am clicked.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>从代码结构上来看，事件监听器很像回调，即传递一个包含回调函数（onClick()）的对象给另一个函数。从应用场景上来看，它又很像观察者模式，即事先注册观察者（OnClickListener），当用户点击按钮的时候，发送点击事件给观察者，并且执行相应的onClick()函数。</p>
<p>我们前面讲到，回调分为同步回调和异步回调。这里的回调算是异步回调，我们往setOnClickListener()函数中注册好回调函数之后，并不需要等待回调函数执行。这也印证了我们前面讲的，异步回调比较像观察者模式。</p>
<p><strong>应用举例三：addShutdownHook()</strong></p>
<p>Hook可以翻译成“钩子”，那它跟Callback有什么区别呢？</p>
<p>网上有人认为Hook就是Callback，两者说的是一回事儿，只是表达不同而已。而有人觉得Hook是Callback的一种应用。Callback更侧重语法机制的描述，Hook更加侧重应用场景的描述。我个人比较认可后面一种说法。不过，这个也不重要，我们只需要见了代码能认识，遇到场景会用就可以了。</p>
<p>Hook比较经典的应用场景是Tomcat和JVM的shutdown hook。接下来，我们拿JVM来举例说明一下。JVM提供了Runtime.addShutdownHook(Thread hook)方法，可以注册一个JVM关闭的Hook。当应用程序关闭的时候，JVM会自动调用Hook代码。代码示例如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShutdownHookDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ShutdownHook</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;I am called during shutting down.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="title class_">ShutdownHook</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再来看addShutdownHook()的代码实现，如下所示。这里我只给出了部分相关代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Runtime</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addShutdownHook</span><span class="params">(Thread hook)</span> &#123;</span><br><span class="line">    <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">      sm.checkPermission(<span class="keyword">new</span> <span class="title class_">RuntimePermission</span>(<span class="string">&quot;shutdownHooks&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    ApplicationShutdownHooks.add(hook);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ApplicationShutdownHooks</span> &#123;</span><br><span class="line">    <span class="comment">/* The set of registered hooks */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> IdentityHashMap&lt;Thread, Thread&gt; hooks;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">            hooks = <span class="keyword">new</span> <span class="title class_">IdentityHashMap</span>&lt;&gt;();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">            hooks = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Thread hook)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(hooks == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Shutdown in progress&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hook.isAlive())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Hook already running&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hooks.containsKey(hook))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Hook previously registered&quot;</span>);</span><br><span class="line"></span><br><span class="line">        hooks.put(hook, hook);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">runHooks</span><span class="params">()</span> &#123;</span><br><span class="line">        Collection&lt;Thread&gt; threads;</span><br><span class="line">        <span class="keyword">synchronized</span>(ApplicationShutdownHooks.class) &#123;</span><br><span class="line">            threads = hooks.keySet();</span><br><span class="line">            hooks = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread hook : threads) &#123;</span><br><span class="line">            hook.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread hook : threads) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    hook.join();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中我们可以发现，有关Hook的逻辑都被封装到ApplicationShutdownHooks类中了。当应用程序关闭的时候，JVM会调用这个类的runHooks()方法，创建多个线程，并发地执行多个Hook。我们在注册完Hook之后，并不需要等待Hook执行完成，所以，这也算是一种异步回调。</p>
<p><strong>模板模式 VS 回调</strong></p>
<p>回调的原理、实现和应用到此就都讲完了。接下来，我们从应用场景和代码实现两个角度，来对比一下模板模式和回调。</p>
<p>从应用场景上来看，同步回调跟模板模式几乎一致。它们都是在一个大的算法骨架中，自由替换其中的某个步骤，起到代码复用和扩展的目的。而异步回调跟模板模式有较大差别，更像是观察者模式。</p>
<p>从代码实现上来看，回调和模板模式完全不同。回调基于组合关系来实现，把一个对象传递给另一个对象，是一种对象之间的关系；模板模式基于继承关系来实现，子类重写父类的抽象方法，是一种类之间的关系。</p>
<p>前面我们也讲到，组合优于继承。实际上，这里也不例外。在代码实现上，回调相对于模板模式会更加灵活，主要体现在下面几点。</p>
<ul>
<li>像Java这种只支持单继承的语言，基于模板模式编写的子类，已经继承了一个父类，不再具有继承的能力。</li>
<li>回调可以使用匿名类来创建回调对象，可以不用事先定义类；而模板模式针对不同的实现都要定义不同的子类。</li>
<li>如果某个类中定义了多个模板方法，每个方法都有对应的抽象方法，那即便我们只用到其中的一个模板方法，子类也必须实现所有的抽象方法。而回调就更加灵活，我们只需要往用到的模板方法中注入回调对象即可。</li>
</ul>
<h3 id="43-行为型：策略模式（1）"><a href="#43-行为型：策略模式（1）" class="headerlink" title="43. 行为型：策略模式（1）"></a>43. 行为型：策略模式（1）</h3><p><strong>策略模式的原理与实现</strong></p>
<p>策略模式，英文全称是Strategy Design Pattern。在GoF的《设计模式》一书中，它是这样定义的：</p>
<blockquote>
<p>Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.</p>
</blockquote>
<p>翻译成中文就是：定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）。</p>
<p>我们知道，工厂模式是解耦对象的创建和使用，观察者模式是解耦观察者和被观察者。策略模式跟两者类似，也能起到解耦的作用，不过，它<u>解耦的是策略的定义、创建、使用这三部分</u>。接下来，我就详细讲讲一个完整的策略模式应该包含的这三个部分。</p>
<p><u>1.策略的定义</u></p>
<p>策略类的定义比较简单，包含一个策略接口和一组实现这个接口的策略类。因为所有的策略类都实现相同的接口，所以，客户端代码基于接口而非实现编程，可以灵活地替换不同的策略。示例代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">algorithmInterface</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteStrategyA</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">algorithmInterface</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//具体的算法...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteStrategyB</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">algorithmInterface</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//具体的算法...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u>2.策略的创建</u></p>
<p>因为策略模式会包含一组策略，在使用它们的时候，一般会通过类型（type）来判断创建哪个策略来使用。为了封装创建逻辑，我们需要对客户端代码屏蔽创建细节。我们可以把根据type创建策略的逻辑抽离出来，放到工厂类中。示例代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyFactory</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Strategy&gt; strategies = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    strategies.put(<span class="string">&quot;A&quot;</span>, <span class="keyword">new</span> <span class="title class_">ConcreteStrategyA</span>());</span><br><span class="line">    strategies.put(<span class="string">&quot;B&quot;</span>, <span class="keyword">new</span> <span class="title class_">ConcreteStrategyB</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Strategy <span class="title function_">getStrategy</span><span class="params">(String type)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="literal">null</span> || type.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;type should not be empty.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strategies.get(type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般来讲，如果策略类是无状态的，不包含成员变量，只是纯粹的算法实现，这样的策略对象是可以被共享使用的，不需要在每次调用getStrategy()的时候，都创建一个新的策略对象。针对这种情况，我们可以使用上面这种工厂类的实现方式，事先创建好每个策略对象，缓存到工厂类中，用的时候直接返回。</p>
<p>相反，如果策略类是有状态的，根据业务场景的需要，我们希望每次从工厂方法中，获得的都是新创建的策略对象，而不是缓存好可共享的策略对象，那我们就需要按照如下方式来实现策略工厂类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyFactory</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Strategy <span class="title function_">getStrategy</span><span class="params">(String type)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="literal">null</span> || type.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;type should not be empty.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type.equals(<span class="string">&quot;A&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteStrategyA</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">&quot;B&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteStrategyB</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u>3.策略的使用</u></p>
<p>刚刚讲了策略的定义和创建，现在，我们再来看一下，策略的使用。</p>
<p>我们知道，策略模式包含一组可选策略，客户端代码一般如何确定使用哪个策略呢？最常见的是运行时动态确定使用哪种策略，这也是策略模式最典型的应用场景。</p>
<p>这里的“运行时动态”指的是，我们事先并不知道会使用哪个策略，而是在程序运行期间，根据配置、用户输入、计算结果等这些不确定因素，动态决定使用哪种策略。接下来，我们通过一个例子来解释一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 策略接口：EvictionStrategy</span></span><br><span class="line"><span class="comment">// 策略类：LruEvictionStrategy、FifoEvictionStrategy、LfuEvictionStrategy...</span></span><br><span class="line"><span class="comment">// 策略工厂：EvictionStrategyFactory</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserCache</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Map&lt;String, User&gt; cacheData = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> EvictionStrategy eviction;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">UserCache</span><span class="params">(EvictionStrategy eviction)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.eviction = eviction;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行时动态确定，根据配置文件的配置决定使用哪种策略</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">EvictionStrategy</span> <span class="variable">evictionStrategy</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    props.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;./config.properties&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> props.getProperty(<span class="string">&quot;eviction_type&quot;</span>);</span><br><span class="line">    evictionStrategy = EvictionStrategyFactory.getEvictionStrategy(type);</span><br><span class="line">    <span class="type">UserCache</span> <span class="variable">userCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserCache</span>(evictionStrategy);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非运行时动态确定，在代码中指定使用哪种策略</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="type">EvictionStrategy</span> <span class="variable">evictionStrategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LruEvictionStrategy</span>();</span><br><span class="line">    <span class="type">UserCache</span> <span class="variable">userCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserCache</span>(evictionStrategy);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中，我们也可以看出，“非运行时动态确定”，也就是第二个Application中的使用方式，并不能发挥策略模式的优势。在这种应用场景下，策略模式实际上退化成了“面向对象的多态特性”或“基于接口而非实现编程原则”。</p>
<p><strong>如何利用策略模式避免分支判断？</strong></p>
<p>实际上，能够移除分支判断逻辑的模式不仅仅有策略模式，后面我们要讲的状态模式也可以。对于使用哪种模式，具体还要看应用场景来定。 策略模式适用于根据不同类型的动态，决定使用哪种策略这样一种应用场景。</p>
<p>我们先通过一个例子来看下，if-else或switch-case分支判断逻辑是如何产生的。具体的代码如下所示。在这个例子中，我们没有使用策略模式，而是将策略的定义、创建、使用直接耦合在一起。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">discount</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">discount</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">OrderType</span> <span class="variable">type</span> <span class="operator">=</span> order.getType();</span><br><span class="line">    <span class="keyword">if</span> (type.equals(OrderType.NORMAL)) &#123; <span class="comment">// 普通订单</span></span><br><span class="line">      <span class="comment">//...省略折扣计算算法代码</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(OrderType.GROUPON)) &#123; <span class="comment">// 团购订单</span></span><br><span class="line">      <span class="comment">//...省略折扣计算算法代码</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(OrderType.PROMOTION)) &#123; <span class="comment">// 促销订单</span></span><br><span class="line">      <span class="comment">//...省略折扣计算算法代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> discount;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何来移除掉分支判断逻辑呢？那策略模式就派上用场了。我们使用策略模式对上面的代码重构，将不同类型订单的打折策略设计成策略类，并由工厂类来负责创建策略对象。具体的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 策略的定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DiscountStrategy</span> &#123;</span><br><span class="line">  <span class="type">double</span> <span class="title function_">calDiscount</span><span class="params">(Order order)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 省略NormalDiscountStrategy、GrouponDiscountStrategy、PromotionDiscountStrategy类代码...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 策略的创建</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiscountStrategyFactory</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;OrderType, DiscountStrategy&gt; strategies = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    strategies.put(OrderType.NORMAL, <span class="keyword">new</span> <span class="title class_">NormalDiscountStrategy</span>());</span><br><span class="line">    strategies.put(OrderType.GROUPON, <span class="keyword">new</span> <span class="title class_">GrouponDiscountStrategy</span>());</span><br><span class="line">    strategies.put(OrderType.PROMOTION, <span class="keyword">new</span> <span class="title class_">PromotionDiscountStrategy</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> DiscountStrategy <span class="title function_">getDiscountStrategy</span><span class="params">(OrderType type)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> strategies.get(type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 策略的使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">discount</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">    <span class="type">OrderType</span> <span class="variable">type</span> <span class="operator">=</span> order.getType();</span><br><span class="line">    <span class="type">DiscountStrategy</span> <span class="variable">discountStrategy</span> <span class="operator">=</span> DiscountStrategyFactory.getDiscountStrategy(type);</span><br><span class="line">    <span class="keyword">return</span> discountStrategy.calDiscount(order);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重构之后的代码就没有了if-else分支判断语句了。实际上，这得益于策略工厂类。在工厂类中，我们用Map来缓存策略，根据type直接从Map中获取对应的策略，从而避免if-else分支判断逻辑。等后面讲到使用状态模式来避免分支判断逻辑的时候，你会发现，它们使用的是同样的套路。本质上都是借助“查表法”，根据type查表（代码中的strategies就是表）替代根据type分支判断。</p>
<p>但是，如果业务场景需要每次都创建不同的策略对象，我们就要用另外一种工厂类的实现方式了。具体的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiscountStrategyFactory</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> DiscountStrategy <span class="title function_">getDiscountStrategy</span><span class="params">(OrderType type)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Type should not be null.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type.equals(OrderType.NORMAL)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NormalDiscountStrategy</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(OrderType.GROUPON)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GrouponDiscountStrategy</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(OrderType.PROMOTION)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PromotionDiscountStrategy</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种实现方式相当于把原来的if-else分支逻辑，从OrderService类中转移到了工厂类中，实际上并没有真正将它移除。关于这个问题如何解决，我今天先暂时卖个关子。你可以在留言区说说你的想法，我在下一节课中再讲解。</p>
<h3 id="44-行为型：策略模式（2）"><a href="#44-行为型：策略模式（2）" class="headerlink" title="44. 行为型：策略模式（2）"></a>44. 行为型：策略模式（2）</h3><p><strong>问题与解决思路</strong></p>
<p>假设有这样一个需求，希望写一个小程序，实现对一个文件进行排序的功能。文件中只包含整型数，并且，相邻的数字通过逗号来区隔。如果由你来编写这样一个小程序，你会如何来实现呢？你可以把它当作面试题，先自己思考一下，再来看我下面的讲解。</p>
<p>你可能会说，这不是很简单嘛，只需要将文件中的内容读取出来，并且通过逗号分割成一个一个的数字，放到内存数组中，然后编写某种排序算法（比如快排），或者直接使用编程语言提供的排序函数，对数组进行排序，最后再将数组中的数据写入文件就可以了。</p>
<p>但是，如果文件很大呢？比如有10GB大小，因为内存有限（比如只有8GB大小），我们没办法一次性加载文件中的所有数据到内存中，这个时候，我们就要利用外部排序算法（具体怎么做，可以参看我的另一个专栏《数据结构与算法之美》中的“排序”相关章节）了。</p>
<p>如果文件更大，比如有100GB大小，我们为了利用CPU多核的优势，可以在外部排序的基础之上进行优化，加入多线程并发排序的功能，这就有点类似“单机版”的MapReduce。</p>
<p>如果文件非常大，比如有1TB大小，即便是单机多线程排序，这也算很慢了。这个时候，我们可以使用真正的MapReduce框架，利用多机的处理能力，提高排序的效率。</p>
<p><strong>代码实现与分析</strong></p>
<p>解决思路讲完了，不难理解。接下来，我们看一下，如何将解决思路翻译成代码实现。</p>
<p>我先用最简单直接的方式将它实现出来。具体代码我贴在下面了，你可以先看一下。因为我们是在讲设计模式，不是讲算法，所以，在下面的代码实现中，我只给出了跟设计模式相关的骨架代码，并没有给出每种排序算法的具体代码实现。感兴趣的话，你可以自行实现一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sorter</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">GB</span> <span class="operator">=</span> <span class="number">1000</span> * <span class="number">1000</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortFile</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">    <span class="comment">// 省略校验逻辑</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filePath);</span><br><span class="line">    <span class="type">long</span> <span class="variable">fileSize</span> <span class="operator">=</span> file.length();</span><br><span class="line">    <span class="keyword">if</span> (fileSize &lt; <span class="number">6</span> * GB) &#123; <span class="comment">// [0, 6GB)</span></span><br><span class="line">      quickSort(filePath);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fileSize &lt; <span class="number">10</span> * GB) &#123; <span class="comment">// [6GB, 10GB)</span></span><br><span class="line">      externalSort(filePath);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fileSize &lt; <span class="number">100</span> * GB) &#123; <span class="comment">// [10GB, 100GB)</span></span><br><span class="line">      concurrentExternalSort(filePath);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// [100GB, ~)</span></span><br><span class="line">      mapreduceSort(filePath);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">    <span class="comment">// 快速排序</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">externalSort</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">    <span class="comment">// 外部排序</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">concurrentExternalSort</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">    <span class="comment">// 多线程外部排序</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mapreduceSort</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">    <span class="comment">// 利用MapReduce多机排序</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortingTool</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Sorter</span> <span class="variable">sorter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sorter</span>();</span><br><span class="line">    sorter.sortFile(args[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在“编码规范”那一部分我们讲过，函数的行数不能过多，最好不要超过一屏的大小。所以，为了避免sortFile()函数过长，我们把每种排序算法从sortFile()函数中抽离出来，拆分成4个独立的排序函数。</p>
<p>如果只是开发一个简单的工具，那上面的代码实现就足够了。毕竟，代码不多，后续修改、扩展的需求也不多，怎么写都不会导致代码不可维护。但是，如果我们是在开发一个大型项目，排序文件只是其中的一个功能模块，那我们就要在代码设计、代码质量上下点儿功夫了。只有每个小的功能模块都写好，整个项目的代码才能不差。</p>
<p>在刚刚的代码中，我们并没有给出每种排序算法的代码实现。实际上，如果自己实现一下的话，你会发现，每种排序算法的实现逻辑都比较复杂，代码行数都比较多。所有排序算法的代码实现都堆在Sorter一个类中，这就会导致这个类的代码很多。而在“编码规范”那一部分中，我们也讲到，一个类的代码太多也会影响到可读性、可维护性。除此之外，所有的排序算法都设计成Sorter的私有函数，也会影响代码的可复用性。</p>
<p><strong>代码优化与重构</strong></p>
<p>只要掌握了我们之前讲过的设计原则和思想，针对上面的问题，即便我们想不到该用什么设计模式来重构，也应该能知道该如何解决，那就是将Sorter类中的某些代码拆分出来，独立成职责更加单一的小类。实际上，拆分是应对类或者函数代码过多、应对代码复杂性的一个常用手段。按照这个解决思路，我们对代码进行重构。重构之后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ISortAlg</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(String filePath)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> <span class="keyword">implements</span> <span class="title class_">ISortAlg</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExternalSort</span> <span class="keyword">implements</span> <span class="title class_">ISortAlg</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentExternalSort</span> <span class="keyword">implements</span> <span class="title class_">ISortAlg</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapReduceSort</span> <span class="keyword">implements</span> <span class="title class_">ISortAlg</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sorter</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">GB</span> <span class="operator">=</span> <span class="number">1000</span> * <span class="number">1000</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortFile</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">    <span class="comment">// 省略校验逻辑</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filePath);</span><br><span class="line">    <span class="type">long</span> <span class="variable">fileSize</span> <span class="operator">=</span> file.length();</span><br><span class="line">    ISortAlg sortAlg;</span><br><span class="line">    <span class="keyword">if</span> (fileSize &lt; <span class="number">6</span> * GB) &#123; <span class="comment">// [0, 6GB)</span></span><br><span class="line">      sortAlg = <span class="keyword">new</span> <span class="title class_">QuickSort</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fileSize &lt; <span class="number">10</span> * GB) &#123; <span class="comment">// [6GB, 10GB)</span></span><br><span class="line">      sortAlg = <span class="keyword">new</span> <span class="title class_">ExternalSort</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fileSize &lt; <span class="number">100</span> * GB) &#123; <span class="comment">// [10GB, 100GB)</span></span><br><span class="line">      sortAlg = <span class="keyword">new</span> <span class="title class_">ConcurrentExternalSort</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// [100GB, ~)</span></span><br><span class="line">      sortAlg = <span class="keyword">new</span> <span class="title class_">MapReduceSort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    sortAlg.sort(filePath);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过拆分之后，每个类的代码都不会太多，每个类的逻辑都不会太复杂，代码的可读性、可维护性提高了。除此之外，我们将排序算法设计成独立的类，跟具体的业务逻辑（代码中的if-else那部分逻辑）解耦，也让排序算法能够复用。这一步实际上就是策略模式的第一步，也就是将策略的定义分离出来。</p>
<p>实际上，上面的代码还可以继续优化。<u>每种排序类都是无状态的，我们没必要在每次使用的时候，都重新创建一个新的对象。所以，我们可以使用工厂模式对对象的创建进行封装</u>。按照这个思路，我们对代码进行重构。重构之后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortAlgFactory</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, ISortAlg&gt; algs = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    algs.put(<span class="string">&quot;QuickSort&quot;</span>, <span class="keyword">new</span> <span class="title class_">QuickSort</span>());</span><br><span class="line">    algs.put(<span class="string">&quot;ExternalSort&quot;</span>, <span class="keyword">new</span> <span class="title class_">ExternalSort</span>());</span><br><span class="line">    algs.put(<span class="string">&quot;ConcurrentExternalSort&quot;</span>, <span class="keyword">new</span> <span class="title class_">ConcurrentExternalSort</span>());</span><br><span class="line">    algs.put(<span class="string">&quot;MapReduceSort&quot;</span>, <span class="keyword">new</span> <span class="title class_">MapReduceSort</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> ISortAlg <span class="title function_">getSortAlg</span><span class="params">(String type)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="literal">null</span> || type.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;type should not be empty.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> algs.get(type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sorter</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">GB</span> <span class="operator">=</span> <span class="number">1000</span> * <span class="number">1000</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortFile</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">    <span class="comment">// 省略校验逻辑</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filePath);</span><br><span class="line">    <span class="type">long</span> <span class="variable">fileSize</span> <span class="operator">=</span> file.length();</span><br><span class="line">    ISortAlg sortAlg;</span><br><span class="line">    <span class="keyword">if</span> (fileSize &lt; <span class="number">6</span> * GB) &#123; <span class="comment">// [0, 6GB)</span></span><br><span class="line">      sortAlg = SortAlgFactory.getSortAlg(<span class="string">&quot;QuickSort&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fileSize &lt; <span class="number">10</span> * GB) &#123; <span class="comment">// [6GB, 10GB)</span></span><br><span class="line">      sortAlg = SortAlgFactory.getSortAlg(<span class="string">&quot;ExternalSort&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fileSize &lt; <span class="number">100</span> * GB) &#123; <span class="comment">// [10GB, 100GB)</span></span><br><span class="line">      sortAlg = SortAlgFactory.getSortAlg(<span class="string">&quot;ConcurrentExternalSort&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// [100GB, ~)</span></span><br><span class="line">      sortAlg = SortAlgFactory.getSortAlg(<span class="string">&quot;MapReduceSort&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sortAlg.sort(filePath);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过上面两次重构之后，现在的代码实际上已经符合策略模式的代码结构了。我们通过策略模式将策略的定义、创建、使用解耦，让每一部分都不至于太复杂。不过，Sorter类中的sortFile()函数还是有一堆if-else逻辑。这里的if-else逻辑分支不多、也不复杂，这样写完全没问题。但如果你特别想将if-else分支判断移除掉，那也是有办法的。我直接给出代码，你一看就能明白。实际上，这也是基于查表法来解决的，其中的“algs”就是“表”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sorter</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">GB</span> <span class="operator">=</span> <span class="number">1000</span> * <span class="number">1000</span> * <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;AlgRange&gt; algs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    algs.add(<span class="keyword">new</span> <span class="title class_">AlgRange</span>(<span class="number">0</span>, <span class="number">6</span>*GB, SortAlgFactory.getSortAlg(<span class="string">&quot;QuickSort&quot;</span>)));</span><br><span class="line">    algs.add(<span class="keyword">new</span> <span class="title class_">AlgRange</span>(<span class="number">6</span>*GB, <span class="number">10</span>*GB, SortAlgFactory.getSortAlg(<span class="string">&quot;ExternalSort&quot;</span>)));</span><br><span class="line">    algs.add(<span class="keyword">new</span> <span class="title class_">AlgRange</span>(<span class="number">10</span>*GB, <span class="number">100</span>*GB, SortAlgFactory.getSortAlg(<span class="string">&quot;ConcurrentExternalSort&quot;</span>)));</span><br><span class="line">    algs.add(<span class="keyword">new</span> <span class="title class_">AlgRange</span>(<span class="number">100</span>*GB, Long.MAX_VALUE, SortAlgFactory.getSortAlg(<span class="string">&quot;MapReduceSort&quot;</span>)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortFile</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">    <span class="comment">// 省略校验逻辑</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filePath);</span><br><span class="line">    <span class="type">long</span> <span class="variable">fileSize</span> <span class="operator">=</span> file.length();</span><br><span class="line">    <span class="type">ISortAlg</span> <span class="variable">sortAlg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (AlgRange algRange : algs) &#123;</span><br><span class="line">      <span class="keyword">if</span> (algRange.inRange(fileSize)) &#123;</span><br><span class="line">        sortAlg = algRange.getAlg();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sortAlg.sort(filePath);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AlgRange</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> end;</span><br><span class="line">    <span class="keyword">private</span> ISortAlg alg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AlgRange</span><span class="params">(<span class="type">long</span> start, <span class="type">long</span> end, ISortAlg alg)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.start = start;</span><br><span class="line">      <span class="built_in">this</span>.end = end;</span><br><span class="line">      <span class="built_in">this</span>.alg = alg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ISortAlg <span class="title function_">getAlg</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> alg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">inRange</span><span class="params">(<span class="type">long</span> size)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> size &gt;= start &amp;&amp; size &lt; end;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在的代码实现就更加优美了。我们把可变的部分隔离到了策略工厂类和Sorter类中的静态代码段中。当要添加一个新的排序算法时，我们只需要修改策略工厂类和Sort类中的静态代码段，其他代码都不需要修改，这样就将代码改动最小化、集中化了。</p>
<p>你可能会说，即便这样，当我们添加新的排序算法的时候，还是需要修改代码，并不完全符合开闭原则。有什么办法让我们完全满足开闭原则呢？</p>
<p>对于Java语言来说，我们可以通过反射来避免对策略工厂类的修改。具体是这么做的：我们通过一个配置文件或者自定义的annotation来标注都有哪些策略类；策略工厂类读取配置文件或者搜索被annotation标注的策略类，然后通过反射动态地加载这些策略类、创建策略对象；当我们新添加一个策略的时候，只需要将这个新添加的策略类添加到配置文件或者用annotation标注即可。还记得上一节课的课堂讨论题吗？我们也可以用这种方法来解决。</p>
<p>对于Sorter来说，我们可以通过同样的方法来避免修改。我们通过将文件大小区间和算法之间的对应关系放到配置文件中。当添加新的排序算法时，我们只需要改动配置文件即可，不需要改动代码。</p>
<h3 id="99-总结"><a href="#99-总结" class="headerlink" title="99. 总结"></a>99. 总结</h3><img src="https://static001.geekbang.org/resource/image/bd/0a/bdc5e66fe65d4801ebe32e96c813e20a.png" alt="img" style="zoom:33%;" />

<p><strong>一、创建型设计模式</strong></p>
<p>创建型设计模式包括：单例模式、工厂模式、建造者模式、原型模式。它主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。</p>
<p><u>1.单例模式</u></p>
<p>单例模式用来创建全局唯一的对象。一个类只允许创建一个对象（或者叫实例），那这个类就是一个单例类，这种设计模式就叫作单例模式。单例有几种经典的实现方式，它们分别是：饿汉式、懒汉式、双重检测、静态内部类、枚举。</p>
<p>尽管单例是一个很常用的设计模式，在实际的开发中，我们也确实经常用到它，但是，有些人认为单例是一种反模式（anti-pattern），并不推荐使用，主要的理由有以下几点：</p>
<ul>
<li>单例对OOP特性的支持不友好</li>
<li>单例会隐藏类之间的依赖关系</li>
<li>单例对代码的扩展性不友好</li>
<li>单例对代码的可测试性不友好</li>
<li>单例不支持有参数的构造函数</li>
</ul>
<p>那有什么替代单例的解决方案呢？如果要完全解决这些问题，我们可能要从根上寻找其他方式来实现全局唯一类。比如，通过工厂模式、IOC容器来保证全局唯一性。</p>
<p>有人把单例当作反模式，主张杜绝在项目中使用。我个人觉得这有点极端。模式本身没有对错，关键看你怎么用。如果单例类并没有后续扩展的需求，并且不依赖外部系统，那设计成单例类就没有太大问题。对于一些全局类，我们在其他地方new的话，还要在类之间传来传去，不如直接做成单例类，使用起来简洁方便。</p>
<p>除此之外，我们还讲到了进程唯一单例、线程唯一单例、集群唯一单例、多例等扩展知识点，这一部分在实际的开发中并不会被用到，但是可以扩展你的思路、锻炼你的逻辑思维。这里我就不带你回顾了，你可以自己回忆一下。</p>
<p><u>2.工厂模式</u></p>
<p>工厂模式包括简单工厂、工厂方法、抽象工厂这3种细分模式。其中，简单工厂和工厂方法比较常用，抽象工厂的应用场景比较特殊，所以很少用到，不是我们学习的重点。</p>
<p>工厂模式用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。实际上，如果创建对象的逻辑并不复杂，那我们直接通过new来创建对象就可以了，不需要使用工厂模式。当创建逻辑比较复杂，是一个“大工程”的时候，我们就考虑使用工厂模式，封装对象的创建过程，将对象的创建和使用相分离。</p>
<p>当每个对象的创建逻辑都比较简单的时候，我推荐使用简单工厂模式，将多个对象的创建逻辑放到一个工厂类中。当每个对象的创建逻辑都比较复杂的时候，为了避免设计一个过于庞大的工厂类，我们推荐使用工厂方法模式，将创建逻辑拆分得更细，每个对象的创建逻辑独立到各自的工厂类中。</p>
<p>详细点说，工厂模式的作用有下面4个，这也是判断要不要使用工厂模式最本质的参考标准。</p>
<ul>
<li>封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明。</li>
<li>代码复用：创建代码抽离到独立的工厂类之后可以复用。</li>
<li>隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象。</li>
<li>控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁。</li>
</ul>
<p>除此之外，我们还讲了工厂模式一个非常经典的应用场景：依赖注入框架，比如Spring IOC、Google Guice，它用来集中创建、组装、管理对象，跟具体业务代码解耦，让程序员聚焦在业务代码的开发上。DI框架已经成为了我们平时开发的必备框架，在专栏中，我还带你实现了一个简单的DI框架，你可以再回过头去看看。</p>
<p><u>3.建造者模式</u></p>
<p>建造者模式用来创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。建造者模式的原理和实现比较简单，重点是掌握应用场景，避免过度使用。</p>
<p>如果一个类中有很多属性，为了避免构造函数的参数列表过长，影响代码的可读性和易用性，我们可以通过构造函数配合set()方法来解决。但是，如果存在下面情况中的任意一种，我们就要考虑使用建造者模式了。</p>
<ul>
<li>我们把类的必填属性放到构造函数中，强制创建对象的时候就设置。如果必填的属性有很多，把这些必填属性都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填属性通过set()方法设置，那校验这些必填属性是否已经填写的逻辑就无处安放了。</li>
<li>如果类的属性之间有一定的依赖关系或者约束条件，我们继续使用构造函数配合set()方法的设计思路，那这些依赖关系或约束条件的校验逻辑就无处安放了。</li>
<li>如果我们希望创建不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值，要实现这个功能，我们就不能在类中暴露set()方法。构造函数配合set()方法来设置属性值的方式就不适用了。</li>
</ul>
<p><u>4.原型模式</u></p>
<p>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式，来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型模式。</p>
<p>原型模式有两种实现方法，深拷贝和浅拷贝。浅拷贝只会复制对象中基本数据类型数据和引用对象的内存地址，不会递归地复制引用对象，以及引用对象的引用对象……而深拷贝得到的是一份完完全全独立的对象。所以，深拷贝比起浅拷贝来说，更加耗时，更加耗内存空间。</p>
<p>如果要拷贝的对象是不可变对象，浅拷贝共享不可变对象是没问题的，但对于可变对象来说，浅拷贝得到的对象和原始对象会共享部分数据，就有可能出现数据被修改的风险，也就变得复杂多了。操作非常耗时的情况下，我们比较推荐使用浅拷贝，否则，没有充分的理由，不要为了一点点的性能提升而使用浅拷贝。</p>
<p><strong>二、结构型设计模式</strong></p>
<p>结构型模式主要总结了一些类或对象组合在一起的经典结构，这些经典的结构可以解决特定应用场景的问题。结构型模式包括：代理模式、桥接模式、装饰器模式、适配器模式、门面模式、组合模式、享元模式。</p>
<p><u>1.代理模式</u></p>
<p>代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。一般情况下，我们让代理类和原始类实现同样的接口。但是，如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的。在这种情况下，我们可以通过让代理类继承原始类的方法来实现代理模式。</p>
<p>静态代理需要针对每个类都创建一个代理类，并且每个代理类中的代码都有点像模板式的“重复”代码，增加了维护成本和开发成本。对于静态代理存在的问题，我们可以通过动态代理来解决。我们不事先为每个原始类编写代理类，而是在运行的时候动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。</p>
<p>代理模式常用在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类统一处理，让程序员只需要关注业务方面的开发。除此之外，代理模式还可以用在RPC、缓存等应用场景中。</p>
<p><u>2.桥接模式</u></p>
<p>桥接模式的代码实现非常简单，但是理解起来稍微有点难度，并且应用场景也比较局限，所以，相对来说，桥接模式在实际的项目中并没有那么常用，你只需要简单了解，见到能认识就可以了，并不是我们学习的重点。</p>
<p>桥接模式有两种理解方式。第一种理解方式是“将抽象和实现解耦，让它们能独立开发”。这种理解方式比较特别，应用场景也不多。另一种理解方式更加简单，等同于“组合优于继承”设计原则，这种理解方式更加通用，应用场景比较多。不管是哪种理解方式，它们的代码结构都是相同的，都是一种类之间的组合关系。</p>
<p>对于第一种理解方式，弄懂定义中“抽象”和“实现”两个概念，是理解它的关键。定义中的“抽象”，指的并非“抽象类”或“接口”，而是被抽象出来的一套“类库”，它只包含骨架代码，真正的业务逻辑需要委派给定义中的“实现”来完成。而定义中的“实现”，也并非“接口的实现类”，而是的一套独立的“类库”。“抽象”和“实现”独立开发，通过对象之间的组合关系组装在一起。</p>
<p><u>3.装饰器模式</u></p>
<p>装饰器模式主要解决继承关系过于复杂的问题，通过组合来替代继承，给原始类添加增强功能。这也是判断是否该用装饰器模式的一个重要的依据。除此之外，装饰器模式还有一个特点，那就是可以对原始类嵌套使用多个装饰器。为了满足这样的需求，在设计的时候，装饰器类需要跟原始类继承相同的抽象类或者接口。</p>
<p><u>4.适配器模式</u></p>
<p>代理模式、装饰器模式提供的都是跟原始类相同的接口，而适配器提供跟原始类不同的接口。适配器模式是用来做适配的，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。适配器模式有两种实现方式：类适配器和对象适配器。其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。</p>
<p>适配器模式是一种事后的补救策略，用来补救设计上的缺陷。应用这种模式算是“无奈之举”。如果在设计初期，我们就能规避接口不兼容的问题，那这种模式就无用武之地了。在实际的开发中，什么情况下才会出现接口不兼容呢？我总结下了下面这5种场景：</p>
<ul>
<li>封装有缺陷的接口设计</li>
<li>统一多个类的接口设计</li>
<li>替换依赖的外部系统</li>
<li>兼容老版本接口</li>
<li>适配不同格式的数据</li>
</ul>
<p><u>5.门面模式</u></p>
<p>门面模式原理、实现都非常简单，应用场景比较明确。它通过封装细粒度的接口，提供组合各个细粒度接口的高层次接口，来提高接口的易用性，或者解决性能、分布式事务等问题。</p>
<p><u>6.组合模式</u></p>
<p>组合模式跟我们之前讲的面向对象设计中的“组合关系（通过组合来组装两个类）”，完全是两码事。这里讲的“组合模式”，主要是用来处理树形结构数据。正因为其应用场景的特殊性，数据必须能表示成树形结构，这也导致了这种模式在实际的项目开发中并不那么常用。但是，一旦数据满足树形结构，应用这种模式就能发挥很大的作用，能让代码变得非常简洁。</p>
<p>组合模式的设计思路，与其说是一种设计模式，倒不如说是对业务场景的一种数据结构和算法的抽象。其中，数据可以表示成树这种数据结构，业务需求可以通过在树上的递归遍历算法来实现。组合模式，将一组对象组织成树形结构，将单个对象和组合对象都看作树中的节点，以统一处理逻辑，并且它利用树形结构的特点，递归地处理每个子树，依次简化代码实现。</p>
<p><u>7.享元模式</u></p>
<p>所谓“享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。</p>
<p>具体来讲，当一个系统中存在大量重复对象的时候，我们就可以利用享元模式，将对象设计成享元，在内存中只保留一份实例，供多处代码引用，这样可以减少内存中对象的数量，以起到节省内存的目的。实际上，不仅仅相同对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分（字段），提取出来设计成享元，让这些大量相似对象引用这些享元。</p>
<p><strong>三、行为型设计模式</strong></p>
<p>我们知道，创建型设计模式主要解决“对象的创建”问题，结构型设计模式主要解决“类或对象的组合”问题，那行为型设计模式主要解决的就是“类或对象之间的交互”问题。行为型模式比较多，有11种，它们分别是：观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式、访问者模式、备忘录模式、命令模式、解释器模式、中介模式。</p>
<p><u>1.观察者模式</u></p>
<p>观察者模式将观察者和被观察者代码解耦。观察者模式的应用场景非常广泛，小到代码层面的解耦，大到架构层面的系统解耦，再或者一些产品的设计思路，都有这种模式的影子，比如，邮件订阅、RSS Feeds，本质上都是观察者模式。</p>
<p>不同的应用场景和需求下，这个模式也有截然不同的实现方式：有同步阻塞的实现方式，也有异步非阻塞的实现方式；有进程内的实现方式，也有跨进程的实现方式。同步阻塞是最经典的实现方式，主要是为了代码解耦；异步非阻塞除了能实现代码解耦之外，还能提高代码的执行效率；进程间的观察者模式解耦更加彻底，一般是基于消息队列来实现，用来实现不同进程间的被观察者和观察者之间的交互。</p>
<p>框架的作用有隐藏实现细节，降低开发难度，实现代码复用，解耦业务与非业务代码，让程序员聚焦业务开发。针对异步非阻塞观察者模式，我们也可以将它抽象成EventBus框架来达到这样的效果。EventBus翻译为“事件总线”，它提供了实现观察者模式的骨架代码。我们可以基于此框架非常容易地在自己的业务场景中实现观察者模式，不需要从零开始开发。</p>
<p><u>2.模板模式</u></p>
<p>模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。这里的“算法”，我们可以理解为广义上的“业务逻辑”，并不特指数据结构和算法中的“算法”。这里的算法骨架就是“模板”，包含算法骨架的方法就是“模板方法”，这也是模板方法模式名字的由来。</p>
<p>模板模式有两大作用：复用和扩展。其中复用指的是，所有的子类可以复用父类中提供的模板方法的代码。扩展指的是，框架通过模板模式提供功能扩展点，让框架用户可以在不修改框架源码的情况下，基于扩展点定制化框架的功能。</p>
<p>除此之外，我们还讲到回调。它跟模板模式具有相同的作用：代码复用和扩展。在一些框架、类库、组件等的设计中经常会用到，比如JdbcTemplate就是用了回调。</p>
<p>相对于普通的函数调用，回调是一种双向调用关系。A类事先注册某个函数F到B类，A类在调用B类的P函数的时候，B类反过来调用A类注册给它的F函数。这里的F函数就是“回调函数”。A调用B，B反过来又调用A，这种调用机制就叫作“回调”。</p>
<p>回调可以细分为同步回调和异步回调。从应用场景上来看，同步回调看起来更像模板模式，异步回调看起来更像观察者模式。回调跟模板模式的区别，更多的是在代码实现上，而非应用场景上。回调基于组合关系来实现，模板模式基于继承关系来实现。回调比模板模式更加灵活。</p>
<p><u>3.策略模式</u></p>
<p>策略模式定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）。策略模式用来解耦策略的定义、创建、使用。实际上，一个完整的策略模式就是由这三个部分组成的。</p>
<p>策略类的定义比较简单，包含一个策略接口和一组实现这个接口的策略类。策略的创建由工厂类来完成，封装策略创建的细节。策略模式包含一组策略可选，客户端代码选择使用哪个策略，有两种确定方法：编译时静态确定和运行时动态确定。其中，“运行时动态确定”才是策略模式最典型的应用场景。</p>
<p>在实际的项目开发中，策略模式也比较常用。最常见的应用场景是，利用它来避免冗长的if-else或switch分支判断。不过，它的作用还不止如此。它也可以像模板模式那样，提供框架的扩展点等等。实际上，策略模式主要的作用还是解耦策略的定义、创建和使用，控制代码的复杂度，让每个部分都不至于过于复杂、代码量过多。除此之外，对于复杂代码来说，策略模式还能让其满足开闭原则，添加新策略的时候，最小化、集中化代码改动，减少引入bug的风险。</p>
<p><u>4.职责链模式</u></p>
<p>在职责链模式中，多个处理器依次处理同一个请求。一个请求先经过A处理器处理，然后再把请求传递给B处理器，B处理器处理完后再传递给C处理器，以此类推，形成一个链条。链条上的每个处理器各自承担各自的处理职责，所以叫作职责链模式。</p>
<p>在GoF的定义中，一旦某个处理器能处理这个请求，就不会继续将请求传递给后续的处理器了。当然，在实际的开发中，也存在对这个模式的变体，那就是请求不会中途终止传递，而是会被所有的处理器都处理一遍。</p>
<p>职责链模式常用在框架开发中，用来实现过滤器、拦截器功能，让框架的使用者在不需要修改框架源码的情况下，添加新的过滤、拦截功能。这也体现了之前讲到的对扩展开放、对修改关闭的设计原则。</p>
<p><u>5.迭代器模式</u></p>
<p>迭代器模式也叫游标模式，它用来遍历集合对象。这里说的“集合对象”，我们也可以叫“容器”“聚合对象”，实际上就是包含一组对象的对象，比如，数组、链表、树、图、跳表。迭代器模式主要作用是解耦容器代码和遍历代码。大部分编程语言都提供了现成的迭代器可以使用，我们不需要从零开始开发。</p>
<p>遍历集合一般有三种方式：for循环、foreach循环、迭代器遍历。后两种本质上属于一种，都可以看作迭代器遍历。相对于for循环遍历，利用迭代器来遍历有3个优势：</p>
<ul>
<li>迭代器模式封装集合内部的复杂数据结构，开发者不需要了解如何遍历，直接使用容器提供的迭代器即可；</li>
<li>迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一；</li>
<li>迭代器模式让添加新的遍历算法更加容易，更符合开闭原则。除此之外，因为迭代器都实现自相同的接口，在开发中，基于接口而非实现编程，替换迭代器也变得更加容易。</li>
</ul>
<p>在通过迭代器来遍历集合元素的同时，增加或者删除集合中的元素，有可能会导致某个元素被重复遍历或遍历不到。针对这个问题，有两种比较干脆利索的解决方案，来避免出现这种不可预期的运行结果。一种是遍历的时候不允许增删元素，另一种是增删元素之后让遍历报错。第一种解决方案比较难实现，因为很难确定迭代器使用结束的时间点。第二种解决方案更加合理，Java语言就是采用的这种解决方案。增删元素之后，我们选择fail-fast解决方式，让遍历操作直接抛出运行时异常。</p>
<p><u>6.状态模式</u></p>
<p>状态模式一般用来实现状态机，而状态机常用在游戏、工作流引擎等系统开发中。状态机又叫有限状态机，它由3个部分组成：状态、事件、动作。其中，事件也称为转移条件。事件触发状态的转移及动作的执行。不过，动作不是必须的，也可能只转移状态，不执行任何动作。</p>
<p>针对状态机，我们总结了三种实现方式。</p>
<p>第一种实现方式叫分支逻辑法。利用if-else或者switch-case分支逻辑，参照状态转移图，将每一个状态转移原模原样地直译成代码。对于简单的状态机来说，这种实现方式最简单、最直接，是首选。</p>
<p>第二种实现方式叫查表法。对于状态很多、状态转移比较复杂的状态机来说，查表法比较合适。通过二维数组来表示状态转移图，能极大地提高代码的可读性和可维护性。</p>
<p>第三种实现方式就是利用状态模式。对于状态并不多、状态转移也比较简单，但事件触发执行的动作包含的业务逻辑可能比较复杂的状态机来说，我们首选这种实现方式。</p>
<p><u>7.访问者模式</u></p>
<p>访问者模式允许一个或者多个操作应用到一组对象上，设计意图是解耦操作和对象本身，保持类职责单一、满足开闭原则以及应对代码的复杂性。</p>
<p>对于访问者模式，学习的主要难点在代码实现。而代码实现比较复杂的主要原因是，函数重载在大部分面向对象编程语言中是静态绑定的。也就是说，调用类的哪个重载函数，是在编译期间，由参数的声明类型决定的，而非运行时，根据参数的实际类型决定的。除此之外，我们还讲到Double Disptach。如果某种语言支持Double Dispatch，那就不需要访问者模式了。</p>
<p>正是因为代码实现难理解，所以，在项目中应用这种模式，会导致代码的可读性比较差。如果你的同事不了解这种设计模式，可能就会读不懂、维护不了你写的代码。所以，除非不得已，不要使用这种模式。</p>
<p><u>8.备忘录模式</u></p>
<p>备忘录模式也叫快照模式，具体来说，就是在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态。这个模式的定义表达了两部分内容：一部分是，存储副本以便后期恢复；另一部分是，要在不违背封装原则的前提下，进行对象的备份和恢复。</p>
<p>备忘录模式的应用场景也比较明确和有限，主要用来防丢失、撤销、恢复等。它跟平时我们常说的“备份”很相似。两者的主要区别在于，备忘录模式更侧重于代码的设计和实现，备份更侧重架构设计或产品设计。</p>
<p>对于大对象的备份来说，备份占用的存储空间会比较大，备份和恢复的耗时会比较长。针对这个问题，不同的业务场景有不同的处理方式。比如，只备份必要的恢复信息，结合最新的数据来恢复；再比如，全量备份和增量备份相结合，低频全量备份，高频增量备份，两者结合来做恢复。</p>
<p><u>9.命令模式</u></p>
<p>命令模式在平时工作中并不常用，你稍微了解一下就可以。</p>
<p>落实到编码实现，命令模式用到最核心的实现手段，就是将函数封装成对象。我们知道，在大部分编程语言中，函数是没法作为参数传递给其他函数的，也没法赋值给变量。借助命令模式，我们将函数封装成对象，这样就可以实现把函数像对象一样使用。</p>
<p>命令模式的主要作用和应用场景，是用来控制命令的执行，比如，异步、延迟、排队执行命令、撤销重做命令、存储命令、给命令记录日志等，这才是命令模式能发挥独一无二作用的地方。</p>
<p><u>10.解释器模式</u></p>
<p>解释器模式为某个语言定义它的语法（或者叫文法）表示，并定义一个解释器用来处理这个语法。实际上，这里的“语言”不仅仅指我们平时说的中、英、日、法等各种语言。从广义上来讲，只要是能承载信息的载体，我们都可以称之为“语言”，比如，古代的结绳记事、盲文、哑语、摩斯密码等。</p>
<p>要想了解“语言”要表达的信息，我们就必须定义相应的语法规则。这样，书写者就可以根据语法规则来书写“句子”（专业点的叫法应该是“表达式”），阅读者根据语法规则来阅读“句子”，这样才能做到信息的正确传递。而我们要讲的解释器模式，其实就是用来实现根据语法规则解读“句子”的解释器。</p>
<p>解释器模式的代码实现比较灵活，没有固定的模板。我们前面说过，应用设计模式主要是应对代码的复杂性，解释器模式也不例外。它的代码实现的核心思想，就是将语法解析的工作拆分到各个小类中，以此来避免大而全的解析类。一般的做法是，将语法规则拆分一些小的独立的单元，然后对每个单元进行解析，最终合并为对整个语法规则的解析。</p>
<p><u>11.中介模式</u></p>
<p>中介模式的设计思想跟中间层很像，通过引入中介这个中间层，将一组对象之间的交互关系（或者说依赖关系）从多对多（网状关系）转换为一对多（星状关系）。原来一个对象要跟n个对象交互，现在只需要跟一个中介对象交互，从而最小化对象之间的交互关系，降低了代码的复杂度，提高了代码的可读性和可维护性。</p>
<p>观察者模式和中介模式都是为了实现参与者之间的解耦，简化交互关系。两者的不同在于应用场景上。在观察者模式的应用场景中，参与者之间的交互比较有条理，一般都是单向的，一个参与者只有一个身份，要么是观察者，要么是被观察者。而在中介模式的应用场景中，参与者之间的交互关系错综复杂，既可以是消息的发送者、也可以同时是消息的接收者。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>深入拆解Java虚拟机JVM</title>
    <url>/2022/06/12/JVM/</url>
    <content><![CDATA[<p>本文记录了Java虚拟机的基本原理，高效实现和代码优化方面的内容</p>
<span id="more"></span>

<h3 id="00-为什么要了解JVM"><a href="#00-为什么要了解JVM" class="headerlink" title="00. 为什么要了解JVM"></a>00. 为什么要了解JVM</h3><p>如果我们把核心类库的 API 比做数学公式的话，那么 Java 虚拟机的知识就好比公式的推导过程。掌握数学公式固然可以应付考试，但是了解背后的推导过程更加有助于记忆和理解。并且，在遇到那些没法套公式的情况下，我们也能知道如何解决。</p>
<p>具体来说，了解 Java 虚拟机有如下（但不限于）好处。</p>
<p>首先，Java 虚拟机提供了许多配置参数，用于满足不同应用场景下，对程序性能的需求。学习 Java 虚拟机，你可以针对自己的应用，最优化匹配运行参数。（你可以用下面这个例子看一下自己虚拟机的参数列表。）</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">举例来说，macOS 上的 Java <span class="number">10</span> 共有近千个配置参数：</span><br><span class="line"> </span><br><span class="line"><span class="variable">$ </span>java -<span class="variable constant_">XX</span><span class="symbol">:+PrintFlagsFinal</span> -<span class="variable constant_">XX</span><span class="symbol">:+UnlockDiagnosticVMOptions</span> -version |<span class="params"> wc -l</span></span><br><span class="line"><span class="params">java version &quot;10&quot; 2018-03-20</span></span><br><span class="line"><span class="params">Java(TM) SE Runtime Environment 18.3 (build 10+46)</span></span><br><span class="line"><span class="params">Java HotSpot(TM) 64-Bit Server VM 18.3 (build 10+46, mixed mode)</span></span><br><span class="line"><span class="params">     812</span></span><br></pre></td></tr></table></figure>

<p>其次，Java 虚拟机本身是一种工程产品，在实现过程中自然存在不少局限性。学习 Java 虚拟机，可以更好地规避它在使用中的 Bug，也可以更快地识别出 Java 虚拟机中的错误，</p>
<p>再次，Java 虚拟机拥有当前最前沿、最成熟的垃圾回收算法实现，以及即时编译器实现。学习 Java 虚拟机，我们可以了解背后的设计决策，今后再遇到其他代码托管技术也能触类旁通。</p>
<p>最后，Java 虚拟机发展到了今天，已经脱离 Java 语言，形成了一套相对独立的、高性能的执行方案。除了 Java 外，Scala、Clojure、Groovy，以及时下热门的 Kotlin，这些语言都可以运行在 Java 虚拟机之上。学习 Java 虚拟机，便可以了解这些语言的通用机制，甚至于让这些语言共享生态系统。</p>
<h3 id="01-Java代码是怎么运行的"><a href="#01-Java代码是怎么运行的" class="headerlink" title="01. Java代码是怎么运行的"></a>01. Java代码是怎么运行的</h3><p>作为一名 Java 程序员，你应该知道，Java 代码有很多种不同的运行方式。比如说可以在开发工具中运行，可以双击执行 jar 文件运行，也可以在命令行中运行，甚至可以在网页中运行。当然，这些执行方式都离不开 JRE，也就是 Java 运行时环境。</p>
<p>实际上，JRE 仅包含运行 Java 程序的必需组件，包括 Java 虚拟机以及 Java 核心类库等。我们 Java 程序员经常接触到的 JDK（Java 开发工具包）同样包含了 JRE，并且还附带了一系列开发、诊断工具。</p>
<p>然而，运行 C++ 代码则无需额外的运行时。我们往往把这些代码直接编译成 CPU 所能理解的代码格式，也就是机器码。</p>
<p>既然 C++ 的运行方式如此成熟，那么你有没有想过，为什么 Java 要在虚拟机中运行呢，Java 虚拟机具体又是怎样运行 Java 代码的呢，它的运行效率又如何呢？</p>
<h4 id="为什么Java要在虚拟机里运行？"><a href="#为什么Java要在虚拟机里运行？" class="headerlink" title="为什么Java要在虚拟机里运行？"></a>为什么Java要在虚拟机里运行？</h4><p>Java 作为一门高级程序语言，它的语法非常复杂，抽象程度也很高。因此，直接在硬件上运行这种复杂的程序并不现实。所以呢，在运行 Java 程序之前，我们需要对其进行一番转换。</p>
<p>这个转换具体是怎么操作的呢？当前的主流思路是这样子的，<u>设计一个面向 Java 语言特性的虚拟机，并通过编译器将 Java 程序转换成该虚拟机所能识别的指令序列，也称 Java 字节码</u>。这里顺便说一句，之所以这么取名，是因为 Java 字节码指令的操作码（opcode）被固定为一个字节。</p>
<p>举例来说，下图的中间列，正是用 Java 写的 Helloworld 程序编译而成的字节码。可以看到，它与 C 版本的编译结果一样，都是由一个个字节组成的。</p>
<p>并且，我们同样可以将其反汇编为人类可读的代码格式（如下图的最右列所示）。不同的是，Java 版本的编译结果相对精简一些。这是因为 Java 虚拟机相对于物理机而言，抽象程度更高。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 最左列是偏移；中间列是给虚拟机读的机器码；最右列是给人读的代码</span></span><br><span class="line"><span class="section">0x00:  b2 00 02         getstatic java.lang.System.out</span></span><br><span class="line"><span class="section">0x03:  12 03            ldc &quot;Hello, World!&quot;</span></span><br><span class="line"><span class="section">0x05:  b6 00 04         invokevirtual java.io.PrintStream.println</span></span><br><span class="line"><span class="section">0x08:  b1               return</span></span><br></pre></td></tr></table></figure>

<p>Java 虚拟机可以由硬件<a href="https://en.wikipedia.org/wiki/Java_processor">实现</a>，但更为常见的是在各个现有平台（如 Windows_x64、Linux_aarch64）上提供软件实现。这么做的意义在于：</p>
<ul>
<li><u>一旦一个程序被转换成 Java 字节码，那么它便可以在不同平台上的虚拟机实现里运行。这也就是我们经常说的“一次编写，到处运行”</u>。</li>
<li>虚拟机的另外一个好处是它带来了一个<u>托管环境</u>（Managed Runtime）。这个托管环境能够代替我们处理一些代码中冗长而且容易出错的部分。其中最广为人知的当属<u>自动内存管理与垃圾回收</u>，这部分内容甚至催生了一波垃圾回收调优的业务。</li>
<li>除此之外，托管环境还提供了诸如数组越界、动态类型、安全权限等等的动态检测，使我们免于书写这些无关业务逻辑的代码。</li>
</ul>
<h4 id="Java虚拟机具体是怎样运行Java字节码的"><a href="#Java虚拟机具体是怎样运行Java字节码的" class="headerlink" title="Java虚拟机具体是怎样运行Java字节码的"></a>Java虚拟机具体是怎样运行Java字节码的</h4><p>下面我将以标准 JDK 中的 HotSpot 虚拟机为例，从虚拟机以及底层硬件两个角度，讲一讲 Java 虚拟机具体是怎么运行 Java 字节码的。</p>
<p>从<strong>虚拟机视角</strong>来看，执行 Java 代码首先需要将它编译而成的 class 文件加载到 Java 虚拟机中。加载后的 Java 类会被存放于方法区（Method Area）中。实际运行时，虚拟机会执行方法区内的代码。</p>
<p>如果你熟悉 X86 的话，你会发现这和段式内存管理中的代码段类似。而且，Java 虚拟机同样也在内存中划分出堆和栈来存储运行时数据。</p>
<p>不同的是，Java 虚拟机会将栈细分为面向 Java 方法的 Java 方法栈，面向本地方法（用 C++ 写的 native 方法）的本地方法栈，以及存放各个线程执行位置的 PC 寄存器。</p>
<img src="https://pic.imgdb.cn/item/62a4d3cd09475431294de3f7.jpg" style="zoom: 80%;" />

<p>在运行过程中，每当调用进入一个 Java 方法，Java 虚拟机会在当前线程的 Java 方法栈中生成一个栈帧，用以存放局部变量以及字节码的操作数。这个栈帧的大小是提前计算好的，而且 Java 虚拟机不要求栈帧在内存空间里连续分布。</p>
<p>当退出当前执行的方法时，不管是正常返回还是异常返回，Java 虚拟机均会弹出当前线程的当前栈帧，并将之舍弃。</p>
<p>从<strong>硬件视角</strong>来看，Java 字节码无法直接执行。因此，Java 虚拟机需要将字节码翻译成机器码。</p>
<p>在 HotSpot 里面，上述翻译过程有两种形式：第一种是解释执行，即逐条将字节码翻译成机器码并执行；第二种是即时编译（Just-In-Time compilation，JIT），即将一个方法中包含的所有字节码编译成机器码后再执行。</p>
<img src="https://pic.imgdb.cn/item/62a4d4ca09475431294f3dd0.jpg" style="zoom:80%;" />

<p>前者的优势在于无需等待编译，而后者的优势在于实际运行速度更快。HotSpot 默认采用混合模式，综合了解释执行和即时编译两者的优点。它会先解释执行字节码，而后将其中反复执行的热点代码，以方法为单位进行即时编译。</p>
<h4 id="Java-虚拟机的运行效率究竟是怎么样的？"><a href="#Java-虚拟机的运行效率究竟是怎么样的？" class="headerlink" title="Java 虚拟机的运行效率究竟是怎么样的？"></a>Java 虚拟机的运行效率究竟是怎么样的？</h4><p>HotSpot 采用了多种技术来提升启动性能以及峰值性能，刚刚提到的即时编译便是其中最重要的技术之一。</p>
<p>即时编译建立在程序符合二八定律的假设上，也就是百分之二十的代码占据了百分之八十的计算资源。</p>
<p><strong>对于占据大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。</strong></p>
<p>理论上讲，即时编译后的 Java 程序的执行效率，是可能超过 C++ 程序的。这是因为与静态编译相比，即时编译拥有程序的运行时信息，并且能够根据这个信息做出相应的优化。</p>
<p>举个例子，我们知道虚方法是用来实现面向对象语言多态性的。对于一个虚方法调用，尽管它有很多个目标方法，但在实际运行过程中它可能只调用其中的一个。</p>
<p>这个信息便可以被即时编译器所利用，来规避虚方法调用的开销，从而达到比静态编译的 C++ 程序更高的性能。</p>
<p>为了满足不同用户场景的需要，HotSpot 内置了多个即时编译器：C1、C2 和 Graal。Graal 是 Java 10 正式引入的实验性即时编译器。</p>
<p>之所以引入多个即时编译器，是为了在编译时间和生成代码的执行效率之间进行取舍。</p>
<ul>
<li>C1 又叫做 Client 编译器，面向的是对启动性能有要求的客户端 GUI 程序，采用的优化手段相对简单，因此编译时间较短。</li>
<li>C2 又叫做 Server 编译器，面向的是对峰值性能有要求的服务器端程序，采用的优化手段相对复杂，因此编译时间较长，但同时生成代码的执行效率较高。</li>
</ul>
<p>从 Java 7 开始，HotSpot 默认采用分层编译的方式：热点方法首先会被 C1 编译，而后热点方法中的热点会进一步被 C2 编译。</p>
<p>为了不干扰应用的正常运行，HotSpot 的即时编译是放在额外的编译线程中进行的。HotSpot 会根据 CPU 的数量设置编译线程的数目，并且按 1:2 的比例配置给 C1 及 C2 编译器。</p>
<p>在计算资源充足的情况下，字节码的解释执行和即时编译可同时进行。编译完成后的机器码会在下次调用该方法时启用，以替换原本的解释执行。</p>
<h3 id="02-Java的基本类型"><a href="#02-Java的基本类型" class="headerlink" title="02. Java的基本类型"></a>02. Java的基本类型</h3><p>如果你了解面向对象语言的发展史，那你可能听说过 Smalltalk 这门语言。它的影响力之大，以至于之后诞生的面向对象语言，或多或少都借鉴了它的设计和实现。</p>
<p>在 Smalltalk 中，所有的值都是对象。因此，许多人认为它是一门纯粹的面向对象语言。</p>
<p>Java 则不同，它引进了八个基本类型，来支持数值计算。Java 这么做的原因主要是工程上的考虑，因为使用基本类型能够在执行效率以及内存使用两方面提升软件性能。</p>
<p>今天，我们就来了解一下基本类型在 Java 虚拟机中的实现。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>) &#123;</span><br><span class="line">    <span class="built_in">boolean</span> 吃过饭没 = <span class="number">2</span>; <span class="comment">// 直接编译的话 javac 会报错</span></span><br><span class="line">    <span class="keyword">if</span> (吃过饭没) <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot; 吃了 &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span> == 吃过饭没) <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot; 真吃了 &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这么一段代码，它将一个 boolean 类型的局部变量赋值为 2。为了方便记忆，我们给这个变量起个名字，就叫“吃过饭没”。</p>
<p>赋值语句后边我设置了两个看似一样的 if 语句。第一个 if 语句，也就是直接判断“吃过饭没”，在它成立的情况下，代码会打印“吃了”。</p>
<p>第二个 if 语句，也就是判断“吃过饭没”和 true 是否相等，在它成立的情况下，代码会打印“真吃了”。</p>
<p>当然，直接编译这段代码，编译器是会报错的。所以，我迂回了一下，采用一个 Java 字节码的汇编工具，直接对字节码进行更改。</p>
<p>那么问题就来了：当一个 boolean 变量的值是 2 时，它究竟是 true 还是 false 呢？</p>
<p>如果你跑过这段代码，你会发现，问虚拟机“吃过饭没”，它会回答“吃了”，而问虚拟机“真（&#x3D;&#x3D;）吃过饭没”，虚拟机则不会回答“真吃了”。</p>
<p>那么虚拟机到底吃过没，下面我们来一起分析一下这背后的细节。</p>
<h4 id="Java-虚拟机的-boolean-类型"><a href="#Java-虚拟机的-boolean-类型" class="headerlink" title="Java 虚拟机的 boolean 类型"></a>Java 虚拟机的 boolean 类型</h4><p>首先，我们来看看 Java 语言规范以及 Java 虚拟机规范是怎么定义 boolean 类型的。</p>
<p>在 Java 语言规范中，boolean 类型的值只有两种可能，它们分别用符号“true”和“false”来表示。显然，这两个符号是不能被虚拟机直接使用的。</p>
<p><u>在 Java 虚拟机规范中，boolean 类型则被映射成 int 类型。具体来说，“true”被映射为整数 1，而“false”被映射为整数 0。这个编码规则约束了 Java 字节码的具体实现。</u></p>
<p>举个例子，对于存储 boolean 数组的字节码，Java 虚拟机需保证实际存入的值是整数 1 或者 0。</p>
<p>Java 虚拟机规范同时也要求 Java 编译器遵守这个编码规则，并且用整数相关的字节码来实现逻辑运算，以及基于 boolean 类型的条件跳转。这样一来，在编译而成的 class 文件中，除了字段和传入参数外，基本看不出 boolean 类型的痕迹了。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Foo.main 编译后的字节码</span></span><br><span class="line"> <span class="attr">0:</span> <span class="string">iconst_2</span>       <span class="string">//</span> <span class="string">我们用</span> <span class="string">AsmTools</span> <span class="string">更改了这一指令</span></span><br><span class="line"> <span class="attr">1:</span> <span class="string">istore_1</span></span><br><span class="line"> <span class="attr">2:</span> <span class="string">iload_1</span></span><br><span class="line"> <span class="attr">3:</span> <span class="string">ifeq</span> <span class="number">14</span>        <span class="string">//</span> <span class="string">第一个</span> <span class="string">if</span> <span class="string">语句，即操作数栈上数值为</span> <span class="number">0</span> <span class="string">时跳转</span></span><br><span class="line"> <span class="attr">6:</span> <span class="string">getstatic</span> <span class="string">java.lang.System.out</span></span><br><span class="line"> <span class="attr">9:</span> <span class="string">ldc</span> <span class="string">&quot; 吃了 &quot;</span></span><br><span class="line"><span class="attr">11:</span> <span class="string">invokevirtual</span> <span class="string">java.io.PrintStream.println</span></span><br><span class="line"><span class="attr">14:</span> <span class="string">iload_1</span></span><br><span class="line"><span class="attr">15:</span> <span class="string">iconst_1</span></span><br><span class="line"><span class="attr">16:</span> <span class="string">if_icmpne</span> <span class="number">27</span>   <span class="string">//</span> <span class="string">第二个</span> <span class="string">if</span> <span class="string">语句，即操作数栈上两个数值不相同时跳转</span></span><br><span class="line"><span class="attr">19:</span> <span class="string">getstatic</span> <span class="string">java.lang.System.out</span></span><br><span class="line"><span class="attr">22:</span> <span class="string">ldc</span> <span class="string">&quot; 真吃了 &quot;</span></span><br><span class="line"><span class="attr">24:</span> <span class="string">invokevirtual</span> <span class="string">java.io.PrintStream.println</span></span><br><span class="line"><span class="attr">27:</span> <span class="string">return</span></span><br></pre></td></tr></table></figure>

<p>在前面的例子中，第一个 if 语句会被编译成条件跳转字节码 ifeq，翻译成人话就是说，如果局部变量“吃过饭没”的值为 0，那么跳过打印“吃了”的语句。</p>
<p>而第二个 if 语句则会被编译成条件跳转字节码 if_icmpne，也就是说，如果局部变量的值和整数 1 不相等，那么跳过打印“真吃了”的语句。</p>
<p>可以看到，Java 编译器的确遵守了相同的编码规则。当然，这个约束很容易绕开。除了我们小作业中用到的汇编工具 AsmTools 外，还有许多可以修改字节码的 Java 库，比如说<a href="https://asm.ow2.io/">ASM</a>等。</p>
<p>对于 Java 虚拟机来说，它看到的 boolean 类型，早已被映射为整数类型。因此，将原本声明为 boolean 类型的局部变量，赋值为除了 0、1 之外的整数值，在 Java 虚拟机看来是“合法”的。</p>
<p>在我们的例子中，经过编译器编译之后，Java 虚拟机看到的不是在问“吃过饭没”，而是在问“吃过几碗饭”。也就是说，第一个 if 语句变成：你不会一碗饭都没吃吧。第二个 if 语句则变成：你吃过一碗饭了吗。</p>
<p>如果我们约定俗成，每人每顿只吃一碗，那么第二个 if 语句还是有意义的。但如果我们打破常规，吃了两碗，那么较真的 Java 虚拟机就会将第二个 if 语句判定为假了。</p>
<h4 id="Java-的基本类型"><a href="#Java-的基本类型" class="headerlink" title="Java 的基本类型"></a>Java 的基本类型</h4><p>除了上面提到的 boolean 类型外，Java 的基本类型还包括整数类型 byte、short、char、int 和 long，以及浮点类型 float 和 double。</p>
<img src="https://pic.imgdb.cn/item/62a4d8ad09475431295366a6.jpg" style="zoom:80%;" />

<p>Java 的基本类型都有对应的值域和默认值。可以看到，byte、short、int、long、float 以及 double 的值域依次扩大，而且前面的值域被后面的值域所包含。因此，<u>从前面的基本类型转换至后面的基本类型，无需强制转换</u>。另外一点值得注意的是，<u>尽管他们的默认值看起来不一样，但在内存中都是 0</u>。</p>
<p>在这些基本类型中，boolean 和 char 是唯二的无符号类型。在不考虑违反规范的情况下，boolean 类型的取值范围是 0 或者 1。char 类型的取值范围则是 [0, 65535]。通常我们可以认定 char 类型的值为非负数。这种特性十分有用，比如说作为数组索引等。</p>
<p>在前面的例子中，我们能够将整数 2 存储到一个声明为 boolean 类型的局部变量中。那么，声明为 byte、char 以及 short 的局部变量，是否也能够存储超出它们取值范围的数值呢？</p>
<p>答案是可以的。而且，这些超出取值范围的数值同样会带来一些麻烦。比如说，声明为 char 类型的局部变量实际上有可能为负数。当然，在正常使用 Java 编译器的情况下，生成的字节码会遵守 Java 虚拟机规范对编译器的约束，因此你无须过分担心局部变量会超出它们的取值范围。</p>
<p>Java 的浮点类型采用 IEEE 754 浮点数格式。以 float 为例，浮点类型通常有两个 0，+0.0F 以及 -0.0F。</p>
<p>前者在 Java 里是 0，后者是符号位为 1、其他位均为 0 的浮点数，在内存中等同于十六进制整数 0x8000000（即 -0.0F 可通过 Float.intBitsToFloat(0x8000000) 求得）。尽管它们的内存数值不同，但是在 Java 中 +0.0F &#x3D;&#x3D; -0.0F 会返回真。</p>
<p>在有了 +0.0F 和 -0.0F 这两个定义后，我们便可以定义浮点数中的正无穷及负无穷。正无穷就是任意正浮点数（不包括 +0.0F）除以 +0.0F 得到的值，而负无穷是任意正浮点数除以 -0.0F 得到的值。在 Java 中，正无穷和负无穷是有确切的值，在内存中分别等同于十六进制整数 0x7F800000 和 0xFF800000。</p>
<p>你也许会好奇，既然整数 0x7F800000 等同于正无穷，那么 0x7F800001 又对应什么浮点数呢？</p>
<p>这个数字对应的浮点数是 NaN（Not-a-Number）。</p>
<p>不仅如此，[0x7F800001, 0x7FFFFFFF] 和 [0xFF800001, 0xFFFFFFFF] 对应的都是 NaN。当然，一般我们计算得出的 NaN，比如说通过 +0.0F&#x2F;+0.0F，在内存中应为 0x7FC00000。这个数值，我们称之为标准的 NaN，而其他的我们称之为不标准的 NaN。</p>
<p><u>NaN 有一个有趣的特性：除了“!&#x3D;”始终返回 true 之外，所有其他比较结果都会返回 false</u>。</p>
<p>举例来说，“NaN&lt;1.0F”返回 false，而“NaN&gt;&#x3D;1.0F”同样返回 false。对于任意浮点数 f，不管它是 0 还是 NaN，“f!&#x3D;NaN”始终会返回 true，而“f&#x3D;&#x3D;NaN”始终会返回 false。</p>
<p>因此，我们在程序里做浮点数比较的时候，需要考虑上述特性。在本专栏的第二部分，我会介绍这个特性给向量化比较带来什么麻烦。</p>
<h4 id="Java-基本类型的大小"><a href="#Java-基本类型的大小" class="headerlink" title="Java 基本类型的大小"></a>Java 基本类型的大小</h4><p>前面提到，Java 虚拟机每调用一个 Java 方法，便会创建一个栈帧。为了方便理解，这里我只讨论供解释器使用的解释栈帧（interpreted frame）。</p>
<p>这种栈帧有两个主要的组成部分，分别是局部变量区，以及字节码的操作数栈。这里的局部变量是广义的，除了普遍意义下的局部变量之外，它还包含实例方法的“this 指针”以及方法所接收的参数。</p>
<p>在 Java 虚拟机规范中，局部变量区等价于一个数组，并且可以用正整数来索引。除了 long、double 值需要用两个数组单元来存储之外，其他基本类型以及引用类型的值均占用一个数组单元。</p>
<p>也就是说，boolean、byte、char、short 这四种类型，在栈上占用的空间和 int 是一样的，和引用类型也是一样的。因此，在 32 位的 HotSpot 中，这些类型在栈上将占用 4 个字节；而在 64 位的 HotSpot 中，他们将占 8 个字节。</p>
<p>当然，这种情况仅存在于局部变量，而并不会出现在存储于堆中的字段或者数组元素上。对于 byte、char 以及 short 这三种类型的字段或者数组单元，它们在堆上占用的空间分别为一字节、两字节，以及两字节，也就是说，跟这些类型的值域相吻合。</p>
<p>因此，当我们将一个 int 类型的值，存储到这些类型的字段或数组时，相当于做了一次隐式的掩码操作。举例来说，当我们把 0xFFFFFFFF（-1）存储到一个声明为 char 类型的字段里时，由于该字段仅占两字节，所以高两位的字节便会被截取掉，最终存入“\uFFFF”。</p>
<p>boolean 字段和 boolean 数组则比较特殊。在 HotSpot 中，boolean 字段占用一字节，而 boolean 数组则直接用 byte 数组来实现。为了保证堆中的 boolean 值是合法的，HotSpot 在存储时显式地进行掩码操作，也就是说，只取最后一位的值存入 boolean 字段或数组中。</p>
<p>讲完了存储，现在我来讲讲加载。Java 虚拟机的算数运算几乎全部依赖于操作数栈。也就是说，我们需要将堆中的 boolean、byte、char 以及 short 加载到操作数栈上，而后将栈上的值当成 int 类型来运算。</p>
<p>对于 boolean、char 这两个无符号类型来说，加载伴随着零扩展。举个例子，char 的大小为两个字节。在加载时 char 的值会被复制到 int 类型的低二字节，而高二字节则会用 0 来填充。</p>
<p>对于 byte、short 这两个类型来说，加载伴随着符号扩展。举个例子，short 的大小为两个字节。在加载时 short 的值同样会被复制到 int 类型的低二字节。如果该 short 值为非负数，即最高位为 0，那么该 int 类型的值的高二字节会用 0 来填充，否则用 1 来填充。</p>
<h3 id="03-Java虚拟机是如何加载Java类的"><a href="#03-Java虚拟机是如何加载Java类的" class="headerlink" title="03. Java虚拟机是如何加载Java类的"></a>03. Java虚拟机是如何加载Java类的</h3><p> Java 虚拟机中的类加载：从 class 文件到内存中的类，按先后顺序需要经过加载、链接以及初始化三大步骤。其中，链接过程中同样需要验证；而内存中的类没有经过初始化，同样不能使用。那么，是否所有的 Java 类都需要经过这几步呢？</p>
<p>我们知道 Java 语言的类型可以分为两大类：基本类型（primitive types）和引用类型（reference types）。其中 Java 的基本类型是由 Java 虚拟机预先定义好的。</p>
<p>至于另一大类引用类型，Java 将其细分为四种：<u>类、接口、数组类和泛型参数</u>。由于泛型参数会在编译过程中被擦除（我会在专栏的第二部分详细介绍），因此 Java 虚拟机实际上只有前三种。在类、接口和数组类中，数组类是由 Java 虚拟机直接生成的，其他两种则有对应的字节流。</p>
<p>说到字节流，最常见的形式要属由 Java 编译器生成的 class 文件。除此之外，我们也可以在程序内部直接生成，或者从网络中获取（例如网页中内嵌的小程序 Java applet）字节流。这些不同形式的字节流，都会被加载到 Java 虚拟机中，成为类或接口。为了叙述方便，下面我就用“类”来统称它们。</p>
<p>无论是直接生成的数组类，还是加载的类，Java 虚拟机都需要对其进行链接和初始化。接下来，我会详细给你介绍一下每个步骤具体都在干些什么。</p>
<h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p><u>加载，是指查找字节流，并且据此创建类的过程</u>。前面提到，对于数组类来说，它并没有对应的字节流，而是由 Java 虚拟机直接生成的。对于其他的类来说，Java 虚拟机则需要借助类加载器来完成查找字节流的过程。</p>
<p>以盖房子为例，村里的 Tony 要盖个房子，那么按照流程他得先找个建筑师，跟他说想要设计一个房型，比如说“一房、一厅、四卫”。你或许已经听出来了，这里的房型相当于类，而建筑师，就相当于类加载器。</p>
<p>村里有许多建筑师，他们等级森严，但有着共同的祖师爷，叫启动类加载器（bootstrap class loader）。启动类加载器是由 C++ 实现的，没有对应的 Java 对象，因此在 Java 中只能用 null 来指代。换句话说，祖师爷不喜欢像 Tony 这样的小角色来打扰他，所以谁也没有祖师爷的联系方式。</p>
<p>除了启动类加载器之外，其他的类加载器都是 java.lang.ClassLoader 的子类，因此有对应的 Java 对象。这些类加载器需要先由另一个类加载器，比如说启动类加载器，加载至 Java 虚拟机中，方能执行类加载。</p>
<p>村里的建筑师有一个潜规则，就是接到单子自己不能着手干，得先给师傅过过目。师傅不接手的情况下，才能自己来。在 Java 虚拟机中，这个潜规则有个特别的名字，叫<strong>双亲委派模型</strong>。<u>每当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。</u></p>
<p>在 Java 9 之前，<u>启动类加载器负责加载最为基础、最为重要的类</u>，比如存放在 JRE 的 lib 目录下 jar 包中的类（以及由虚拟机参数 -Xbootclasspath 指定的类）。除了启动类加载器之外，另外两个重要的类加载器是扩展类加载器（extension class loader）和应用类加载器（application class loader），均由 Java 核心类库提供。</p>
<p><u>扩展类加载器的父类加载器是启动类加载器</u>。它负责加载相对次要、但又通用的类，比如存放在 JRE 的 lib&#x2F;ext 目录下 jar 包中的类（以及由系统变量 java.ext.dirs 指定的类）。</p>
<p><u>应用类加载器的父类加载器则是扩展类加载器</u>。它负责加载应用程序路径下的类。（这里的应用程序路径，便是指虚拟机参数 -cp&#x2F;-classpath、系统变量 java.class.path 或环境变量 CLASSPATH 所指定的路径。）默认情况下，应用程序中包含的类便是由应用类加载器加载的。</p>
<p>Java 9 引入了模块系统，并且略微更改了上述的类加载器<a href="https://docs.oracle.com/javase/9/migrate/toc.htm#JSMIG-GUID-A868D0B9-026F-4D46-B979-901834343F9E">1</a>。扩展类加载器被改名为平台类加载器（platform class loader）。Java SE 中除了少数几个关键模块，比如说 java.base 是由启动类加载器加载之外，其他的模块均由平台类加载器所加载。</p>
<p>除了由 Java 核心类库提供的类加载器外，我们还可以加入自定义的类加载器，来实现特殊的加载方式。举例来说，我们可以对 class 文件进行加密，加载时再利用自定义的类加载器对其解密。</p>
<p>除了加载功能之外，类加载器还提供了命名空间的作用。这个很好理解，打个比方，咱们这个村不讲究版权，如果你剽窃了另一个建筑师的设计作品，那么只要你标上自己的名字，这两个房型就是不同的。</p>
<p>在 Java 虚拟机中，类的唯一性是由类加载器实例以及类的全名一同确定的。即便是同一串字节流，经由不同的类加载器加载，也会得到两个不同的类。在大型应用中，我们往往借助这一特性，来运行同一个类的不同版本。</p>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p><u>链接，是指将创建成的类合并至 Java 虚拟机中，使之能够执行的过程</u>。它可分为验证、准备以及解析三个阶段。</p>
<ul>
<li><p><u>验证阶段的目的，在于确保被加载类能够满足 Java 虚拟机的约束条件</u>。这就好比 Tony 需要将设计好的房型提交给市政部门审核。只有当审核通过，才能继续下面的建造工作。</p>
<p>通常而言，Java 编译器生成的类文件必然满足 Java 虚拟机的约束条件。因此，这部分我留到讲解字节码注入时再详细介绍。</p>
</li>
<li><p><u>准备阶段的目的，则是为被加载类的静态字段分配内存</u>。Java 代码中对静态字段的具体初始化，则会在稍后的初始化阶段中进行。过了这个阶段，咱们算是盖好了毛坯房。虽然结构已经完整，但是在没有装修之前是不能住人的。</p>
<p>除了分配内存外，部分 Java 虚拟机还会在此阶段构造其他跟类层次相关的数据结构，比如说用来实现虚方法的动态绑定的方法表。</p>
<p>在 class 文件被加载至 Java 虚拟机之前，这个类无法知道其他类及其方法、字段所对应的具体地址，甚至不知道自己方法、字段的地址。因此，每当需要引用这些成员时，Java 编译器会生成一个符号引用。在运行阶段，这个符号引用一般都能够无歧义地定位到具体目标上。</p>
<p>举例来说，对于一个方法调用，编译器会生成一个包含目标方法所在类的名字、目标方法的名字、接收参数类型以及返回值类型的符号引用，来指代所要调用的方法。</p>
</li>
<li><p><u>解析阶段的目的，正是将这些符号引用解析成为实际引用</u>。如果符号引用指向一个未被加载的类，或者未被加载类的字段或方法，那么解析将触发这个类的加载（但未必触发这个类的链接以及初始化。）</p>
<p>如果将这段话放在盖房子的语境下，那么符号引用就好比“Tony 的房子”这种说法，不管它存在不存在，我们都可以用这种说法来指代 Tony 的房子。实际引用则好比实际的通讯地址，如果我们想要与 Tony 通信，则需要启动盖房子的过程。</p>
<p>Java 虚拟机规范并没有要求在链接过程中完成解析。它仅规定了：如果某些字节码使用了符号引用，那么在执行这些字节码之前，需要完成对这些符号引用的解析。</p>
</li>
</ul>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>在 Java 代码中，如果要初始化一个静态字段，我们可以在声明时直接赋值，也可以在静态代码块中对其赋值。</p>
<p>如果直接赋值的静态字段被 final 所修饰，并且它的类型是基本类型或字符串时，那么该字段便会被 Java 编译器标记成常量值（ConstantValue），其初始化直接由 Java 虚拟机完成。除此之外的直接赋值操作，以及所有静态代码块中的代码，则会被 Java 编译器置于同一方法中，并把它命名为 &lt; clinit &gt;。</p>
<p><u>类加载的最后一步是初始化，便是为标记为常量值的字段赋值，以及执行 &lt; clinit &gt; 方法的过程</u>。Java 虚拟机会通过加锁来确保类的 &lt; clinit &gt; 方法仅被执行一次。</p>
<p>只有当初始化完成之后，类才正式成为可执行的状态。这放在我们盖房子的例子中就是，只有当房子装修过后，Tony 才能真正地住进去。</p>
<p>那么，类的初始化何时会被触发呢？JVM 规范枚举了下述多种触发情况：</p>
<ol>
<li>当虚拟机启动时，初始化用户指定的主类；</li>
<li>当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类；</li>
<li>当遇到调用静态方法的指令时，初始化该静态方法所在的类；</li>
<li>当遇到访问静态字段的指令时，初始化该静态字段所在的类；</li>
<li>子类的初始化会触发父类的初始化；</li>
<li>如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化；</li>
<li>使用反射 API 对某个类进行反射调用时，初始化这个类；</li>
<li>当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>()</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">LazyHolder</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> final Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> LazyHolder.INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我在文章中贴了一段代码，这段代码是在著名的单例延迟初始化例子中<a href="https://en.wikipedia.org/wiki/Initialization-on-demand_holder_idiom">2</a>，只有当调用 Singleton.getInstance 时，程序才会访问 LazyHolder.INSTANCE，才会触发对 LazyHolder 的初始化（对应第 4 种情况），继而新建一个 Singleton 的实例。</p>
<p>由于类初始化是线程安全的，并且仅被执行一次，因此程序可以确保多线程环境下有且仅有一个 Singleton 实例。</p>
<h3 id="04-JVM是如何执行方法调用的？（上）"><a href="#04-JVM是如何执行方法调用的？（上）" class="headerlink" title="04. JVM是如何执行方法调用的？（上）"></a>04. JVM是如何执行方法调用的？（上）</h3><p>前不久在写代码的时候，我不小心踩到一个可变长参数的坑。你或许已经猜到了，它正是可变长参数方法的重载造成的。（注：官方文档建议避免重载可变长参数方法，见 [1] 的最后一段。）</p>
<p>我把踩坑的过程放在了文稿里，你可以点击查看。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Object obj, Object... args)</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(String s, Object obj, Object... args)</span> &#123; ... &#125;</span><br><span class="line"> </span><br><span class="line">invoke(<span class="literal">null</span>, <span class="number">1</span>);    <span class="comment">// 调用第二个 invoke 方法</span></span><br><span class="line">invoke(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 调用第二个 invoke 方法</span></span><br><span class="line">invoke(<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="number">1</span>&#125;); <span class="comment">// 只有手动绕开可变长参数的语法糖，</span></span><br><span class="line">                               <span class="comment">// 才能调用第一个 invoke 方法</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>当时情况是这样子的，某个 API 定义了两个同名的重载方法。其中，第一个接收一个 Object，以及声明为 Object…的变长参数；而第二个则接收一个 String、一个 Object，以及声明为 Object…的变长参数。</p>
<p>这里我想调用第一个方法，传入的参数为 (null, 1)。也就是说，声明为 Object 的形式参数所对应的实际参数为 null，而变长参数则对应 1。</p>
<p>通常来说，之所以不提倡可变长参数方法的重载，是因为 Java 编译器可能无法决定应该调用哪个目标方法。</p>
<p>在这种情况下，编译器会报错，并且提示这个方法调用有二义性。然而，Java 编译器直接将我的方法调用识别为调用第二个方法，这究竟是为什么呢？</p>
<p>带着这个问题，我们来看一看 Java 虚拟机是怎么识别目标方法的。</p>
<h4 id="重载与重写"><a href="#重载与重写" class="headerlink" title="重载与重写"></a>重载与重写</h4><p>在 Java 程序里，如果同一个类中出现多个名字相同，并且参数类型相同的方法，那么它无法通过编译。也就是说，在正常情况下，如果我们想要在同一个类中定义名字相同的方法，那么它们的参数类型必须不同。这些方法之间的关系，我们称之为重载。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">小知识：这个限制可以通过字节码工具绕开。也就是说，在编译完成之后，我们可以再向 class 文件中添加方法名和参数类型相同，而返回类型不同的方法。</span><br><span class="line">当这种包括多个方法名相同、参数类型相同，而返回类型不同的方法的类，出现在 Java 编译器的用户类路径上时，它是怎么确定需要调用哪个方法的呢？</span><br><span class="line">当前版本的 Java 编译器会直接选取第一个方法名以及参数类型匹配的方法。并且，它会根据所选取方法的返回类型来决定可不可以通过编译，以及需不需要进行值转换等。</span><br></pre></td></tr></table></figure>

<p><u>重载的方法在<strong>编译过程</strong>中即可完成识别</u>。具体到每一个方法调用，Java 编译器会根据所传入参数的声明类型（注意与实际类型区分）来选取重载方法。选取的过程共分为三个阶段：</p>
<ol>
<li>在不考虑对基本类型自动装拆箱（auto-boxing，auto-unboxing），以及可变长参数的情况下选取重载方法；</li>
<li>如果在第 1 个阶段中没有找到适配的方法，那么在允许自动装拆箱，但不允许可变长参数的情况下选取重载方法；</li>
<li>如果在第 2 个阶段中没有找到适配的方法，那么在允许自动装拆箱以及可变长参数的情况下选取重载方法。</li>
</ol>
<p>如果 Java 编译器在同一个阶段中找到了多个适配的方法，那么它会在其中选择一个最为贴切的，而决定贴切程度的一个关键就是形式参数类型的继承关系。</p>
<p>在开头的例子中，当传入 null 时，它既可以匹配第一个方法中声明为 Object 的形式参数，也可以匹配第二个方法中声明为 String 的形式参数。由于 String 是 Object 的子类，因此 Java 编译器会认为第二个方法更为贴切。</p>
<p>除了同一个类中的方法，重载也可以作用于这个类所继承而来的方法。也就是说，如果子类定义了与父类中非私有方法同名的方法，而且这两个方法的参数类型不同，那么在子类中，这两个方法同样构成了重载。</p>
<p>那么，如果子类定义了与父类中非私有方法同名的方法，而且这两个方法的参数类型相同，那么这两个方法之间又是什么关系呢？</p>
<p>如果这两个方法都是静态的，那么子类中的方法隐藏了父类中的方法。如果这两个方法都不是静态的，且都不是私有的，那么子类的方法重写了父类中的方法。</p>
<p>众所周知，Java 是一门面向对象的编程语言，它的一个重要特性便是多态。而方法重写，正是多态最重要的一种体现方式：它允许子类在继承父类部分功能的同时，拥有自己独特的行为。</p>
<p>打个比方，如果你经常漫游，那么你可能知道，拨打 10086 会根据你当前所在地，连接到当地的客服。重写调用也是如此：它会根据调用者的动态类型，来选取实际的目标方法。</p>
<h5 id="JVM-的静态绑定和动态绑定"><a href="#JVM-的静态绑定和动态绑定" class="headerlink" title="JVM 的静态绑定和动态绑定"></a>JVM 的静态绑定和动态绑定</h5><p>接下来，我们来看看 Java 虚拟机是怎么识别方法的。</p>
<p>Java 虚拟机识别方法的关键在于<strong>类名、方法名以及方法描述符</strong>（method descriptor）。前面两个就不做过多的解释了。至于<u>方法描述符，它是由方法的参数类型以及返回类型所构成</u>。在同一个类中，如果同时出现多个名字相同且描述符也相同的方法，那么 Java 虚拟机会在类的验证阶段报错。</p>
<p>可以看到，Java 虚拟机与 Java 语言不同，它并不限制名字与参数类型相同，但返回类型不同的方法出现在同一个类中，对于调用这些方法的字节码来说，由于字节码所附带的方法描述符包含了返回类型，因此 Java 虚拟机能够准确地识别目标方法。</p>
<p>Java 虚拟机中关于方法重写的判定同样基于方法描述符。也就是说，如果子类定义了与父类中非私有、非静态方法同名的方法，那么只有当这两个方法的参数类型以及返回类型一致，Java 虚拟机才会判定为重写。</p>
<p>对于 Java 语言中重写而 Java 虚拟机中非重写的情况，编译器会通过生成<a href="https://docs.oracle.com/javase/tutorial/java/generics/bridgeMethods.html">桥接方法</a> 来实现 Java 中的重写语义。</p>
<p>由于对重载方法的区分在编译阶段已经完成，我们可以认为 Java 虚拟机不存在重载这一概念。因此，在某些文章中，<u>重载也被称为静态绑定（static binding），或者编译时多态（compile-time polymorphism）；而重写则被称为动态绑定（dynamic binding）</u>。</p>
<p>这个说法在 Java 虚拟机语境下并非完全正确。这是因为某个类中的重载方法可能被它的子类所重写，因此 Java 编译器会将所有对非私有实例方法的调用编译为需要动态绑定的类型。</p>
<p>确切地说，Java 虚拟机中的静态绑定指的是在解析时便能够直接识别目标方法的情况，而动态绑定则指的是需要在运行过程中根据调用者的动态类型来识别目标方法的情况。</p>
<p>具体来说，Java 字节码中与调用相关的指令共有五种。</p>
<ol>
<li><code>invokestatic</code>：用于调用静态方法。</li>
<li><code>invokespecial</code>：用于调用私有实例方法、构造器，以及使用 super 关键字调用父类的实例方法或构造器，和所实现接口的默认方法。</li>
<li><code>invokevirtual</code>：用于调用非私有实例方法。</li>
<li><code>invokeinterface</code>：用于调用接口方法。</li>
<li><code>invokedynamic</code>：用于调用动态方法。</li>
</ol>
<p>由于 invokedynamic 指令较为复杂，我将在后面的篇章中单独介绍。这里我们只讨论前四种。</p>
<p>我在文章中贴了一段代码，展示了编译生成这四种调用指令的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">interface 客户 &#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">isVIP</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class 商户 &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> 折后价格 (<span class="type">double</span> 原价, 客户 某客户) &#123;</span><br><span class="line">    <span class="keyword">return</span> 原价 * <span class="number">0.8d</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class 奸商 extends 商户 &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> 折后价格 (<span class="type">double</span> 原价, 客户 某客户) &#123;</span><br><span class="line">    <span class="keyword">if</span> (某客户.isVIP()) &#123;                         <span class="comment">// invokeinterface      </span></span><br><span class="line">      <span class="keyword">return</span> 原价 * 价格歧视 ();                    <span class="comment">// invokestatic</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">super</span>. 折后价格 (原价, 某客户);          <span class="comment">// invokespecial</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> 价格歧视 () &#123;</span><br><span class="line">    <span class="comment">// 咱们的杀熟算法太粗暴了，应该将客户城市作为随机数生成器的种子。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Random</span>()                          <span class="comment">// invokespecial</span></span><br><span class="line">           .nextDouble()                         <span class="comment">// invokevirtual</span></span><br><span class="line">           + <span class="number">0.8d</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在代码中，“商户”类定义了一个成员方法，叫做“折后价格”，它将接收一个 double 类型的参数，以及一个“客户”类型的参数。这里“客户”是一个接口，它定义了一个接口方法，叫“isVIP”。</p>
<p>我们还定义了另一个叫做“奸商”的类，它继承了“商户”类，并且重写了“折后价格”这个方法。如果客户是 VIP，那么它会被给到一个更低的折扣。</p>
<p>在这个方法中，我们首先会调用“客户”接口的”isVIP“方法。该调用会被编译为 invokeinterface 指令。</p>
<p>如果客户是 VIP，那么我们会调用奸商类的一个名叫“价格歧视”的静态方法。该调用会被编译为 invokestatic 指令。如果客户不是 VIP，那么我们会通过 super 关键字调用父类的“折后价格”方法。该调用会被编译为 invokespecial 指令。</p>
<p>在静态方法“价格歧视”中，我们会调用 Random 类的构造器。该调用会被编译为 invokespecial 指令。然后我们会以这个新建的 Random 对象为调用者，调用 Random 类中的 nextDouble 方法。该调用会被编译为 invokevirutal 指令。</p>
<p>对于 invokestatic 以及 invokespecial 而言，Java 虚拟机能够直接识别具体的目标方法。</p>
<p>而对于 invokevirtual 以及 invokeinterface 而言，在绝大部分情况下，虚拟机需要在执行过程中，根据调用者的动态类型，来确定具体的目标方法。</p>
<p>唯一的例外在于，如果虚拟机能够确定目标方法有且仅有一个，比如说目标方法被标记为 final，那么它可以不通过动态类型，直接确定目标方法。</p>
<h5 id="调用指令的符号引用"><a href="#调用指令的符号引用" class="headerlink" title="调用指令的符号引用"></a>调用指令的符号引用</h5><p>在编译过程中，我们并不知道目标方法的具体内存地址。因此，Java 编译器会暂时用符号引用来表示该目标方法。这一符号引用包括目标方法所在的类或接口的名字，以及目标方法的方法名和方法描述符。</p>
<p>符号引用存储在 class 文件的常量池之中。根据目标方法是否为接口方法，这些引用可分为接口符号引用和非接口符号引用。我在文章中贴了一个例子，利用“javap -v”打印某个类的常量池，如果你感兴趣的话可以到文章中查看。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 在奸商.class 的常量池中，#16 为接口符号引用，指向接口方法 &quot; 客户.isVIP()&quot;。而 #22 为非接口符号引用，指向静态方法 &quot; 奸商. 价格歧视 ()&quot;。</span><br><span class="line">$ javap -v 奸商.class ...</span><br><span class="line">Constant pool:</span><br><span class="line">...</span><br><span class="line">  #16 = InterfaceMethodref #27.#29        // 客户.isVIP:()Z</span><br><span class="line">...</span><br><span class="line">  #22 = Methodref          #1.#33         // 奸商. 价格歧视:()D</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>之前曾提到过，在执行使用了符号引用的字节码前，Java 虚拟机需要解析这些符号引用，并替换为实际引用。</p>
<p>对于<strong>非接口符号引用</strong>，假定该符号引用所指向的类为 C，则 Java 虚拟机会按照如下步骤进行查找。</p>
<ol>
<li>在 C 中查找符合名字及描述符的方法。</li>
<li>如果没有找到，在 C 的父类中继续搜索，直至 Object 类。</li>
<li>如果没有找到，在 C 所直接实现或间接实现的接口中搜索，这一步搜索得到的目标方法必须是非私有、非静态的。并且，如果目标方法在间接实现的接口中，则需满足 C 与该接口之间没有其他符合条件的目标方法。如果有多个符合条件的目标方法，则任意返回其中一个。</li>
</ol>
<p>从这个解析算法可以看出，<strong>静态方法也可以通过子类来调用。此外，子类的静态方法会隐藏（注意与重写区分）父类中的同名、同描述符的静态方法。</strong></p>
<p>对于<strong>接口符号引用</strong>，假定该符号引用所指向的接口为 I，则 Java 虚拟机会按照如下步骤进行查找。</p>
<ol>
<li>在 I 中查找符合名字及描述符的方法。</li>
<li>如果没有找到，在 Object 类中的公有实例方法中搜索。</li>
<li>如果没有找到，则在 I 的超接口中搜索。这一步的搜索结果的要求与非接口符号引用步骤 3 的要求一致。</li>
</ol>
<p>经过上述的解析步骤之后，符号引用会被解析成实际引用。对于可以静态绑定的方法调用而言，实际引用是一个指向方法的指针。对于需要动态绑定的方法调用而言，实际引用则是一个方法表的索引。具体什么是方法表，我会在下一篇中做出解答。</p>
<h3 id="05-JVM是如何执行方法调用的？（下）"><a href="#05-JVM是如何执行方法调用的？（下）" class="headerlink" title="05. JVM是如何执行方法调用的？（下）"></a>05. JVM是如何执行方法调用的？（下）</h3><p>聊一聊 Java 虚拟机中虚方法调用的具体实现。</p>
<p>首先，我们来看一个模拟出国边检的小例子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Passenger</span> &#123;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">passThroughImmigration</span><span class="params">()</span>;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ForeignerPassenger</span> <span class="keyword">extends</span> <span class="title class_">Passenger</span> &#123;</span><br><span class="line">	 <span class="meta">@Override</span></span><br><span class="line"> 	<span class="keyword">void</span> <span class="title function_">passThroughImmigration</span><span class="params">()</span> &#123; <span class="comment">/* 进外国人通道 */</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChinesePassenger</span> <span class="keyword">extends</span> <span class="title class_">Passenger</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">passThroughImmigration</span><span class="params">()</span> &#123; <span class="comment">/* 进中国人通道 */</span> &#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">visitDutyFreeShops</span><span class="params">()</span> &#123; <span class="comment">/* 逛免税店 */</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">Passenger</span> <span class="variable">passenger</span> <span class="operator">=</span> ...</span><br><span class="line">passenger.passThroughImmigration();</span><br></pre></td></tr></table></figure>

<p>这里我定义了一个抽象类，叫做 Passenger，这个类中有一个名为 passThroughImmigration 的抽象方法，以及重写自 Object 类的 toString 方法。</p>
<p>然后，我将 Passenger 粗暴地分为两种：ChinesePassenger 和 ForeignerPassenger。</p>
<p>两个类分别实现了 passThroughImmigration 这个方法，具体来说，就是中国人走中国人通道，外国人走外国人通道。由于咱们储蓄较多，所以我在 ChinesePassenger 这个类中，还特意添加了一个叫做 visitDutyFreeShops 的方法。</p>
<p>那么在实际运行过程中，Java 虚拟机是如何高效地确定每个 Passenger 实例应该去哪条通道的呢？我们一起来看一下。</p>
<h4 id="1-虚方法调用"><a href="#1-虚方法调用" class="headerlink" title="1. 虚方法调用"></a>1. 虚方法调用</h4><p>在上一篇中我曾经提到，Java 里所有非私有实例方法调用都会被编译成 invokevirtual 指令，而接口方法调用都会被编译成 invokeinterface 指令。这两种指令，均属于 Java 虚拟机中的虚方法调用。</p>
<p>在绝大多数情况下，Java 虚拟机需要根据调用者的动态类型，来确定虚方法调用的目标方法。这个过程我们称之为动态绑定。那么，相对于静态绑定的非虚方法调用来说，虚方法调用更加耗时。</p>
<p>在 Java 虚拟机中，静态绑定包括用于调用静态方法的 invokestatic 指令，和用于调用构造器、私有实例方法以及超类非私有实例方法的 invokespecial 指令。如果虚方法调用指向一个标记为 final 的方法，那么 Java 虚拟机也可以静态绑定该虚方法调用的目标方法。</p>
<p><u>Java 虚拟机中采取了一种用空间换取时间的策略来实现动态绑定。它为每个类生成一张方法表，用以快速定位目标方法。</u>那么方法表具体是怎样实现的呢？</p>
<h4 id="2-方法表"><a href="#2-方法表" class="headerlink" title="2. 方法表"></a>2. 方法表</h4><p>在介绍类加载机制的链接部分中，曾提到类加载的准备阶段，它除了为静态字段分配内存之外，还会构造与该类相关联的方法表。</p>
<p>这个数据结构，便是 Java 虚拟机实现动态绑定的关键所在。下面我将以 invokevirtual 所使用的虚方法表（virtual method table，vtable）为例介绍方法表的用法。invokeinterface 所使用的接口方法表（interface method table，itable）稍微复杂些，但是原理其实是类似的。</p>
<p>方法表本质上是一个数组，每个数组元素指向一个当前类及其祖先类中非私有的实例方法。</p>
<p>这些方法可能是具体的、可执行的方法，也可能是没有相应字节码的抽象方法。方法表满足两个特质：<u>其一，子类方法表中包含父类方法表中的所有方法；其二，子类方法在方法表中的索引值，与它所重写的父类方法的索引值相同。</u></p>
<p>我们知道，方法调用指令中的符号引用会在执行之前解析成实际引用。对于静态绑定的方法调用而言，实际引用将指向具体的目标方法。对于动态绑定的方法调用而言，实际引用则是方法表的索引值（实际上并不仅是索引值）。</p>
<p>在执行过程中，Java 虚拟机将获取调用者的实际类型，并在该实际类型的虚方法表中，根据索引值获得目标方法。这个过程便是动态绑定。</p>
<p><img src="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/assets/f1ff9dcb297a458981bd1d189a5b04c3.png" alt="img"></p>
<p>在我们的例子中，Passenger 类的方法表包括两个方法：</p>
<ul>
<li>toString</li>
<li>passThroughImmigration，</li>
</ul>
<p>它们分别对应 0 号和 1 号。之所以方法表调换了 toString 方法和 passThroughImmigration 方法的位置，是因为 toString 方法的索引值需要与 Object 类中同名方法的索引值一致。为了保持简洁，这里我就不考虑 Object 类中的其他方法。</p>
<p>ForeignerPassenger 的方法表同样有两行。其中，0 号方法指向继承而来的 Passenger 类的 toString 方法。1 号方法则指向自己重写的 passThroughImmigration 方法。</p>
<p>ChinesePassenger 的方法表则包括三个方法，除了继承而来的 Passenger 类的 toString 方法，自己重写的 passThroughImmigration 方法之外，还包括独有的 visitDutyFreeShops 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Passenger</span> <span class="variable">passenger</span> <span class="operator">=</span> ...</span><br><span class="line">passenger.passThroughImmigration();</span><br></pre></td></tr></table></figure>

<p>这里，Java 虚拟机的工作可以想象为导航员。每当来了一个乘客需要出境，导航员会先问是中国人还是外国人（获取动态类型），然后翻出中国人 &#x2F; 外国人对应的小册子（获取动态类型的方法表），小册子的第 1 页便写着应该到哪条通道办理出境手续（用 1 作为索引来查找方法表所对应的目标方法）。</p>
<p>实际上，使用了方法表的动态绑定与静态绑定相比，仅仅多出几个内存解引用操作：访问栈上的调用者，读取调用者的动态类型，读取该类型的方法表，读取方法表中某个索引值所对应的目标方法。相对于创建并初始化 Java 栈帧来说，这几个内存解引用操作的开销简直可以忽略不计。</p>
<p>那么我们是否可以认为虚方法调用对性能没有太大影响呢？</p>
<p>其实是不能的，上述优化的效果看上去十分美好，但实际上仅存在于解释执行中，或者即时编译代码的最坏情况中。这是因为即时编译还拥有另外两种性能更好的优化手段：内联缓存（inlining cache）和方法内联（method inlining）。下面我便来介绍第一种内联缓存。</p>
<h4 id="3-内联缓存"><a href="#3-内联缓存" class="headerlink" title="3. 内联缓存"></a>3. 内联缓存</h4><p>内联缓存是一种加快动态绑定的优化技术。它能够缓存虚方法调用中调用者的动态类型，以及该类型所对应的目标方法。在之后的执行过程中，如果碰到已缓存的类型，内联缓存便会直接调用该类型所对应的目标方法。如果没有碰到已缓存的类型，内联缓存则会退化至使用基于方法表的动态绑定。</p>
<p>在我们的例子中，这相当于导航员记住了上一个出境乘客的国籍和对应的通道，例如中国人，走了左边通道出境。那么下一个乘客想要出境的时候，导航员会先问是不是中国人，是的话就走左边通道。如果不是的话，只好拿出外国人的小册子，翻到第 1 页，再告知查询结果：右边。</p>
<p>在针对多态的优化手段中，我们通常会提及以下三个术语。</p>
<ol>
<li>单态（monomorphic）指的是仅有一种状态的情况。</li>
<li>多态（polymorphic）指的是有限数量种状态的情况。二态（bimorphic）是多态的其中一种。</li>
<li>超多态（megamorphic）指的是更多种状态的情况。通常我们用一个具体数值来区分多态和超多态。在这个数值之下，我们称之为多态。否则，我们称之为超多态。</li>
</ol>
<p>对于内联缓存来说，我们也有对应的单态内联缓存、多态内联缓存和超多态内联缓存。单态内联缓存，顾名思义，便是只缓存了一种动态类型以及它所对应的目标方法。它的实现非常简单：比较所缓存的动态类型，如果命中，则直接调用对应的目标方法。</p>
<p>多态内联缓存则缓存了多个动态类型及其目标方法。它需要逐个将所缓存的动态类型与当前动态类型进行比较，如果命中，则调用对应的目标方法。</p>
<p>一般来说，我们会将更加热门的动态类型放在前面。在实践中，大部分的虚方法调用均是单态的，也就是只有一种动态类型。为了节省内存空间，Java 虚拟机只采用单态内联缓存。</p>
<p>前面提到，当内联缓存没有命中的情况下，Java 虚拟机需要重新使用方法表进行动态绑定。对于内联缓存中的内容，我们有两种选择。一是替换单态内联缓存中的纪录。这种做法就好比 CPU 中的数据缓存，它对数据的局部性有要求，即在替换内联缓存之后的一段时间内，方法调用的调用者的动态类型应当保持一致，从而能够有效地利用内联缓存。</p>
<p>因此，在最坏情况下，我们用两种不同类型的调用者，轮流执行该方法调用，那么每次进行方法调用都将替换内联缓存。也就是说，只有写缓存的额外开销，而没有用缓存的性能提升。</p>
<p>另外一种选择则是劣化为超多态状态。这也是 Java 虚拟机的具体实现方式。处于这种状态下的内联缓存，实际上放弃了优化的机会。它将直接访问方法表，来动态绑定目标方法。与替换内联缓存纪录的做法相比，它牺牲了优化的机会，但是节省了写缓存的额外开销。</p>
<p>具体到我们的例子，如果来了一队乘客，其中外国人和中国人依次隔开，那么在重复使用的单态内联缓存中，导航员需要反复记住上个出境的乘客，而且记住的信息在处理下一乘客时又会被替换掉。因此，倒不如一直不记，以.此来节省脑细胞。</p>
<p>虽然内联缓存附带内联二字，但是它并没有内联目标方法。这里需要明确的是，任何方法调用除非被内联，否则都会有固定开销。这些开销来源于保存程序在该方法中的执行位置，以及新建、压入和弹出新方法所使用的栈帧。</p>
<p>对于极其简单的方法而言，比如说 getter&#x2F;setter，这部分固定开销占据的 CPU 时间甚至超过了方法本身。此外，在即时编译中，方法内联不仅仅能够消除方法调用的固定开销，而且还增加了进一步优化的可能性，我们会在专栏的第二部分详细介绍方法内联的内容。</p>
<h3 id="06-JVM是如何处理异常的？"><a href="#06-JVM是如何处理异常的？" class="headerlink" title="06. JVM是如何处理异常的？"></a>06. JVM是如何处理异常的？</h3><p>讲讲 Java 虚拟机的异常处理。</p>
<p>众所周知，异常处理的两大组成要素是抛出异常和捕获异常。这两大要素共同实现程序控制流的非正常转移。</p>
<p>抛出异常可分为显式和隐式两种。显式抛异常的主体是应用程序，它指的是在程序中使用“throw”关键字，手动将异常实例抛出。</p>
<p>隐式抛异常的主体则是 Java 虚拟机，它指的是 Java 虚拟机在执行过程中，碰到无法继续执行的异常状态，自动抛出异常。举例来说，Java 虚拟机在执行读取数组操作时，发现输入的索引值是负数，故而抛出数组索引越界异常（ArrayIndexOutOfBoundsException）。</p>
<p>捕获异常则涉及了如下三种代码块。</p>
<ol>
<li><p>try 代码块：用来标记需要进行异常监控的代码。</p>
</li>
<li><p>catch 代码块：跟在 try 代码块之后，用来捕获在 try 代码块中触发的某种指定类型的异常。除了声明所捕获异常的类型之外，catch 代码块还定义了针对该异常类型的异常处理器。在 Java 中，try 代码块后面可以跟着多个 catch 代码块，来捕获不同类型的异常。Java 虚拟机会从上至下匹配异常处理器。因此，前面的 catch 代码块所捕获的异常类型不能覆盖后边的，否则编译器会报错。</p>
</li>
<li><p>finally 代码块：跟在 try 代码块和 catch 代码块之后，用来声明一段必定运行的代码。它的设计初衷是为了避免跳过某些关键的清理代码，例如关闭已打开的系统资源。</p>
<p>在程序正常执行的情况下，这段代码会在 try 代码块之后运行。否则，也就是 try 代码块触发异常的情况下，如果该异常没有被捕获，finally 代码块会直接运行，并且在运行之后重新抛出该异常。</p>
<p>如果该异常被 catch 代码块捕获，finally 代码块则在 catch 代码块之后运行。在某些不幸的情况下，catch 代码块也触发了异常，那么 finally 代码块同样会运行，并会抛出 catch 代码块触发的异常。在某些极端不幸的情况下，finally 代码块也触发了异常，那么只好中断当前 finally 代码块的执行，并往外抛异常。</p>
</li>
</ol>
<h4 id="异常的基本概念"><a href="#异常的基本概念" class="headerlink" title="异常的基本概念"></a>异常的基本概念</h4><p>在 Java 语言规范中，所有异常都是 Throwable 类或者其子类的实例。Throwable 有两大直接子类。第一个是 Error，涵盖程序不应捕获的异常。<u>当程序触发 Error 时，它的执行状态已经无法恢复，需要中止线程甚至是中止虚拟机</u>。第二子类则是 Exception，涵盖程序可能需要捕获并且处理的异常。</p>
<img src="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/assets/47c8429fc30aec201286b47f3c1a5993.png" alt="img" style="zoom: 25%;" />

<p>Exception 有一个特殊的子类 RuntimeException，用来表示“程序虽然无法继续执行，但是还能抢救一下”的情况。前边提到的数组索引越界便是其中的一种。</p>
<p>RuntimeException 和 Error 属于 Java 里的非检查异常（unchecked exception）。其他异常则属于检查异常（checked exception）。在 Java 语法中，所有的检查异常都需要程序显式地捕获，或者在方法声明中用 throws 关键字标注。通常情况下，程序中自定义的异常应为检查异常，以便最大化利用 Java 编译器的编译时检查。</p>
<p><u>异常实例的构造十分昂贵。这是由于在构造异常实例时，Java 虚拟机便需要生成该异常的栈轨迹（stack trace）。该操作会逐一访问当前线程的 Java 栈帧，并且记录下各种调试信息，包括栈帧所指向方法的名字，方法所在的类名、文件名，以及在代码中的第几行触发该异常。</u></p>
<p>当然，在生成栈轨迹时，Java 虚拟机会忽略掉异常构造器以及填充栈帧的 Java 方法（Throwable.fillInStackTrace），直接从新建异常位置开始算起。此外，Java 虚拟机还会忽略标记为不可见的 Java 方法栈帧。我们在介绍 Lambda 的时候会看到具体的例子。</p>
<p>既然异常实例的构造十分昂贵，我们是否可以缓存异常实例，在需要用到的时候直接抛出呢？从语法角度上来看，这是允许的。然而，该异常对应的栈轨迹并非 throw 语句的位置，而是新建异常的位置。</p>
<p>因此，这种做法可能会误导开发人员，使其定位到错误的位置。这也是为什么在实践中，我们往往选择抛出新建异常实例的原因。</p>
<h4 id="Java-虚拟机是如何捕获异常的？"><a href="#Java-虚拟机是如何捕获异常的？" class="headerlink" title="Java 虚拟机是如何捕获异常的？"></a>Java 虚拟机是如何捕获异常的？</h4><p>在编译生成的字节码中，每个方法都附带一个异常表。异常表中的每一个条目代表一个异常处理器，并且由 from 指针、to 指针、target 指针以及所捕获的异常类型构成。这些指针的值是字节码索引（bytecode index，bci），用以定位字节码。</p>
<p>其中，from 指针和 to 指针标示了该异常处理器所监控的范围，例如 try 代码块所覆盖的范围。target 指针则指向异常处理器的起始位置，例如 catch 代码块的起始位置。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">static</span> <span class="keyword">void</span> <span class="title function_ invoke__">main</span>(String[] args) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">mayThrowException</span>();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (<span class="built_in">Exception</span> e) &#123;</span><br><span class="line">    e.<span class="title function_ invoke__">printStackTrace</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对应的 Java 字节码</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">static</span> <span class="keyword">void</span> <span class="title function_ invoke__">main</span>(java.lang.String[]);</span><br><span class="line">  Code:</span><br><span class="line">    <span class="number">0</span>: invokestatic mayThrowException:()V</span><br><span class="line">    <span class="number">3</span>: <span class="keyword">goto</span> <span class="number">11</span></span><br><span class="line">    <span class="number">6</span>: astore_1</span><br><span class="line">    <span class="number">7</span>: aload_1</span><br><span class="line">    <span class="number">8</span>: invokevirtual java.lang.<span class="built_in">Exception</span>.printStackTrace</span><br><span class="line">   <span class="number">11</span>: <span class="keyword">return</span></span><br><span class="line">  <span class="built_in">Exception</span> table:</span><br><span class="line">    <span class="keyword">from</span>  to target type</span><br><span class="line">      <span class="number">0</span>   <span class="number">3</span>   <span class="number">6</span>  Class java/lang/<span class="built_in">Exception</span>  <span class="comment">// 异常表条目</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>举个例子，在上图的 main 方法中，我定义了一段 try-catch 代码。其中，catch 代码块所捕获的异常类型为 Exception。</p>
<p>编译过后，该方法的异常表拥有一个条目。其 from 指针和 to 指针分别为 0 和 3，代表它的监控范围从索引为 0 的字节码开始，到索引为 3 的字节码结束（不包括 3）。该条目的 target 指针是 6，代表这个异常处理器从索引为 6 的字节码开始。条目的最后一列，代表该异常处理器所捕获的异常类型正是 Exception。</p>
<p>当程序触发异常时，Java 虚拟机会从上至下遍历异常表中的所有条目。当触发异常的字节码的索引值在某个异常表条目的监控范围内，Java 虚拟机会判断所抛出的异常和该条目想要捕获的异常是否匹配。如果匹配，Java 虚拟机会将控制流转移至该条目 target 指针指向的字节码。</p>
<p>如果遍历完所有异常表条目，Java 虚拟机仍未匹配到异常处理器，那么它会弹出当前方法对应的 Java 栈帧，并且在调用者（caller）中重复上述操作。在最坏情况下，Java 虚拟机需要遍历当前线程 Java 栈上所有方法的异常表。</p>
<p>finally 代码块的编译比较复杂。当前版本 Java 编译器的做法，是复制 finally 代码块的内容，分别放在 try-catch 代码块所有正常执行路径以及异常执行路径的出口中。</p>
<p><img src="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/assets/17e2a3053b06b0a4383884f106e31c06.png" alt="img"></p>
<p>针对异常执行路径，Java 编译器会生成一个或多个异常表条目，监控整个 try-catch 代码块，并且捕获所有种类的异常（在 javap 中以 any 指代）。这些异常表条目的 target 指针将指向另一份复制的 finally 代码块。并且，在这个 finally 代码块的最后，Java 编译器会重新抛出所捕获的异常。</p>
<p>如果你感兴趣的话，可以用 javap 工具来查看下面这段包含了 try-catch-finally 代码块的编译结果。为了更好地区分每个代码块，我定义了四个实例字段：tryBlock、catchBlock、finallyBlock、以及 methodExit，并且仅在对应的代码块中访问这些字段。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">public</span> <span class="string">class</span> <span class="string">Foo</span> &#123;</span><br><span class="line">  <span class="string">private</span> <span class="string">int</span> <span class="string">tryBlock;</span></span><br><span class="line">  <span class="string">private</span> <span class="string">int</span> <span class="string">catchBlock;</span></span><br><span class="line">  <span class="string">private</span> <span class="string">int</span> <span class="string">finallyBlock;</span></span><br><span class="line">  <span class="string">private</span> <span class="string">int</span> <span class="string">methodExit;</span></span><br><span class="line"> </span><br><span class="line">  <span class="string">public</span> <span class="string">void</span> <span class="string">test()</span> &#123;</span><br><span class="line">    <span class="string">try</span> &#123;</span><br><span class="line">      <span class="string">tryBlock</span> <span class="string">=</span> <span class="number">0</span><span class="string">;</span></span><br><span class="line">    &#125; <span class="string">catch</span> <span class="string">(Exception</span> <span class="string">e)</span> &#123;</span><br><span class="line">      <span class="string">catchBlock</span> <span class="string">=</span> <span class="number">1</span><span class="string">;</span></span><br><span class="line">    &#125; <span class="string">finally</span> &#123;</span><br><span class="line">      <span class="string">finallyBlock</span> <span class="string">=</span> <span class="number">2</span><span class="string">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="string">methodExit</span> <span class="string">=</span> <span class="number">3</span><span class="string">;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="string">$</span> <span class="string">javap</span> <span class="string">-c</span> <span class="string">Foo</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line">  <span class="string">public</span> <span class="string">void</span> <span class="string">test();</span></span><br><span class="line">    <span class="attr">Code:</span></span><br><span class="line">       <span class="attr">0:</span> <span class="string">aload_0</span></span><br><span class="line">       <span class="attr">1:</span> <span class="string">iconst_0</span></span><br><span class="line">       <span class="attr">2:</span> <span class="string">putfield</span>      <span class="comment">#20                 // Field tryBlock:I</span></span><br><span class="line">       <span class="attr">5:</span> <span class="string">goto</span>          <span class="number">30</span></span><br><span class="line">       <span class="attr">8:</span> <span class="string">astore_1</span></span><br><span class="line">       <span class="attr">9:</span> <span class="string">aload_0</span></span><br><span class="line">      <span class="attr">10:</span> <span class="string">iconst_1</span></span><br><span class="line">      <span class="attr">11:</span> <span class="string">putfield</span>      <span class="comment">#22                 // Field catchBlock:I</span></span><br><span class="line">      <span class="attr">14:</span> <span class="string">aload_0</span></span><br><span class="line">      <span class="attr">15:</span> <span class="string">iconst_2</span></span><br><span class="line">      <span class="attr">16:</span> <span class="string">putfield</span>      <span class="comment">#24                 // Field finallyBlock:I</span></span><br><span class="line">      <span class="attr">19:</span> <span class="string">goto</span>          <span class="number">35</span></span><br><span class="line">      <span class="attr">22:</span> <span class="string">astore_2</span></span><br><span class="line">      <span class="attr">23:</span> <span class="string">aload_0</span></span><br><span class="line">      <span class="attr">24:</span> <span class="string">iconst_2</span></span><br><span class="line">      <span class="attr">25:</span> <span class="string">putfield</span>      <span class="comment">#24                 // Field finallyBlock:I</span></span><br><span class="line">      <span class="attr">28:</span> <span class="string">aload_2</span></span><br><span class="line">      <span class="attr">29:</span> <span class="string">athrow</span></span><br><span class="line">      <span class="attr">30:</span> <span class="string">aload_0</span></span><br><span class="line">      <span class="attr">31:</span> <span class="string">iconst_2</span></span><br><span class="line">      <span class="attr">32:</span> <span class="string">putfield</span>      <span class="comment">#24                 // Field finallyBlock:I</span></span><br><span class="line">      <span class="attr">35:</span> <span class="string">aload_0</span></span><br><span class="line">      <span class="attr">36:</span> <span class="string">iconst_3</span></span><br><span class="line">      <span class="attr">37:</span> <span class="string">putfield</span>      <span class="comment">#26                 // Field methodExit:I</span></span><br><span class="line">      <span class="attr">40:</span> <span class="string">return</span></span><br><span class="line">    <span class="attr">Exception table:</span></span><br><span class="line">       <span class="string">from</span>    <span class="string">to</span>  <span class="string">target</span> <span class="string">type</span></span><br><span class="line">           <span class="number">0</span>     <span class="number">5</span>     <span class="number">8</span>   <span class="string">Class</span> <span class="string">java/lang/Exception</span></span><br><span class="line">           <span class="number">0</span>    <span class="number">14</span>    <span class="number">22</span>   <span class="string">any</span></span><br><span class="line"> </span><br><span class="line">  <span class="string">...</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>可以看到，编译结果包含三份 finally 代码块。其中，前两份分别位于 try 代码块和 catch 代码块的正常执行路径出口。最后一份则作为异常处理器，监控 try 代码块以及 catch 代码块。它将捕获 try 代码块触发的、未被 catch 代码块捕获的异常，以及 catch 代码块触发的异常。</p>
<p>这里有一个小问题，如果 catch 代码块捕获了异常，并且触发了另一个异常，那么 finally 捕获并且重抛的异常是哪个呢？答案是后者。也就是说原本的异常便会被忽略掉，这对于代码调试来说十分不利。</p>
<h4 id="Java-7-的-Supressed-异常以及语法糖"><a href="#Java-7-的-Supressed-异常以及语法糖" class="headerlink" title="Java 7 的 Supressed 异常以及语法糖"></a>Java 7 的 Supressed 异常以及语法糖</h4><p>Java 7 引入了 Supressed 异常来解决这个问题。这个新特性允许开发人员将一个异常附于另一个异常之上。因此，抛出的异常可以附带多个异常的信息。</p>
<p>然而，Java 层面的 finally 代码块缺少指向所捕获异常的引用，所以这个新特性使用起来非常繁琐。</p>
<p>为此，Java 7 专门构造了一个名为 try-with-resources 的语法糖，在字节码层面自动使用 Supressed 异常。当然，该语法糖的主要目的并不是使用 Supressed 异常，而是精简资源打开关闭的用法。</p>
<p>在 Java 7 之前，对于打开的资源，我们需要定义一个 finally 代码块，来确保该资源在正常或者异常执行状况下都能关闭。</p>
<p>资源的关闭操作本身容易触发异常。因此，如果同时打开多个资源，那么每一个资源都要对应一个独立的 try-finally 代码块，以保证每个资源都能够关闭。这样一来，代码将会变得十分繁琐。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">in0</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">in1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">in2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  in0 = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;in0.txt&quot;</span>));</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    in1 = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;in1.txt&quot;</span>));</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      in2 = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;in2.txt&quot;</span>));</span><br><span class="line">      ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (in2 != <span class="literal">null</span>) in2.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (in1 != <span class="literal">null</span>) in1.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (in0 != <span class="literal">null</span>) in0.close();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>Java 7 的 try-with-resources 语法糖，极大地简化了上述代码。<u>程序可以在 try 关键字后声明并实例化实现了 AutoCloseable 接口的类，编译器将自动添加对应的 close() 操作。</u>在声明多个 AutoCloseable 实例的情况下，编译生成的字节码类似于上面手工编写代码的编译结果。与手工代码相比，try-with-resources 还会使用 Supressed 异常的功能，来避免原异常“被消失”。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_ invoke__">Foo</span>(String name) &#123; this.name = name; &#125;</span><br><span class="line"> </span><br><span class="line">  @Override</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_ invoke__">close</span>() &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">RuntimeException</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">static</span> <span class="keyword">void</span> <span class="title function_ invoke__">main</span>(String[] args) &#123;</span><br><span class="line">    <span class="keyword">try</span> (Foo foo0 = <span class="keyword">new</span> <span class="title class_">Foo</span>(<span class="string">&quot;Foo0&quot;</span>); <span class="comment">// try-with-resources</span></span><br><span class="line">         Foo foo1 = <span class="keyword">new</span> <span class="title class_">Foo</span>(<span class="string">&quot;Foo1&quot;</span>);</span><br><span class="line">         Foo foo2 = <span class="keyword">new</span> <span class="title class_">Foo</span>(<span class="string">&quot;Foo2&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">RuntimeException</span>(<span class="string">&quot;Initial&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="built_in">Exception</span> in thread <span class="string">&quot;main&quot;</span> java.lang.<span class="built_in">RuntimeException</span>: Initial</span><br><span class="line">        at Foo.<span class="title function_ invoke__">main</span>(Foo.<span class="attr">java</span>:<span class="number">18</span>)</span><br><span class="line">        Suppressed: java.lang.<span class="built_in">RuntimeException</span>: Foo2</span><br><span class="line">                at Foo.<span class="title function_ invoke__">close</span>(Foo.<span class="attr">java</span>:<span class="number">13</span>)</span><br><span class="line">                at Foo.<span class="title function_ invoke__">main</span>(Foo.<span class="attr">java</span>:<span class="number">19</span>)</span><br><span class="line">        Suppressed: java.lang.<span class="built_in">RuntimeException</span>: Foo1</span><br><span class="line">                at Foo.<span class="title function_ invoke__">close</span>(Foo.<span class="attr">java</span>:<span class="number">13</span>)</span><br><span class="line">                at Foo.<span class="title function_ invoke__">main</span>(Foo.<span class="attr">java</span>:<span class="number">19</span>)</span><br><span class="line">        Suppressed: java.lang.<span class="built_in">RuntimeException</span>: Foo0</span><br><span class="line">                at Foo.<span class="title function_ invoke__">close</span>(Foo.<span class="attr">java</span>:<span class="number">13</span>)</span><br><span class="line">                at Foo.<span class="title function_ invoke__">main</span>(Foo.<span class="attr">java</span>:<span class="number">19</span>)</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>除了 try-with-resources 语法糖之外，Java 7 还支持在同一 catch 代码块中捕获多种异常。实际实现非常简单，生成多个异常表条目即可。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在同一 catch 代码块中捕获多种异常</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">catch</span> (SomeException | OtherException e) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="07-JVM是如何实现反射的？"><a href="#07-JVM是如何实现反射的？" class="headerlink" title="07. JVM是如何实现反射的？"></a>07. JVM是如何实现反射的？</h3><p>反射是 Java 语言中一个相当重要的特性，它允许正在运行的 Java 程序观测，甚至是修改程序的动态行为。</p>
<p>举例来说，我们可以通过 Class 对象枚举该类中的所有方法，我们还可以通过 Method.setAccessible（位于 java.lang.reflect 包，该方法继承自 AccessibleObject）绕过 Java 语言的访问权限，在私有方法所在类之外的地方调用该方法。</p>
<p>反射在 Java 中的应用十分广泛。开发人员日常接触到的 Java 集成开发环境（IDE）便运用了这一功能：每当我们敲入点号时，IDE 便会根据点号前的内容，动态展示可以访问的字段或者方法。</p>
<p>另一个日常应用则是 Java 调试器，它能够在调试过程中枚举某一对象所有字段的值。</p>
<img src="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/assets/ceeabb2dbdd80577feaecd0879e42675.png" alt="img" style="zoom:50%;" />

<p>（图中 eclipse 的自动提示使用了反射）</p>
<p>在 Web 开发中，我们经常能够接触到各种可配置的通用框架。为了保证框架的可扩展性，它们往往借助 Java 的反射机制，根据配置文件来加载不同的类。举例来说，Spring 框架的依赖反转（IoC），便是依赖于反射机制。</p>
<p>然而，我相信不少开发人员都嫌弃反射机制比较慢。甚至是甲骨文关于反射的教学网页，也强调了反射性能开销大的缺点。</p>
<p>今天我们便来了解一下反射的实现机制，以及它性能糟糕的原因。</p>
<p>首先，我们来看看方法的反射调用，也就是 Method.invoke，是怎么实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Method</span> <span class="keyword">extends</span> <span class="title class_">Executable</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object obj, Object... args)</span> <span class="keyword">throws</span> ... &#123;</span><br><span class="line">    ... <span class="comment">// 权限检查</span></span><br><span class="line">    <span class="type">MethodAccessor</span> <span class="variable">ma</span> <span class="operator">=</span> methodAccessor;</span><br><span class="line">    <span class="keyword">if</span> (ma == <span class="literal">null</span>) &#123;</span><br><span class="line">      ma = acquireMethodAccessor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ma.invoke(obj, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>如果你查阅 Method.invoke 的源代码，那么你会发现，它实际上委派给 MethodAccessor 来处理。MethodAccessor 是一个接口，它有两个已有的具体实现：一个通过本地方法来实现反射调用，另一个则使用了委派模式。为了方便记忆，我便用“本地实现”和“委派实现”来指代这两者。</p>
<p>每个 Method 实例的第一次反射调用都会生成一个委派实现，它所委派的具体实现便是一个本地实现。本地实现非常容易理解。当进入了 Java 虚拟机内部之后，我们便拥有了 Method 实例所指向方法的具体地址。这时候，反射调用无非就是将传入的参数准备好，然后调用进入目标方法。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v0 版本</span></span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">target</span>(<span class="params"><span class="built_in">int</span> i</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> Exception(<span class="string">&quot;#&quot;</span> + i).printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) throws Exception</span> &#123;</span><br><span class="line">    Class&lt;?&gt; klass = Class.forName(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">    Method method = klass.getMethod(<span class="string">&quot;target&quot;</span>, <span class="built_in">int</span>.<span class="keyword">class</span>);</span><br><span class="line">    method.invoke(<span class="literal">null</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta"># 不同版本的输出略有不同，这里我使用了 Java 10。</span></span><br><span class="line">$ java Test</span><br><span class="line">java.lang.Exception: <span class="meta">#0</span></span><br><span class="line">        at Test.target(Test.java:<span class="number">5</span>)</span><br><span class="line">        at java.<span class="keyword">base</span>/jdk.<span class="keyword">internal</span>.reflect.NativeMethodAccessorImpl .invoke0(Native Method)</span><br><span class="line"> a      t java.<span class="keyword">base</span>/jdk.<span class="keyword">internal</span>.reflect.NativeMethodAccessorImpl. .invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line"> t       java.<span class="keyword">base</span>/jdk.<span class="keyword">internal</span>.reflect.DelegatingMethodAccessorImpl.i .invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">        java.<span class="keyword">base</span>/java.lang.reflect.Method.invoke(Method.java:<span class="number">564</span>)</span><br><span class="line">  t        Test.main(Test.java:<span class="number">131</span></span><br></pre></td></tr></table></figure>

<p>为了方便理解，我们可以打印一下反射调用到目标方法时的栈轨迹。在上面的 v0 版本代码中，我们获取了一个指向 Test.target 方法的 Method 对象，并且用它来进行反射调用。在 Test.target 中，我会打印出栈轨迹。</p>
<p>可以看到，反射调用先是调用了 Method.invoke，然后进入委派实现（DelegatingMethodAccessorImpl），再然后进入本地实现（NativeMethodAccessorImpl），最后到达目标方法。</p>
<p>这里你可能会疑问，为什么反射调用还要采取委派实现作为中间层？直接交给本地实现不可以么？</p>
<p>其实，Java 的反射调用机制还设立了另一种动态生成字节码的实现（下称动态实现），直接使用 invoke 指令来调用目标方法。之所以采用委派实现，便是为了能够在本地实现以及动态实现中切换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态实现的伪代码，这里只列举了关键的调用逻辑，其实它还包括调用者检测、参数检测的字节码。</span></span><br><span class="line"><span class="keyword">package</span> jdk.internal.reflect;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GeneratedMethodAccessor1</span> extends ... &#123;</span><br><span class="line">  <span class="meta">@Overrides</span>    </span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object obj, Object[] args)</span> <span class="keyword">throws</span> ... &#123;</span><br><span class="line">    Test.target((<span class="type">int</span>) args[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态实现和本地实现相比，其运行效率要快上 20 倍 [2] 。这是因为动态实现无需经过 Java 到 C++ 再到 Java 的切换，但由于生成字节码十分耗时，仅调用一次的话，反而是本地实现要快上 3 到 4 倍 [3]。</p>
<p>考虑到许多反射调用仅会执行一次，Java 虚拟机设置了一个阈值 15（可以通过 -Dsun.reflect.inflationThreshold&#x3D; 来调整），当某个反射调用的调用次数在 15 之下时，采用本地实现；当达到 15 时，便开始动态生成字节码，并将委派实现的委派对象切换至动态实现，这个过程我们称之为 Inflation。</p>
<p>为了观察这个过程，我将刚才的例子更改为下面的 v1 版本。它会将反射调用循环 20 次。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v1 版本</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">target</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Exception</span>(<span class="string">&quot;#&quot;</span> + i).<span class="built_in">printStackTrace</span>();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(String[] args)</span> throws Exception </span>&#123;</span><br><span class="line">    Class&lt;?&gt; klass = Class.forName(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">    Method method = klass.<span class="built_in">getMethod</span>(<span class="string">&quot;target&quot;</span>, <span class="type">int</span>.<span class="keyword">class</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">      method.<span class="built_in">invoke</span>(null, i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"># 使用 -verbose:<span class="keyword">class</span> 打印加载的类</span><br><span class="line">$ java -verbose:<span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">...</span><br><span class="line">java.lang.Exception: #<span class="number">14</span></span><br><span class="line">        at Test.<span class="built_in">target</span>(Test.java:<span class="number">5</span>)</span><br><span class="line">        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl .<span class="built_in">invoke0</span>(Native Method)</span><br><span class="line">        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl .<span class="built_in">invoke</span>(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">        at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl .<span class="built_in">invoke</span>(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">        at java.base/java.lang.reflect.Method.<span class="built_in">invoke</span>(Method.java:<span class="number">564</span>)</span><br><span class="line">        at Test.<span class="built_in">main</span>(Test.java:<span class="number">12</span>)</span><br><span class="line">[<span class="number">0.158</span>s][info][<span class="keyword">class</span>,load] ...</span><br><span class="line">...</span><br><span class="line">[<span class="number">0.160</span>s][info][<span class="keyword">class</span>,load] jdk.internal.reflect.GeneratedMethodAccessor1 source: __JVM_DefineClass__</span><br><span class="line">java.lang.Exception: #<span class="number">15</span></span><br><span class="line">       at Test.<span class="built_in">target</span>(Test.java:<span class="number">5</span>)</span><br><span class="line">       at java.base/jdk.internal.reflect.NativeMethodAccessorImpl .<span class="built_in">invoke0</span>(Native Method)</span><br><span class="line">       at java.base/jdk.internal.reflect.NativeMethodAccessorImpl .<span class="built_in">invoke</span>(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">       at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl .<span class="built_in">invoke</span>(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">       at java.base/java.lang.reflect.Method.<span class="built_in">invoke</span>(Method.java:<span class="number">564</span>)</span><br><span class="line">       at Test.<span class="built_in">main</span>(Test.java:<span class="number">12</span>)</span><br><span class="line">java.lang.Exception: #<span class="number">16</span></span><br><span class="line">       at Test.<span class="built_in">target</span>(Test.java:<span class="number">5</span>)</span><br><span class="line">       at jdk.internal.reflect.GeneratedMethodAccessor1 .<span class="built_in">invoke</span>(Unknown Source)</span><br><span class="line">       at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl .<span class="built_in">invoke</span>(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">       at java.base/java.lang.reflect.Method.<span class="built_in">invoke</span>(Method.java:<span class="number">564</span>)</span><br><span class="line">       at Test.<span class="built_in">main</span>(Test.java:<span class="number">12</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>可以看到，在第 15 次（从 0 开始数）反射调用时，我们便触发了动态实现的生成。这时候，Java 虚拟机额外加载了不少类。其中，最重要的当属 GeneratedMethodAccessor1（第 30 行）。并且，从第 16 次反射调用开始，我们便切换至这个刚刚生成的动态实现（第 40 行）。</p>
<p>反射调用的 Inflation 机制是可以通过参数（-Dsun.reflect.noInflation&#x3D;true）来关闭的。这样一来，在反射调用一开始便会直接生成动态实现，而不会使用委派实现或者本地实现。</p>
<h4 id="反射调用的开销"><a href="#反射调用的开销" class="headerlink" title="反射调用的开销"></a>反射调用的开销</h4><p>下面，我们便来拆解反射调用的性能开销。</p>
<p>在刚才的例子中，我们先后进行了 Class.forName，Class.getMethod 以及 Method.invoke 三个操作。其中，Class.forName 会调用本地方法，Class.getMethod 则会遍历该类的公有方法。如果没有匹配到，它还将遍历父类的公有方法。可想而知，这两个操作都非常费时。</p>
<p>值得注意的是，<u>以 getMethod 为代表的查找方法操作，会返回查找得到结果的一份拷贝。因此，我们应当避免在热点代码中使用返回 Method 数组的 getMethods 或者 getDeclaredMethods 方法，以减少不必要的堆空间消耗</u>。</p>
<p>在实践中，我们往往会在应用程序中缓存 Class.forName 和 Class.getMethod 的结果。因此，下面我就只关注反射调用本身的性能开销。</p>
<p>为了比较直接调用和反射调用的性能差距，我将前面的例子改为下面的 v2 版本。它会将反射调用循环二十亿次。此外，它还将记录下每跑一亿次的时间。</p>
<p>我将取最后五个记录的平均值，作为预热后的峰值性能。（注：这种性能评估方式并不严谨，我会在专栏的第三部分介绍如何用 JMH 来测性能。）</p>
<p>在我这个老笔记本上，一亿次直接调用耗费的时间大约在 120ms。这和不调用的时间是一致的。其原因在于这段代码属于热循环，同样会触发即时编译。并且，即时编译会将对 Test.target 的调用内联进来，从而消除了调用的开销。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v2 版本</span></span><br><span class="line">mport java.lang.reflect.Method;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">target</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="comment">// 空方法</span></span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Class&lt;?&gt; klass = Class.forName(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> klass.getMethod(<span class="string">&quot;target&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line"> </span><br><span class="line">    <span class="type">long</span> <span class="variable">current</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">2_000_000_000</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i % <span class="number">100_000_000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">temp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(temp - current);</span><br><span class="line">        current = temp;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      method.invoke(<span class="literal">null</span>, <span class="number">128</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>下面我将以 120ms 作为基准，来比较反射调用的性能开销。</p>
<p>由于目标方法 Test.target 接收一个 int 类型的参数，因此我传入 128 作为反射调用的参数，测得的结果约为基准的 2.7 倍。我们暂且不管这个数字是高是低，先来看看在反射调用之前字节码都做了什么。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">59:</span> <span class="string">aload_2</span>                         <span class="string">//</span> <span class="string">加载</span> <span class="string">Method</span> <span class="string">对象</span></span><br><span class="line"><span class="attr">60:</span> <span class="string">aconst_null</span>                     <span class="string">//</span> <span class="string">反射调用的第一个参数</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">61:</span> <span class="string">iconst_1</span></span><br><span class="line"><span class="attr">62:</span> <span class="string">anewarray</span> <span class="string">Object</span>                <span class="string">//</span> <span class="string">生成一个长度为</span> <span class="number">1</span> <span class="string">的</span> <span class="string">Object</span> <span class="string">数组</span></span><br><span class="line"><span class="attr">65:</span> <span class="string">dup</span></span><br><span class="line"><span class="attr">66:</span> <span class="string">iconst_0</span></span><br><span class="line"><span class="attr">67:</span> <span class="string">sipush</span> <span class="number">128</span></span><br><span class="line"><span class="attr">70:</span> <span class="string">invokestatic</span> <span class="string">Integer.valueOf</span>    <span class="string">//</span> <span class="string">将</span> <span class="number">128</span> <span class="string">自动装箱成</span> <span class="string">Integer</span></span><br><span class="line"><span class="attr">73:</span> <span class="string">aastore</span>                         <span class="string">//</span> <span class="string">存入</span> <span class="string">Object</span> <span class="string">数组中</span></span><br><span class="line"><span class="attr">74:</span> <span class="string">invokevirtual</span> <span class="string">Method.invoke</span>     <span class="string">//</span> <span class="string">反射调用</span></span><br></pre></td></tr></table></figure>

<p>这里我截取了循环中反射调用编译而成的字节码。可以看到，这段字节码除了反射调用外，还额外做了两个操作。</p>
<p>第一，由于 Method.invoke 是一个变长参数方法，在字节码层面它的最后一个参数会是 Object 数组（感兴趣的同学私下可以用 javap 查看）。Java 编译器会在方法调用处生成一个长度为传入参数数量的 Object 数组，并将传入参数一一存储进该数组中。</p>
<p>第二，由于 Object 数组不能存储基本类型，Java 编译器会对传入的基本类型参数进行自动装箱。</p>
<p>这两个操作除了带来性能开销外，还可能占用堆内存，使得 GC 更加频繁。（如果你感兴趣的话，可以用虚拟机参数 -XX:+PrintGC 试试。）那么，如何消除这部分开销呢？</p>
<p>关于第二个自动装箱，Java 缓存了 [-128, 127] 中所有整数所对应的 Integer 对象。当需要自动装箱的整数在这个范围之内时，便返回缓存的 Integer，否则需要新建一个 Integer 对象。</p>
<p>因此，我们可以将这个缓存的范围扩大至覆盖 128（对应参数 -Djava.lang.Integer.IntegerCache.high&#x3D;128），便可以避免需要新建 Integer 对象的场景。</p>
<p>或者，我们可以在循环外缓存 128 自动装箱得到的 Integer 对象，并且直接传入反射调用中。这两种方法测得的结果差不多，约为基准的 1.8 倍。</p>
<p>现在我们再回来看看第一个因变长参数而自动生成的 Object 数组。既然每个反射调用对应的参数个数是固定的，那么我们可以选择在循环外新建一个 Object 数组，设置好参数，并直接交给反射调用。改好的代码可以参照文稿中的 v3 版本。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v3 版本</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">target</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="comment">// 空方法</span></span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Class&lt;?&gt; klass = Class.forName(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> klass.getMethod(<span class="string">&quot;target&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line"> </span><br><span class="line">    Object[] arg = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">1</span>]; <span class="comment">// 在循环外构造参数数组</span></span><br><span class="line">    arg[<span class="number">0</span>] = <span class="number">128</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="type">long</span> <span class="variable">current</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">2_000_000_000</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i % <span class="number">100_000_000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">temp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(temp - current);</span><br><span class="line">        current = temp;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      method.invoke(<span class="literal">null</span>, arg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测得的结果反而更糟糕了，为基准的 2.9 倍。这是为什么呢？</p>
<p>如果你在上一步解决了自动装箱之后查看运行时的 GC 状况，你会发现这段程序并不会触发 GC。其原因在于，原本的反射调用被内联了，从而使得即时编译器中的逃逸分析将原本新建的 Object 数组判定为不逃逸的对象。</p>
<p>如果一个对象不逃逸，那么即时编译器可以选择栈分配甚至是虚拟分配，也就是不占用堆空间。具体我会在本专栏的第二部分详细解释。</p>
<p>如果在循环外新建数组，即时编译器无法确定这个数组会不会中途被更改，因此无法优化掉访问数组的操作，可谓是得不偿失。</p>
<p>到目前为止，我们的最好记录是 1.8 倍。那能不能再进一步提升呢？</p>
<p>刚才我曾提到，可以关闭反射调用的 Inflation 机制，从而取消委派实现，并且直接使用动态实现。此外，每次反射调用都会检查目标方法的权限，而这个检查同样可以在 Java 代码里关闭，在关闭了这两项机制之后，也就得到了我们的 v4 版本，它测得的结果约为基准的 1.3 倍。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v4 版本</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 在运行指令中添加如下两个虚拟机参数：</span></span><br><span class="line"><span class="comment">// -Djava.lang.Integer.IntegerCache.high=128</span></span><br><span class="line"><span class="comment">// -Dsun.reflect.noInflation=true</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">target</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="comment">// 空方法</span></span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Class&lt;?&gt; klass = Class.forName(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> klass.getMethod(<span class="string">&quot;target&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line">    method.setAccessible(<span class="literal">true</span>);  <span class="comment">// 关闭权限检查</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">long</span> <span class="variable">current</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">2_000_000_000</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i % <span class="number">100_000_000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">temp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(temp - current);</span><br><span class="line">        current = temp;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      method.invoke(<span class="literal">null</span>, <span class="number">128</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>到这里，我们基本上把反射调用的水分都榨干了。接下来，我来把反射调用的性能开销给提回去。</p>
<p>首先，在这个例子中，之所以反射调用能够变得这么快，主要是因为即时编译器中的方法内联。在关闭了 Inflation 的情况下，内联的瓶颈在于 Method.invoke 方法中对 MethodAccessor.invoke 方法的调用。</p>
<p><img src="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/assets/93dec45b7af7951a2b6daeb01941b9b5.png" alt="img"></p>
<p>我会在后面的文章中介绍方法内联的具体实现，这里先说个结论：在生产环境中，我们往往拥有多个不同的反射调用，对应多个 GeneratedMethodAccessor，也就是动态实现。</p>
<p>由于 Java 虚拟机的关于上述调用点的类型 profile（注：对于 invokevirtual 或者 invokeinterface，Java 虚拟机会记录下调用者的具体类型，我们称之为类型 profile）无法同时记录这么多个类，因此可能造成所测试的反射调用没有被内联的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v5 版本</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">target</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="comment">// 空方法</span></span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Class&lt;?&gt; klass = Class.forName(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> klass.getMethod(<span class="string">&quot;target&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line">    method.setAccessible(<span class="literal">true</span>);  <span class="comment">// 关闭权限检查</span></span><br><span class="line">    polluteProfile();</span><br><span class="line"> </span><br><span class="line">    <span class="type">long</span> <span class="variable">current</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">2_000_000_000</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i % <span class="number">100_000_000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">temp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(temp - current);</span><br><span class="line">        current = temp;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      method.invoke(<span class="literal">null</span>, <span class="number">128</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">polluteProfile</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Method</span> <span class="variable">method1</span> <span class="operator">=</span> Test.class.getMethod(<span class="string">&quot;target1&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line">    <span class="type">Method</span> <span class="variable">method2</span> <span class="operator">=</span> Test.class.getMethod(<span class="string">&quot;target2&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2000</span>; i++) &#123;</span><br><span class="line">      method1.invoke(<span class="literal">null</span>, <span class="number">0</span>);</span><br><span class="line">      method2.invoke(<span class="literal">null</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">target1</span><span class="params">(<span class="type">int</span> i)</span> &#123; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">target2</span><span class="params">(<span class="type">int</span> i)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>在上面的 v5 版本中，我在测试循环之前调用了 polluteProfile 的方法。该方法将反射调用另外两个方法，并且循环上 2000 遍。</p>
<p>而测试循环则保持不变。测得的结果约为基准的 6.7 倍。也就是说，只要误扰了 Method.invoke 方法的类型 profile，性能开销便会从 1.3 倍上升至 6.7 倍。</p>
<p>之所以这么慢，除了没有内联之外，另外一个原因是逃逸分析不再起效。这时候，我们便可以采用刚才 v3 版本中的解决方案，在循环外构造参数数组，并直接传递给反射调用。这样子测得的结果约为基准的 5.2 倍。</p>
<p>除此之外，我们还可以提高 Java 虚拟机关于每个调用能够记录的类型数目（对应虚拟机参数 -XX:TypeProfileWidth，默认值为 2，这里设置为 3）。最终测得的结果约为基准的 2.8 倍，尽管它和原本的 1.3 倍还有一定的差距，但总算是比 6.7 倍好多了。</p>
<h4 id="附录：反射-API-简介"><a href="#附录：反射-API-简介" class="headerlink" title="附录：反射 API 简介"></a>附录：反射 API 简介</h4><p>通常来说，使用反射 API 的第一步便是获取 Class 对象。在 Java 中常见的有这么三种。</p>
<ol>
<li>使用静态方法 Class.forName 来获取。</li>
<li>调用对象的 getClass() 方法。</li>
<li>直接用类名 +“.class”访问。对于基本类型来说，它们的包装类型（wrapper classes）拥有一个名为“TYPE”的 final 静态字段，指向该基本类型对应的 Class 对象。</li>
</ol>
<p>例如，Integer.TYPE 指向 int.class。对于数组类型来说，可以使用类名 +“[ ].class”来访问，如 int[ ].class。</p>
<p>除此之外，Class 类和 java.lang.reflect 包中还提供了许多返回 Class 对象的方法。例如，对于数组类的 Class 对象，调用 Class.getComponentType() 方法可以获得数组元素的类型。</p>
<p>一旦得到了 Class 对象，我们便可以正式地使用反射功能了。下面我列举了较为常用的几项。</p>
<ol>
<li>使用 newInstance() 来生成一个该类的实例。它要求该类中拥有一个无参数的构造器。</li>
<li>使用 isInstance(Object) 来判断一个对象是否该类的实例，语法上等同于 instanceof 关键字（JIT 优化时会有差别，我会在本专栏的第二部分详细介绍）。</li>
<li>使用 Array.newInstance(Class,int) 来构造该类型的数组。</li>
<li>使用 <code>getFields()/getConstructors()/getMethods()</code> 来访问该类的成员。除了这三个之外，Class 类还提供了许多<a href="https://docs.oracle.com/javase/tutorial/reflect/class/classMembers.html">其他方法</a>。需要注意的是，方法名中带 Declared 的不会返回父类的成员，但是会返回私有成员；而不带 Declared 的则相反。</li>
</ol>
<p>当获得了类成员之后，我们可以进一步做如下操作。</p>
<ul>
<li>使用 Constructor&#x2F;Field&#x2F;Method.setAccessible(true) 来绕开 Java 语言的访问限制。</li>
<li>使用 Constructor.newInstance(Object[]) 来生成该类的实例。</li>
<li>使用 Field.get&#x2F;set(Object) 来访问字段的值。</li>
<li>使用 Method.invoke(Object, Object[]) 来调用方法。</li>
</ul>
<p>有关反射 API 的其他用法，可以参考 reflect 包的 <a href="https://docs.oracle.com/javase/10/docs/api/java/lang/reflect/package-summary.html">javadoc</a>，这里就不详细展开了。</p>
<h3 id="08-JVM是怎么实现invokedynamic的？（上）"><a href="#08-JVM是怎么实现invokedynamic的？（上）" class="headerlink" title="08. JVM是怎么实现invokedynamic的？（上）"></a>08. JVM是怎么实现invokedynamic的？（上）</h3><p>前不久，“虚拟机”赛马俱乐部来了个年轻人，标榜自己是动态语言，是先进分子。</p>
<p>这一天，先进分子牵着一头鹿进来，说要参加赛马。咱部里的老学究 Java 就不同意了呀，鹿又不是马，哪能参加赛马。</p>
<p>当然了，这种墨守成规的调用方式，自然是先进分子所不齿的。现在年轻人里流行的是鸭子类型（<a href="https://en.wikipedia.org/wiki/Duck_typing">duck typing</a>），只要是跑起来像只马的，它就是一只马，也就能够参加赛马比赛。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Horse</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">race</span>()</span> &#123;</span><br><span class="line">    System.<span class="keyword">out</span>.println(<span class="string">&quot;Horse.race()&quot;</span>); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title">Deer</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">race</span>()</span> &#123;</span><br><span class="line">    System.<span class="keyword">out</span>.println(<span class="string">&quot;Deer.race()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title">Cobra</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">race</span>()</span> &#123;</span><br><span class="line">    System.<span class="keyword">out</span>.println(<span class="string">&quot;How do you turn this on?&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(如何用同一种方式调用他们的赛跑方法？)</p>
<p>说到了这里，如果我们将赛跑定义为对赛跑方法（对应上述代码中的 race()）的调用的话，那么这个故事的关键，就在于能不能在马场中调用非马类型的赛跑方法。</p>
<p>为了解答这个问题，我们先来回顾一下 Java 里的方法调用。<strong>在 Java 中，方法调用会被编译为 invokestatic，invokespecial，invokevirtual 以及 invokeinterface 四种指令</strong>。这些指令与包含目标方法类名、方法名以及方法描述符的符号引用捆绑。在实际运行之前，Java 虚拟机将根据这个符号引用链接到具体的目标方法。</p>
<p>可以看到，在这四种调用指令中，Java 虚拟机明确要求方法调用需要提供目标方法的类名。在这种体系下，我们有两个解决方案。一是调用其中一种类型的赛跑方法，比如说马类的赛跑方法。对于非马的类型，则给它套一层马甲，当成马来赛跑。</p>
<p>另外一种解决方式，是通过反射机制，来查找并且调用各个类型中的赛跑方法，以此模拟真正的赛跑。</p>
<p>显然，比起直接调用，这两种方法都相当复杂，执行效率也可想而知。为了解决这个问题，<strong>Java 7 引入了一条新的指令 invokedynamic。该指令的调用机制抽象出调用点这一个概念，并允许应用程序将调用点链接至任意符合条件的方法上。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">startRace</span><span class="params">(java.lang.Object)</span></span><br><span class="line">       <span class="number">0</span>: aload_0                <span class="comment">// 加载一个任意对象</span></span><br><span class="line">       <span class="number">1</span>: invokedynamic race     <span class="comment">// 调用赛跑方法</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>(理想的调用方式)</p>
<p>作为 invokedynamic 的准备工作，Java 7 引入了更加底层、更加灵活的方法抽象 ：方法句柄（MethodHandle）。</p>
<h4 id="方法句柄的概念"><a href="#方法句柄的概念" class="headerlink" title="方法句柄的概念"></a>方法句柄的概念</h4><p><a href="https://docs.oracle.com/javase/10/docs/api/java/lang/invoke/MethodHandle.html">方法句柄</a>是一个强类型的，能够被直接执行的引用。<u>该引用可以指向常规的静态方法或者实例方法，也可以指向构造器或者字段。当指向字段时，方法句柄实则指向包含字段访问字节码的虚构方法，语义上等价于目标字段的 getter 或者 setter 方法。</u></p>
<p>这里需要注意的是，它并不会直接指向目标字段所在类中的 getter&#x2F;setter，毕竟你无法保证已有的 getter&#x2F;setter 方法就是在访问目标字段。</p>
<p><u>方法句柄的类型（MethodType）是由所指向方法的参数类型以及返回类型组成的。它是用来确认方法句柄是否适配的唯一关键。当使用方法句柄时，我们其实并不关心方法句柄所指向方法的类名或者方法名。</u></p>
<p>打个比方，如果兔子的“赛跑”方法和“睡觉”方法的参数类型以及返回类型一致，那么对于兔子递过来的一个方法句柄，我们并不知道会是哪一个方法。</p>
<p>方法句柄的创建是通过 MethodHandles.Lookup 类来完成的。它提供了多个 API，既可以使用反射 API 中的 Method 来查找，也可以根据类、方法名以及方法句柄类型来查找。</p>
<p>当使用后者这种查找方式时，用户需要区分具体的调用类型，比如说对于用 invokestatic 调用的静态方法，我们需要使用 Lookup.findStatic 方法；对于用 invokevirutal 调用的实例方法，以及用 invokeinterface 调用的接口方法，我们需要使用 findVirtual 方法；对于用 invokespecial 调用的实例方法，我们则需要使用 findSpecial 方法。</p>
<p>调用方法句柄，和原本对应的调用指令是一致的。也就是说，对于原本用 invokevirtual 调用的方法句柄，它也会采用动态绑定；而对于原本用 invokespecial 调用的方法句柄，它会采用静态绑定。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    ..</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Lookup <span class="title function_">lookup</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> MethodHandles.lookup();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 获取方法句柄的不同方式</span></span><br><span class="line">MethodHandles.<span class="type">Lookup</span> <span class="variable">l</span> <span class="operator">=</span> Foo.lookup(); <span class="comment">// 具备 Foo 类的访问权限</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> Foo.class.getDeclaredMethod(<span class="string">&quot;bar&quot;</span>, Object.class);</span><br><span class="line"><span class="type">MethodHandle</span> <span class="variable">mh0</span> <span class="operator">=</span> l.unreflect(m);</span><br><span class="line"> </span><br><span class="line"><span class="type">MethodType</span> <span class="variable">t</span> <span class="operator">=</span> MethodType.methodType(<span class="keyword">void</span>.class, Object.class);</span><br><span class="line"><span class="type">MethodHandle</span> <span class="variable">mh1</span> <span class="operator">=</span> l.findStatic(Foo.class, <span class="string">&quot;bar&quot;</span>, t);</span><br></pre></td></tr></table></figure>

<p>方法句柄同样也有权限问题。但它与反射 API 不同，其权限检查是在句柄的创建阶段完成的。在实际调用过程中，Java 虚拟机并不会检查方法句柄的权限。如果该句柄被多次调用的话，那么与反射调用相比，它将省下重复权限检查的开销。</p>
<p>需要注意的是，方法句柄的访问权限不取决于方法句柄的创建位置，而是取决于 Lookup 对象的创建位置。</p>
<p>举个例子，对于一个私有字段，如果 Lookup 对象是在私有字段所在类中获取的，那么这个 Lookup 对象便拥有对该私有字段的访问权限，即使是在所在类的外边，也能够通过该 Lookup 对象创建该私有字段的 getter 或者 setter。</p>
<p>由于方法句柄没有运行时权限检查，因此，应用程序需要负责方法句柄的管理。一旦它发布了某些指向私有方法的方法句柄，那么这些私有方法便被暴露出去了。</p>
<h4 id="方法句柄的操作"><a href="#方法句柄的操作" class="headerlink" title="方法句柄的操作"></a>方法句柄的操作</h4><p>方法句柄的调用可分为两种，一是需要严格匹配参数类型的 invokeExact。它有多严格呢？假设一个方法句柄将接收一个 Object 类型的参数，如果你直接传入 String 作为实际参数，那么方法句柄的调用会在运行时抛出方法类型不匹配的异常。正确的调用方式是将该 String 显式转化为 Object 类型。</p>
<p>在普通 Java 方法调用中，我们只有在选择重载方法时，才会用到这种显式转化。这是因为经过显式转化后，参数的声明类型发生了改变，因此有可能匹配到不同的方法描述符，从而选取不同的目标方法。调用方法句柄也是利用同样的原理，并且涉及了一个签名多态性（signature polymorphism）的概念。（在这里我们暂且认为签名等同于方法描述符。）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="meta">@PolymorphicSignature</span> Object <span class="title function_">invokeExact</span><span class="params">(Object... args)</span> <span class="keyword">throws</span> Throwable;</span><br></pre></td></tr></table></figure>

<p>方法句柄 API 有一个特殊的注解类 @PolymorphicSignature。在碰到被它注解的方法调用时，Java 编译器会根据所传入参数的声明类型来生成方法描述符，而不是采用目标方法所声明的描述符。</p>
<p>在刚才的例子中，当传入的参数是 String 时，对应的方法描述符包含 String 类；而当我们转化为 Object 时，对应的方法描述符则包含 Object 类。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">test</span>(<span class="title class_">MethodHandle</span> mh, <span class="title class_">String</span> s) throws <span class="title class_">Throwable</span> &#123;</span><br><span class="line">  mh.<span class="title function_">invokeExact</span>(s);</span><br><span class="line">  mh.<span class="title function_">invokeExact</span>((<span class="title class_">Object</span>) s);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 对应的 Java 字节码</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">test</span>(<span class="title class_">MethodHandle</span>, <span class="title class_">String</span>) throws java.<span class="property">lang</span>.<span class="property">Throwable</span>;</span><br><span class="line">  <span class="title class_">Code</span>:</span><br><span class="line">     <span class="number">0</span>: aload_1</span><br><span class="line">     <span class="number">1</span>: aload_2</span><br><span class="line">     <span class="number">2</span>: invokevirtual <span class="title class_">MethodHandle</span>.<span class="property">invokeExact</span>:(<span class="title class_">Ljava</span>/lang/<span class="title class_">String</span>;)V</span><br><span class="line">     <span class="number">5</span>: aload_1</span><br><span class="line">     <span class="number">6</span>: aload_2</span><br><span class="line">     <span class="number">7</span>: invokevirtual <span class="title class_">MethodHandle</span>.<span class="property">invokeExact</span>:(<span class="title class_">Ljava</span>/lang/<span class="title class_">Object</span>;)V</span><br><span class="line">    <span class="number">10</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>invokeExact 会确认该 invokevirtual 指令对应的方法描述符，和该方法句柄的类型是否严格匹配。在不匹配的情况下，便会在运行时抛出异常。</p>
<p>如果你需要自动适配参数类型，那么你可以选取方法句柄的第二种调用方式 invoke。它同样是一个签名多态性的方法。invoke 会调用 MethodHandle.asType 方法，生成一个适配器方法句柄，对传入的参数进行适配，再调用原方法句柄。调用原方法句柄的返回值同样也会先进行适配，然后再返回给调用者。</p>
<p>方法句柄还支持增删改参数的操作，这些操作都是通过生成另一个方法句柄来实现的。这其中，改操作就是刚刚介绍的 MethodHandle.asType 方法。删操作指的是将传入的部分参数就地抛弃，再调用另一个方法句柄。它对应的 API 是 MethodHandles.dropArguments 方法。</p>
<p>增操作则非常有意思。它会往传入的参数中插入额外的参数，再调用另一个方法句柄，它对应的 API 是 MethodHandle.bindTo 方法。Java 8 中捕获类型的 Lambda 表达式便是用这种操作来实现的，下一篇我会详细进行解释。</p>
<p>增操作还可以用来实现方法的柯里化 [3]。举个例子，有一个指向 f(x, y) 的方法句柄，我们可以通过将 x 绑定为 4，生成另一个方法句柄 g(y) &#x3D; f(4, y)。在执行过程中，每当调用 g(y) 的方法句柄，它会在参数列表最前面插入一个 4，再调用指向 f(x, y) 的方法句柄。</p>
<h4 id="方法句柄的实现"><a href="#方法句柄的实现" class="headerlink" title="方法句柄的实现"></a>方法句柄的实现</h4><p>下面我们来看看 HotSpot 虚拟机中方法句柄调用的具体实现。（由于篇幅原因，这里只讨论 DirectMethodHandle。）</p>
<p>前面提到，调用方法句柄所使用的 invokeExact 或者 invoke 方法具备签名多态性的特性。它们会根据具体的传入参数来生成方法描述符。那么，拥有这个描述符的方法实际存在吗？对 invokeExact 或者 invoke 的调用具体会进入哪个方法呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.invoke.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Exception</span>().printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    MethodHandles.<span class="type">Lookup</span> <span class="variable">l</span> <span class="operator">=</span> MethodHandles.lookup();</span><br><span class="line">    <span class="type">MethodType</span> <span class="variable">t</span> <span class="operator">=</span> MethodType.methodType(<span class="keyword">void</span>.class, Object.class);</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">mh</span> <span class="operator">=</span> l.findStatic(Foo.class, <span class="string">&quot;bar&quot;</span>, t);</span><br><span class="line">    mh.invokeExact(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和查阅反射调用的方式一样，我们可以通过新建异常实例来查看栈轨迹。打印出来的占轨迹如下所示：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$ java Foo</span><br><span class="line">java.lang.<span class="built_in">Exception</span></span><br><span class="line">        at Foo.<span class="title function_ invoke__">bar</span>(Foo.<span class="attr">java</span>:<span class="number">5</span>)</span><br><span class="line">        at Foo.<span class="title function_ invoke__">main</span>(Foo.<span class="attr">java</span>:<span class="number">12</span>)</span><br></pre></td></tr></table></figure>

<p>也就是说，invokeExact 的目标方法竟然就是方法句柄指向的方法。</p>
<p>先别高兴太早。我刚刚提到过，invokeExact 会对参数的类型进行校验，并在不匹配的情况下抛出异常。如果它直接调用了方法句柄所指向的方法，那么这部分参数类型校验的逻辑将无处安放。因此，唯一的可能便是 Java 虚拟机隐藏了部分栈信息。</p>
<p>当我们启用了 -XX:+ShowHiddenFrames 这个参数来打印被 Java 虚拟机隐藏了的栈信息时，你会发现 main 方法和目标方法中间隔着两个貌似是生成的方法。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>java -<span class="variable constant_">XX</span><span class="symbol">:+UnlockDiagnosticVMOptions</span> -<span class="variable constant_">XX</span><span class="symbol">:+ShowHiddenFrames</span> Foo</span><br><span class="line">java.lang.Exception</span><br><span class="line">        at Foo.bar(Foo.<span class="symbol">java:</span><span class="number">5</span>)</span><br><span class="line">        at java.base/java.lang.invoke.DirectMethodHandle<span class="variable">$Holder</span>. invokeStatic(DirectMethodHandle<span class="variable">$Holder</span><span class="symbol">:</span><span class="number">1000010</span>)</span><br><span class="line">        at java.base/java.lang.invoke.LambdaForm<span class="variable">$MH000</span>/<span class="number">766572210</span>. invokeExact_MT000_LLL_V(LambdaForm<span class="variable">$MH000</span><span class="symbol">:</span><span class="number">1000019</span>)</span><br><span class="line">        at Foo.main(Foo.<span class="symbol">java:</span><span class="number">12</span>)</span><br></pre></td></tr></table></figure>

<p>实际上，Java 虚拟机会对 invokeExact 调用做特殊处理，调用至一个共享的、与方法句柄类型相关的特殊适配器中。这个适配器是一个 LambdaForm，我们可以通过添加虚拟机参数将之导出成 class 文件（-Djava.lang.invoke.MethodHandle.DUMP_CLASS_FILES&#x3D;true）。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">final</span> <span class="string">class</span> <span class="string">java.lang.invoke.LambdaForm$MH000</span> &#123;  <span class="string">static</span> <span class="string">void</span> <span class="string">invokeExact_MT000_LLLLV(jeava.lang.bject</span>, <span class="string">jjava.lang.bject</span>, <span class="string">jjava.lang.bject);</span></span><br><span class="line">    <span class="attr">Code:</span></span><br><span class="line">        <span class="string">:</span> <span class="string">aload_0</span></span><br><span class="line">      <span class="attr">1 :</span> <span class="string">checkcast</span>      <span class="comment">#14                 //Mclass java/lang/invoke/ethodHandle</span></span><br><span class="line">        <span class="string">:</span> <span class="string">dup</span></span><br><span class="line">      <span class="attr">5 :</span> <span class="string">astore_0</span></span><br><span class="line">        <span class="string">:</span> <span class="attr">aload_32        :</span> <span class="string">checkcast</span>      <span class="comment">#16                 //Mclass java/lang/invoke/ethodType</span></span><br><span class="line">      <span class="attr">10:</span> <span class="string">invokestatic</span>  <span class="string">I#22</span>                 <span class="string">//</span> <span class="string">Method</span> <span class="string">java/lang/invoke/nvokers.checkExactType:(MLjava/lang/invoke/ethodHandle</span>,<span class="string">;Ljava/lang/invoke/ethodType);V</span></span><br><span class="line">      <span class="attr">13:</span> <span class="string">aload_0</span></span><br><span class="line">      <span class="attr">14:</span> <span class="string">invokestatic</span>   <span class="comment">#26     I           // Method java/lang/invoke/nvokers.checkCustomized:(MLjava/lang/invoke/ethodHandle);V</span></span><br><span class="line">      <span class="attr">17:</span> <span class="string">aload_0</span></span><br><span class="line">      <span class="attr">18:</span> <span class="string">aload_1</span></span><br><span class="line">      <span class="attr">19:</span> <span class="string">ainvakevirtudl</span> <span class="comment">#30             2   // Methodijava/lang/nvokev/ethodHandle.invokeBasic:(LLeava/lang/bject;;V</span></span><br><span class="line">       <span class="number">23</span> <span class="string">return</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>可以看到，在这个适配器中，它会调用 Invokers.checkExactType 方法来检查参数类型，然后调用 Invokers.checkCustomized 方法。后者会在方法句柄的执行次数超过一个阈值时进行优化（对应参数 -Djava.lang.invoke.MethodHandle.CUSTOMIZE_THRESHOLD，默认值为 127）。最后，它会调用方法句柄的 invokeBasic 方法。</p>
<p>Java 虚拟机同样会对 invokeBasic 调用做特殊处理，这会将调用至方法句柄本身所持有的适配器中。这个适配器同样是一个 LambdaForm，你可以通过反射机制将其打印出来。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该方法句柄持有的 LambdaForm 实例的 toString() 结果</span></span><br><span class="line">DMH.invokeStatic_L_V=<span class="title function_ invoke__">Lambda</span>(<span class="attr">a0</span>:L,<span class="attr">a1</span>:L)=&gt;&#123;</span><br><span class="line">  t2:L=DirectMethodHandle.<span class="title function_ invoke__">internalMemberName</span>(<span class="attr">a0</span>:L);</span><br><span class="line">  t3:V=MethodHandle.<span class="title function_ invoke__">linkToStatic</span>(<span class="attr">a1</span>:L,<span class="attr">t2</span>:L);<span class="keyword">void</span>&#125;</span><br></pre></td></tr></table></figure>

<p>这个适配器将获取方法句柄中的 MemberName 类型的字段，并且以它为参数调用 linkToStatic 方法。估计你已经猜到了，Java 虚拟机也会对 linkToStatic 调用做特殊处理，它将根据传入的 MemberName 参数所存储的方法地址或者方法表索引，直接跳转至目标方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">MemberName</span> <span class="keyword">implements</span> <span class="title class_">Member</span>, Cloneable &#123;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">//@Injected JVM_Method* vmtarget;</span></span><br><span class="line">    <span class="comment">//@Injected int         vmindex;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>那么前面那个适配器中的优化又是怎么回事？实际上，方法句柄一开始持有的适配器是共享的。当它被多次调用之后，Invokers.checkCustomized 方法会为该方法句柄生成一个特有的适配器。这个特有的适配器会将方法句柄作为常量，直接获取其 MemberName 类型的字段，并继续后面的 linkToStatic 调用。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">final</span> <span class="string">class</span> <span class="string">java.lang.invoke.LambdaForm$DMH000</span> &#123;</span><br><span class="line">  <span class="string">static</span> <span class="string">void</span> <span class="string">invokeStatic000_LL_V(java.lang.Object</span>, <span class="string">java.lang.Object);</span></span><br><span class="line">    <span class="attr">Code:</span></span><br><span class="line">       <span class="attr">0:</span> <span class="string">ldc</span>           <span class="comment">#14                 // String CONSTANT_PLACEHOLDER_1 &lt;&lt;Foo.bar(Object)void/invokeStatic&gt;&gt;</span></span><br><span class="line">       <span class="attr">2:</span> <span class="string">checkcast</span>     <span class="comment">#16                 // class java/lang/invoke/MethodHandle</span></span><br><span class="line">       <span class="attr">5:</span> <span class="string">astore_0</span>     <span class="string">//</span> <span class="string">上面的优化代码覆盖了传入的方法句柄</span></span><br><span class="line">       <span class="attr">6:</span> <span class="string">aload_0</span>      <span class="string">//</span> <span class="string">从这里开始跟初始版本一致</span></span><br><span class="line">       <span class="attr">7:</span> <span class="string">invokestatic</span>  <span class="comment">#22                 // Method java/lang/invoke/DirectMethodHandle.internalMemberName:(Ljava/lang/Object;)Ljava/lang/Object;</span></span><br><span class="line">      <span class="attr">10:</span> <span class="string">astore_2</span></span><br><span class="line">      <span class="attr">11:</span> <span class="string">aload_1</span></span><br><span class="line">      <span class="attr">12:</span> <span class="string">aload_2</span></span><br><span class="line">      <span class="attr">13:</span> <span class="string">checkcast</span>     <span class="comment">#24                 // class java/lang/invoke/MemberName</span></span><br><span class="line">      <span class="attr">16:</span> <span class="string">invokestatic</span>  <span class="comment">#28                 // Method java/lang/invoke/MethodHandle.linkToStatic:(Ljava/lang/Object;Ljava/lang/invoke/MemberName;)V</span></span><br><span class="line">      <span class="attr">19:</span> <span class="string">return</span></span><br></pre></td></tr></table></figure>

<p>可以看到，方法句柄的调用和反射调用一样，都是间接调用。因此，它也会面临无法内联的问题。不过，与反射调用不同的是，方法句柄的内联瓶颈在于即时编译器能否将该方法句柄识别为常量。具体内容我会在下一篇中进行详细的解释。</p>
<h3 id="09-JVM是怎么实现invokedynamic的？（下）"><a href="#09-JVM是怎么实现invokedynamic的？（下）" class="headerlink" title="09. JVM是怎么实现invokedynamic的？（下）"></a>09. JVM是怎么实现invokedynamic的？（下）</h3><p>上回讲到，为了让所有的动物都能参加赛马，Java 7 引入了 invokedynamic 机制，允许调用任意类的“赛跑”方法。不过，我们并没有讲解 invokedynamic，而是深入地探讨了它所依赖的方法句柄。</p>
<p>今天，我便来正式地介绍 invokedynamic 指令，讲讲它是如何生成调用点，并且允许应用程序自己决定链接至哪一个方法中的。</p>
<h4 id="invokedynamic-指令"><a href="#invokedynamic-指令" class="headerlink" title="invokedynamic 指令"></a>invokedynamic 指令</h4><p>invokedynamic 是 Java 7 引入的一条新指令，用以支持动态语言的方法调用。具体来说，它将调用点（CallSite）抽象成一个 Java 类，并且将原本由 Java 虚拟机控制的方法调用以及方法链接暴露给了应用程序。<u>在运行过程中，每一条 invokedynamic 指令将捆绑一个调用点，并且会调用该调用点所链接的方法句柄。</u></p>
<p>在第一次执行 invokedynamic 指令时，Java 虚拟机会调用该指令所对应的启动方法（BootStrap Method），来生成前面提到的调用点，并且将之绑定至该 invokedynamic 指令中。在之后的运行过程中，Java 虚拟机则会直接调用绑定的调用点所链接的方法句柄。</p>
<p>在字节码中，启动方法是用方法句柄来指定的。这个方法句柄指向一个返回类型为调用点的静态方法。该方法必须接收三个固定的参数，分别为一个 Lookup 类实例，一个用来指代目标方法名字的字符串，以及该调用点能够链接的方法句柄的类型。</p>
<p>除了这三个必需参数之外，启动方法还可以接收若干个其他的参数，用来辅助生成调用点，或者定位所要链接的目标方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.invoke.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Horse</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">race</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Horse.race()&quot;</span>); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Deer</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">race</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Deer.race()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// javac Circuit.java</span></span><br><span class="line"><span class="comment">// java Circuit</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circuit</span> &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">startRace</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="comment">// aload obj</span></span><br><span class="line">    <span class="comment">// invokedynamic race()</span></span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    startRace(<span class="keyword">new</span> <span class="title class_">Horse</span>());</span><br><span class="line">    <span class="comment">// startRace(new Deer());</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> CallSite <span class="title function_">bootstrap</span><span class="params">(MethodHandles.Lookup l, String name, MethodType callSiteType)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">mh</span> <span class="operator">=</span> l.findVirtual(Horse.class, name, MethodType.methodType(<span class="keyword">void</span>.class));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConstantCallSite</span>(mh.asType(callSiteType));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我在文稿中贴了一段代码，其中便包含一个启动方法。它将接收前面提到的三个固定参数，并且返回一个链接至 Horse.race 方法的 ConstantCallSite。</p>
<p>这里的 ConstantCallSite 是一种不可以更改链接对象的调用点。除此之外，Java 核心类库还提供多种可以更改链接对象的调用点，比如 MutableCallSite 和 VolatileCallSite。</p>
<p>这两者的区别就好比正常字段和 volatile 字段之间的区别。此外，应用程序还可以自定义调用点类，来满足特定的重链接需求。</p>
<p>由于 Java 暂不支持直接生成 invokedynamic 指令 [1]，所以接下来我会借助之前介绍过的字节码工具 ASM 来实现这一目的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.*;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// javac -cp /path/to/asm-all-6.0_BETA.jar:. ASMHelper.java</span></span><br><span class="line"><span class="comment">// java -cp /path/to/asm-all-6.0_BETA.jar:. ASMHelper</span></span><br><span class="line"><span class="comment">// java Circuit</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ASMHelper</span> <span class="keyword">implements</span> <span class="title class_">Opcodes</span> &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyMethodVisitor</span> <span class="keyword">extends</span> <span class="title class_">MethodVisitor</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BOOTSTRAP_CLASS_NAME</span> <span class="operator">=</span> Circuit.class.getName().replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BOOTSTRAP_METHOD_NAME</span> <span class="operator">=</span> <span class="string">&quot;bootstrap&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BOOTSTRAP_METHOD_DESC</span> <span class="operator">=</span> MethodType</span><br><span class="line">        .methodType(CallSite.class, MethodHandles.Lookup.class, String.class, MethodType.class)</span><br><span class="line">        .toMethodDescriptorString();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TARGET_METHOD_NAME</span> <span class="operator">=</span> <span class="string">&quot;race&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TARGET_METHOD_DESC</span> <span class="operator">=</span> <span class="string">&quot;(Ljava/lang/Object;)V&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> MethodVisitor mv;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyMethodVisitor</span><span class="params">(<span class="type">int</span> api, MethodVisitor mv)</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>(api);</span><br><span class="line">      <span class="built_in">this</span>.mv = mv;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitCode</span><span class="params">()</span> &#123;</span><br><span class="line">      mv.visitCode();</span><br><span class="line">      mv.visitVarInsn(ALOAD, <span class="number">0</span>);</span><br><span class="line">      <span class="type">Handle</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handle</span>(H_INVOKESTATIC, BOOTSTRAP_CLASS_NAME, BOOTSTRAP_METHOD_NAME, BOOTSTRAP_METHOD_DESC, <span class="literal">false</span>);</span><br><span class="line">      mv.visitInvokeDynamicInsn(TARGET_METHOD_NAME, TARGET_METHOD_DESC, h);</span><br><span class="line">      mv.visitInsn(RETURN);</span><br><span class="line">      mv.visitMaxs(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">      mv.visitEnd();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">ClassReader</span> <span class="variable">cr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassReader</span>(<span class="string">&quot;Circuit&quot;</span>);</span><br><span class="line">    <span class="type">ClassWriter</span> <span class="variable">cw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(cr, ClassWriter.COMPUTE_FRAMES);</span><br><span class="line">    <span class="type">ClassVisitor</span> <span class="variable">cv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassVisitor</span>(ASM6, cw) &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> MethodVisitor <span class="title function_">visitMethod</span><span class="params">(<span class="type">int</span> access, String name, String descriptor, String signature,</span></span><br><span class="line"><span class="params">          String[] exceptions)</span> &#123;</span><br><span class="line">        <span class="type">MethodVisitor</span> <span class="variable">visitor</span> <span class="operator">=</span> <span class="built_in">super</span>.visitMethod(access, name, descriptor, signature, exceptions);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;startRace&quot;</span>.equals(name)) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyMethodVisitor</span>(ASM6, visitor);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> visitor;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    cr.accept(cv, ClassReader.SKIP_FRAMES);</span><br><span class="line"> </span><br><span class="line">    Files.write(Paths.get(<span class="string">&quot;Circuit.class&quot;</span>), cw.toByteArray());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你无需理解上面这段代码的具体含义，只须了解它会更改同一目录下 Circuit 类的 startRace(Object) 方法，使之包含 invokedynamic 指令，执行所谓的赛跑方法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">startRace</span><span class="params">(java.lang.Object)</span></span>;</span><br><span class="line">        <span class="number">0</span>: aload_0</span><br><span class="line">        <span class="number">1</span>: invokedynamic #<span class="number">80</span>,  <span class="number">0</span> <span class="comment">// race:(Ljava/lang/Object;)V</span></span><br><span class="line">        <span class="number">6</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>如果你足够细心的话，你会发现该指令所调用的赛跑方法的描述符，和 Horse.race 方法或者 Deer.race 方法的描述符并不一致。这是因为 invokedynamic 指令最终调用的是方法句柄，而方法句柄会将调用者当成第一个参数。因此，刚刚提到的那两个方法恰恰符合这个描述符所对应的方法句柄类型。</p>
<p>到目前为止，我们已经可以通过 invokedynamic 调用 Horse.race 方法了。为了支持调用任意类的 race 方法，我实现了一个简单的单态内联缓存。如果调用者的类型命中缓存中的类型，便直接调用缓存中的方法句柄，否则便更新缓存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需要更改 ASMHelper.MyMethodVisitor 中的 BOOTSTRAP_CLASS_NAME</span></span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MonomorphicInlineCache</span> &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> MethodHandles.Lookup lookup;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MonomorphicInlineCache</span><span class="params">(MethodHandles.Lookup lookup, String name)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.lookup = lookup;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> Class&lt;?&gt; cachedClass = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">MethodHandle</span> <span class="variable">mh</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Object receiver)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="keyword">if</span> (cachedClass != receiver.getClass()) &#123;</span><br><span class="line">      cachedClass = receiver.getClass();</span><br><span class="line">      mh = lookup.findVirtual(cachedClass, name, MethodType.methodType(<span class="keyword">void</span>.class));</span><br><span class="line">    &#125;</span><br><span class="line">    mh.invoke(receiver);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> CallSite <span class="title function_">bootstrap</span><span class="params">(MethodHandles.Lookup l, String name, MethodType callSiteType)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">MonomorphicInlineCache</span> <span class="variable">ic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MonomorphicInlineCache</span>(l, name);</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">mh</span> <span class="operator">=</span> l.findVirtual(MonomorphicInlineCache.class, <span class="string">&quot;invoke&quot;</span>, MethodType.methodType(<span class="keyword">void</span>.class, Object.class));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConstantCallSite</span>(mh.bindTo(ic));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，尽管 invokedynamic 指令调用的是所谓的 race 方法，但是实际上我返回了一个链接至名为“invoke”的方法的调用点。由于调用点仅要求方法句柄的类型能够匹配，因此这个链接是合法的。</p>
<p>不过，这正是 invokedynamic 的目的，也就是将调用点与目标方法的链接交由应用程序来做，并且依赖于应用程序对目标方法进行验证。所以，如果应用程序将赛跑方法链接至兔子的睡觉方法，那也只能怪应用程序自己了。</p>
<h4 id="Java-8-的-Lambda-表达式"><a href="#Java-8-的-Lambda-表达式" class="headerlink" title="Java 8 的 Lambda 表达式"></a>Java 8 的 Lambda 表达式</h4><p>在 Java 8 中，Lambda 表达式也是借助 invokedynamic 来实现的。</p>
<p>具体来说，<u>Java 编译器利用 invokedynamic 指令来生成实现了函数式接口的适配器。</u>这里的函数式接口指的是仅包括一个非 default 接口方法的接口，一般通过 @FunctionalInterface 注解。不过就算是没有使用该注解，Java 编译器也会将符合条件的接口辨认为函数式接口。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = ..</span><br><span class="line">IntStream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).<span class="keyword">map</span>(i -&gt; i * <span class="number">2</span>).<span class="keyword">map</span>(i -&gt; i * x);</span><br></pre></td></tr></table></figure>

<p>举个例子，上面这段代码会对 IntStream 中的元素进行两次映射。我们知道，映射方法 map 所接收的参数是 IntUnaryOperator（这是一个函数式接口）。也就是说，在运行过程中我们需要将 i-&gt;i<em>2 和 i-&gt;i</em>x 这两个 Lambda 表达式转化成 IntUnaryOperator 的实例。这个转化过程便是由 invokedynamic 来实现的。</p>
<p>在编译过程中，Java 编译器会对 Lambda 表达式进行解语法糖（desugar），生成一个方法来保存 Lambda 表达式的内容。该方法的参数列表不仅包含原本 Lambda 表达式的参数，还包含它所捕获的变量。(注：方法引用，如 Horse::race，则不会生成生成额外的方法。)</p>
<p>在上面那个例子中，第一个 Lambda 表达式没有捕获其他变量，而第二个 Lambda 表达式（也就是 i-&gt;i*x）则会捕获局部变量 x。这两个 Lambda 表达式对应的方法如下所示。可以看到，所捕获的变量同样也会作为参数传入生成的方法之中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// i -&gt; i * 2</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">static</span> <span class="type">int</span> lambda$<span class="number">0</span>(<span class="type">int</span>);</span><br><span class="line">  Code:</span><br><span class="line">     <span class="number">0</span>: iload_0</span><br><span class="line">     <span class="number">1</span>: iconst_2</span><br><span class="line">     <span class="number">2</span>: imul</span><br><span class="line">     <span class="number">3</span>: ireturn</span><br><span class="line"> </span><br><span class="line"><span class="comment">// i -&gt; i * x</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">static</span> <span class="type">int</span> lambda$<span class="number">1</span>(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line">  Code:</span><br><span class="line">     <span class="number">0</span>: iload_1</span><br><span class="line">     <span class="number">1</span>: iload_0</span><br><span class="line">     <span class="number">2</span>: imul</span><br><span class="line">     <span class="number">3</span>: ireturn</span><br></pre></td></tr></table></figure>

<p>第一次执行 invokedynamic 指令时，它所对应的启动方法会通过 ASM 来生成一个适配器类。这个适配器类实现了对应的函数式接口，在我们的例子中，也就是 IntUnaryOperator。启动方法的返回值是一个 ConstantCallSite，其链接对象为一个返回适配器类实例的方法句柄。</p>
<p>根据 Lambda 表达式是否捕获其他变量，启动方法生成的适配器类以及所链接的方法句柄皆不同。</p>
<p>如果该 Lambda 表达式没有捕获其他变量，那么可以认为它是上下文无关的。因此，启动方法将新建一个适配器类的实例，并且生成一个特殊的方法句柄，始终返回该实例。</p>
<p>如果该 Lambda 表达式捕获了其他变量，那么每次执行该 invokedynamic 指令，我们都要更新这些捕获了的变量，以防止它们发生了变化。</p>
<p>另外，为了保证 Lambda 表达式的线程安全，我们无法共享同一个适配器类的实例。因此，在每次执行 invokedynamic 指令时，所调用的方法句柄都需要新建一个适配器类实例。</p>
<p>在这种情况下，启动方法生成的适配器类将包含一个额外的静态方法，来构造适配器类的实例。该方法将接收这些捕获的参数，并且将它们保存为适配器类实例的实例字段。</p>
<p>你可以通过虚拟机参数 -Djdk.internal.lambda.dumpProxyClasses&#x3D;&#x2F;DUMP&#x2F;PATH 导出这些具体的适配器类。这里我导出了上面这个例子中两个 Lambda 表达式对应的适配器类。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// i-&gt;i*2 对应的适配器类</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">LambdaTest$$Lambda$1</span> <span class="title class_">implements</span> <span class="title class_">IntUnaryOperator</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="type">LambdaTest</span>$<span class="variable">$Lambda</span><span class="variable">$1</span>();</span><br><span class="line">  <span class="type">Code</span>:</span><br><span class="line">    <span class="number">0</span>: aload_0</span><br><span class="line">    <span class="number">1</span>: invokespecial java<span class="operator">/</span>lang<span class="operator">/</span><span class="type">Object</span>.<span class="string">&quot;&lt;init&gt;&quot;</span>:()<span class="type">V</span></span><br><span class="line">    <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">public</span> int applyAsInt(int);</span><br><span class="line">  <span class="type">Code</span>:</span><br><span class="line">    <span class="number">0</span>: iload_1</span><br><span class="line">    <span class="number">1</span>: invokestatic <span class="type">LambdaTest</span>.lambda<span class="variable">$0</span>:(<span class="type">I</span>)<span class="type">I</span></span><br><span class="line">    <span class="number">4</span>: ireturn</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// i-&gt;i*x 对应的适配器类</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">LambdaTest$$Lambda$2</span> <span class="title class_">implements</span> <span class="title class_">IntUnaryOperator</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> int arg<span class="variable">$1</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">private</span> <span class="type">LambdaTest</span>$<span class="variable">$Lambda</span><span class="variable">$2</span>(int);</span><br><span class="line">  <span class="type">Code</span>:</span><br><span class="line">    <span class="number">0</span>: aload_0</span><br><span class="line">    <span class="number">1</span>: invokespecial java<span class="operator">/</span>lang<span class="operator">/</span><span class="type">Object</span>.<span class="string">&quot;&lt;init&gt;&quot;</span>:()<span class="type">V</span></span><br><span class="line">    <span class="number">4</span>: aload_0</span><br><span class="line">    <span class="number">5</span>: iload_1</span><br><span class="line">    <span class="number">6</span>: putfield arg<span class="variable">$1</span>:<span class="type">I</span></span><br><span class="line">    <span class="number">9</span>: <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> java.util.function.<span class="type">IntUnaryOperator</span> <span class="keyword">get</span><span class="variable">$Lambda</span>(int);</span><br><span class="line">  <span class="type">Code</span>:</span><br><span class="line">    <span class="number">0</span>: new <span class="type">LambdaTest</span>$<span class="variable">$Lambda</span><span class="variable">$2</span></span><br><span class="line">    <span class="number">3</span>: dup</span><br><span class="line">    <span class="number">4</span>: iload_0</span><br><span class="line">    <span class="number">5</span>: invokespecial <span class="string">&quot;&lt;init&gt;&quot;</span>:(<span class="type">I</span>)<span class="type">V</span></span><br><span class="line">    <span class="number">8</span>: areturn</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">public</span> int applyAsInt(int);</span><br><span class="line">  <span class="type">Code</span>:</span><br><span class="line">    <span class="number">0</span>: aload_0</span><br><span class="line">    <span class="number">1</span>: getfield arg<span class="variable">$1</span>:<span class="type">I</span></span><br><span class="line">    <span class="number">4</span>: iload_1</span><br><span class="line">    <span class="number">5</span>: invokestatic <span class="type">LambdaTest</span>.lambda<span class="variable">$1</span>:(<span class="type">II</span>)<span class="type">I</span></span><br><span class="line">    <span class="number">8</span>: ireturn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，捕获了局部变量的 Lambda 表达式多出了一个 get$Lambda 的方法。启动方法便会所返回的调用点链接至指向该方法的方法句柄。也就是说，每次执行 invokedynamic 指令时，都会调用至这个方法中，并构造一个新的适配器类实例。</p>
<p>这个多出来的新建实例会对程序性能造成影响吗？</p>
<h4 id="Lambda-以及方法句柄的性能分析"><a href="#Lambda-以及方法句柄的性能分析" class="headerlink" title="Lambda 以及方法句柄的性能分析"></a>Lambda 以及方法句柄的性能分析</h4><p>我再次请出测试反射调用性能开销的那段代码，并将其改造成使用 Lambda 表达式的 v6 版本。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v6 版本</span></span><br><span class="line"><span class="keyword">import</span> java.util.function.IntConsumer;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">target</span><span class="params">(<span class="type">int</span> i)</span> &#123; &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">current</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">2_000_000_000</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i % <span class="number">100_000_000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">temp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(temp - current);</span><br><span class="line">        current = temp;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      ((IntConsumer) j -&gt; Test.target(j)).accept(<span class="number">128</span>);</span><br><span class="line">      <span class="comment">// ((IntConsumer) Test::target.accept(128);</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测量结果显示，它与直接调用的性能并无太大的区别。也就是说，即时编译器能够将转换 Lambda 表达式所使用的 invokedynamic，以及对 IntConsumer.accept 方法的调用统统内联进来，最终优化为空操作。</p>
<p>这个其实不难理解：Lambda 表达式所使用的 invokedynamic 将绑定一个 ConstantCallSite，其链接的目标方法无法改变。因此，即时编译器会将该目标方法直接内联进来。对于这类没有捕获变量的 Lambda 表达式而言，目标方法只完成了一个动作，便是加载缓存的适配器类常量。</p>
<p>另一方面，对 IntConsumer.accept 方法的调用实则是对适配器类的 accept 方法的调用。</p>
<p>如果你查看了 accept 方法对应的字节码的话，你会发现它仅包含一个方法调用，调用至 Java 编译器在解 Lambda 语法糖时生成的方法。</p>
<p>该方法的内容便是 Lambda 表达式的内容，也就是直接调用目标方法 Test.target。将这几个方法调用内联进来之后，原本对 accept 方法的调用则会被优化为空操作。</p>
<p>下面我将之前的代码更改为带捕获变量的 v7 版本。理论上，每次调用 invokedynamic 指令，Java 虚拟机都会新建一个适配器类的实例。然而，实际运行结果还是与直接调用的性能一致。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v7 版本</span></span><br><span class="line"><span class="keyword">import</span> java.util.function.IntConsumer;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">target</span><span class="params">(<span class="type">int</span> i)</span> &#123; &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="type">long</span> <span class="variable">current</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">2_000_000_000</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i % <span class="number">100_000_000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">temp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(temp - current);</span><br><span class="line">        current = temp;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      ((IntConsumer) j -&gt; Test.target(x + j)).accept(<span class="number">128</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然，即时编译器的逃逸分析又将该新建实例给优化掉了。我们可以通过虚拟机参数 -XX:-DoEscapeAnalysis 来关闭逃逸分析。果然，这时候测得的值约为直接调用的 2.5 倍。</p>
<p>尽管逃逸分析能够去除这些额外的新建实例开销，但是它也不是时时奏效。它需要同时满足两件事：invokedynamic 指令所执行的方法句柄能够内联，和接下来的对 accept 方法的调用也能内联。</p>
<p>只有这样，逃逸分析才能判定该适配器实例不逃逸。否则，我们会在运行过程中不停地生成适配器类实例。所以，我们应当尽量使用非捕获的 Lambda 表达式。</p>
<h3 id="10-Java对象的内存布局"><a href="#10-Java对象的内存布局" class="headerlink" title="10. Java对象的内存布局"></a>10. Java对象的内存布局</h3><p>在 Java 程序中，我们拥有多种新建对象的方式。<u>除了最为常见的 new 语句之外，我们还可以通过反射机制、Object.clone 方法、反序列化以及 Unsafe.allocateInstance 方法来新建对象。</u></p>
<p>其中，Object.clone 方法和反序列化通过直接复制已有的数据，来初始化新建对象的实例字段。Unsafe.allocateInstance 方法则没有初始化实例字段，而 new 语句和反射机制，则是通过调用构造器来初始化实例字段。</p>
<p>以 new 语句为例，它编译而成的字节码将包含用来请求内存的 new 指令，以及用来调用构造器的 invokespecial 指令。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Foo foo = new Foo(); 编译而成的字节码</span></span><br><span class="line">  <span class="number">0</span> <span class="keyword">new</span> Foo</span><br><span class="line">  <span class="number">3</span> dup</span><br><span class="line">  <span class="number">4</span> <span class="function">invokespecial <span class="title">Foo</span>()</span></span><br><span class="line"><span class="function">  7 astore_1</span></span><br></pre></td></tr></table></figure>

<p>提到构造器，就不得不提到 Java 对构造器的诸多约束。首先，如果一个类没有定义任何构造器的话， Java 编译器会自动添加一个无参数的构造器。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Foo 类构造器会调用其父类 Object 的构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Foo</span>()</span>;</span><br><span class="line">  <span class="number">0</span> aload_0 [<span class="keyword">this</span>]</span><br><span class="line">  <span class="number">1</span> invokespecial java.lang.Object() [<span class="number">8</span>]</span><br><span class="line">  <span class="number">4</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>然后，子类的构造器需要调用父类的构造器。如果父类存在无参数构造器的话，该调用可以是隐式的，也就是说 Java 编译器会自动添加对父类构造器的调用。但是，<u>如果父类没有无参数构造器，那么子类的构造器则需要显式地调用父类带参数的构造器。</u></p>
<p>显式调用又可分为两种：</p>
<ul>
<li>一是直接使用“super”关键字调用父类构造器</li>
<li>二是使用“this”关键字调用同一个类中的其他构造器。无论是直接的显式调用，还是间接的显式调用，都需要作为构造器的第一条语句，以便优先初始化继承而来的父类字段。（不过这可以通过调用其他生成参数的方法，或者字节码注入来绕开。）</li>
</ul>
<p>总而言之，<u>当我们调用一个构造器时，它将优先调用父类的构造器，直至 Object 类</u>。这些构造器的调用者皆为同一对象，也就是通过 new 指令新建而来的对象。</p>
<p>你应该已经发现了其中的玄机：通过 new 指令新建出来的对象，它的内存其实涵盖了所有父类中的实例字段。也就是说，<u>虽然子类无法访问父类的私有实例字段，或者子类的实例字段隐藏了父类的同名实例字段，但是子类的实例还是会为这些父类实例字段分配内存的。</u></p>
<p>这些字段在内存中的具体分布是怎么样的呢？今天我们就来看看对象的内存布局。</p>
<h4 id="压缩指针"><a href="#压缩指针" class="headerlink" title="压缩指针"></a>压缩指针</h4><p>在 Java 虚拟机中，每个 Java 对象都有一个<strong>对象头</strong>（object header），这个<u>由标记字段和类型指针所构成</u>。其中，<strong>标记字段用以存储 Java 虚拟机有关该对象的运行数据，如哈希码、GC 信息以及锁信息，而类型指针则指向该对象的类</strong>。</p>
<p>在 64 位的 Java 虚拟机中，对象头的标记字段占 64 位，而类型指针又占了 64 位。也就是说，<u>每一个 Java 对象在内存中的额外开销就是 16 个字节</u>。以 Integer 类为例，它仅有一个 int 类型的私有字段，占 4 个字节。因此，每一个 Integer 对象的额外内存开销至少是 400%。这也是为什么 Java 要引入基本类型的原因之一。</p>
<p>为了尽量较少对象的内存使用量，64 位 Java 虚拟机引入了<a href="https://wiki.openjdk.java.net/display/HotSpot/CompressedOops">压缩指针</a>的概念（对应虚拟机选项 -XX:+UseCompressedOops，默认开启），将堆中原本 64 位的 Java 对象指针压缩成 32 位的。</p>
<p>这样一来，<strong>对象头中的类型指针也会被压缩成 32 位，使得对象头的大小从 16 字节降至 12 字节。当然，压缩指针不仅可以作用于对象头的类型指针，还可以作用于引用类型的字段，以及引用类型数组。</strong></p>
<p>那么压缩指针是什么原理呢？</p>
<p>打个比方，路上停着的全是房车，而且每辆房车恰好占据两个停车位。现在，我们按照顺序给它们编号。也就是说，停在 0 号和 1 号停车位上的叫 0 号车，停在 2 号和 3 号停车位上的叫 1 号车，依次类推。</p>
<p>原本的内存寻址用的是车位号。比如说我有一个值为 6 的指针，代表第 6 个车位，那么沿着这个指针可以找到 3 号车。现在我们规定指针里存的值是车号，比如 3 指代 3 号车。当需要查找 3 号车时，我便可以将该指针的值乘以 2，再沿着 6 号车位找到 3 号车。</p>
<p>这样一来，32 位压缩指针最多可以标记 2 的 32 次方辆车，对应着 2 的 33 次方个车位。当然，房车也有大小之分。大房车占据的车位可能是三个甚至是更多。不过这并不会影响我们的寻址算法：我们只需跳过部分车号，便可以保持原本车号 *2 的寻址系统。</p>
<p>上述模型有一个前提，你应该已经想到了，就是每辆车都从偶数号车位停起。这个概念我们称之为内存对齐（对应虚拟机选项 -XX:ObjectAlignmentInBytes，默认值为 8）。</p>
<p><strong>默认情况下，Java 虚拟机堆中对象的起始地址需要对齐至 8 的倍数</strong>。如果一个对象用不到 8N 个字节，那么空白的那部分空间就浪费掉了。这些浪费掉的空间我们称之为对象间的填充（padding）。</p>
<p>在默认情况下，Java 虚拟机中的 32 位压缩指针可以寻址到 2 的 35 次方个字节，也就是 32GB 的地址空间（超过 32GB 则会关闭压缩指针）。</p>
<p>在对压缩指针解引用时，我们需要将其左移 3 位，再加上一个固定偏移量，便可以得到能够寻址 32GB 地址空间的伪 64 位指针了。</p>
<p>此外，我们可以通过配置刚刚提到的内存对齐选项（-XX:ObjectAlignmentInBytes）来进一步提升寻址范围。但是，这同时也可能增加对象间填充，导致压缩指针没有达到原本节省空间的效果。</p>
<p>举例来说，如果规定每辆车都需要从偶数车位号停起，那么对于占据两个车位的小房车来说刚刚好，而对于需要三个车位的大房车来说，也仅是浪费一个车位。</p>
<p>但是如果规定需要从 4 的倍数号车位停起，那么小房车则会浪费两个车位，而大房车至多可能浪费三个车位。</p>
<p>当然，就算是关闭了压缩指针，Java 虚拟机还是会进行内存对齐。此外，<u>内存对齐不仅存在于对象与对象之间，也存在于对象中的字段之间。比如说，Java 虚拟机要求 long 字段、double 字段，以及非压缩指针状态下的引用字段地址为 8 的倍数。</u></p>
<p>字段内存对齐的其中一个原因，是让字段只出现在同一 CPU 的缓存行中。如果字段不是对齐的，那么就有可能出现跨缓存行的字段。也就是说，该字段的读取可能需要替换两个缓存行，而该字段的存储也会同时污染两个缓存行。这两种情况对程序的执行效率而言都是不利的。</p>
<p>下面我来介绍一下对象内存布局另一个有趣的特性：字段重排列。</p>
<h4 id="字段重排列"><a href="#字段重排列" class="headerlink" title="字段重排列"></a>字段重排列</h4><p>字段重排列，顾名思义，就是 J<u>ava 虚拟机重新分配字段的先后顺序，以达到内存对齐的目的</u>。Java 虚拟机中有三种排列方法（对应 Java 虚拟机选项 -XX:FieldsAllocationStyle，默认值为 1），但都会遵循如下两个规则。</p>
<p><strong>其一，如果一个字段占据 C 个字节，那么该字段的偏移量需要对齐至 NC。这里偏移量指的是字段地址与对象的起始地址差值。</strong></p>
<p>以 long 类为例，它仅有一个 long 类型的实例字段。在使用了压缩指针的 64 位虚拟机中，尽管对象头的大小为 12 个字节，该 long 类型字段的偏移量也只能是 16，而中间空着的 4 个字节便会被浪费掉。</p>
<p><strong>其二，子类所继承字段的偏移量，需要与父类对应字段的偏移量保持一致。</strong></p>
<p>在具体实现中，Java 虚拟机还会对齐子类字段的起始位置。对于使用了压缩指针的 64 位虚拟机，子类第一个字段需要对齐至 4N；而对于关闭了压缩指针的 64 位虚拟机，子类第一个字段则需要对齐至 8N。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="type">long</span> l;</span><br><span class="line">  <span class="type">int</span> i；</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="type">long</span> l;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我在文中贴了一段代码，里边定义了两个类 A 和 B，其中 B 继承 A。A 和 B 各自定义了一个 long 类型的实例字段和一个 int 类型的实例字段。下面我分别打印了 B 类在启用压缩指针和未启用压缩指针时，各个字段的偏移量。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># 启用压缩指针时，B 类的字段分布</span></span><br><span class="line">B <span class="built_in">object</span> internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (<span class="built_in">object</span> header)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (<span class="built_in">object</span> header)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (<span class="built_in">object</span> header)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>    <span class="built_in">int</span> A.i                                       <span class="number">0</span></span><br><span class="line">     <span class="number">16</span>     <span class="number">8</span>   <span class="built_in">long</span> A.l                                       <span class="number">0</span></span><br><span class="line">     <span class="number">24</span>     <span class="number">8</span>   <span class="built_in">long</span> B.l                                       <span class="number">0</span></span><br><span class="line">     <span class="number">32</span>     <span class="number">4</span>    <span class="built_in">int</span> B.i                                       <span class="number">0</span></span><br><span class="line">     <span class="number">36</span>     <span class="number">4</span>        (loss due to the next <span class="built_in">object</span> alignment)</span><br></pre></td></tr></table></figure>

<p>当启用压缩指针时，可以看到 Java 虚拟机将 A 类的 int 字段放置于 long 字段之前，以填充因为 long 字段对齐造成的 4 字节缺口。由于对象整体大小需要对齐至 8N，因此对象的最后会有 4 字节的空白填充。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># 关闭压缩指针时，B 类的字段分布</span></span><br><span class="line">B <span class="built_in">object</span> internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (<span class="built_in">object</span> header)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (<span class="built_in">object</span> header)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (<span class="built_in">object</span> header)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (<span class="built_in">object</span> header)</span><br><span class="line">     <span class="number">16</span>     <span class="number">8</span>   <span class="built_in">long</span> A.l</span><br><span class="line">     <span class="number">24</span>     <span class="number">4</span>    <span class="built_in">int</span> A.i</span><br><span class="line">     <span class="number">28</span>     <span class="number">4</span>        (alignment/padding gap)                  </span><br><span class="line">     <span class="number">32</span>     <span class="number">8</span>   <span class="built_in">long</span> B.l</span><br><span class="line">     <span class="number">40</span>     <span class="number">4</span>    <span class="built_in">int</span> B.i</span><br><span class="line">     <span class="number">44</span>     <span class="number">4</span>        (loss due to the next <span class="built_in">object</span> alignment)</span><br></pre></td></tr></table></figure>

<p>当关闭压缩指针时，B 类字段的起始位置需对齐至 8N。这么一来，B 类字段的前后各有 4 字节的空白。那么我们可不可以将 B 类的 int 字段移至前面的空白中，从而节省这 8 字节呢？</p>
<p>我认为是可以的，并且我修改过后的 Java 虚拟机也没有跑崩。由于 HotSpot 中的这块代码年久失修，公司的同事也已经记不得是什么原因了，那么姑且先认为是一些历史遗留问题吧。</p>
<p>Java 8 还引入了一个新的注释 @Contended，用来解决对象字段之间的<a href="%5Bhttp://openjdk.java.net/jeps/142%5D(https://openjdk.java.net/jeps/142)">虚共享</a>（false sharing）问题。这个注释也会影响到字段的排列。</p>
<p>虚共享是怎么回事呢？假设两个线程分别访问同一对象中不同的 volatile 字段，逻辑上它们并没有共享内容，因此不需要同步。</p>
<p>然而，如果这两个字段恰好在同一个缓存行中，那么对这些字段的写操作会导致缓存行的写回，也就造成了实质上的共享。（volatile 字段和缓存行的故事我会在之后的篇章中详细介绍。）</p>
<p>Java 虚拟机会让不同的 @Contended 字段处于独立的缓存行中，因此你会看到大量的空间被浪费掉。具体的分布算法属于实现细节，随着 Java 版本的变动也比较大，因此这里就不做阐述了。</p>
<p>如果你感兴趣，可以利用实践环节的工具，来查阅 Contended 字段的内存布局。注意使用虚拟机选项 -XX:-RestrictContended。如果你在 Java 9 以上版本试验的话，在使用 javac 编译时需要添加 –add-exports java.base&#x2F;jdk.internal.vm.annotation&#x3D;ALL-UNNAME</p>
<h3 id="11-垃圾回收（上）"><a href="#11-垃圾回收（上）" class="headerlink" title="11 垃圾回收（上）"></a>11 垃圾回收（上）</h3><p>你应该听说过这么一句话：免费的其实是最贵的。</p>
<p>Java 虚拟机的自动内存管理，将原本需要由开发人员手动回收的内存，交给垃圾回收器来自动回收。不过既然是自动机制，肯定没法做到像<a href="https://media.giphy.com/media/EZ8QO0myvsSk/giphy.gif">手动回收</a>那般精准高效，而且还会带来不少与垃圾回收实现相关的问题。</p>
<p>接下来的两篇，我们会深入探索 Java 虚拟机中的垃圾回收器。今天这一篇，我们来回顾一下垃圾回收的基础知识。</p>
<h4 id="引用计数法与可达性分析"><a href="#引用计数法与可达性分析" class="headerlink" title="引用计数法与可达性分析"></a>引用计数法与可达性分析</h4><p>垃圾回收，顾名思义，便是将已经分配出去的，但却不再使用的内存回收回来，以便能够再次分配。<strong>在 Java 虚拟机的语境下，垃圾指的是死亡的对象所占据的堆空间。</strong>这里便涉及了一个关键的问题：<u>如何辨别一个对象是存是亡</u>？</p>
<p>我们先来讲一种古老的辨别方法：引用计数法（reference counting）。它的做法是为每个对象添加一个引用计数器，用来统计指向该对象的引用个数。一旦某个对象的引用计数器为 0，则说明该对象已经死亡，便可以被回收了。</p>
<p>它的具体实现是这样子的：如果有一个引用，被赋值为某一对象，那么将该对象的引用计数器 +1。如果一个指向某一对象的引用，被赋值为其他值，那么将该对象的引用计数器 -1。也就是说，我们需要截获所有的引用更新操作，并且相应地增减目标对象的引用计数器。</p>
<p>除了需要额外的空间来存储计数器，以及繁琐的更新操作，<strong>引用计数法还有一个重大的漏洞，那便是无法处理循环引用对象</strong>。</p>
<p>举个例子，假设对象 a 与 b 相互引用，除此之外没有其他引用指向 a 或者 b。在这种情况下，a 和 b 实际上已经死了，但由于它们的引用计数器皆不为 0，在引用计数法的心中，这两个对象还活着。因此，这些循环引用对象所占据的空间将不可回收，从而造成了内存泄露。</p>
<img src="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/assets/8546a9b3c6660a31ae24bef0ef0a35b9.png" alt="img" style="zoom:50%;" />

<p><strong>目前 Java 虚拟机的主流垃圾回收器采取的是可达性分析算法</strong>。这个算法的实质在于将一系列 <strong>GC Roots</strong> 作为初始的存活对象合集（live set），然后从该合集出发，探索所有能够被该集合引用到的对象，并将其加入到该集合中，这个过程我们也称之为标记（mark）。最终，未被探索到的对象便是死亡的，是可以回收的。</p>
<p>那么什么是 GC Roots 呢？我们<u>可以暂时理解为由堆外指向堆内的引用</u>，一般而言，GC Roots 包括（但不限于）如下几种：</p>
<ol>
<li>Java 方法栈桢中的局部变量；</li>
<li>已加载类的静态变量；</li>
<li>JNI handles；</li>
<li>已启动且未停止的 Java 线程。</li>
</ol>
<p>可达性分析可以解决引用计数法所不能解决的循环引用问题。举例来说，即便对象 a 和 b 相互引用，只要从 GC Roots 出发无法到达 a 或者 b，那么可达性分析便不会将它们加入存活对象合集之中。</p>
<p>虽然可达性分析的算法本身很简明，但是在实践中还是有不少其他问题需要解决的。</p>
<p>比如说，<u>在多线程环境下，其他线程可能会更新已经访问过的对象中的引用，从而造成误报（将引用设置为 null）或者漏报（将引用设置为未被访问过的对象）</u>。</p>
<p>误报并没有什么伤害，Java 虚拟机至多损失了部分垃圾回收的机会。漏报则比较麻烦，因为垃圾回收器可能回收事实上仍被引用的对象内存。一旦从原引用访问已经被回收了的对象，则很有可能会直接导致 Java 虚拟机崩溃。</p>
<h4 id="Stop-the-world-以及安全点"><a href="#Stop-the-world-以及安全点" class="headerlink" title="Stop-the-world 以及安全点"></a>Stop-the-world 以及安全点</h4><p>怎么解决这个问题呢？在 Java 虚拟机里，传统的垃圾回收算法采用的是一种简单粗暴的方式，那便是 <strong>Stop-the-world，停止其他非垃圾回收线程的工作，直到完成垃圾回收</strong>。这也就造成了垃圾回收所谓的暂停时间（GC pause）。</p>
<p>Java 虚拟机中的 Stop-the-world 是通过安全点（safepoint）机制来实现的。当 Java 虚拟机收到 Stop-the-world 请求，它便会等待所有的线程都到达安全点，才允许请求 Stop-the-world 的线程进行独占的工作。</p>
<p><a href="%5Bhttp://psy-lob-saw.blogspot.com/2015/12/safepoints.html%5D(https://psy-lob-saw.blogspot.com/2015/12/safepoints.html)">这篇博客</a> 还提到了一种比较另类的解释：安全词。一旦垃圾回收线程喊出了安全词，其他非垃圾回收线程便会一一停下。</p>
<p>当然，安全点的初始目的并不是让其他线程停下，而是找到一个稳定的执行状态。在这个执行状态下，Java 虚拟机的堆栈不会发生变化。这么一来，垃圾回收器便能够“安全”地执行可达性分析。</p>
<p>举个例子，当 Java 程序通过 JNI 执行本地代码时，如果这段代码不访问 Java 对象、调用 Java 方法或者返回至原 Java 方法，那么 Java 虚拟机的堆栈不会发生改变，也就代表着这段本地代码可以作为同一个安全点。</p>
<p>只要不离开这个安全点，Java 虚拟机便能够在垃圾回收的同时，继续运行这段本地代码。</p>
<p>由于本地代码需要通过 JNI 的 API 来完成上述三个操作，因此 Java 虚拟机仅需在 API 的入口处进行<strong>安全点检测</strong>（safepoint poll），测试是否有其他线程请求停留在安全点里，便可以在必要的时候挂起当前线程。</p>
<p>除了执行 JNI 本地代码外，Java 线程还有其他几种状态：<strong>解释执行字节码、执行即时编译器生成的机器码和线程阻塞</strong>。阻塞的线程由于处于 Java 虚拟机线程调度器的掌控之下，因此属于安全点。</p>
<p>其他几种状态则是运行状态，需要虚拟机保证在可预见的时间内进入安全点。否则，垃圾回收线程可能长期处于等待所有线程进入安全点的状态，从而变相地提高了垃圾回收的暂停时间。</p>
<p>对于解释执行来说，字节码与字节码之间皆可作为安全点。Java 虚拟机采取的做法是，当有安全点请求时，执行一条字节码便进行一次安全点检测。</p>
<p>执行即时编译器生成的机器码则比较复杂。由于这些代码直接运行在底层硬件之上，不受 Java 虚拟机掌控，因此在生成机器码时，即时编译器需要插入安全点检测，以避免机器码长时间没有安全点检测的情况。HotSpot 虚拟机的做法便是<u>在生成代码的方法出口以及非计数循环的循环回边（back-edge）处插入安全点检测</u>。</p>
<p>那么为什么不在每一条机器码或者每一个机器码基本块处插入安全点检测呢？原因主要有两个。</p>
<ul>
<li>第一，安全点检测本身也有一定的开销。不过 HotSpot 虚拟机已经将机器码中安全点检测简化为一个内存访问操作。在有安全点请求的情况下，Java 虚拟机会将安全点检测访问的内存所在的页设置为不可读，并且定义一个 segfault 处理器，来截获因访问该不可读内存而触发 segfault 的线程，并将它们挂起。</li>
<li>第二，即时编译器生成的机器码打乱了原本栈桢上的对象分布状况。在进入安全点时，机器码还需提供一些额外的信息，来表明哪些寄存器，或者当前栈帧上的哪些内存空间存放着指向对象的引用，以便垃圾回收器能够枚举 GC Roots。</li>
</ul>
<p>由于这些信息需要不少空间来存储，因此即时编译器会尽量避免过多的安全点检测。</p>
<p>不过，不同的即时编译器插入安全点检测的位置也可能不同。以 Graal 为例，除了上述位置外，它还会在计数循环的循环回边处插入安全点检测。其他的虚拟机也可能选取方法入口而非方法出口来插入安全点检测。</p>
<p>不管如何，其目的都是在可接受的性能开销以及内存开销之内，避免机器码长时间不进入安全点的情况，间接地减少垃圾回收的暂停时间。</p>
<p>除了垃圾回收之外，Java 虚拟机其他一些对堆栈内容的一致性有要求的操作也会用到安全点这一机制。我会在涉及的时侯再进行具体的讲解。</p>
<h4 id="垃圾回收的三种方式"><a href="#垃圾回收的三种方式" class="headerlink" title="垃圾回收的三种方式"></a>垃圾回收的三种方式</h4><p>当标记完所有的存活对象时，我们便可以进行死亡对象的回收工作了。主流的基础回收方式可分为三种。</p>
<ul>
<li><p>第一种是<strong>清除（sweep）</strong>，即把死亡对象所占据的内存标记为空闲内存，并记录在一个空闲列表（free list）之中。当需要新建对象时，内存管理模块便会从该空闲列表中寻找空闲内存，并划分给新建的对象。</p>
<img src="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/assets/f225126be24826658ca5a899fcff5003.png" alt="img" style="zoom: 50%;" />

<p>清除这种回收方式的原理及其简单，但是有两个缺点:</p>
<ul>
<li>一是会造成内存碎片。由于 Java 虚拟机的堆中对象必须是连续分布的，因此可能出现总空闲内存足够，但是无法分配的极端情况。</li>
<li>另一个则是分配效率较低。如果是一块连续的内存空间，那么我们可以通过指针加法（pointer bumping）来做分配。而对于空闲列表，Java 虚拟机则需要逐个访问列表中的项，来查找能够放入新建对象的空闲内存。</li>
</ul>
</li>
<li><p>第二种是<strong>压缩（compact）</strong>，即把存活的对象聚集到内存区域的起始位置，从而留下一段连续的内存空间。这种做法能够解决内存碎片化的问题，但代价是压缩算法的性能开销。</p>
<img src="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/assets/415ee8e4aef12ff076b42e41660dad39.png" alt="img" style="zoom:50%;" />
</li>
<li><p>第三种则是<strong>复制（copy）</strong>，即把内存区域分为两等分，分别用两个指针 from 和 to 来维护，并且只是用 from 指针指向的内存区域来分配内存。当发生垃圾回收时，便把存活的对象复制到 to 指针指向的内存区域中，并且交换 from 指针和 to 指针的内容。复制这种回收方式同样能够解决内存碎片化的问题，但是它的缺点也极其明显，即堆空间的使用效率极其低下。</p>
<img src="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/assets/4749cad235deb1542d4ca3b232ebf261.png" alt="img" style="zoom:50%;" /></li>
</ul>
<p>当然，现代的垃圾回收器往往会综合上述几种回收方式，综合它们优点的同时规避它们的缺点。在下一篇中我们会详细介绍 Java 虚拟机中垃圾回收算法的具体实现。</p>
<h3 id="12-垃圾回收（下）"><a href="#12-垃圾回收（下）" class="headerlink" title="12 垃圾回收（下）"></a>12 垃圾回收（下）</h3><p>在读博士的时候，我曾经写过一个统计 Java 对象生命周期的动态分析，并且用它来跑了一些基准测试。</p>
<p>其中一些程序的结果，恰好验证了许多研究人员的假设，即大部分的 Java 对象只存活一小段时间，而存活下来的小部分 Java 对象则会存活很长一段时间。</p>
<img src="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/assets/e235d25ca15b60a511a2d90317eb9589.png" alt="img" style="zoom:50%;" />

<p>（pmd 中 Java 对象生命周期的直方图，红色的表示被逃逸分析优化掉的对象）</p>
<p>之所以要提到这个假设，是因为它造就了 Java 虚拟机的<strong>分代回收思想</strong>。简单来说，就是<strong>将堆空间划分为两代，分别叫做新生代和老年代。新生代用来存储新建的对象。当对象存活时间够长时，则将其移动到老年代</strong>。</p>
<p>Java 虚拟机可以给不同代使用不同的回收算法。对于新生代，我们猜测大部分的 Java 对象只存活一小段时间，那么便可以频繁地采用耗时较短的垃圾回收算法，让大部分的垃圾都能够在新生代被回收掉。</p>
<p>对于老年代，我们猜测大部分的垃圾已经在新生代中被回收了，而在老年代中的对象有大概率会继续存活。当真正触发针对老年代的回收时，则代表这个假设出错了，或者堆的空间已经耗尽了。</p>
<p>这时候，Java 虚拟机往往需要做一次全堆扫描，耗时也将不计成本。（当然，现代的垃圾回收器都在并发收集的道路上发展，来避免这种全堆扫描的情况。）</p>
<p>今天这一篇我们来关注一下针对新生代的 Minor GC。首先，我们来看看 Java 虚拟机中的堆具体是怎么划分的。</p>
<h4 id="Java-虚拟机的堆划分"><a href="#Java-虚拟机的堆划分" class="headerlink" title="Java 虚拟机的堆划分"></a>Java 虚拟机的堆划分</h4><p>前面提到，Java 虚拟机将堆划分为新生代和老年代。其中，新生代又被划分为 Eden 区，以及两个大小相同的 Survivor 区。</p>
<p><u>默认情况下，Java 虚拟机采取的是一种动态分配的策略</u>（对应 Java 虚拟机参数 -XX:+UsePSAdaptiveSurvivorSizePolicy），根据生成对象的速率，以及 Survivor 区的使用情况动态调整 Eden 区和 Survivor 区的比例。</p>
<p>当然，你也可以通过参数 -XX:SurvivorRatio 来固定这个比例。但是需要注意的是，其中一个 Survivor 区会一直为空，因此比例越低浪费的堆空间将越高。</p>
<p><img src="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/assets/2cc29b8de676d3747416416a3523e4e5.png" alt="img"></p>
<p>通常来说，<u>当我们调用 new 指令时，它会在 Eden 区中划出一块作为存储对象的内存</u>。<u>由于堆空间是线程共享的，因此直接在这里边划空间是需要进行同步的</u>。</p>
<p>否则，将有可能出现两个对象共用一段内存的事故。如果你还记得前两篇我用“停车位”打的比方的话，这里就相当于两个司机（线程）同时将车停入同一个停车位，因而发生剐蹭事故。</p>
<p>Java 虚拟机的解决方法是为每个司机预先申请多个停车位，并且只允许该司机停在自己的停车位上。那么当司机的停车位用完了该怎么办呢（假设这个司机代客泊车）？</p>
<p>答案是：再申请多个停车位便可以了。这项技术被称之为 TLAB（Thread Local Allocation Buffer，对应虚拟机参数 -XX:+UseTLAB，默认开启）。</p>
<p>具体来说，<u>每个线程可以向 Java 虚拟机申请一段连续的内存，比如 2048 字节，作为线程私有的 TLAB。</u></p>
<p><u>这个操作需要加锁，线程需要维护两个指针（实际上可能更多，但重要也就两个），一个指向 TLAB 中空余内存的起始位置，一个则指向 TLAB 末尾。</u></p>
<p>接下来的 new 指令，便可以直接通过指针加法（bump the pointer）来实现，即把指向空余内存位置的指针加上所请求的字节数。</p>
<blockquote>
<p>我猜测会有留言问为什么不把 bump the pointer 翻译成指针碰撞。这里先解释一下，在英语中我们通常省略了 bump up the pointer 中的 up。在这个上下文中 bump 的含义应为“提高”。另外一个例子是当我们发布软件的新版本时，也会说 bump the version number。</p>
</blockquote>
<p>如果加法后空余内存指针的值仍小于或等于指向末尾的指针，则代表分配成功。否则，TLAB 已经没有足够的空间来满足本次新建操作。这个时候，便需要当前线程重新申请新的 TLAB。</p>
<p>当 Eden 区的空间耗尽了怎么办？这个时候 Java 虚拟机便会触发一次 Minor GC，来收集新生代的垃圾。存活下来的对象，则会被送到 Survivor 区。</p>
<p>前面提到，新生代共有两个 Survivor 区，我们分别用 from 和 to 来指代。其中 to 指向的 Survivior 区是空的。</p>
<p>当发生 Minor GC 时，Eden 区和 from 指向的 Survivor 区中的存活对象会被复制到 to 指向的 Survivor 区中，然后交换 from 和 to 指针，以保证下一次 Minor GC 时，to 指向的 Survivor 区还是空的。</p>
<p>Java 虚拟机会记录 Survivor 区中的对象一共被来回复制了几次。如果一个对象被复制的次数为 15（对应虚拟机参数 -XX:+MaxTenuringThreshold），那么该对象将被晋升（promote）至老年代。另外，如果单个 Survivor 区已经被占用了 50%（对应虚拟机参数 -XX:TargetSurvivorRatio），那么较高复制次数的对象也会被晋升至老年代。</p>
<p>总而言之，<strong>当发生 Minor GC 时，我们应用了标记 - 复制算法，将 Survivor 区中的老存活对象晋升到老年代，然后将剩下的存活对象和 Eden 区的存活对象复制到另一个 Survivor 区中</strong>。理想情况下，Eden 区中的对象基本都死亡了，那么需要复制的数据将非常少，因此采用这种标记 - 复制算法的效果极好。</p>
<p>Minor GC 的另外一个好处是不用对整个堆进行垃圾回收。但是，它却<u>有一个问题，那就是老年代的对象可能引用新生代的对象</u>。也就是说，在标记存活对象的时候，我们需要扫描老年代中的对象。如果该对象拥有对新生代对象的引用，那么这个引用也会被作为 GC Roots。</p>
<p>这样一来，岂不是又做了一次全堆扫描呢？</p>
<h4 id="卡表"><a href="#卡表" class="headerlink" title="卡表"></a>卡表</h4><p>HotSpot 给出的解决方案是一项叫做<strong>卡表</strong>（Card Table）的技术。该技术将整个堆划分为一个个大小为 512 字节的卡，并且<u>维护一个卡表，用来存储每张卡的一个标识位。这个标识位代表对应的卡是否可能存有指向新生代对象的引用</u>。如果可能存在，那么我们就认为这张卡是脏的。</p>
<p>在进行 Minor GC 的时候，我们便<u>可以不用扫描整个老年代，而是在卡表中寻找脏卡，并将脏卡中的对象加入到 Minor GC 的 GC Roots 里</u>。当完成所有脏卡的扫描之后，Java 虚拟机便会将所有脏卡的标识位清零。</p>
<p>由于 Minor GC 伴随着存活对象的复制，而复制需要更新指向该对象的引用。因此，在更新引用的同时，我们又会设置引用所在的卡的标识位。这个时候，我们可以确保脏卡中必定包含指向新生代对象的引用。</p>
<p>在 Minor GC 之前，我们并不能确保脏卡中包含指向新生代对象的引用。其原因和如何设置卡的标识位有关。</p>
<p>首先，如果想要保证每个可能有指向新生代对象引用的卡都被标记为脏卡，那么 Java 虚拟机需要截获每个引用型实例变量的写操作，并作出对应的写标识位操作。</p>
<p>这个操作在解释执行器中比较容易实现。但是在即时编译器生成的机器码中，则需要插入额外的逻辑。这也就是所谓的写屏障（write barrier，注意不要和 volatile 字段的写屏障混淆）。</p>
<p>写屏障需要尽可能地保持简洁。这是因为我们并不希望在每条引用型实例变量的写指令后跟着一大串注入的指令。</p>
<p>因此，写屏障并不会判断更新后的引用是否指向新生代中的对象，而是宁可错杀，不可放过，一律当成可能指向新生代对象的引用。</p>
<p>这么一来，写屏障便可精简为下面的<a href="%5Bhttp://psy-lob-saw.blogspot.com/2014/10/the-jvm-write-barrier-card-marking.html%5D(https://psy-lob-saw.blogspot.com/2014/10/the-jvm-write-barrier-card-marking.html)">伪代码</a> 。这里右移 9 位相当于除以 512，Java 虚拟机便是通过这种方式来从地址映射到卡表中的索引的。最终，这段代码会被编译成一条移位指令和一条存储指令。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">CARD_TABLE [<span class="keyword">this</span> address &gt;&gt; <span class="number">9</span>] = DIRTY;</span><br></pre></td></tr></table></figure>

<p>虽然写屏障不可避免地带来一些开销，但是它能够加大 Minor GC 的吞吐率（ 应用运行时间 &#x2F;(应用运行时间 + 垃圾回收时间) ）。总的来说还是值得的。不过，在高并发环境下，写屏障又带来了<a href="https://blogs.oracle.com/dave/false-sharing-induced-by-card-table-marking">虚共享（false sharing）问题</a>。</p>
<p>在介绍对象内存布局中曾提到虚共享问题，讲的是几个 volatile 字段出现在同一缓存行里造成的虚共享。这里的虚共享则是卡表中不同卡的标识位之间的虚共享问题。</p>
<p>在 HotSpot 中，卡表是通过 byte 数组来实现的。对于一个 64 字节的缓存行来说，如果用它来加载部分卡表，那么它将对应 64 张卡，也就是 32KB 的内存。</p>
<p>如果同时有两个 Java 线程，在这 32KB 内存中进行引用更新操作，那么也将造成存储卡表的同一部分的缓存行的写回、无效化或者同步操作，因而间接影响程序性能。</p>
<p>为此，HotSpot 引入了一个新的参数 -XX:+UseCondCardMark，来尽量减少写卡表的操作。其伪代码如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (CARD_TABLE [<span class="keyword">this</span> address &gt;&gt; <span class="number">9</span>] != DIRTY) </span><br><span class="line">  CARD_TABLE [<span class="keyword">this</span> address &gt;&gt; <span class="number">9</span>] = DIRTY;</span><br></pre></td></tr></table></figure>

<h4 id="附录：Java-虚拟机中的垃圾回收器"><a href="#附录：Java-虚拟机中的垃圾回收器" class="headerlink" title="附录：Java 虚拟机中的垃圾回收器"></a>附录：Java 虚拟机中的垃圾回收器</h4><p>针对新生代的垃圾回收器共有三个：Serial，Parallel Scavenge 和 Parallel New。这三个采用的都是标记 - 复制算法。其中，Serial 是一个单线程的，Parallel New 可以看成 Serial 的多线程版本。Parallel Scavenge 和 Parallel New 类似，但更加注重吞吐率。此外，Parallel Scavenge 不能与 CMS 一起使用。</p>
<p>针对老年代的垃圾回收器也有三个：刚刚提到的 Serial Old 和 Parallel Old，以及 CMS。Serial Old 和 Parallel Old 都是标记 - 压缩算法。同样，前者是单线程的，而后者可以看成前者的多线程版本。</p>
<p>CMS 采用的是标记 - 清除算法，并且是并发的。除了少数几个操作需要 Stop-the-world 之外，它可以在应用程序运行过程中进行垃圾回收。在并发收集失败的情况下，Java 虚拟机会使用其他两个压缩型垃圾回收器进行一次垃圾回收。由于 G1 的出现，CMS 在 Java 9 中已<a href="https://openjdk.java.net/jeps/291">被废弃</a>。</p>
<p>G1（Garbage First）是一个横跨新生代和老年代的垃圾回收器。实际上，它已经打乱了前面所说的堆结构，直接将堆分成极其多个区域。每个区域都可以充当 Eden 区、Survivor 区或者老年代中的一个。它采用的是标记 - 压缩算法，而且和 CMS 一样都能够在应用程序运行过程中并发地进行垃圾回收。</p>
<p>G1 能够针对每个细分的区域来进行垃圾回收。在选择进行垃圾回收的区域时，它会优先回收死亡对象较多的区域。这也是 G1 名字的由来。</p>
<p>即将到来的 Java 11 引入了 ZGC，宣称暂停时间不超过 10ms。如果你感兴趣的话，可参考 R 大的<a href="https://www.zhihu.com/question/287945354/answer/458761494">这篇文章</a>。</p>
<h3 id="13-Java内存模型"><a href="#13-Java内存模型" class="headerlink" title="13 Java内存模型"></a>13 Java内存模型</h3><p>我们先来看一个反常识的例子。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> a=<span class="number">0</span>, b=<span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span>()</span> &#123;</span><br><span class="line">  <span class="built_in">int</span> r2 = a;</span><br><span class="line">  b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span>()</span> &#123;</span><br><span class="line">  <span class="built_in">int</span> r1 = b;</span><br><span class="line">  a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我定义了两个共享变量 a 和 b，以及两个方法。第一个方法将局部变量 r2 赋值为 a，然后将共享变量 b 赋值为 1。第二个方法将局部变量 r1 赋值为 b，然后将共享变量 a 赋值为 2。请问（r1，r2）的可能值都有哪些？</p>
<p>在单线程环境下，我们可以先调用第一个方法，最终（r1，r2）为（1，0）；也可以先调用第二个方法，最终为（0，2）。</p>
<p>在多线程环境下，假设这两个方法分别跑在两个不同的线程之上，如果 Java 虚拟机在执行了任一方法的第一条赋值语句之后便切换线程，那么最终结果将可能出现（0，0）的情况。</p>
<p>除上述三种情况之外，<a href="https://docs.oracle.com/javase/specs/jls/se10/html/jls-17.html#jls-17.4">Java 语言规范第 17.4 小节</a> 还介绍了一种看似不可能的情况（1，2）。</p>
<p>造成这一情况的原因有三个，分别为即时编译器的重排序，处理器的乱序执行，以及内存系统的重排序。由于后两种原因涉及具体的体系架构，我们暂且放到一边。下面我先来讲一下编译器优化的重排序是怎么一回事。</p>
<p>首先需要说明一点，即时编译器（和处理器）需要保证程序能够遵守 as-if-serial 属性。通俗地说，就是在单线程情况下，要给程序一个顺序执行的假象。即经过重排序的执行结果要与顺序执行的结果保持一致。</p>
<p>另外，如果两个操作之间存在数据依赖，那么即时编译器（和处理器）不能调整它们的顺序，否则将会造成程序语义的改变。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> a=<span class="number">0</span>, b=<span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span>()</span> &#123;</span><br><span class="line">  <span class="built_in">int</span> r2 = a;</span><br><span class="line">  b = <span class="number">1</span>;</span><br><span class="line">  .. <span class="comment">// Code uses b</span></span><br><span class="line">  <span class="keyword">if</span> (r2 == <span class="number">2</span>) &#123;</span><br><span class="line">    .. </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面这段代码中，我扩展了先前例子中的第一个方法。新增的代码会先使用共享变量 b 的值，然后再使用局部变量 r2 的值。</p>
<p>此时，即时编译器有两种选择。</p>
<p>第一，在一开始便将 a 加载至某一寄存器中，并且在接下来 b 的赋值操作以及使用 b 的代码中避免使用该寄存器。第二，在真正使用 r2 时才将 a 加载至寄存器中。这么一来，在执行使用 b 的代码时，我们不再霸占一个通用寄存器，从而减少需要借助栈空间的情况。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> a=<span class="number">0</span>, b=<span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span>()</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (..) &#123;</span><br><span class="line">    <span class="built_in">int</span> r2 = a;</span><br><span class="line">    b = <span class="number">1</span>;</span><br><span class="line">    .. <span class="comment">// Code uses r2 and rewrites a</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个例子则是将第一个方法的代码放入一个循环中。除了原本的两条赋值语句之外，我只在循环中添加了使用 r2，并且更新 a 的代码。由于对 b 的赋值是循环无关的，即时编译器很有可能将其移出循环之前，而对 r2 的赋值语句还停留在循环之中。</p>
<p>如果想要复现这两个场景，你可能需要添加大量有意义的局部变量，来给寄存器分配算法施加压力。</p>
<p>可以看到，即时编译器的优化可能将原本字段访问的执行顺序打乱。在单线程环境下，由于 as-if-serial 的保证，我们无须担心顺序执行不可能发生的情况，如（r1，r2）&#x3D;（1，2）。</p>
<p>然而，在多线程情况下，这种数据竞争（data race）的情况是有可能发生的。而且，Java 语言规范将其归咎于应用程序没有作出恰当的同步操作。</p>
<h4 id="Java-内存模型与-happens-before-关系"><a href="#Java-内存模型与-happens-before-关系" class="headerlink" title="Java 内存模型与 happens-before 关系"></a>Java 内存模型与 happens-before 关系</h4><p>为了让应用程序能够免于数据竞争的干扰，Java 5 引入了明确定义的 Java 内存模型。其中最为重要的一个概念便是 happens-before 关系。happens-before 关系是用来描述两个操作的内存可见性的。如果操作 X happens-before 操作 Y，那么 X 的结果对于 Y 可见。</p>
<p>在同一个线程中，字节码的先后顺序（program order）也暗含了 happens-before 关系：在程序控制流路径中靠前的字节码 happens-before 靠后的字节码。然而，这并不意味着前者一定在后者之前执行。实际上，如果后者没有观测前者的运行结果，即后者没有数据依赖于前者，那么它们可能会被重排序。</p>
<p>除了线程内的 happens-before 关系之外，Java 内存模型还定义了下述<strong>线程间的 happens-before 关系</strong>。</p>
<ol>
<li>解锁操作 happens-before 之后（这里指时钟顺序先后）对同一把锁的加锁操作。</li>
<li>volatile 字段的写操作 happens-before 之后（这里指时钟顺序先后）对同一字段的读操作。</li>
<li>线程的启动操作（即 Thread.starts()） happens-before 该线程的第一个操作。</li>
<li>线程的最后一个操作 happens-before 它的终止事件（即其他线程通过 Thread.isAlive() 或 Thread.join() 判断该线程是否中止）。</li>
<li>线程对其他线程的中断操作 happens-before 被中断线程所收到的中断事件（即被中断线程的 InterruptedException 异常，或者第三个线程针对被中断线程的 Thread.interrupted 或者 Thread.isInterrupted 调用）。</li>
<li>构造器中的最后一个操作 happens-before 析构器的第一个操作。</li>
</ol>
<p>happens-before 关系还具备传递性。如果操作 X happens-before 操作 Y，而操作 Y happens-before 操作 Z，那么操作 X happens-before 操作 Z。</p>
<p>在文章开头的例子中，程序没有定义任何 happens-before 关系，仅拥有默认的线程内 happens-before 关系。也就是 r2 的赋值操作 happens-before b 的赋值操作，r1 的赋值操作 happens-before a 的赋值操作。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">Thread1      Thread2</span><br><span class="line">  |            |</span><br><span class="line"> b=1           |</span><br><span class="line">  |          r1=b</span><br><span class="line">  |           a=2</span><br><span class="line">r2=a           | </span><br></pre></td></tr></table></figure>

<p>拥有 happens-before 关系的两对赋值操作之间没有数据依赖，因此即时编译器、处理器都可能对其进行重排序。举例来说，只要将 b 的赋值操作排在 r2 的赋值操作之前，那么便可以按照赋值 b，赋值 r1，赋值 a，赋值 r2 的顺序得到（1，2）的结果。</p>
<p>那么如何解决这个问题呢？答案是，将 a 或者 b 设置为 volatile 字段。</p>
<p>比如说将 b 设置为 volatile 字段。假设 r1 能够观测到 b 的赋值结果 1。显然，这需要 b 的赋值操作在时钟顺序上先于 r1 的赋值操作。根据 volatile 字段的 happens-before 关系，我们知道 b 的赋值操作 happens-before r1 的赋值操作。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> a=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="built_in">int</span> b=<span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span>()</span> &#123;</span><br><span class="line">  <span class="built_in">int</span> r2 = a;</span><br><span class="line">  b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span>()</span> &#123;</span><br><span class="line">  <span class="built_in">int</span> r1 = b;</span><br><span class="line">  a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据同一个线程中，字节码顺序所暗含的 happens-before 关系，以及 happens-before 关系的传递性，我们可以轻易得出 r2 的赋值操作 happens-before a 的赋值操作。</p>
<p>这也就意味着，当对 a 进行赋值时，对 r2 的赋值操作已经完成了。因此，在 b 为 volatile 字段的情况下，程序不可能出现（r1，r2）为（1，2）的情况。</p>
<p>由此可以看出，<u>解决这种数据竞争问题的关键在于构造一个跨线程的 happens-before 关系</u> ：操作 X happens-before 操作 Y，使得操作 X 之前的字节码的结果对操作 Y 之后的字节码可见。</p>
<h4 id="Java-内存模型的底层实现"><a href="#Java-内存模型的底层实现" class="headerlink" title="Java 内存模型的底层实现"></a>Java 内存模型的底层实现</h4><p>在理解了 Java 内存模型的概念之后，我们现在来看看它的底层实现。<u>Java 内存模型是通过<strong>内存屏障</strong>（memory barrier）来禁止重排序的。</u></p>
<p>对于即时编译器来说，它会针对前面提到的每一个 happens-before 关系，向正在编译的目标方法中插入相应的读读、读写、写读以及写写内存屏障。</p>
<p>这些内存屏障会限制即时编译器的重排序操作。以 volatile 字段访问为例，所插入的内存屏障将不允许 volatile 字段写操作之前的内存访问被重排序至其之后；也将不允许 volatile 字段读操作之后的内存访问被重排序至其之前。</p>
<p>然后，即时编译器将根据具体的底层体系架构，将这些内存屏障替换成具体的 CPU 指令。以我们日常接触的 X86_64 架构来说，读读、读写以及写写内存屏障是空操作（no-op），只有写读内存屏障会被替换成<a href="http://gee.cs.oswego.edu/dl/jmm/cookbook.html">具体指令</a>。</p>
<p>在文章开头的例子中，method1 和 method2 之中的代码均属于先读后写（假设 r1 和 r2 被存储在寄存器之中）。X86_64 架构的处理器并不能将读操作重排序至写操作之后，具体可参考 Intel Software Developer Manual Volumn 3，8.2.3.3 小节。因此，我认为例子中的重排序必然是即时编译器造成的。</p>
<p>举例来说，对于 volatile 字段，即时编译器将在 volatile 字段的读写操作前后各插入一些内存屏障。</p>
<p>然而，在 X86_64 架构上，只有 volatile 字段写操作之后的写读内存屏障需要用具体指令来替代。（HotSpot 所选取的具体指令是 lock add DWORD PTR [rsp],0x0，而非 mfence[3]。）</p>
<p>该具体指令的效果，可以简单理解为强制刷新处理器的写缓存。写缓存是处理器用来加速内存存储效率的一项技术。</p>
<p>在碰到内存写操作时，处理器并不会等待该指令结束，而是直接开始下一指令，并且依赖于写缓存将更改的数据同步至主内存（main memory）之中。</p>
<p>强制刷新写缓存，将使得当前线程写入 volatile 字段的值（以及写缓存中已有的其他内存修改），同步至主内存之中。</p>
<p>由于内存写操作同时会无效化其他处理器所持有的、指向同一内存地址的缓存行，因此可以认为其他处理器能够立即见到该 volatile 字段的最新值。</p>
<h4 id="锁，volatile-字段，final-字段与安全发布"><a href="#锁，volatile-字段，final-字段与安全发布" class="headerlink" title="锁，volatile 字段，final 字段与安全发布"></a>锁，volatile 字段，final 字段与安全发布</h4><p>下面我来讲讲 Java 内存模型涉及的几个关键词。</p>
<p>前面提到，锁操作同样具备 happens-before 关系。具体来说，解锁操作 happens-before 之后对同一把锁的加锁操作。实际上，在解锁时，Java 虚拟机同样需要强制刷新缓存，使得当前线程所修改的内存对其他线程可见。</p>
<p>需要注意的是，锁操作的 happens-before 规则的关键字是同一把锁。也就意味着，如果编译器能够（通过逃逸分析）证明某把锁仅被同一线程持有，那么它可以移除相应的加锁解锁操作。</p>
<p>因此也就不再强制刷新缓存。举个例子，即时编译后的 synchronized (new Object()) {}，可能等同于空操作，而不会强制刷新缓存。</p>
<p><strong>volatile 字段可以看成一种轻量级的、不保证原子性的同步</strong>，其性能往往优于（至少不亚于）锁操作。然而，频繁地访问 volatile 字段也会因为不断地强制刷新缓存而严重影响程序的性能。</p>
<p>在 X86_64 平台上，只有 volatile 字段的写操作会强制刷新缓存。因此，理想情况下对 volatile 字段的使用应当多读少写，并且应当只有一个线程进行写操作。</p>
<p>volatile 字段的另一个特性是即时编译器无法将其分配到寄存器里。换句话说，volatile 字段的每次访问均需要直接从内存中读写。</p>
<p>final 实例字段则涉及新建对象的发布问题。当一个对象包含 final 实例字段时，我们希望其他线程只能看到已初始化的 final 实例字段。</p>
<p>因此，即时编译器会在 final 字段的写操作后插入一个写写屏障，以防某些优化将新建对象的发布（即将实例对象写入一个共享引用中）重排序至 final 字段的写操作之前。在 X86_64 平台上，写写屏障是空操作。</p>
<p>新建对象的安全发布（safe publication）问题不仅仅包括 final 实例字段的可见性，还包括其他实例字段的可见性。</p>
<p>当发布一个已初始化的对象时，我们希望所有已初始化的实例字段对其他线程可见。否则，其他线程可能见到一个仅部分初始化的新建对象，从而造成程序错误。这里我就不展开了。如果你感兴趣的话，可以参考<a href="http://vlkan.com/blog/post/2014/02/14/java-safe-publication/">这篇博客</a>。</p>
<h3 id="14-Java虚拟机是怎么实现synchronized的？"><a href="#14-Java虚拟机是怎么实现synchronized的？" class="headerlink" title="14 Java虚拟机是怎么实现synchronized的？"></a>14 Java虚拟机是怎么实现synchronized的？</h3><p>在 Java 程序中，我们<u>可以利用 synchronized 关键字来对程序进行加锁。它既可以用来声明一个 synchronized 代码块，也可以直接标记静态方法或者实例方法。</u></p>
<p>当声明 synchronized 代码块时，编译而成的字节码将包含 monitorenter 和 monitorexit 指令。这两种指令均会消耗操作数栈上的一个引用类型的元素（也就是 synchronized 关键字括号里的引用），作为所要加锁解锁的锁对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(Object lock)</span> &#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">    lock.hashCode();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面的 Java 代码将编译为下面的字节码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(java.lang.Object)</span>;</span><br><span class="line">  Code:</span><br><span class="line">     <span class="number">0</span>: aload_1</span><br><span class="line">     <span class="number">1</span>: dup</span><br><span class="line">     <span class="number">2</span>: astore_2</span><br><span class="line">     <span class="number">3</span>: monitorenter</span><br><span class="line">     <span class="number">4</span>: aload_1</span><br><span class="line">     <span class="number">5</span>: invokevirtual java/lang/Object.hashCode:()I</span><br><span class="line">     <span class="number">8</span>: pop</span><br><span class="line">     <span class="number">9</span>: aload_2</span><br><span class="line">    <span class="number">10</span>: monitorexit</span><br><span class="line">    <span class="number">11</span>: goto          <span class="number">19</span></span><br><span class="line">    <span class="number">14</span>: astore_3</span><br><span class="line">    <span class="number">15</span>: aload_2</span><br><span class="line">    <span class="number">16</span>: monitorexit</span><br><span class="line">    <span class="number">17</span>: aload_3</span><br><span class="line">    <span class="number">18</span>: athrow</span><br><span class="line">    <span class="number">19</span>: <span class="keyword">return</span></span><br><span class="line">  Exception table:</span><br><span class="line">     from    to  target type</span><br><span class="line">         <span class="number">4</span>    <span class="number">11</span>    <span class="number">14</span>   any</span><br><span class="line">        <span class="number">14</span>    <span class="number">17</span>    <span class="number">14</span>   any</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>我在文稿中贴了一段包含 synchronized 代码块的 Java 代码，以及它所编译而成的字节码。你可能会留意到，上面的字节码中包含一个 monitorenter 指令以及多个 monitorexit 指令。这是因为 Java 虚拟机需要确保所获得的锁在正常执行路径，以及异常执行路径上都能够被解锁。</p>
<p>你可以根据我在介绍异常处理时介绍过的知识，对照字节码和异常处理表来构造所有可能的执行路径，看看在执行了 monitorenter 指令之后，是否都有执行 monitorexit 指令。</p>
<p>当用 synchronized 标记方法时，你会看到字节码中方法的访问标记包括 ACC_SYNCHRONIZED。该标记表示在进入该方法时，Java 虚拟机需要进行 monitorenter 操作。而在退出该方法时，不管是正常返回，还是向调用者抛异常，Java 虚拟机均需要进行 monitorexit 操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(Object lock)</span> &#123;</span><br><span class="line">  lock.hashCode();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面的 Java 代码将编译为下面的字节码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(java.lang.Object)</span>;</span><br><span class="line">  descriptor: (Ljava/lang/Object;)V</span><br><span class="line">  flags: (<span class="number">0x0021</span>) ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">1</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">       <span class="number">0</span>: aload_1</span><br><span class="line">       <span class="number">1</span>: invokevirtual java/lang/Object.hashCode:()I</span><br><span class="line">       <span class="number">4</span>: pop</span><br><span class="line">       <span class="number">5</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>这里 monitorenter 和 monitorexit 操作所对应的锁对象是隐式的。对于实例方法来说，这两个操作对应的锁对象是 this；对于静态方法来说，这两个操作对应的锁对象则是所在类的 Class 实例。</p>
<p>关于 monitorenter 和 monitorexit 的作用，我们可以抽象地理解为每个锁对象拥有一个锁计数器和一个指向持有该锁的线程的指针。</p>
<p>当执行 monitorenter 时，如果目标锁对象的计数器为 0，那么说明它没有被其他线程所持有。在这个情况下，Java 虚拟机会将该锁对象的持有线程设置为当前线程，并且将其计数器加 1。</p>
<p>在目标锁对象的计数器不为 0 的情况下，如果锁对象的持有线程是当前线程，那么 Java 虚拟机可以将其计数器加 1，否则需要等待，直至持有线程释放该锁。</p>
<p>当执行 monitorexit 时，Java 虚拟机则需将锁对象的计数器减 1。当计数器减为 0 时，那便代表该锁已经被释放掉了。</p>
<p>之所以采用这种计数器的方式，是为了允许同一个线程重复获取同一把锁。举个例子，如果一个 Java 类中拥有多个 synchronized 方法，那么这些方法之间的相互调用，不管是直接的还是间接的，都会涉及对同一把锁的重复加锁操作。因此，我们需要设计这么一个可重入的特性，来避免编程里的隐式约束。</p>
<p>说完抽象的锁算法，下面我们便来介绍 HotSpot 虚拟机中具体的锁实现。</p>
<h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>重量级锁是 Java 虚拟机中最为基础的锁实现。在这种状态下，Java 虚拟机会阻塞加锁失败的线程，并且在目标锁被释放的时候，唤醒这些线程。</p>
<p>Java 线程的阻塞以及唤醒，都是依靠操作系统来完成的。举例来说，对于符合 posix 接口的操作系统（如 macOS 和绝大部分的 Linux），上述操作是通过 pthread 的互斥锁（mutex）来实现的。此外，这些操作将涉及系统调用，需要从操作系统的用户态切换至内核态，其开销非常之大。</p>
<p><u>为了尽量避免昂贵的线程阻塞、唤醒操作，Java 虚拟机会在线程进入阻塞状态之前，以及被唤醒后竞争不到锁的情况下，进入自旋状态，在处理器上空跑并且轮询锁是否被释放。如果此时锁恰好被释放了，那么当前线程便无须进入阻塞状态，而是直接获得这把锁。</u></p>
<p>与线程阻塞相比，自旋状态可能会浪费大量的处理器资源。这是因为当前线程仍处于运行状况，只不过跑的是无用指令。它期望在运行无用指令的过程中，锁能够被释放出来。</p>
<p>我们可以用等红绿灯作为例子。Java 线程的阻塞相当于熄火停车，而自旋状态相当于怠速停车。如果红灯的等待时间非常长，那么熄火停车相对省油一些；如果红灯的等待时间非常短，比如说我们在 synchronized 代码块里只做了一个整型加法，那么在短时间内锁肯定会被释放出来，因此怠速停车更加合适。</p>
<p>然而，对于 Java 虚拟机来说，它并不能看到红灯的剩余时间，也就没办法根据等待时间的长短来选择自旋还是阻塞。Java 虚拟机给出的方案是自适应自旋，根据以往自旋等待时是否能够获得锁，来动态调整自旋的时间（循环数目）。</p>
<p>就我们的例子来说，如果之前不熄火等到了绿灯，那么这次不熄火的时间就长一点；如果之前不熄火没等到绿灯，那么这次不熄火的时间就短一点。</p>
<p><u>自旋状态还带来另外一个副作用，那便是不公平的锁机制。处于阻塞状态的线程，并没有办法立刻竞争被释放的锁。然而，处于自旋状态的线程，则很有可能优先获得这把锁。</u></p>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>你可能见到过深夜的十字路口，四个方向都闪黄灯的情况。由于深夜十字路口的车辆来往可能比较少，如果还设置红绿灯交替，那么很有可能出现四个方向仅有一辆车在等红灯的情况。</p>
<p>因此，红绿灯可能被设置为闪黄灯的情况，代表车辆可以自由通过，但是司机需要注意观察（个人理解，实际意义请咨询交警部门）。</p>
<p>Java 虚拟机也存在着类似的情形：<u>多个线程在不同的时间段请求同一把锁，也就是说没有锁竞争。针对这种情形，Java 虚拟机采用了轻量级锁，来避免重量级锁的阻塞以及唤醒。</u></p>
<p>在介绍轻量级锁的原理之前，我们先来了解一下 Java 虚拟机是怎么区分轻量级锁和重量级锁的。</p>
<p>（你可以参照<a href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization">HotSpot Wiki</a>里这张图阅读。）</p>
<p>在对象内存布局那一篇中我曾经介绍了对象头中的<strong>标记字段（mark word）</strong>。它的<u>最后两位便被用来表示该对象的锁状态。其中，00 代表轻量级锁，01 代表无锁（或偏向锁），10 代表重量级锁，11 则跟垃圾回收算法的标记有关。</u></p>
<p>当进行加锁操作时，Java 虚拟机会判断是否已经是重量级锁。如果不是，它会在当前线程的当前栈桢中划出一块空间，作为该锁的锁记录，并且将锁对象的标记字段复制到该锁记录中。</p>
<p>然后，Java 虚拟机会尝试用 CAS（compare-and-swap）操作替换锁对象的标记字段。这里解释一下，CAS 是一个原子操作，它会比较目标地址的值是否和期望值相等，如果相等，则替换为一个新的值。</p>
<p>假设当前锁对象的标记字段为 X…XYZ，Java 虚拟机会比较该字段是否为 X…X01。如果是，则替换为刚才分配的锁记录的地址。由于内存对齐的缘故，它的最后两位为 00。此时，该线程已成功获得这把锁，可以继续执行了。</p>
<p>如果不是 X…X01，那么有两种可能。第一，该线程重复获取同一把锁。此时，Java 虚拟机会将锁记录清零，以代表该锁被重复获取。第二，其他线程持有该锁。此时，Java 虚拟机会将这把锁膨胀为重量级锁，并且阻塞当前线程。</p>
<p>当进行解锁操作时，如果当前锁记录（你可以将一个线程的所有锁记录想象成一个栈结构，每次加锁压入一条锁记录，解锁弹出一条锁记录，当前锁记录指的便是栈顶的锁记录）的值为 0，则代表重复进入同一把锁，直接返回即可。</p>
<p>否则，Java 虚拟机会尝试用 CAS 操作，比较锁对象的标记字段的值是否为当前锁记录的地址。如果是，则替换为锁记录中的值，也就是锁对象原本的标记字段。此时，该线程已经成功释放这把锁。</p>
<p>如果不是，则意味着这把锁已经被膨胀为重量级锁。此时，Java 虚拟机会进入重量级锁的释放过程，唤醒因竞争该锁而被阻塞了的线程。</p>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>如果说轻量级锁针对的情况很乐观，那么接下来的偏向锁针对的情况则更加乐观：从始至终只有一个线程请求某一把锁。</p>
<p>这就好比你在私家庄园里装了个红绿灯，并且庄园里只有你在开车。偏向锁的做法便是在红绿灯处识别来车的车牌号。如果匹配到你的车牌号，那么直接亮绿灯。</p>
<p>具体来说，在线程进行加锁时，如果该锁对象支持偏向锁，那么 Java 虚拟机会通过 CAS 操作，将当前线程的地址记录在锁对象的标记字段之中，并且将标记字段的最后三位设置为 101。</p>
<p>在接下来的运行过程中，每当有线程请求这把锁，Java 虚拟机只需判断锁对象标记字段中：最后三位是否为 101，是否包含当前线程的地址，以及 epoch 值是否和锁对象的类的 epoch 值相同。如果都满足，那么当前线程持有该偏向锁，可以直接返回。</p>
<p>这里的 epoch 值是一个什么概念呢？</p>
<p>我们先从偏向锁的撤销讲起。当请求加锁的线程和锁对象标记字段保持的线程地址不匹配时（而且 epoch 值相等，如若不等，那么当前线程可以将该锁重偏向至自己），Java 虚拟机需要撤销该偏向锁。这个撤销过程非常麻烦，它要求持有偏向锁的线程到达安全点，再将偏向锁替换成轻量级锁。</p>
<p>如果某一类锁对象的总撤销数超过了一个阈值（对应 Java 虚拟机参数 -XX:BiasedLockingBulkRebiasThreshold，默认为 20），那么 Java 虚拟机会宣布这个类的偏向锁失效。</p>
<p>具体的做法便是在每个类中维护一个 epoch 值，你可以理解为第几代偏向锁。当设置偏向锁时，Java 虚拟机需要将该 epoch 值复制到锁对象的标记字段中。</p>
<p><u>在宣布某个类的偏向锁失效时，Java 虚拟机实则将该类的 epoch 值加 1，表示之前那一代的偏向锁已经失效</u>。而新设置的偏向锁则需要复制新的 epoch 值。</p>
<p>为了保证当前持有偏向锁并且已加锁的线程不至于因此丢锁，Java 虚拟机需要遍历所有线程的 Java 栈，找出该类已加锁的实例，并且将它们标记字段中的 epoch 值加 1。该操作需要所有线程处于安全点状态。</p>
<p>如果总撤销数超过另一个阈值（对应 Java 虚拟机参数 -XX:BiasedLockingBulkRevokeThreshold，默认值为 40），那么 Java 虚拟机会认为这个类已经不再适合偏向锁。此时，Java 虚拟机会撤销该类实例的偏向锁，并且在之后的加锁过程中直接为该类实例设置轻量级锁。</p>
<h3 id="15-Java语法糖与Java编译器"><a href="#15-Java语法糖与Java编译器" class="headerlink" title="15 Java语法糖与Java编译器"></a>15 Java语法糖与Java编译器</h3><p>在前面的篇章中，我们多次提到了 Java 语法和 Java 字节码的差异之处。这些差异之处都是通过 Java 编译器来协调的。今天我们便来列举一下 Java 编译器的协调工作。</p>
<h4 id="自动装箱与自动拆箱"><a href="#自动装箱与自动拆箱" class="headerlink" title="自动装箱与自动拆箱"></a>自动装箱与自动拆箱</h4><p>首先要提到的便是 Java 的自动装箱（auto-boxing）和自动拆箱（auto-unboxing）。</p>
<p>我们知道，Java 语言拥有 8 个基本类型，每个基本类型都有对应的包装（wrapper）类型。</p>
<p>之所以需要包装类型，是因为许多 Java 核心类库的 API 都是面向对象的。举个例子，Java 核心类库中的容器类，就只支持引用类型。</p>
<p>当需要一个能够存储数值的容器类时，我们往往定义一个存储包装类对象的容器。</p>
<p>对于基本类型的数值来说，我们需要先将其转换为对应的包装类，再存入容器之中。在 Java 程序中，这个转换可以是显式，也可以是隐式的，后者正是 Java 中的自动装箱。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">foo</span>()</span> &#123;</span><br><span class="line">  ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  list.<span class="keyword">add</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">int</span> result = list.<span class="keyword">get</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上图中的 Java 代码为例。我构造了一个 Integer 类型的 ArrayList，并且向其中添加一个 int 值 0。然后，我会获取该 ArrayList 的第 0 个元素，并作为 int 值返回给调用者。这段代码对应的 Java 字节码如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">public</span> <span class="string">int</span> <span class="string">foo();</span></span><br><span class="line">  <span class="attr">Code:</span></span><br><span class="line">     <span class="attr">0:</span> <span class="string">new</span> <span class="string">java/util/ArrayList</span></span><br><span class="line">     <span class="attr">3:</span> <span class="string">dup</span></span><br><span class="line">     <span class="attr">4:</span> <span class="string">invokespecial</span> <span class="string">java/util/ArrayList.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">     <span class="attr">7:</span> <span class="string">astore_1</span></span><br><span class="line">     <span class="attr">8:</span> <span class="string">aload_1</span></span><br><span class="line">     <span class="attr">9:</span> <span class="string">iconst_0</span></span><br><span class="line">    <span class="attr">10:</span> <span class="string">invokestatic</span> <span class="string">java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span></span><br><span class="line">    <span class="attr">13:</span> <span class="string">invokevirtual</span> <span class="string">java/util/ArrayList.add:(Ljava/lang/Object;)Z</span></span><br><span class="line">    <span class="attr">16:</span> <span class="string">pop</span></span><br><span class="line">    <span class="attr">17:</span> <span class="string">aload_1</span></span><br><span class="line">    <span class="attr">18:</span> <span class="string">iconst_0</span></span><br><span class="line">    <span class="attr">19:</span> <span class="string">invokevirtual</span> <span class="string">java/util/ArrayList.get:(I)Ljava/lang/Object;</span></span><br><span class="line">    <span class="attr">22:</span> <span class="string">checkcast</span> <span class="string">java/lang/Integer</span></span><br><span class="line">    <span class="attr">25:</span> <span class="string">invokevirtual</span> <span class="string">java/lang/Integer.intValue:()I</span></span><br><span class="line">    <span class="attr">28:</span> <span class="string">istore_2</span></span><br><span class="line">    <span class="attr">29:</span> <span class="string">iload_2</span></span><br><span class="line">    <span class="attr">30:</span> <span class="string">ireturn</span></span><br></pre></td></tr></table></figure>

<p>当向泛型参数为 Integer 的 ArrayList 添加 int 值时，便需要用到自动装箱了。在上面字节码偏移量为 10 的指令中，我们调用了 Integer.valueOf 方法，将 int 类型的值转换为 Integer 类型，再存储至容器类中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Integer</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是 Integer.valueOf 的源代码。可以看到，当请求的 int 值在某个范围内时，我们会返回缓存了的 Integer 对象；而当所请求的 int 值在范围之外时，我们则会新建一个 Integer 对象。</p>
<p>在介绍反射的那一篇中，我曾经提到参数 java.lang.Integer.IntegerCache.high。这个参数将影响这里面的 IntegerCache.high。</p>
<p>也就是说，我们可以通过配置该参数，扩大 Integer 缓存的范围。Java 虚拟机参数 -XX:+AggressiveOpts 也会将 IntegerCache.high 调整至 20000。</p>
<p>奇怪的是，Java 并不支持对 IntegerCache.low 的更改，也就是说，对于小于 -128 的整数，我们无法直接使用由 Java 核心类库所缓存的 Integer 对象。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">25: invokevirtual java/lang/Integer.intValue:()I</span><br></pre></td></tr></table></figure>

<p>当从泛型参数为 Integer 的 ArrayList 取出元素时，我们得到的实际上也是 Integer 对象。如果应用程序期待的是一个 int 值，那么就会发生自动拆箱。</p>
<p>在我们的例子中，自动拆箱对应的是字节码偏移量为 25 的指令。该指令将调用 Integer.intValue 方法。这是一个实例方法，直接返回 Integer 对象所存储的 int 值。</p>
<h4 id="泛型与类型擦除"><a href="#泛型与类型擦除" class="headerlink" title="泛型与类型擦除"></a>泛型与类型擦除</h4><p>你可能已经留意到了，在前面例子生成的字节码中，往 ArrayList 中添加元素的 add 方法，所接受的参数类型是 Object；而从 ArrayList 中获取元素的 get 方法，其返回类型同样也是 Object。</p>
<p>前者还好，但是对于后者，<u>在字节码中我们需要进行向下转换，将所返回的 Object 强制转换为 Integer，方能进行接下来的自动拆箱</u>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">13: invokevirtual java/util/ArrayList.add:(Ljava/lang/Object;)Z</span><br><span class="line">...</span><br><span class="line">19: invokevirtual java/util/ArrayList.get:(I)Ljava/lang/Object;</span><br><span class="line">22: checkcast java/lang/Integer</span><br></pre></td></tr></table></figure>

<p>之所以会出现这种情况，是因为 Java 泛型的类型擦除。这是个什么概念呢？简单地说，那便是 <u>Java 程序里的泛型信息，在 Java 虚拟机里全部都丢失了。这么做主要是为了兼容引入泛型之前的代码</u>。</p>
<p>当然，并不是每一个泛型参数被擦除类型后都会变成 Object 类。对于限定了继承类的泛型参数，经过类型擦除后，所有的泛型参数都将变成所限定的继承类。也就是说，Java 编译器将选取该泛型所能指代的所有类中层次最高的那个，作为替换泛型的类。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GenericTest</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; &#123;</span><br><span class="line">  T <span class="title function_">foo</span>(<span class="params">T t</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举个例子，在上面这段 Java 代码中，我定义了一个 T extends Number 的泛型参数。它所对应的字节码如下所示。可以看到，foo 方法的方法描述符所接收参数的类型以及返回类型都为 Number。方法描述符是 Java 虚拟机识别方法调用的目标方法的关键。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">T</span> <span class="string">foo(T);</span></span><br><span class="line">  <span class="attr">descriptor:</span> <span class="string">(Ljava/lang/Number;)Ljava/lang/Number;</span></span><br><span class="line">  <span class="attr">flags:</span> <span class="string">(0x0000)</span></span><br><span class="line">  <span class="attr">Code:</span></span><br><span class="line">    <span class="string">stack=1,</span> <span class="string">locals=2,</span> <span class="string">args_size=2</span></span><br><span class="line">       <span class="attr">0:</span> <span class="string">aload_1</span></span><br><span class="line">       <span class="attr">1:</span> <span class="string">areturn</span></span><br><span class="line">  <span class="attr">Signature:</span> <span class="string">(TT;)TT;</span></span><br></pre></td></tr></table></figure>

<p>不过，字节码中仍存在泛型参数的信息，如方法声明里的 T foo(T)，以及方法签名（Signature）中的“(TT;)TT;”。这类信息主要由 Java 编译器在编译他类时使用。</p>
<p>既然泛型会被类型擦除，那么我们还有必要用它吗？</p>
<p>我认为是有必要的。<u>Java 编译器可以根据泛型参数判断程序中的语法是否正确</u>。举例来说，尽管经过类型擦除后，ArrayList.add 方法所接收的参数是 Object 类型，但是往泛型参数为 Integer 类型的 ArrayList 中添加字符串对象，Java 编译器是会报错的。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.<span class="keyword">add</span>(<span class="string">&quot;0&quot;</span>); <span class="comment">// 编译出错</span></span><br></pre></td></tr></table></figure>

<h4 id="桥接方法"><a href="#桥接方法" class="headerlink" title="桥接方法"></a>桥接方法</h4><p><u>泛型的类型擦除带来了不少问题。其中一个便是方法重写</u>。看一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Merchant</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Customer</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">actionPrice</span><span class="params">(T customer)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0d</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VIPOnlyMerchant</span> <span class="keyword">extends</span> <span class="title class_">Merchant</span>&lt;VIP&gt; &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">actionPrice</span><span class="params">(VIP customer)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0d</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>VIPOnlyMerchant 中的 actionPrice 方法是符合 Java 语言的方法重写的，毕竟都使用 @Override 来注解了。然而，经过类型擦除后，父类的方法描述符为 (LCustomer;)D，而子类的方法描述符为 (LVIP;)D。这显然不符合 Java 虚拟机关于方法重写的定义。</p>
<p>为了保证编译而成的 Java 字节码能够保留重写的语义，Java 编译器额外添加了一个桥接方法。该桥接方法在字节码层面重写了父类的方法，并将调用子类的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VIPOnlyMerchant</span> <span class="keyword">extends</span> <span class="title class_">Merchant</span>&lt;VIP&gt;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">actionPrice</span><span class="params">(VIP)</span>;</span><br><span class="line">    descriptor: (LVIP;)D</span><br><span class="line">    flags: (<span class="number">0x0001</span>) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">         <span class="number">0</span>: dconst_0</span><br><span class="line">         <span class="number">1</span>: dreturn</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">actionPrice</span><span class="params">(Customer)</span>;</span><br><span class="line">    descriptor: (LCustomer;)D</span><br><span class="line">    flags: (<span class="number">0x1041</span>) ACC_PUBLIC, ACC_BRIDGE, ACC_SYNTHETIC</span><br><span class="line">    Code:</span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: aload_1</span><br><span class="line">         <span class="number">2</span>: checkcast <span class="keyword">class</span> <span class="title class_">VIP</span></span><br><span class="line">         <span class="number">5</span>: invokevirtual actionPrice:(LVIP;)D</span><br><span class="line">         <span class="number">8</span>: dreturn</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 这个桥接方法等同于</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">actionPrice</span><span class="params">(Customer customer)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> actionPrice((VIP) customer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在我们的例子中，VIPOnlyMerchant 类将包含一个桥接方法 actionPrice(Customer)，它重写了父类的同名同方法描述符的方法。该桥接方法将传入的 Customer 参数强制转换为 VIP 类型，再调用原本的 actionPrice(VIP) 方法。</p>
<p>当一个声明类型为 Merchant，实际类型为 VIPOnlyMerchant 的对象，调用 actionPrice 方法时，字节码里的符号引用指向的是 Merchant.actionPrice(Customer) 方法。Java 虚拟机将动态绑定至 VIPOnlyMerchant 类的桥接方法之中，并且调用其 actionPrice(VIP) 方法。</p>
<p>需要注意的是，在 javap 的输出中，该桥接方法的访问标识符除了代表桥接方法的 ACC_BRIDGE 之外，还有 ACC_SYNTHETIC。它表示该方法对于 Java 源代码来说是不可见的。当你尝试通过传入一个声明类型为 Customer 的对象作为参数，调用 VIPOnlyMerchant 类的 actionPrice 方法时，Java 编译器会报错，并且提示参数类型不匹配。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Customer</span> <span class="variable">customer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VIP</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">VIPOnlyMerchant</span>().actionPrice(customer); <span class="comment">// 编译出错    </span></span><br></pre></td></tr></table></figure>

<p>当然，如果你实在想要调用这个桥接方法，那么你可以选择使用反射机制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Merchant</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> Number <span class="title function_">actionPrice</span><span class="params">(Customer customer)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NaiveMerchant</span> <span class="keyword">extends</span> <span class="title class_">Merchant</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Double <span class="title function_">actionPrice</span><span class="params">(Customer customer)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0D</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了前面介绍的泛型重写会生成桥接方法之外，如果子类定义了一个与父类参数类型相同的方法，其返回类型为父类方法返回类型的子类，那么 Java 编译器也会为其生成桥接方法。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">class</span> <span class="string">NaiveMerchant</span> <span class="string">extends</span> <span class="string">Merchant</span></span><br><span class="line">  <span class="string">public</span> <span class="string">java.lang.Double</span> <span class="string">actionPrice(Customer);</span></span><br><span class="line">    <span class="attr">descriptor:</span> <span class="string">(LCustomer;)Ljava/lang/Double;</span></span><br><span class="line">    <span class="attr">flags:</span> <span class="string">(0x0001)</span> <span class="string">ACC_PUBLIC</span></span><br><span class="line">    <span class="attr">Code:</span></span><br><span class="line">      <span class="string">stack=2,</span> <span class="string">locals=2,</span> <span class="string">args_size=2</span></span><br><span class="line">         <span class="attr">0:</span> <span class="string">dconst_0</span></span><br><span class="line">         <span class="attr">1:</span> <span class="string">invokestatic</span> <span class="string">Double.valueOf:(D)Ljava/lang/Double;</span></span><br><span class="line">         <span class="attr">4:</span> <span class="string">areturn</span></span><br><span class="line"> </span><br><span class="line">  <span class="string">public</span> <span class="string">java.lang.Number</span> <span class="string">actionPrice(Customer);</span></span><br><span class="line">    <span class="attr">descriptor:</span> <span class="string">(LCustomer;)Ljava/lang/Number;</span></span><br><span class="line">    <span class="attr">flags:</span> <span class="string">(0x1041)</span> <span class="string">ACC_PUBLIC,</span> <span class="string">ACC_BRIDGE,</span> <span class="string">ACC_SYNTHETIC</span></span><br><span class="line">    <span class="attr">Code:</span></span><br><span class="line">      <span class="string">stack=2,</span> <span class="string">locals=2,</span> <span class="string">args_size=2</span></span><br><span class="line">         <span class="attr">0:</span> <span class="string">aload_0</span></span><br><span class="line">         <span class="attr">1:</span> <span class="string">aload_1</span></span><br><span class="line">         <span class="attr">2:</span> <span class="string">invokevirtual</span> <span class="string">actionPrice:(LCustomer;)Ljava/lang/Double;</span></span><br><span class="line">         <span class="attr">5:</span> <span class="string">areturn</span>         </span><br></pre></td></tr></table></figure>

<p>我之前曾提到过，class 文件里允许出现两个同名、同参数类型但是不同返回类型的方法。这里的原方法和桥接方法便是其中一个例子。由于该桥接方法同样标注了 ACC_SYNTHETIC，因此，当在 Java 程序中调用 NaiveMerchant.actionPrice 时，我们只会调用到原方法。</p>
<h4 id="其他语法糖"><a href="#其他语法糖" class="headerlink" title="其他语法糖"></a>其他语法糖</h4><p>在前面的篇章中，我已经介绍过了变长参数、try-with-resources 以及在同一 catch 代码块中捕获多种异常等语法糖。下面我将列举另外两个常见的语法糖。</p>
<p>foreach 循环允许 Java 程序在 for 循环里遍历数组或者 Iterable 对象。对于数组来说，foreach 循环将从 0 开始逐一访问数组中的元素，直至数组的末尾。其等价的代码如下面所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> item : array) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">  <span class="type">int</span>[] myArray = array;</span><br><span class="line">  <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> myArray.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">item</span> <span class="operator">=</span> myArray[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 Iterable 对象来说，foreach 循环将调用其 iterator 方法，并且用它的 hasNext 以及 next 方法来遍历该 Iterable 对象中的元素。其等价的代码如下面所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(ArrayList&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (Integer item : list) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">(ArrayList&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">  Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">  <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">item</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字符串 switch 编译而成的字节码看起来非常复杂，但实际上就是一个哈希桶。由于每个 case 所截获的字符串都是常量值，因此，Java 编译器会将原来的字符串 switch 转换为 int 值 switch，比较所输入的字符串的哈希值。</p>
<p>由于字符串哈希值很容易发生碰撞，因此，我们还需要用 String.equals 逐个比较相同哈希值的字符串。</p>
<p>如果你感兴趣的话，可以自己利用 javap 分析字符串 switch 编译而成的字节码。</p>
<h3 id="19-Java字节码（基础篇）"><a href="#19-Java字节码（基础篇）" class="headerlink" title="19 Java字节码（基础篇）"></a>19 Java字节码（基础篇）</h3><p>系统性地介绍一遍 Java 字节码。</p>
<h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><p>我们知道，Java 字节码是 Java 虚拟机所使用的指令集。因此，它与 Java 虚拟机基于栈的计算模型是密不可分的。</p>
<p>在解释执行过程中，每当为 Java 方法分配栈桢时，Java 虚拟机往往需要开辟一块额外的空间作为操作数栈，来存放计算的操作数以及返回结果。</p>
<p>具体来说便是：执行每一条指令之前，Java 虚拟机要求该指令的操作数已被压入操作数栈中。在执行指令时，Java 虚拟机会将该指令所需的操作数弹出，并且将指令的结果重新压入栈中。</p>
<img src="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/assets/13720f6eb83d096ec600309648330821.png" alt="img" style="zoom:50%;" />

<p>以加法指令 iadd 为例。假设在执行该指令前，栈顶的两个元素分别为 int 值 1 和 int 值 2，那么 iadd 指令将弹出这两个 int，并将求得的和 int 值 3 压入栈中。</p>
<img src="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/assets/138c20e60c081c8698770ff8d5d93fdb.png" alt="img" style="zoom:50%;" />

<p>由于 iadd 指令只消耗栈顶的两个元素，因此，对于离栈顶距离为 2 的元素，即图中的问号，iadd 指令并不关心它是否存在，更加不会对其进行修改。</p>
<p>Java 字节码中有好几条指令是直接作用在操作数栈上的。最为常见的便是 dup： 复制栈顶元素，以及 pop：舍弃栈顶元素。</p>
<p>dup 指令常用于复制 new 指令所生成的未经初始化的引用。例如在下面这段代码的 foo 方法中，当执行 new 指令时，Java 虚拟机将指向一块已分配的、未初始化的内存的引用压入操作数栈中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对应的字节码如下：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>;</span><br><span class="line">  <span class="number">0</span>  <span class="keyword">new</span> <span class="title class_">java</span>.lang.Object [<span class="number">3</span>]</span><br><span class="line">  <span class="number">3</span>  dup</span><br><span class="line">  <span class="number">4</span>  invokespecial java.lang.Object() [<span class="number">8</span>]</span><br><span class="line">  <span class="number">7</span>  astore_1 [o]</span><br><span class="line">  <span class="number">8</span>  <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>接下来，我们需要以这个引用为调用者，调用其构造器，也就是上面字节码中的 invokespecial 指令。要注意，该指令将消耗操作数栈上的元素，作为它的调用者以及参数（不过 Object 的构造器不需要参数）。</p>
<p>因此，我们需要利用 dup 指令复制一份 new 指令的结果，并用来调用构造器。当调用返回之后，操作数栈上仍有原本由 new 指令生成的引用，可用于接下来的操作（即偏移量为 7 的字节码，下面会介绍到）。</p>
<p>pop 指令则常用于舍弃调用指令的返回结果。例如在下面这段代码的 foo 方法中，我将调用静态方法 bar，但是却不用其返回值。</p>
<p>由于对应的 invokestatic 指令仍旧会将返回值压入 foo 方法的操作数栈中，因此 Java 虚拟机需要额外执行 pop 指令，将返回值舍弃。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">  bar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo 方法对应的字节码如下：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>;</span><br><span class="line">  <span class="number">0</span>  invokestatic FooTest.bar() : <span class="type">boolean</span> [<span class="number">24</span>]</span><br><span class="line">  <span class="number">3</span>  pop</span><br><span class="line">  <span class="number">4</span>  <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，上述两条指令只能处理非 long 或者非 double 类型的值，这是因为 long 类型或者 double 类型的值，需要占据两个栈单元。当遇到这些值时，我们需要同时复制栈顶两个单元的 dup2 指令，以及弹出栈顶两个单元的 pop2 指令。</p>
<p>除此之外，不算常见但也是直接作用于操作数栈的还有 swap 指令，它将交换栈顶两个元素的值。</p>
<p>在 Java 字节码中，有一部分指令可以直接将常量加载到操作数栈上。以 int 类型为例，Java 虚拟机既可以通过 iconst 指令加载 -1 至 5 之间的 int 值，也可以通过 bipush、sipush 加载一个字节、两个字节所能代表的 int 值。</p>
<p>Java 虚拟机还可以通过 ldc 加载常量池中的常量值，例如 ldc #18 将加载常量池中的第 18 项。</p>
<p>这些常量包括 int 类型、long 类型、float 类型、double 类型、String 类型以及 Class 类型的常量。</p>
<p><img src="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/assets/0dfbecf954660bcdc76eac65beac1e8f.jpg" alt="img"></p>
<p><strong>常数加载指令表</strong></p>
<p>正常情况下，操作数栈的压入弹出都是一条条指令完成的。唯一的例外情况是<u>在抛异常时，Java 虚拟机会清除操作数栈上的所有内容，而后将异常实例压入操作数栈上</u>。</p>
<h4 id="局部变量区"><a href="#局部变量区" class="headerlink" title="局部变量区"></a>局部变量区</h4><p>Java 方法栈桢的另外一个重要组成部分则是局部变量区，<strong>字节码程序可以将计算的结果缓存在局部变量区之中。</strong></p>
<p>实际上，<u>Java 虚拟机将局部变量区当成一个数组，依次存放 this 指针（仅非静态方法），所传入的参数，以及字节码中的局部变量</u>。</p>
<p>和操作数栈一样，long 类型以及 double 类型的值将占据两个单元，其余类型仅占据一个单元。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">long</span> l, <span class="type">float</span> f)</span> &#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello, World&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上面这段代码中的 foo 方法为例，由于它是一个实例方法，因此局部变量数组的第 0 个单元存放着 this 指针。</p>
<p>第一个参数为 long 类型，于是数组的 1、2 两个单元存放着所传入的 long 类型参数的值。第二个参数则是 float 类型，于是数组的第 3 个单元存放着所传入的 float 类型参数的值。</p>
<p><img src="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/assets/228d0f5f2d6437e7aca87c6df2d01bd9.png" alt="img"></p>
<p>在方法体里的两个代码块中，我分别定义了两个局部变量 i 和 s。由于这两个局部变量的生命周期没有重合之处，因此，Java 编译器可以将它们编排至同一单元中。也就是说，局部变量数组的第 4 个单元将为 i 或者 s。</p>
<p><u>存储在局部变量区的值，通常需要加载至操作数栈中，方能进行计算，得到计算结果后再存储至局部变量数组中</u>。这些加载、存储指令是区分类型的。例如，int 类型的加载指令为 iload，存储指令为 istore。</p>
<p><img src="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/assets/83ece83ecd260c2eda282747467e49f9.jpg" alt="img"><strong>局部变量区访问指令表</strong></p>
<p>局部变量数组的加载、存储指令都需要指明所加载单元的下标。举例来说，<u>aload 0 指的是加载第 0 个单元所存储的引用</u>，在前面示例中的 foo 方法里指的便是加载 this 指针。</p>
<p>在我印象中，Java 字节码中唯一能够直接作用于局部变量区的指令是 iinc M N（M 为非负整数，N 为整数）。该指令指的是将局部变量数组的第 M 个单元中的 int 值增加 N，常用于 for 循环中自增量的更新。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>; i&gt;=<span class="number">0</span>; i--) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对应的字节码如下：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>;</span><br><span class="line">   <span class="number">0</span>  bipush <span class="number">100</span></span><br><span class="line">   <span class="number">2</span>  istore_1 [i]</span><br><span class="line">   <span class="number">3</span>  goto <span class="number">9</span></span><br><span class="line">   <span class="number">6</span>  iinc <span class="number">1</span> -<span class="number">1</span> [i] <span class="comment">// i--</span></span><br><span class="line">   <span class="number">9</span>  iload_1 [i]</span><br><span class="line">  <span class="number">10</span>  ifge <span class="number">6</span></span><br><span class="line">  <span class="number">13</span>  <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<h4 id="综合示例"><a href="#综合示例" class="headerlink" title="综合示例"></a>综合示例</h4><p>下面我们来看一个综合的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">bar</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ((i + <span class="number">1</span>) - <span class="number">2</span>) * <span class="number">3</span> / <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对应的字节码如下：</span></span><br><span class="line">Code:</span><br><span class="line">  stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">     <span class="number">0</span>: iload_0</span><br><span class="line">     <span class="number">1</span>: iconst_1</span><br><span class="line">     <span class="number">2</span>: iadd</span><br><span class="line">     <span class="number">3</span>: iconst_2</span><br><span class="line">     <span class="number">4</span>: isub</span><br><span class="line">     <span class="number">5</span>: iconst_3</span><br><span class="line">     <span class="number">6</span>: imul</span><br><span class="line">     <span class="number">7</span>: iconst_4</span><br><span class="line">     <span class="number">8</span>: idiv</span><br><span class="line">     <span class="number">9</span>: ireturn</span><br></pre></td></tr></table></figure>

<p>这里我定义了一个 bar 方法。它将接收一个 int 类型的参数，进行一系列计算之后再返回。</p>
<p>对应的字节码中的 stack&#x3D;2, locals&#x3D;1 代表该方法需要的操作数栈空间为 2，局部变量数组空间为 1（静态方法，没有this指针）。当调用 bar(5) 时，每条指令执行前后局部变量数组空间以及操作数栈的分布如下：</p>
<img src="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/assets/c57cb9c2222f0f79459bf4c58e1a4c32.png" alt="img" style="zoom:50%;" />

<h4 id="Java-字节码简介"><a href="#Java-字节码简介" class="headerlink" title="Java 字节码简介"></a>Java 字节码简介</h4><p>前面我已经介绍了加载常量指令、操作数栈专用指令以及局部变量区访问指令。下面我们来看看其他的类别。</p>
<p>Java 相关指令，包括各类具备高层语义的字节码，即 ：</p>
<ul>
<li><strong>new（后跟目标类，生成该类的未初始化的对象）</strong></li>
<li><strong>instanceof（后跟目标类，判断栈顶元素是否为目标类 &#x2F; 接口的实例。是则压入 1，否则压入 0）</strong></li>
<li><strong>checkcast（后跟目标类，判断栈顶元素是否为目标类 &#x2F; 接口的实例。如果不是便抛出异常）</strong></li>
<li><strong>athrow（将栈顶异常抛出）</strong></li>
<li><strong>以及 monitorenter（为栈顶对象加锁）和 monitorexit（为栈顶对象解锁）</strong>。</li>
</ul>
<p>此外，该类型的指令还包括<strong>字段访问指令</strong>，即<strong>静态字段访问指令 getstatic、putstatic，和实例字段访问指令 getfield、putfield</strong>。这四条指令均附带用以定位目标字段的信息，但所消耗的操作数栈元素皆不同。</p>
<p><img src="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/assets/da3ff3aa4aaa2531d23286fec65b08d9.png" alt="img"></p>
<p>以 putfield 为例，在上图中，它会把值 v 存储至对象 obj 的目标字段之中。</p>
<p><strong>方法调用指令</strong>，<strong>包括 invokestatic，invokespecial，invokevirtual，invokeinterface 以及 invokedynamic</strong>。这几条字节码我们已经反反复复提及了，就不再具体介绍各自的含义了。</p>
<p>除 invokedynamic 外，其他的方法调用指令所消耗的操作数栈元素是根据调用类型以及目标方法描述符来确定的。在进行方法调用之前，程序需要依次压入调用者（invokestatic 不需要），以及各个参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">neg</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> -i;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> neg(neg(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo 方法对应的字节码如下：foo 方法对应的字节码如下：</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line">  <span class="number">0</span>  aload_0 [<span class="built_in">this</span>]</span><br><span class="line">  <span class="number">1</span>  aload_0 [<span class="built_in">this</span>]</span><br><span class="line">  <span class="number">2</span>  iload_1 [i]</span><br><span class="line">  <span class="number">3</span>  invokevirtual FooTest.neg(<span class="type">int</span>) : <span class="type">int</span> [<span class="number">25</span>]</span><br><span class="line">  <span class="number">6</span>  invokevirtual FooTest.neg(<span class="type">int</span>) : <span class="type">int</span> [<span class="number">25</span>]</span><br><span class="line">  <span class="number">9</span>  ireturn</span><br></pre></td></tr></table></figure>

<p>以上面这段代码为例，当调用 foo(2) 时，每条指令执行前后局部变量数组空间以及操作数栈的分布如下所示：</p>
<img src="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/assets/476fa1bcb6b36b5b651c2a4101073295.png" alt="img" style="zoom:50%;" />

<p><strong>数组相关指令</strong>，包括新建基本类型数组的 newarray，新建引用类型数组的 anewarray，生成多维数组的 multianewarray，以及求数组长度的 arraylength。另外，它还包括数组的加载指令以及存储指令。这些指令是区分类型的。例如，int 数组的加载指令为 iaload，存储指令为 iastore。</p>
<img src="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/assets/5d935dcdd55e9f8461a6e5b0ac22001f.jpg" alt="img"  />

<p><strong>数组访问指令表</strong></p>
<p>控制流指令，包括无条件跳转 goto，条件跳转指令，tableswitch 和 lookupswtich（前者针对密集的 cases，后者针对稀疏的 cases），返回指令，以及被废弃的 jsr，ret 指令。其中返回指令是区分类型的。例如，返回 int 值的指令为 ireturn。</p>
<p><img src="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/assets/f5195b5425a9547af9ce8371aef5c4f0.jpg" alt="img"></p>
<p><strong>返回指令表</strong></p>
<p>除返回指令外，其他的控制流指令均附带一个或者多个字节码偏移量，代表需要跳转到的位置。例如下面的 abs 方法中偏移量为 1 的条件跳转指令，当栈顶元素小于 0 时，跳转至偏移量为 6 的字节码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">abs</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对应的字节码如下所示：</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">abs</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line">  <span class="number">0</span>  iload_1 [i]</span><br><span class="line">  <span class="number">1</span>  iflt <span class="number">6</span></span><br><span class="line">  <span class="number">4</span>  iload_1 [i]</span><br><span class="line">  <span class="number">5</span>  ireturn</span><br><span class="line">  <span class="number">6</span>  iload_1 [i]</span><br><span class="line">  <span class="number">7</span>  ineg</span><br><span class="line">  <span class="number">8</span>  ireturn</span><br></pre></td></tr></table></figure>

<p>剩余的 Java 字节码几乎都和计算相关，这里就不再详细阐述了。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL锁</title>
    <url>/2022/06/11/mysql04/</url>
    <content><![CDATA[<p>概述：本文记录了MySQL的锁相关的知识，参考极客时间的文章</p>
<span id="more"></span>

<p>数据库锁设计的初衷是处理并发问题。作为多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。而锁就是用来实现这些访问规则的重要数据结构。</p>
<p><strong>根据加锁的范围，MySQL里面的锁大致可以分成全局锁、表级锁和行锁三类</strong>。</p>
<p>这里需要说明的是，锁的设计比较复杂，文章不会涉及锁的具体实现细节，主要介绍的是碰到锁时的现象和其背后的原理。</p>
<h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><p>顾名思义，全局锁就是对整个数据库实例加锁。MySQL提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。</p>
<p><strong>全局锁的典型使用场景是，做全库逻辑备份。</strong>也就是把整库每个表都select出来存成文本。</p>
<p>以前有一种做法，是通过FTWRL确保不会有其他线程对数据库做更新，然后对整个库做备份。注意，在备份过程中整个库完全处于只读状态。</p>
<p>但是让整库都只读，听上去就很危险：</p>
<ul>
<li>如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；</li>
<li>如果你在从库上备份，那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟。</li>
</ul>
<p>看来加全局锁不太好。但是细想一下，备份为什么要加锁呢？我们来看一下不加锁会有什么问题。</p>
<p>假设你现在要维护“极客时间”的购买系统，关注的是用户账户余额表和用户课程表。</p>
<p>现在发起一个逻辑备份。假设备份期间，有一个用户，他购买了一门课程，业务逻辑里就要扣掉他的余额，然后往已购课程里面加上一门课。</p>
<p>如果时间顺序上是先备份账户余额表(u_account)，然后用户购买，然后备份用户课程表(u_course)，会怎么样呢？你可以看一下这个图：</p>
<img src="https://pic.imgdb.cn/item/62a450bd0947543129978abd.jpg" style="zoom:67%;" />

<p>可以看到，这个备份结果里，用户A的数据状态是“账户余额没扣，但是用户课程表里面已经多了一门课”。如果后面用这个备份来恢复数据的话，用户A就发现，自己赚了。</p>
<p>作为用户可别觉得这样可真好啊，你可以试想一下：如果备份表的顺序反过来，先备份用户课程表再备份账户余额表，又可能会出现什么结果？</p>
<p>也就是说，不加锁的话，备份系统备份的得到的库不是一个逻辑时间点，这个视图是逻辑不一致的。</p>
<p>说到视图你肯定想起来了，我们在前面讲事务隔离的时候，其实是有一个方法能够拿到一致性视图的，对吧？</p>
<p>是的，就是在可重复读隔离级别下开启一个事务。</p>
<p>官方自带的逻辑备份工具是mysqldump。当mysqldump使用参数–single-transaction的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是可以正常更新的。</p>
<p>你一定在疑惑，有了这个功能，为什么还需要FTWRL呢？<strong>一致性读是好，但前提是引擎要支持这个隔离级别。</strong>比如，对于MyISAM这种不支持事务的引擎，如果备份过程中有更新，总是只能取到最新的数据，那么就破坏了备份的一致性。这时，我们就需要使用FTWRL命令了。</p>
<p>所以，<strong>single-transaction方法只适用于所有的表使用事务引擎的库。</strong>如果有的表使用了不支持事务的引擎，那么备份就只能通过FTWRL方法。这往往是DBA要求业务开发人员使用InnoDB替代MyISAM的原因之一。</p>
<p>你也许会问，<strong>既然要全库只读，为什么不使用set global readonly&#x3D;true的方式呢</strong>？确实readonly方式也可以让全库进入只读状态，但我还是会建议你用FTWRL方式，主要有两个原因：</p>
<ul>
<li>一是，在有些系统中，readonly的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，<u>修改global变量的方式影响面更大，不建议使用</u>。</li>
<li>二是，在异常处理机制上有差异。如果执行FTWRL命令之后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为readonly之后，如果客户端发生异常，则数据库就会一直保持readonly状态，这样会导致整个库长时间处于不可写状态，风险较高。</li>
</ul>
<p>业务的更新不只是增删改数据（DML)，还有可能是加字段等修改表结构的操作（DDL）。不论是哪种方法，一个库被全局锁上以后，你要对里面任何一个表做加字段操作，都是会被锁住的。</p>
<p>但是，即使没有被全局锁住，加字段也不是就能一帆风顺的，因为你还会碰到接下来我们要介绍的表级锁。</p>
<h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p>MySQL里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。</p>
<p><strong>表锁的语法是 lock tables … read&#x2F;write。</strong>与FTWRL类似，可以用unlock tables主动释放锁，也可以在客户端断开的时候自动释放。需要注意，lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。</p>
<p>举个例子, 如果在某个线程A中执行lock tables t1 read, t2 write; 这个语句，则其他线程写t1、读写t2的语句都会被阻塞。同时，线程A在执行unlock tables之前，也只能执行读t1、读写t2的操作。连写t1都不允许，自然也不能访问其他表。</p>
<p>在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于InnoDB这种支持行锁的引擎，一般不使用lock tables命令来控制并发，毕竟锁住整个表的影响面还是太大。</p>
<p><strong>另一类表级的锁是MDL（metadata lock)。</strong>MDL不需要显式使用，在访问一个表的时候会被自动加上。MDL的作用是，保证读写的正确性。你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。</p>
<p>因此，在MySQL 5.5版本中引入了MDL，当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。</p>
<ul>
<li>读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。</li>
<li>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</li>
</ul>
<p>虽然MDL锁是系统默认会加的，但却是你不能忽略的一个机制。比如下面这个例子，我经常看到有人掉到这个坑里：给一个小表加个字段，导致整个库挂了。</p>
<p>你肯定知道，给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据。在对大表操作的时候，你肯定会特别小心，以免对线上服务造成影响。而实际上，即使是小表，操作不慎也会出问题。我们来看一下下面的操作序列，假设表t是一个小表。</p>
<blockquote>
<p>备注：这里的实验环境是MySQL 5.6。</p>
</blockquote>
<img src="https://pic.imgdb.cn/item/62a4560509475431299ee653.jpg" style="zoom:67%;" />

<p>我们可以看到session A先启动，这时候会对表t加一个MDL读锁。由于session B需要的也是MDL读锁，因此可以正常执行。</p>
<p>之后session C会被blocked，是因为session A的MDL读锁还没有释放，而session C需要MDL写锁，因此只能被阻塞。</p>
<p>如果只有session C自己被阻塞还没什么关系，但是之后所有要在表t上新申请MDL读锁的请求也会被session C阻塞。前面我们说了，所有对表的增删改查操作都需要先申请MDL读锁，就都被锁住，等于这个表现在完全不可读写了。</p>
<p>如果某个表上的查询语句频繁，而且客户端有重试机制，也就是说超时后会再起一个新session再请求的话，这个库的线程很快就会爆满。</p>
<p>你现在应该知道了，事务中的MDL锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。</p>
<p>基于上面的分析，我们来讨论一个问题，<strong>如何安全地给小表加字段？</strong></p>
<p>首先我们要解决长事务，事务不提交，就会一直占着MDL锁。在MySQL的information_schema 库的 innodb_trx 表中，你可以查到当前执行中的事务。如果你要做DDL变更的表刚好有长事务在执行，要考虑先暂停DDL，或者kill掉这个长事务。</p>
<p>但考虑一下这个场景。如果你要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，而你不得不加个字段，你该怎么做呢？</p>
<p>这时候kill可能未必管用，因为新的请求马上就来了。比较理想的机制是，在alter table语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到MDL写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者DBA再通过重试命令重复这个过程。</p>
<p>MariaDB已经合并了AliSQL的这个功能，所以这两个开源分支目前都支持DDL NOWAIT&#x2F;WAIT n这个语法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE tbl_name NOWAIT add column ...</span><br><span class="line">ALTER TABLE tbl_name WAIT N add column ... </span><br></pre></td></tr></table></figure>



<h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><p>MySQL的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如MyISAM引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB是支持行锁的，这也是MyISAM被InnoDB替代的重要原因之一。</p>
<p>这部分主要来聊聊InnoDB的行锁，以及如何通过减少锁冲突来提升业务并发度。</p>
<p>顾名思义，行锁就是针对数据表中行记录的锁。这很好理解，比如事务A更新了一行，而这时候事务B也要更新同一行，则必须等事务A的操作完成后才能进行更新。</p>
<p>当然，数据库中还有一些没那么一目了然的概念和设计，这些概念如果理解和使用不当，容易导致程序出现非预期行为，比如两阶段锁。</p>
<h4 id="两阶段锁"><a href="#两阶段锁" class="headerlink" title="两阶段锁"></a>两阶段锁</h4><p>先举个例子。在下面的操作序列中，事务B的update语句执行时会是什么现象呢？假设字段id是表t的主键。</p>
<img src="https://pic.imgdb.cn/item/62a45b170947543129a6685e.jpg" style="zoom:67%;" />

<p>这个问题的结论取决于事务A在执行完两条update语句后，持有哪些锁，以及在什么时候释放。你可以验证一下：实际上事务B的update语句会被阻塞，直到事务A执行commit之后，事务B才能继续执行。</p>
<p>知道了这个答案，你一定知道了事务A持有的两个记录的行锁，都是在commit的时候才释放的。</p>
<p>也就是说，<strong>在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。</strong></p>
<p>知道了这个设定，对我们使用事务有什么帮助呢？那就是，如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。我给你举个例子。</p>
<p>假设你负责实现一个电影票在线交易业务，顾客A要在影院B购买电影票。我们简化一点，这个业务需要涉及到以下操作：</p>
<ol>
<li>从顾客A账户余额中扣除电影票价；</li>
<li>给影院B的账户余额增加这张电影票价；</li>
<li>记录一条交易日志。</li>
</ol>
<p>也就是说，要完成这个交易，我们需要update两条记录，并insert一条记录。当然，为了保证交易的原子性，我们要把这三个操作放在一个事务中。那么，你会怎样安排这三个语句在事务中的顺序呢？</p>
<p>试想如果同时有另外一个顾客C要在影院B买票，那么这两个事务冲突的部分就是语句2了。因为它们要更新同一个影院账户的余额，需要修改同一行数据。</p>
<p>根据两阶段锁协议，不论你怎样安排语句顺序，所有的操作需要的行锁都是在事务提交的时候才释放的。所以，如果你把语句2安排在最后，比如按照3、1、2这样的顺序，那么影院账户余额这一行的锁时间就最少。这就最大程度地减少了事务之间的锁等待，提升了并发度。</p>
<p>好了，现在由于你的正确设计，影院余额这一行的行锁在一个事务中不会停留很长时间。但是，这并没有完全解决你的困扰。</p>
<p>如果这个影院做活动，可以低价预售一年内所有的电影票，而且这个活动只做一天。于是在活动时间开始的时候，你的MySQL就挂了。你登上服务器一看，CPU消耗接近100%，但整个数据库每秒就执行不到100个事务。这是什么原因呢？</p>
<p>这里，我就要说到死锁和死锁检测了。</p>
<h4 id="死锁和死锁检测"><a href="#死锁和死锁检测" class="headerlink" title="死锁和死锁检测"></a>死锁和死锁检测</h4><p>当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。这里我用数据库中的行锁举个例子。</p>
<img src="https://pic.imgdb.cn/item/62a45da10947543129a9d1ad.jpg" style="zoom:67%;" />

<p>这时候，事务A在等待事务B释放id&#x3D;2的行锁，而事务B在等待事务A释放id&#x3D;1的行锁。 事务A和事务B在互相等待对方的资源释放，就是进入了死锁状态。当出现死锁以后，有两种策略：</p>
<ul>
<li>一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数innodb_lock_wait_timeout来设置。</li>
<li>另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on，表示开启这个逻辑。</li>
</ul>
<p>在InnoDB中，innodb_lock_wait_timeout的默认值是50s，意味着如果采用第一个策略，当出现死锁以后，第一个被锁住的线程要过50s才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的。</p>
<p>但是，我们又不可能直接把这个时间设置成一个很小的值，比如1s。这样当出现死锁的时候，确实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以，超时时间设置太短的话，会出现很多误伤。</p>
<p>所以，正常情况下我们还是要采用第二种策略，即：主动死锁检测，而且innodb_deadlock_detect的默认值本身就是on。主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的。</p>
<p>你可以想象一下这个过程：每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。</p>
<p>那如果是我们上面说到的所有事务都要更新同一行的场景呢？</p>
<p>每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是O(n)的操作。假设有1000个并发线程要同时更新同一行，那么死锁检测操作就是100万这个量级的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的CPU资源。因此，你就会看到CPU利用率很高，但是每秒却执行不了几个事务。</p>
<p>根据上面的分析，我们来讨论一下，怎么解决由这种热点行更新导致的性能问题呢？问题的症结在于，死锁检测要耗费大量的CPU资源。</p>
<p><strong>一种头痛医头的方法，就是如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。</strong>但是这种操作本身带有一定的风险，因为业务设计的时候一般不会把死锁当做一个严重错误，毕竟出现死锁了，就回滚，然后通过业务重试一般就没问题了，这是业务无损的。而关掉死锁检测意味着可能会出现大量的超时，这是业务有损的。</p>
<p><strong>另一个思路是控制并发度。</strong>根据上面的分析，你会发现如果并发能够控制住，比如同一行同时最多只有10个线程在更新，那么死锁检测的成本很低，就不会出现这个问题。一个直接的想法就是，在客户端做并发控制。但是，你会很快发现这个方法不太可行，因为客户端很多。我见过一个应用，有600个客户端，这样即使每个客户端控制到只有5个并发线程，汇总到数据库服务端以后，峰值并发数也可能要达到3000。</p>
<p>因此，这个并发控制要做在数据库服务端。如果你有中间件，可以考虑在中间件实现；如果你的团队有能修改MySQL源码的人，也可以做在MySQL里面。基本思路就是，<u>对于相同行的更新，在进入引擎之前排队</u>。这样在InnoDB内部就不会有大量的死锁检测工作了。</p>
<p>可能你会问，<strong>如果团队里暂时没有数据库方面的专家，不能实现这样的方案，能不能从设计上优化这个问题呢？</strong></p>
<p>你可以考虑通过将一行改成逻辑上的多行来减少锁冲突。还是以影院账户为例，可以考虑放在多条记录上，比如10个记录，影院的账户总额等于这10个记录的值的总和。这样每次要给影院账户加金额的时候，随机选其中一条记录来加。这样每次冲突概率变成原来的1&#x2F;10，可以减少锁等待个数，也就减少了死锁检测的CPU消耗。</p>
<p>这个方案看上去是无损的，但其实这类方案需要根据业务逻辑做详细设计。如果账户余额可能会减少，比如退票逻辑，那么这时候就需要考虑当一部分行记录变成0的时候，代码要有特殊处理。</p>
<h3 id="隔离性到底怎样？"><a href="#隔离性到底怎样？" class="headerlink" title="隔离性到底怎样？"></a>隔离性到底怎样？</h3><p>讲事务隔离级别的时候提到过，如果是可重复读隔离级别，事务T启动的时候会创建一个视图read-view，之后事务T执行期间，即使有其他事务修改了数据，事务T看到的仍然跟在启动时看到的一样。也就是说，一个在可重复读隔离级别下执行的事务，好像与世无争，不受外界影响。</p>
<p>但是，行锁的部分又提到，一个事务要更新一行，如果刚好有另外一个事务拥有这一行的行锁，它又不能这么超然了，会被锁住，进入等待状态。问题是，既然进入了等待状态，那么等到这个事务自己获取到行锁要更新数据的时候，它读到的值又是什么呢？</p>
<p>举个例子，下面是一个只有两行的表的初始化语句。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `k` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line">insert into t(id, k) values(1,1),(2,2);</span><br></pre></td></tr></table></figure>

<img src="https://pic.imgdb.cn/item/62a4a47e09475431290c67ef.jpg" style="zoom: 80%;" />

<p>这里，我们需要注意的是事务的启动时机。</p>
<p>begin&#x2F;start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个操作InnoDB表的语句（第一个快照读语句），事务才真正启动。如果你想要马上启动一个事务，可以使用start transaction with consistent snapshot 这个命令。</p>
<p>还需要注意的是，在整个专栏里面，我们的例子中如果没有特别说明，都是默认autocommit&#x3D;1。</p>
<p>在这个例子中，事务C没有显式地使用begin&#x2F;commit，表示这个update语句本身就是一个事务，语句完成的时候会自动提交。事务B在更新了行之后查询; 事务A在一个只读事务中查询，并且时间顺序上是在事务B的查询之后。</p>
<p>这时，如果我告诉你事务B查到的k的值是3，而事务A查到的k的值是1，你是不是感觉有点晕呢？</p>
<p>所以，今天这篇文章，我其实就是想和你说明白这个问题，希望借由把这个疑惑解开的过程，能够帮助你对InnoDB的事务和锁有更进一步的理解。</p>
<p>在MySQL里，有两个“视图”的概念：</p>
<ul>
<li>一个是view。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是create view … ，而它的查询方法与表一样。</li>
<li>另一个是InnoDB在实现MVCC时用到的一致性读视图，即consistent read view，用于支持RC（Read Committed，读提交）和RR（Repeatable Read，可重复读）隔离级别的实现。</li>
</ul>
<p>它没有物理结构，作用是事务执行期间用来定义“我能看到什么数据”。</p>
<p>在事务隔离中有讲过MVCC的实现逻辑。为了说明查询和更新的区别，我换一个方式来说明，把read view拆开。</p>
<h4 id="“快照”在MVCC里是怎么工作的？"><a href="#“快照”在MVCC里是怎么工作的？" class="headerlink" title="“快照”在MVCC里是怎么工作的？"></a>“快照”在MVCC里是怎么工作的？</h4><p>在可重复读隔离级别下，事务在启动的时候就“拍了个快照”。注意，这个快照是基于整库的。</p>
<p>这时，你会说这看上去不太现实啊。如果一个库有100G，那么我启动一个事务，MySQL就要拷贝100G的数据出来，这个过程得多慢啊。可是，我平时的事务执行起来很快啊。</p>
<p>实际上，我们并不需要拷贝出这100G的数据。我们先来看看这个快照是怎么实现的。</p>
<p>InnoDB里面每个事务有一个唯一的事务ID，叫作<strong>transaction id</strong>。它是<u>在事务开始的时候向InnoDB的事务系统申请的，是按申请顺序严格递增的</u>。</p>
<p>而<u>每行数据也都是有多个版本的</u>。每次事务更新数据的时候，都会生成一个新的数据版本，并且把transaction id赋值给这个数据版本的事务ID，记为row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。</p>
<p>也就是说，数据表中的一行记录，其实可能有多个版本(row)，每个版本有自己的row trx_id。</p>
<p>如图所示，就是一个记录被多个事务连续更新后的状态。</p>
<img src="https://pic.imgdb.cn/item/62a4a6f10947543129103033.jpg" style="zoom:67%;" />

<p>图中虚线框里是同一行数据的4个版本，当前最新版本是V4，k的值是22，它是被transaction id 为25的事务更新的，因此它的row trx_id也是25。</p>
<p>你可能会问，前面的文章不是说，语句更新会生成undo log（回滚日志）吗？那么，<strong>undo log在哪呢？</strong></p>
<p>实际上，图2中的三个虚线箭头，就是undo log；而V1、V2、V3并不是物理上真实存在的，而是每次需要的时候根据当前版本和undo log计算出来的。比如，需要V2的时候，就是通过V4依次执行U3、U2算出来。</p>
<p>明白了多版本和row trx_id的概念后，我们再来想一下，InnoDB是怎么定义那个“100G”的快照的。</p>
<p>按照可重复读的定义，一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它不可见。</p>
<p>因此，一个事务只需要在启动的时候声明说，“以我启动的时刻为准，如果一个数据版本是在我启动之前生成的，就认；如果是我启动以后才生成的，我就不认，我必须要找到它的上一个版本”。</p>
<p>当然，如果“上一个版本”也不可见，那就得继续往前找。还有，如果是这个事务自己更新的数据，它自己还是要认的。</p>
<p>在实现上， InnoDB为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务ID。“活跃”指的就是，启动了但还没提交。</p>
<p><u>数组里面事务ID的最小值记为低、水位，当前系统里面已经创建过的事务ID的最大值加1记为高水位。</u></p>
<p>这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。</p>
<p>而数据版本的可见性规则，就是基于数据的row trx_id和这个一致性视图的对比结果得到的。</p>
<p>这个视图数组把所有的row trx_id 分成了几种不同的情况。</p>
<img src="https://pic.imgdb.cn/item/62a4a7890947543129111dae.jpg" style="zoom:67%;" />

<p>这样，对于当前事务的启动瞬间来说，一个数据版本的row trx_id，有以下几种可能：</p>
<ol>
<li>如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；</li>
<li>如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；</li>
<li>如果落在黄色部分，那就包括两种情况<br>a. 若 row trx_id在数组中，表示这个版本是由还没提交的事务生成的，不可见；<br>b. 若 row trx_id不在数组中，表示这个版本是已经提交了的事务生成的，可见。</li>
</ol>
<p>比如，对于图2中的数据来说，如果有一个事务，它的低水位是18，那么当它访问这一行数据时，就会从V4通过U3计算出V3，所以在它看来，这一行的值是11。</p>
<p>你看，有了这个声明后，系统里面随后发生的更新，是不是就跟这个事务看到的内容无关了呢？因为之后的更新，生成的版本一定属于上面的2或者3(a)的情况，而对它来说，这些新的数据版本是不存在的，所以这个事务的快照，就是“静态”的了。</p>
<p>所以你现在知道了，<strong>InnoDB利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力。</strong></p>
<p>接下来，我们继续看一下图1中的三个事务，分析下事务A的语句返回的结果，为什么是k&#x3D;1。</p>
<p>这里，我们不妨做如下假设：</p>
<ol>
<li>事务A开始前，系统里面只有一个活跃事务ID是99；</li>
<li>事务A、B、C的版本号分别是100、101、102，且当前系统里只有这四个事务；</li>
<li>三个事务开始前，(1,1）这一行数据的row trx_id是90。</li>
</ol>
<p>这样，事务A的视图数组就是[99,100], 事务B的视图数组是[99,100,101], 事务C的视图数组是[99,100,101,102]。</p>
<p>为了简化分析，我先把其他干扰语句去掉，只画出跟事务A查询逻辑有关的操作：</p>
<img src="https://pic.imgdb.cn/item/62a4a93e094754312913c30f.jpg" style="zoom:67%;" />

<p>从图中可以看到，第一个有效更新是事务C，把数据从(1,1)改成了(1,2)。这时候，这个数据的最新版本的row trx_id是102，而90这个版本已经成为了历史版本。</p>
<p>第二个有效更新是事务B，把数据从(1,2)改成了(1,3)。这时候，这个数据的最新版本（即row trx_id）是101，而102又成为了历史版本。</p>
<p>你可能注意到了，在事务A查询的时候，其实事务B还没有提交，但是它生成的(1,3)这个版本已经变成当前版本了。但这个版本对事务A必须是不可见的，否则就变成脏读了。</p>
<p>好，现在事务A要来读数据了，它的视图数组是[99,100]。当然了，读数据都是从当前版本读起的。所以，事务A查询语句的读数据流程是这样的：</p>
<ul>
<li>找到(1,3)的时候，判断出row trx_id&#x3D;101，比高水位大，处于红色区域，不可见；</li>
<li>接着，找到上一个历史版本，一看row trx_id&#x3D;102，比高水位大，处于红色区域，不可见；</li>
<li>再往前找，终于找到了（1,1)，它的row trx_id&#x3D;90，比低水位小，处于绿色区域，可见。</li>
</ul>
<p>这样执行下来，虽然期间这一行数据被修改过，但是事务A不论在什么时候查询，看到这行数据的结果都是一致的，所以我们称之为一致性读。</p>
<p>这个判断规则是从代码逻辑直接转译过来的，但是正如你所见，用于人肉分析可见性很麻烦。</p>
<p>所以，我来给你翻译一下。一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况：</p>
<ol>
<li><strong>版本未提交，不可见；</strong></li>
<li><strong>版本已提交，但是是在视图创建后提交的，不可见；</strong></li>
<li><strong>版本已提交，而且是在视图创建前提交的，可见。</strong></li>
</ol>
<p>现在，我们用这个规则来判断图4中的查询结果，事务A的查询语句的视图数组是在事务A启动的时候生成的，这时候：</p>
<ul>
<li>(1,3)还没提交，属于情况1，不可见；</li>
<li>(1,2)虽然提交了，但是是在视图数组创建之后提交的，属于情况2，不可见；</li>
<li>(1,1)是在视图数组创建之前提交的，可见。</li>
</ul>
<p>你看，去掉数字对比后，只用时间先后顺序来判断，分析起来是不是轻松多了。所以，后面我们就都用这个规则来分析。</p>
<h4 id="更新逻辑"><a href="#更新逻辑" class="headerlink" title="更新逻辑"></a>更新逻辑</h4><p>细心的同学可能有疑问了：<strong>事务B的update语句，如果按照一致性读，好像结果不对哦？</strong></p>
<p>你看图5中，事务B的视图数组是先生成的，之后事务C才提交，不是应该看不见(1,2)吗，怎么能算出(1,3)来？</p>
<p>是的，如果事务B在更新之前查询一次数据，这个查询返回的k的值确实是1。</p>
<p>但是，当它要去更新数据的时候，就不能再在历史版本上更新了，否则事务C的更新就丢失了。因此，事务B此时的set k&#x3D;k+1是在（1,2）的基础上进行的操作。</p>
<p>所以，这里就用到了这样一条规则：<strong>更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。</strong></p>
<p>因此，在更新的时候，当前读拿到的数据是(1,2)，更新后生成了新版本的数据(1,3)，这个新版本的row trx_id是101。</p>
<p>所以，在执行事务B查询语句的时候，一看自己的版本号是101，最新数据的版本号也是101，是自己的更新，可以直接使用，所以查询得到的k的值是3。</p>
<p>这里我们提到了一个概念，叫作当前读。其实，除了update语句外，select语句如果加锁，也是当前读。</p>
<p>所以，如果把事务A的查询语句select * from t where id&#x3D;1修改一下，加上lock in share mode 或 for update，也都可以读到版本号是101的数据，返回的k的值是3。下面这两个select语句，就是分别加了读锁（S锁，共享锁）和写锁（X锁，排他锁）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select k from t where id=1 lock in share mode;</span><br><span class="line">mysql&gt; select k from t where id=1 for update;</span><br></pre></td></tr></table></figure>

<p>再往前一步，假设事务C不是马上提交的，而是变成了下面的事务C’，会怎么样呢？</p>
<img src="https://pic.imgdb.cn/item/62a4ae1f09475431291b5af6.jpg" style="zoom: 80%;" />

<p>事务C’的不同是，更新后并没有马上提交，在它提交前，事务B的更新语句先发起了。前面说过了，虽然事务C’还没提交，但是(1,2)这个版本也已经生成了，并且是当前的最新版本。那么，事务B的更新语句会怎么处理呢？</p>
<p>这时候，我们在上一篇文章中提到的“两阶段锁协议”就要上场了。事务C’没提交，也就是说(1,2)这个版本上的写锁还没释放。而事务B是当前读，必须要读最新版本，而且必须加锁，因此就被锁住了，必须等到事务C’释放这个锁，才能继续它的当前读。</p>
<img src="https://pic.imgdb.cn/item/62a4afe909475431291e39ef.jpg" style="zoom:67%;" />

<p>到这里，我们把一致性读、当前读和行锁就串起来了。</p>
<p>现在，我们再回到文章开头的问题：<strong>事务的可重复读的能力是怎么实现的？</strong></p>
<p>可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。</p>
<p>而读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：</p>
<ul>
<li>在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；</li>
<li>在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。</li>
</ul>
<p>那么，我们再看一下，在读提交隔离级别下，事务A和事务B的查询语句查到的k，分别应该是多少呢？</p>
<p>这里需要说明一下，“start transaction with consistent snapshot; ”的意思是从这个语句开始，创建一个持续整个事务的一致性快照。所以，在读提交隔离级别下，这个用法就没意义了，等效于普通的start transaction。</p>
<p>下面是读提交时的状态图，可以看到这两个查询语句的创建视图数组的时机发生了变化，就是图中的read view框。（注意：这里，我们用的还是事务C的逻辑直接提交，而不是事务C’）</p>
<img src="https://pic.imgdb.cn/item/62a4b00b09475431291e6b05.jpg" style="zoom:67%;" />

<p>这时，事务A的查询语句的视图数组是在执行这个语句的时候创建的，时序上(1,2)、(1,3)的生成时间都在创建这个视图数组的时刻之前。但是，在这个时刻：</p>
<ul>
<li>(1,3)还没提交，属于情况1，不可见；</li>
<li>(1,2)提交了，属于情况3，可见。</li>
</ul>
<p>所以，这时候事务A查询语句返回的是k&#x3D;2。</p>
<p>显然地，事务B查询结果k&#x3D;3。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL索引</title>
    <url>/2022/06/10/mysql03/</url>
    <content><![CDATA[<p>概述：本文记录了MySQL索引相关的知识，参考极客时间的文章</p>
<span id="more"></span>

<p>提到数据库索引，我想你并不陌生，在日常工作中会经常接触到。比如某一个SQL查询比较慢，分析完原因之后，你可能就会说“给某个字段加个索引吧”之类的解决方案。但到底什么是索引，索引又是如何工作的呢？今天就让我们一起来聊聊这个话题吧。</p>
<p>数据库索引的内容比较多，我分成了上下两篇文章。索引是数据库系统里面最重要的概念之一，所以我希望你能够耐心看完。在后面的实战文章中，我也会经常引用这两篇文章中提到的知识点，加深你对数据库索引的理解。</p>
<p>一句话简单来说，索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。一本500页的书，如果你想快速找到其中的某一个知识点，在不借助目录的情况下，那我估计你可得找一会儿。同样，对于数据库的表而言，索引其实就是它的“目录”。</p>
<h3 id="索引的常见模型"><a href="#索引的常见模型" class="headerlink" title="索引的常见模型"></a>索引的常见模型</h3><p>索引的出现是为了提高查询效率，但是实现索引的方式却有很多种，所以这里也就引入了索引模型的概念。可以用于提高读写效率的数据结构很多，这里我先给你介绍三种常见、也比较简单的数据结构，它们分别是哈希表、有序数组和搜索树。</p>
<p>下面我主要从使用的角度，为你简单分析一下这三种模型的区别。</p>
<p>哈希表是一种以键-值（key-value）存储数据的结构，我们只要输入待查找的值即key，就可以找到其对应的值即Value。哈希的思路很简单，把值放在数组里，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置。</p>
<p>不可避免地，多个key值经过哈希函数的换算，会出现同一个值的情况。处理这种情况的一种方法是，拉出一个链表。</p>
<p>假设，你现在维护着一个身份证信息和姓名的表，需要根据身份证号查找对应的名字，这时对应的哈希索引的示意图如下所示：</p>
<img src="https://pic.imgdb.cn/item/62a34a4f09475431297d8b16.jpg" style="zoom:67%;" />

<p>图中，User2和User4根据身份证号算出来的值都是N，但没关系，后面还跟了一个链表。假设，这时候你要查ID_card_n2对应的名字是什么，处理步骤就是：首先，将ID_card_n2通过哈希函数算出N；然后，按顺序遍历，找到User2。</p>
<p>需要注意的是，图中四个ID_card_n的值并不是递增的，这样做的好处是增加新的User时速度会很快，只需要往后追加。但缺点是，因为不是有序的，所以<strong>哈希索引做区间查询的速度是很慢的</strong>。</p>
<p>你可以设想下，如果你现在要找身份证号在[ID_card_X, ID_card_Y]这个区间的所有用户，就必须全部扫描一遍了。</p>
<p>所以，<strong>哈希表这种结构适用于只有等值查询的场景</strong>，比如Memcached及其他一些NoSQL引擎。</p>
<p>而<strong>有序数组在等值查询和范围查询场景中的性能就都非常优秀</strong>。还是上面这个根据身份证号查名字的例子，如果我们使用有序数组来实现的话，示意图如下所示：</p>
<img src="https://pic.imgdb.cn/item/62a34a9709475431297deeca.jpg" style="zoom:67%;" />

<p>这里我们假设身份证号没有重复，这个数组就是按照身份证号递增的顺序保存的。这时候如果你要查ID_card_n2对应的名字，用二分法就可以快速得到，这个时间复杂度是O(log(N))。</p>
<p>同时很显然，这个索引结构支持范围查询。你要查身份证号在[ID_card_X, ID_card_Y]区间的User，可以先用二分法找到ID_card_X（如果不存在ID_card_X，就找到大于ID_card_X的第一个User），然后向右遍历，直到查到第一个大于ID_card_Y的身份证号，退出循环。</p>
<p>如果仅仅看查询效率，有序数组就是最好的数据结构了。但是，在需要更新数据的时候就麻烦了，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高。</p>
<p>所以，<strong>有序数组索引只适用于静态存储引擎</strong>，比如你要保存的是2017年某个城市的所有人口信息，这类不会再修改的数据。</p>
<p>二叉搜索树也是课本里的经典数据结构了。还是上面根据身份证号查名字的例子，如果我们用二叉搜索树来实现的话，示意图如下所示：</p>
<img src="https://pic.imgdb.cn/item/62a34af209475431297e68fa.jpg" style="zoom:67%;" />

<p><strong>二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子</strong>。这样如果你要查ID_card_n2的话，按照图中的搜索顺序就是按照UserA -&gt; UserC -&gt; UserF -&gt; User2这个路径得到。这个时间复杂度是O(log(N))。</p>
<p>当然为了维持O(log(N))的查询复杂度，你就需要保持这棵树是平衡二叉树。为了做这个保证，更新的时间复杂度也是O(log(N))。</p>
<p>树可以有二叉，也可以有多叉。多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右递增。<strong>二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上</strong>。</p>
<p>你可以想象一下一棵100万节点的平衡二叉树，树高20。一次查询可能需要访问20个数据块。在机械硬盘时代，从磁盘随机读一个数据块需要10 ms左右的寻址时间。也就是说，对于一个100万行的表，如果使用二叉树来存储，单独访问一个行可能需要20个10 ms的时间，这个查询可真够慢的。</p>
<p>为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N叉”树。这里，“N叉”树中的“N”取决于数据块的大小。</p>
<p>以InnoDB的一个整数字段索引为例，这个N差不多是1200。这棵树高是4的时候，就可以存1200的3次方个值，这已经17亿了。考虑到树根的数据块总是在内存中的，一个10亿行的表上一个整数字段的索引，查找一个值最多只需要访问3次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。</p>
<p>N叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中了。</p>
<p>不管是哈希还是有序数组，或者N叉树，它们都是不断迭代、不断优化的产物或者解决方案。数据库技术发展到今天，跳表、LSM树等数据结构也被用于引擎设计中，这里我就不再一一展开了。</p>
<p>你心里要有个概念，数据库底层存储的核心就是基于这些数据模型的。每碰到一个新数据库，我们需要先关注它的数据模型，这样才能从理论上分析出这个数据库的适用场景。</p>
<p>截止到这里，我用了半篇文章的篇幅和你介绍了不同的数据结构，以及它们的适用场景，你可能会觉得有些枯燥。但是，我建议你还是要多花一些时间来理解这部分内容，毕竟这是数据库处理数据的核心概念之一，在分析问题的时候会经常用到。当你理解了索引的模型后，就会发现在分析问题的时候会有一个更清晰的视角，体会到引擎设计的精妙之处。</p>
<p>现在，我们一起进入相对偏实战的内容吧。</p>
<p>在MySQL中，索引是在存储引擎层实现的，所以并没有统一的索引标准，即不同存储引擎的索引的工作方式并不一样。而即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。由于InnoDB存储引擎在MySQL数据库中使用最为广泛，所以下面我就以InnoDB为例，和你分析一下其中的索引模型。</p>
<h3 id="InnoDB的索引模型"><a href="#InnoDB的索引模型" class="headerlink" title="InnoDB的索引模型"></a>InnoDB的索引模型</h3><p>在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。又因为前面我们提到的，InnoDB使用了B+树索引模型，所以数据都是存储在B+树中的。</p>
<p>每一个索引在InnoDB里面对应一棵B+树。</p>
<p>假设，我们有一个<strong>主键列为ID</strong>的表，<strong>表中有字段k</strong>，并且<strong>在k上有索引</strong>。</p>
<p>这个表的建表语句是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table T(</span><br><span class="line">id int primary key, </span><br><span class="line">k int not null, </span><br><span class="line">name varchar(16),</span><br><span class="line">index (k))engine=InnoDB;</span><br></pre></td></tr></table></figure>

<p>表中R1~R5的(ID,k)值分别为(100,1)、(200,2)、(300,3)、(500,5)和(600,6)，两棵树的示例示意图如下。</p>
<img src="https://pic.imgdb.cn/item/62a34d17094754312981a017.jpg" style="zoom:67%;" />

<p>从图中不难看出，根据叶子节点的内容，索引类型分为主键索引和非主键索引。</p>
<p><strong>主键索引的叶子节点存的是整行数据</strong>。在InnoDB里，主键索引也被称为聚簇索引（clustered index）。</p>
<p><strong>非主键索引的叶子节点内容是主键的值</strong>。在InnoDB里，非主键索引也被称为二级索引（secondary index）。</p>
<p>根据上面的索引结构说明，我们来讨论一个问题：<strong>基于主键索引和普通索引的查询有什么区别？</strong></p>
<ul>
<li>如果语句是<code>select * from T where ID=500</code>，即主键查询方式，则只需要搜索ID这棵B+树；</li>
<li>如果语句是<code>select * from T where k=5</code>，即普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。这个过程称为回表。</li>
</ul>
<p>也就是说，<u>基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询</u>。</p>
<h3 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h3><p>B+树为了维护索引有序性，在插入新值的时候需要做必要的维护。以上面这个图为例，如果插入新的行ID值为700，则只需要在R5的记录后面插入一个新记录。如果新插入的ID值为400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。</p>
<p>而更糟的情况是，如果R5所在的数据页已经满了，根据B+树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。在这种情况下，性能自然会受影响。</p>
<p>除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约50%。</p>
<p>当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。</p>
<p>基于上面的索引维护过程说明，我们来讨论一个案例：</p>
<blockquote>
<p>你可能在一些建表规范里面见到过类似的描述，要求建表语句里一定要有自增主键。当然事无绝对，我们来分析一下哪些场景下应该使用自增主键，而哪些场景下不应该。</p>
</blockquote>
<p><strong>自增主键是指自增列上定义的主键</strong>，在建表语句中一般是这么定义的： NOT NULL PRIMARY KEY AUTO_INCREMENT。</p>
<p>插入新记录的时候可以不指定ID的值，系统会获取当前ID最大值加1作为下一条记录的ID值。</p>
<p>也就是说，自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。</p>
<p>而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。</p>
<p>除了考虑性能外，我们还可以从存储空间的角度来看。假设你的表中确实有一个唯一字段，比如字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？</p>
<p>由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约20个字节，而如果用整型做主键，则只要4个字节，如果是长整型（bigint）则是8个字节。</p>
<p><strong>显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</strong></p>
<p>所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。</p>
<p>有没有什么场景适合用业务字段直接做主键的呢？还是有的。比如，有些业务的场景需求是这样的：</p>
<ol>
<li>只有一个索引；</li>
<li>该索引必须是唯一索引。</li>
</ol>
<p>你一定看出来了，这就是典型的KV场景。</p>
<p>由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。</p>
<p>这时候我们就要优先考虑上一段提到的“尽量使用主键查询”原则，直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树。</p>
<h3 id="一个示例"><a href="#一个示例" class="headerlink" title="一个示例"></a>一个示例</h3><p>先来看一下这个问题：</p>
<p>在下面这个表T中，如果我执行 select * from T where k between 3 and 5，需要执行几次树的搜索操作，会扫描多少行？</p>
<p>下面是这个表的初始化语句。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table T (</span><br><span class="line">ID int primary key,</span><br><span class="line">k int NOT NULL DEFAULT 0, </span><br><span class="line">s varchar(16) NOT NULL DEFAULT &#x27;&#x27;,</span><br><span class="line">index k(k))</span><br><span class="line">engine=InnoDB;</span><br><span class="line"></span><br><span class="line">insert into T values(100,1, &#x27;aa&#x27;),(200,2,&#x27;bb&#x27;),(300,3,&#x27;cc&#x27;),(500,5,&#x27;ee&#x27;),(600,6,&#x27;ff&#x27;),(700,7,&#x27;gg&#x27;);</span><br></pre></td></tr></table></figure>

<img src="https://pic.imgdb.cn/item/62a34d17094754312981a017.jpg" style="zoom:67%;" />

<p>现在，我们一起来看看这条SQL查询语句的执行流程：</p>
<ol>
<li>在k索引树上找到k&#x3D;3的记录，取得 ID &#x3D; 300；</li>
<li>再到ID索引树查到ID&#x3D;300对应的R3；</li>
<li>在k索引树取下一个值k&#x3D;5，取得ID&#x3D;500；</li>
<li>再回到ID索引树查到ID&#x3D;500对应的R4；</li>
<li>在k索引树取下一个值k&#x3D;6，不满足条件，循环结束。</li>
</ol>
<p>在这个过程中，<strong>回到主键索引树搜索的过程，我们称为回表</strong>。可以看到，这个查询过程读了k索引树的3条记录（步骤1、3和5），回表了两次（步骤2和4）。</p>
<p>在这个例子中，由于查询结果所需要的数据只在主键索引上有，所以不得不回表。那么，<u>有没有可能经过索引优化，避免回表过程呢</u>？</p>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>如果执行的语句是select ID from T where k between 3 and 5，这时只需要查ID的值，而ID的值已经在k索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引k已经“覆盖了”我们的查询需求，我们称为覆盖索引。</p>
<p><strong>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</strong></p>
<p>需要注意的是，在引擎内部使用覆盖索引在索引k上其实读了三个记录，R3~R5（对应的索引k上的记录项），但是对于MySQL的Server层来说，它就是找引擎拿到了两条记录，因此MySQL认为扫描行数是2。</p>
<blockquote>
<p>备注：关于如何查看扫描行数的问题，我将会在第16文章《如何正确地显示随机消息？》中，和你详细讨论。</p>
</blockquote>
<p>基于上面覆盖索引的说明，我们来讨论一个问题：<strong>在一个市民信息表上，是否有必要将身份证号和名字建立联合索引？</strong></p>
<p>假设这个市民表的定义是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `tuser` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `id_card` varchar(32) DEFAULT NULL,</span><br><span class="line">  `name` varchar(32) DEFAULT NULL,</span><br><span class="line">  `age` int(11) DEFAULT NULL,</span><br><span class="line">  `ismale` tinyint(1) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `id_card` (`id_card`),</span><br><span class="line">  KEY `name_age` (`name`,`age`)</span><br><span class="line">) ENGINE=InnoDB</span><br></pre></td></tr></table></figure>

<p>我们知道，身份证号是市民的唯一标识。也就是说，如果有根据身份证号查询市民信息的需求，我们只要在身份证号字段上建立索引就够了。而再建立一个（身份证号、姓名）的联合索引，是不是浪费空间？</p>
<p>如果现在有一个高频请求，要根据市民的身份证号查询他的姓名，这个联合索引就有意义了。它可以在这个高频请求上用到覆盖索引，不再需要回表查整行记录，减少语句的执行时间。</p>
<p>当然，索引字段的维护总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。这正是业务DBA，或者称为业务数据架构师的工作。</p>
<h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>看到这里你一定有一个疑问，如果为每一种查询都设计一个索引，索引是不是太多了。如果我现在要按照市民的身份证号去查他的家庭地址呢？虽然这个查询需求在业务中出现的概率不高，但总不能让它走全表扫描吧？反过来说，单独为一个不频繁的请求创建一个（身份证号，地址）的索引又感觉有点浪费。应该怎么做呢？</p>
<p>这里，我先和你说结论吧。<strong>B+树这种索引结构，可以利用索引的“最左前缀”，来定位记录。</strong></p>
<p>为了直观地说明这个概念，我们用（name，age）这个联合索引来分析。</p>
<img src="https://pic.imgdb.cn/item/62a446a10947543129896cca.jpg" style="zoom:67%;" />

<p>可以看到，索引项是按照索引定义里面出现的字段顺序排序的。</p>
<p>当你的逻辑需求是查到所有名字是“张三”的人时，可以快速定位到ID4，然后向后遍历得到所有需要的结果。</p>
<p>如果你要查的是所有名字第一个字是“张”的人，你的SQL语句的条件是”where name like ‘张%’”。这时，你也能够用上这个索引，查找到第一个符合条件的记录是ID3，然后向后遍历，直到不满足条件为止。</p>
<p>可以看到，不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。</p>
<p>基于上面对最左前缀索引的说明，我们来讨论一个问题：<strong>在建立联合索引的时候，如何安排索引内的字段顺序。</strong></p>
<p>这里我们的评估标准是，索引的复用能力。因为可以支持最左前缀，所以当已经有了(a,b)这个联合索引后，一般就不需要单独在a上建立索引了。因此，<strong>第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。</strong></p>
<p>所以现在你知道了，这段开头的问题里，我们要为高频请求创建(身份证号，姓名）这个联合索引，并用这个索引支持“根据身份证号查询地址”的需求。</p>
<p>那么，如果既有联合查询，又有基于a、b各自的查询呢？查询条件里面只有b的语句，是无法使用(a,b)这个联合索引的，这时候你不得不维护另外一个索引，也就是说你需要同时维护(a,b)、(b) 这两个索引。</p>
<p>这时候，我们要<strong>考虑的原则就是空间</strong>了。比如上面这个市民表的情况，name字段是比age字段大的 ，那我就建议你创建一个（name,age)的联合索引和一个(age)的单字段索引。</p>
<h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>上一段我们说到满足最左前缀原则的时候，最左前缀可以用于在索引中定位记录。这时，你可能要问，那些不符合最左前缀的部分，会怎么样呢？</p>
<p>我们还是以市民表的联合索引（name, age）为例。如果现在有一个需求：检索出表中“名字第一个字是张，而且年龄是10岁的所有男孩”。那么，SQL语句是这么写的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from tuser where name like &#x27;张%&#x27; and age=10 and ismale=1;</span><br></pre></td></tr></table></figure>

<p>你已经知道了前缀索引规则，所以这个语句在搜索索引树的时候，只能用 “张”，找到第一个满足条件的记录ID3。当然，这还不错，总比全表扫描要好。</p>
<p>然后呢？</p>
<p>当然是判断其他条件是否满足。</p>
<p>在MySQL 5.6之前，只能从ID3开始一个个回表。到主键索引上找出数据行，再对比字段值。</p>
<p>而MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p>
<p>图3和图4，是这两个过程的执行流程图。</p>
<img src="https://pic.imgdb.cn/item/62a44a9f09475431298eec5c.jpg" style="zoom:67%;" />

<img src="https://pic.imgdb.cn/item/62a44bd9094754312990d3f9.jpg" style="zoom:67%;" />

<p>在图3和4这两个图里面，每一个虚线箭头表示回表一次。</p>
<p>图3中，在(name,age)索引里面我特意去掉了age的值，这个过程InnoDB并不会去看age的值，只是按顺序把“name第一个字是’张’”的记录一条条取出来回表。因此，需要回表4次。</p>
<p>图4跟图3的区别是，InnoDB在(name,age)索引内部就判断了age是否等于10，对于不等于10的记录，直接判断并跳过。在我们的这个例子中，只需要对ID4、ID5这两条记录回表取数据判断，就只需要回表2次。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL事务隔离</title>
    <url>/2022/06/10/mysql02/</url>
    <content><![CDATA[<p>概述：本文记录了MySQL事务隔离相关的知识，参考极客时间的文章</p>
<span id="more"></span>

<p>简单来说，事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在MySQL中，事务支持是在引擎层实现的。你现在知道，MySQL是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如MySQL原生的MyISAM引擎就不支持事务，这也是MyISAM被InnoDB取代的重要原因之一。</p>
<p>文章里将会以InnoDB为例，剖析MySQL在事务支持方面的特定实现，并基于原理给出相应的实践建议</p>
<h3 id="隔离性和隔离级别"><a href="#隔离性和隔离级别" class="headerlink" title="隔离性和隔离级别"></a>隔离性和隔离级别</h3><p>提到事务，你肯定会想到ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性），今天我们就来说说其中I，也就是“隔离性”。</p>
<p>当数据库上有多个事务同时执行的时候，就可能出现<u>脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）</u>的问题，为了解决这些问题，就有了“隔离级别”的概念。</p>
<p>在谈隔离级别之前，你首先要知道，你隔离得越严实，效率就会越低。因此很多时候，我们都要在二者之间寻找一个平衡点。SQL标准的事务隔离级别包括：<strong>读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）</strong>。下面我逐一为你解释：</p>
<ul>
<li><strong>读未提交</strong>是指，一个事务还没提交时，它做的变更就能被别的事务看到。</li>
<li><strong>读提交</strong>是指，一个事务提交之后，它做的变更才会被其他事务看到。</li>
<li><strong>可重复读</strong>是指，<u>一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的</u>。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li>
<li><strong>串行化</strong>，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，<u>后访问的事务必须等前一个事务执行完成，才能继续执行</u>。</li>
</ul>
<p>其中“读提交”和“可重复读”比较难理解，所以我用一个例子说明这几种隔离级别。假设数据表T中只有一列，其中一行的值为1，下面是按照时间顺序执行两个事务的行为。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table T(c int) engine=InnoDB;</span><br><span class="line">insert into T(c) values(1);</span><br></pre></td></tr></table></figure>

<img src="https://pic.imgdb.cn/item/62a309e6094754312924a7a6.jpg" style="zoom: 50%;" />

<p>我们来看看在不同的隔离级别下，事务A会有哪些不同的返回结果，也就是图里面V1、V2、V3的返回值分别是什么。</p>
<ul>
<li>若隔离级别是“读未提交”， 则V1的值就是2。这时候事务B虽然还没有提交，但是结果已经被A看到了。因此，V2、V3也都是2。</li>
<li>若隔离级别是“读提交”，则V1是1，V2的值是2。事务B的更新在提交后才能被A看到。所以， V3的值也是2。</li>
<li>若隔离级别是“可重复读”，则V1、V2是1，V3是2。之所以V2还是1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。</li>
<li><u>若隔离级别是“串行化”，则在事务B执行“将1改成2”的时候，会被锁住。直到事务A提交后，事务B才可以继续执行</u>。所以从A的角度看， V1、V2值是1，V3的值是2。</li>
</ul>
<p>在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，这个视图是在每个SQL语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。</p>
<p>我们可以看到在不同的隔离级别下，数据库行为是有所不同的。Oracle数据库的默认隔离级别其实就是“读提交”，因此对于一些从Oracle迁移到MySQL的应用，为保证数据库隔离级别的一致，你一定要记得将MySQL的隔离级别设置为“读提交”。</p>
<p>配置的方式是，将启动参数transaction-isolation的值设置成READ-COMMITTED。你可以用show variables来查看当前的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;transaction_isolation&#x27;;</span><br><span class="line"></span><br><span class="line">+-----------------------+----------------+</span><br><span class="line"></span><br><span class="line">| Variable_name | Value |</span><br><span class="line"></span><br><span class="line">+-----------------------+----------------+</span><br><span class="line"></span><br><span class="line">| transaction_isolation | READ-COMMITTED |</span><br><span class="line"></span><br><span class="line">+-----------------------+----------------+</span><br></pre></td></tr></table></figure>

<p>总结来说，存在即合理，哪个隔离级别都有它自己的使用场景，你要根据自己的业务情况来定。我想<strong>你可能会问那什么时候需要“可重复读”的场景呢</strong>？我们来看一个数据校对逻辑的案例。</p>
<p>假设你在管理一个个人银行账户表。一个表存了每个月月底的余额，一个表存了账单明细。这时候你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。</p>
<p>这时候使用“可重复读”隔离级别就很方便。事务启动时的视图可以认为是静态的，不受其他事务更新的影响。</p>
<h3 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h3><p>理解了事务的隔离级别，我们再来看看事务隔离具体是怎么实现的。这里我们展开说明“可重复读”。</p>
<p>在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。</p>
<p>假设一个值从1被按顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录。</p>
<img src="https://pic.imgdb.cn/item/62a33de109475431296b5958.jpg" style="zoom:80%;" />

<p>当前值是4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的read-view。如图中看到的，在视图A、B、C里面，这一个记录的值分别是1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于read-view A，要得到1，就必须将当前值依次执行图中所有的回滚操作得到。</p>
<p>同时你会发现，即使现在有另外一个事务正在将4改成5，这个事务跟read-view A、B、C对应的事务是不会冲突的。</p>
<p>你一定会问，回滚日志总不能一直保留吧，什么时候删除呢？答案是，在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。</p>
<p>什么时候才不需要了呢？就是<u>当系统里没有比这个回滚日志更早的read-view的时候</u>。</p>
<p>基于上面的说明，我们来讨论一下为什么建议你尽量不要使用长事务。</p>
<p>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</p>
<p>在MySQL 5.5及以前的版本，回滚日志是跟数据字典一起放在ibdata文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。我见过数据只有20GB，而回滚段有200GB的库。最终只好为了清理回滚段，重建整个库。</p>
<p>除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库，这个我们会在后面讲锁的时候展开。</p>
<h3 id="事务的启动方式"><a href="#事务的启动方式" class="headerlink" title="事务的启动方式"></a>事务的启动方式</h3><p>如前面所述，长事务有这些潜在风险，我当然是建议你尽量避免。其实很多时候业务开发同学并不是有意使用长事务，通常是由于误用所致。MySQL的事务启动方式有以下几种：</p>
<ol>
<li>显式启动事务语句， begin 或 start transaction。配套的提交语句是commit，回滚语句是rollback。</li>
<li>set autocommit&#x3D;0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个select语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行commit 或 rollback 语句，或者断开连接。</li>
</ol>
<p>有些客户端连接框架会默认连接成功后先执行一个set autocommit&#x3D;0的命令。这就导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。</p>
<p>因此，我会建议你总是使用set autocommit&#x3D;1, 通过显式语句的方式来启动事务。</p>
<p>但是有的开发同学会纠结“多一次交互”的问题。对于一个需要频繁使用事务的业务，第二种方式每个事务在开始时都不需要主动执行一次 “begin”，减少了语句的交互次数。如果你也有这个顾虑，我建议你使用commit work and chain语法。</p>
<p>在autocommit为1的情况下，用begin显式启动的事务，如果执行commit则提交事务。如果执行 commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行begin语句的开销。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。</p>
<p>你可以在information_schema库的innodb_trx这个表中查询长事务，比如下面这个语句，用于查找持续时间超过60s的事务。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))&gt;60</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>project_in_meituan_04</title>
    <url>/2022/06/09/project-in-meituan-04/</url>
    <content><![CDATA[<p>第四个需求，建一个RPC接口</p>
<span id="more"></span>

<h3 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h3><p>为游戏中心建立一个能够重置游戏中心用户账户的RPC接口，能把用户重置为新用户，注意用户新人奖励也需要重置</p>
<h3 id="开发过程"><a href="#开发过程" class="headerlink" title="开发过程"></a>开发过程</h3><p>其实参照start-up中的RPC接口开发流程，并没有太大的改动。</p>
<p>这里主要注意一下接口的实现中的几个细节：</p>
<ul>
<li>要对参数进行校验<ul>
<li>对于不符合要求的参数返回由GameCenterResponseBuild构造的PARAMETER_ILLEGAL异常</li>
</ul>
</li>
<li>主体使用try-catch：注意有远程调用的时候，由于不知道是否会发生网络异常、超时，或者别人抛出一个异常给你，就需要使用try-catch，另外如果对自己写的代码是否会抛出错误没有把握，也可以使用try-catch</li>
<li>关于返回值，一开始我使用Boolean，后面包装成了Response。其实都是可以的，但是使用Response后续可以继续扩展，即如果后面想反回一些别的内容，可以方便地加进去，增加了扩展性！</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@MdpThriftServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GameCenterUtilsServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">GameCenterUtilsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserAssetsQueryService userAssetsQueryService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> AssetsOperationService assetsOperationService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> GameDataGateway gameDataGateway;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ResetUserAccountResp <span class="title function_">resetUserAccount</span><span class="params">(Long userId)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == userId) &#123;</span><br><span class="line">            <span class="keyword">return</span> GameCenterResponseBuild.build(GameCenterResultCodeEnum.PARAMETER_ILLEGAL, ResetUserAccountResp.class);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">sceneCode</span> <span class="operator">=</span> AssetsSceneCodeEnum.GAME_CENTER.getCode();</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">identity</span> <span class="operator">=</span> AssetsUserIdentityEnum.ACTIVITY_NEW.getCode();</span><br><span class="line">            <span class="type">AssetsAccountResponse</span> <span class="variable">resp</span> <span class="operator">=</span> userAssetsQueryService.queryAccountBySceneCode(userId, sceneCode);</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> == resp || <span class="literal">null</span> == resp.getData() || <span class="literal">null</span> == resp.getData().getAddTime()) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;游戏中心-用户账户信息异常,resp:&#123;&#125;&quot;</span>, resp);</span><br><span class="line">                <span class="keyword">return</span> GameCenterResponseBuild.build(GameCenterResultCodeEnum.SYSTEM_ERROR, ResetUserAccountResp.class);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ResetUserAccountResp</span> <span class="variable">resetUserAccountResp</span> <span class="operator">=</span> GameCenterResponseBuild.success(ResetUserAccountResp.class);</span><br><span class="line">            <span class="comment">//更新addTime</span></span><br><span class="line">            assetsOperationService.updateUserAccountIdentity(userId, sceneCode, identity, <span class="string">&quot;zhuzhangqi&quot;</span>, <span class="string">&quot;wahaha123&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//更新新人奖励</span></span><br><span class="line">            <span class="type">GBDataSaveReq</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GBDataSaveReq</span>();</span><br><span class="line">            request.setUserId(userId);</span><br><span class="line">            request.setGameType(GBDGameTypeEnum.GAME_CENTER.getType());</span><br><span class="line">            List&lt;GBDFieldDTO&gt; fieldList = Lists.newArrayList();</span><br><span class="line">            request.setFieldList(fieldList);</span><br><span class="line">            <span class="type">GBDFieldDTO</span> <span class="variable">fieldDTO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GBDFieldDTO</span>();</span><br><span class="line">            fieldList.add(fieldDTO);</span><br><span class="line"></span><br><span class="line">            fieldDTO.setModuleId(GameCenterModuleEnum.USER_DATA.getId());</span><br><span class="line">            fieldDTO.setFieldId(GameCenterDataFieldEnum.USER_GAME_DATA.getFieldId());</span><br><span class="line">            fieldDTO.setValueType(GBDValueTypeEnum.STRUCT.getType());</span><br><span class="line"></span><br><span class="line">            <span class="type">UserDataBO</span> <span class="variable">userDataBO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDataBO</span>();</span><br><span class="line">            userDataBO.setGuideRewardTime(System.currentTimeMillis());</span><br><span class="line">            userDataBO.setGuideRewardStatus(GuideRewardStatusEnum.PENDING.getValue());</span><br><span class="line">            request.getFieldList().get(<span class="number">0</span>).setFieldValue(GsonUtil.toJSONString(userDataBO));</span><br><span class="line">            gameDataGateway.saveModuleOrFields(request);</span><br><span class="line"></span><br><span class="line">            resetUserAccountResp.setResult(Boolean.TRUE);</span><br><span class="line">            <span class="keyword">return</span> resetUserAccountResp;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;游戏中心-用户账户信息异常,userId=&#123;&#125;&quot;</span>, userId, e);</span><br><span class="line">            <span class="keyword">return</span> GameCenterResponseBuild.build(GameCenterResultCodeEnum.SYSTEM_ERROR, ResetUserAccountResp.class);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>UT测试类，尽可能覆盖代码每一行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GameCenterUtilsServiceTest</span> <span class="keyword">extends</span> <span class="title class_">AbstractTest</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> GameCenterUtilsService gameCenterUtilsService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_resetUserAccount</span><span class="params">()</span>&#123;</span><br><span class="line">        Tracer.setSwimlane(<span class="string">&quot;zhuzhangqi-yzwgj&quot;</span>);</span><br><span class="line">        System.out.println(gameCenterUtilsService.resetUserAccount(<span class="number">5054538345L</span>));</span><br><span class="line">        System.out.println(gameCenterUtilsService.resetUserAccount(<span class="number">123L</span>));</span><br><span class="line">        System.out.println(gameCenterUtilsService.resetUserAccount(<span class="literal">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Projects</category>
        <category>MeiTuan</category>
      </categories>
      <tags>
        <tag>MeiTuan</tag>
        <tag>Projects</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL基础架构</title>
    <url>/2022/06/09/mysql/</url>
    <content><![CDATA[<p>概述：本文记录了MySQL的基本知识和实际使用中的常见问题，参考极客时间的技术文章</p>
<span id="more"></span>

<h3 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h3><p>对于一条最基本的select查询语句，会经过怎么样的处理过程？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from T where ID=10；</span><br></pre></td></tr></table></figure>



<img src="https://pic.imgdb.cn/item/62a164f709475431292e02a9.jpg" style="zoom:80%;" />

<p>大体来说，MySQL可以分为Server层和存储引擎层两部分。</p>
<p>Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p>
<p>而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5.5版本开始成为了默认存储引擎。</p>
<p>也就是说，你执行create table建表的时候，如果不指定引擎类型，默认使用的就是InnoDB。不过，你也可以通过指定存储引擎的类型来选择别的引擎，比如在create table语句中使用engine&#x3D;memory, 来指定使用内存引擎创建表。不同存储引擎的表数据存取方式不同，支持的功能也不同，在后面的文章中，我们会讨论到引擎的选择。</p>
<p>从图中不难看出，不同的存储引擎共用一个<strong>Server层</strong>，也就是从连接器到执行器的部分</p>
<h4 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h4><p>第一步，你会先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令一般是这么写的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -h$ip -P$port -u$user -p</span><br></pre></td></tr></table></figure>

<p>输完命令之后，你就需要在交互对话里面输入密码。虽然密码也可以直接跟在-p后面写在命令行中，但这样可能会导致你的密码泄露。如果你连的是生产服务器，强烈建议你不要这么做。</p>
<p>连接命令中的mysql是客户端工具，用来跟服务端建立连接。在完成经典的TCP握手后，连接器就要开始认证你的身份，这个时候用的就是你输入的用户名和密码。</p>
<ul>
<li>如果用户名或密码不对，你就会收到一个”Access denied for user”的错误，然后客户端程序结束执行。</li>
<li>如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。</li>
</ul>
<p>这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。</p>
<p>连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在show processlist命令中看到它。文本中这个图是show processlist的结果，其中的Command列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。</p>
<img src="https://pic.imgdb.cn/item/62a1668609475431292fed12.jpg" style="zoom:80%;" />

<p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数wait_timeout控制的，默认值是8小时。</p>
<p>如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： Lost connection to MySQL server during query。这时候如果你要继续，就需要重连，然后再执行请求了。</p>
<p>数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</p>
<p>建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。</p>
<p>但是全部使用长连接后，你可能会发现，有些时候MySQL占用内存涨得特别快，这是因为<u>MySQL在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是MySQL异常重启了</u>。</p>
<p>怎么解决这个问题呢？你可以考虑以下两种方案。</p>
<ol>
<li>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</li>
<li>如果你用的是MySQL 5.7或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</li>
</ol>
<h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><p>连接建立完成后，你就可以执行select语句了。执行逻辑就会来到第二步：查询缓存。</p>
<p>MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。key是查询的语句，value是查询的结果。如果你的查询能够直接在这个缓存中找到key，那么这个value就会被直接返回给客户端。</p>
<p>如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。你可以看到，如果查询命中缓存，MySQL不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。</p>
<p><strong>但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。</strong></p>
<p>查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。<u>对于更新压力大的数据库来说，查询缓存的命中率会非常低</u>。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。</p>
<p>好在MySQL也提供了这种“按需使用”的方式。你可以将参数query_cache_type设置成DEMAND，这样对于默认的SQL语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用SQL_CACHE显式指定，像下面这个语句一样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select SQL_CACHE * from T where ID=10；</span><br></pre></td></tr></table></figure>

<p>需要注意的是，MySQL 8.0版本直接将查询缓存的整块功能删掉了，也就是说8.0开始彻底没有这个功能了。</p>
<h4 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h4><p>如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL需要知道你要做什么，因此需要对SQL语句做解析。</p>
<p>分析器先会做“词法分析”。你输入的是由多个字符串和空格组成的一条SQL语句，MySQL需要识别出里面的字符串分别是什么，代表什么。</p>
<p>MySQL从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名T”，把字符串“ID”识别成“列ID”。</p>
<p>做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法。</p>
<p>如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒，比如当select少打了开头的字母“s”时。一般语法错误会提示第一个出现错误的位置</p>
<h4 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h4><p>经过了分析器，MySQL就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。</p>
<p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的join：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from t1 join t2 using(ID)  where t1.c=10 and t2.d=20;</span><br></pre></td></tr></table></figure>

<ul>
<li>既可以先从表t1里面取出c&#x3D;10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是否等于20。</li>
<li>也可以先从表t2里面取出d&#x3D;20的记录的ID值，再根据ID值关联到表t1，再判断t1里面c的值是否等于10。</li>
</ul>
<p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。</p>
<p>优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。如果你还有一些疑问，比如优化器是怎么选择索引的，有没有可能选择错等等，会在后面单独展开说明优化器的内容。</p>
<h4 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h4><p>MySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。</p>
<p>开始执行的时候，要先判断一下你对这个表T有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下所示(在工程实现上，如果命中查询缓存，会在查询缓存放回结果的时候，做权限验证。查询也会在优化器之前调用precheck验证权限)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from T where ID=10;</span><br><span class="line"></span><br><span class="line">ERROR 1142 (42000): SELECT command denied to user &#x27;b&#x27;@&#x27;localhost&#x27; for table &#x27;T&#x27;</span><br></pre></td></tr></table></figure>

<p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。</p>
<p>比如我们这个例子中的表T中，ID字段没有索引，那么执行器的执行流程是这样的：</p>
<ol>
<li>调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中；</li>
<li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li>
<li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li>
</ol>
<p>至此，这个语句就执行完成了。</p>
<p>对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。</p>
<p><u>你会在数据库的慢查询日志中看到一个rows_examined的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的</u>。</p>
<p>在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此<strong>引擎扫描行数跟rows_examined并不是完全相同的。</strong>我们后面会专门有一篇文章来讲存储引擎的内部机制，里面会有详细的说明。</p>
<h3 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h3><p>一条更新语句的执行流程又是怎样的呢</p>
<p>从一个表的一条更新语句说起，下面是这个表的创建语句，这个表有一个主键ID和一个整型字段c：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table T(ID int primary key, c int);</span><br></pre></td></tr></table></figure>

<p>如果要将ID&#x3D;2这一行的值加1，SQL语句就会这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; update T set c=c+1 where ID=2;</span><br></pre></td></tr></table></figure>

<p>参考前面的SQL语句基本的执行链路。首先，可以确定的说，查询语句的那一套流程，更新语句也是同样会走一遍。</p>
<p>你执行语句前要先连接数据库，这是连接器的工作。</p>
<p>前面我们说过，在一个表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句就会把表T上所有缓存结果都清空。这也就是我们一般不建议使用查询缓存的原因。</p>
<p>接下来，分析器会通过词法和语法解析知道这是一条更新语句。优化器决定要使用ID这个索引。然后，执行器负责具体执行，找到这一行，然后更新。</p>
<p>与查询流程不一样的是，更新流程还涉及两个重要的日志模块，它们正是我们今天要讨论的主角：redo log（重做日志）和 binlog（归档日志）。如果接触MySQL，那这两个词肯定是绕不过的，我后面的内容里也会不断地和你强调。不过话说回来，redo log和binlog在设计上有很多有意思的地方，这些设计思路也可以用到你自己的程序里。</p>
<h4 id="重要的日志模块：redo-log"><a href="#重要的日志模块：redo-log" class="headerlink" title="重要的日志模块：redo log"></a>重要的日志模块：redo log</h4><p>不知道你还记不记得《孔乙己》这篇文章，酒店掌柜有一个粉板，专门用来记录客人的赊账记录。如果赊账的人不多，那么他可以把顾客名和账目写在板上。但如果赊账的人多了，粉板总会有记不下的时候，这个时候掌柜一定还有一个专门记录赊账的账本。</p>
<p>如果有人要赊账或者还账的话，掌柜一般有两种做法：</p>
<ul>
<li>一种做法是直接把账本翻出来，把这次赊的账加上去或者扣除掉；</li>
<li>另一种做法是先在粉板上记下这次的账，等打烊以后再把账本翻出来核算。</li>
</ul>
<p>在生意红火柜台很忙时，掌柜一定会选择后者，因为前者操作实在是太麻烦了。首先，你得找到这个人的赊账总额那条记录。你想想，密密麻麻几十页，掌柜要找到那个名字，可能还得带上老花镜慢慢找，找到之后再拿出算盘计算，最后再将结果写回到账本上。</p>
<p>这整个过程想想都麻烦。相比之下，还是先在粉板上记一下方便。你想想，如果掌柜没有粉板的帮助，每次记账都得翻账本，效率是不是低得让人难以忍受？</p>
<p>同样，在MySQL里也有这个问题，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程IO成本、查找成本都很高。为了解决这个问题，MySQL的设计者就用了类似酒店掌柜粉板的思路来提升更新效率。</p>
<p>而粉板和账本配合的整个过程，其实就是MySQL里经常说到的WAL技术，WAL的全称是Write-Ahead Logging，它的关键点就是先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账本。</p>
<p>具体来说，当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log（粉板）里面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事。</p>
<p>如果今天赊账的不多，掌柜可以等打烊后再整理。但如果某天赊账的特别多，粉板写满了，又怎么办呢？这个时候掌柜只好放下手中的活儿，把粉板中的一部分赊账记录更新到账本中，然后把这些记录从粉板上擦掉，为记新账腾出空间。</p>
<p>与此类似，InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB，那么这块“粉板”总共就可以记录4GB的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。</p>
<img src="https://pic.imgdb.cn/item/62a16e8809475431293c6c6d.jpg" style="zoom:80%;" />

<p>write pos是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p>
<p><u>write pos和checkpoint之间的是“粉板”上还空着的部分</u>，可以用来记录新的操作。如果write pos追上checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把checkpoint推进一下。</p>
<p>有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为<strong>crash-safe</strong>。</p>
<p>要理解crash-safe这个概念，可以想想我们前面赊账记录的例子。只要赊账记录记在了粉板上或写在了账本上，之后即使掌柜忘记了，比如突然停业几天，恢复生意后依然可以通过账本和粉板上的数据明确赊账账目。</p>
<h4 id="重要的日志模块：binlog"><a href="#重要的日志模块：binlog" class="headerlink" title="重要的日志模块：binlog"></a>重要的日志模块：binlog</h4><p>前面讲过，MySQL整体来看，其实就有两块：一块是Server层，它主要做的是MySQL功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。上面我们聊到的粉板<u>redo log是InnoDB引擎特有的日志，而Server层也有自己的日志，称为binlog（归档日志）</u>。</p>
<p>我想你肯定会问，为什么会有两份日志呢？</p>
<p>因为最开始MySQL里并没有InnoDB引擎。MySQL自带的引擎是MyISAM，但是MyISAM没有crash-safe的能力，binlog日志只能用于归档。而InnoDB是另一个公司以插件形式引入MySQL的，既然只依靠binlog是没有crash-safe能力的，所以InnoDB使用另外一套日志系统——也就是redo log来实现crash-safe能力。</p>
<p>这两种日志有以下三点不同。</p>
<ol>
<li>redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。</li>
<li>redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID&#x3D;2这一行的c字段加1 ”。</li>
<li>redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li>
</ol>
<p>有了对这两个日志的概念性理解，我们再来看执行器和InnoDB引擎在执行这个简单的update语句时的内部流程。</p>
<ol>
<li>执行器先找引擎取ID&#x3D;2这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID&#x3D;2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li>
<li>执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li>
<li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。</li>
<li>执行器生成这个操作的binlog，并把binlog写入磁盘。</li>
<li>执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。</li>
</ol>
<p>这里我给出这个update语句的执行流程图，图中浅色框表示是在InnoDB内部执行的，深色框表示是在执行器中执行的。</p>
<img src="https://pic.imgdb.cn/item/62a16fcf09475431293e0fef.jpg" style="zoom:80%;" />

<p>你可能注意到了，最后三步看上去有点“绕”，<u>将redo log的写入拆成了两个步骤：prepare和commit，这就是”两阶段提交”</u>。</p>
<h4 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h4><p>为什么必须有“两阶段提交”呢？这是为了让两份日志之间的逻辑一致。要说明这个问题，我们得从文章开头的那个问题说起：<strong>怎样让数据库恢复到半个月内任意一秒的状态？</strong></p>
<p>前面我们说过了，binlog会记录所有的逻辑操作，并且是采用“追加写”的形式。如果你的DBA承诺说半个月内可以恢复，那么备份系统中一定会保存最近半个月的所有binlog，同时系统会定期做整库备份。这里的“定期”取决于系统的重要性，可以是一天一备，也可以是一周一备。</p>
<p>当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那你可以这么做：</p>
<ul>
<li>首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库；</li>
<li>然后，从备份的时间点开始，将备份的binlog依次取出来，重放到中午误删表之前的那个时刻。</li>
</ul>
<p>这样你的临时库就跟误删之前的线上库一样了，然后你可以把表数据从临时库取出来，按需要恢复到线上库去。</p>
<p>好了，说完了数据恢复过程，我们回来说说，为什么日志需要“两阶段提交”。这里不妨用反证法来进行解释。</p>
<p>由于redo log和binlog是两个独立的逻辑，如果不用两阶段提交，要么就是先写完redo log再写binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。</p>
<p>仍然用前面的update语句来做例子。假设当前ID&#x3D;2的行，字段c的值是0，再假设执行update语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了crash，会出现什么情况呢？</p>
<ol>
<li><strong>先写redo log后写binlog</strong>。假设在redo log写完，binlog还没有写完的时候，MySQL进程异常重启。由于我们前面说过的，redo log写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行c的值是1。<br>但是由于binlog没写完就crash了，这时候binlog里面就没有记录这个语句。因此，之后备份日志的时候，存起来的binlog里面就没有这条语句。<br>然后你会发现，如果需要用这个binlog来恢复临时库的话，由于这个语句的binlog丢失，这个临时库就会少了这一次更新，恢复出来的这一行c的值就是0，与原库的值不同。</li>
<li><strong>先写binlog后写redo log</strong>。如果在binlog写完之后crash，由于redo log还没写，崩溃恢复以后这个事务无效，所以这一行c的值是0。但是binlog里面已经记录了“把c从0改成1”这个日志。所以，在之后用binlog来恢复的时候就多了一个事务出来，恢复出来的这一行c的值就是1，与原库的值不同。</li>
</ol>
<p>可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。</p>
<p>你可能会说，这个概率是不是很低，平时也没有什么动不动就需要恢复临时库的场景呀？</p>
<p>其实不是的，不只是误操作后需要用这个过程来恢复数据。当你需要扩容的时候，也就是需要再多搭建一些备库来增加系统的读能力的时候，现在常见的做法也是用全量备份加上应用binlog来实现的，这个“不一致”就会导致你的线上出现主从数据库不一致的情况。</p>
<p>简单说，redo log和binlog都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>今天，我介绍了MySQL里面最重要的两个日志，即物理日志redo log和逻辑日志binlog。</p>
<p>redo log用于保证crash-safe能力。innodb_flush_log_at_trx_commit这个参数设置成1的时候，表示每次事务的redo log都直接持久化到磁盘。这个参数我建议你设置成1，这样可以保证MySQL异常重启之后数据不丢失。</p>
<p>sync_binlog这个参数设置成1的时候，表示每次事务的binlog都持久化到磁盘。这个参数我也建议你设置成1，这样可以保证MySQL异常重启之后binlog不丢失。</p>
<p>还介绍了与MySQL日志系统密切相关的“两阶段提交”。两阶段提交是跨系统维持数据逻辑一致性时常用的一个方案，即使你不做数据库内核开发，日常开发中也有可能会用到。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>game_structure</title>
    <url>/2022/06/08/game-structure/</url>
    <content><![CDATA[<p>概述：本文记录对小组系统架构的理解和学习</p>
<span id="more"></span>

<h4 id="整体架构图"><a href="#整体架构图" class="headerlink" title="整体架构图"></a>整体架构图</h4><img src="https://pic.imgdb.cn/item/62a01f6a0947543129bf3d58.jpg" style="zoom:80%;" />

<p>这是一个典型的微服务架构分层示意图。</p>
<ul>
<li>网关层作为系统真正入口，接收客户端发来的请求，并做预处理，以保证其转发到业务逻辑层都是有意义的。<ul>
<li>网关层主要实现安全策略、用户鉴权、流量控制、产生Session、生成请求ID等功能。</li>
<li>业务网关与游戏网关独立：游戏业务流量峰值与玩法有较大差异，形式也比玩法多，比如会强依赖长链。独立后能够较好的做到隔离性</li>
</ul>
</li>
<li>业务层的功能就是实现具体业务逻辑，网关层与业务层独立，前台展示逻辑切割，尽量保证流量隔离，展示逻辑不侵入业务：<ul>
<li>天天领鸡蛋——growth</li>
<li>走路赚钱——game-service</li>
<li>合成游戏——game-center</li>
</ul>
</li>
<li>通用层（数据访问层）提供数据读写功能，隔离业务逻辑和数据库。这样做的好处是方便对数据做统一处理，比如给热点数据加缓存、分库分表、更换数据库等操作都不需要业务逻辑层关心。</li>
<li>存储层（数据库层）负责数据的存储。</li>
</ul>
<img src="https://pic.imgdb.cn/item/62a04da60947543129f9fd45.jpg" style="zoom:80%;" />

<h4 id="活动中心"><a href="#活动中心" class="headerlink" title="活动中心"></a>活动中心</h4><p>活动中心（core）系统在优选营销互动平台系统群中属于核心系统，提供玩法配置管理、活动匹配、活动实例管理能力</p>
<ul>
<li>活动配置管理：活动配置即活动的元数据<ul>
<li>活动的基础设定（人群、渠道、poi）</li>
<li>专有的玩法模型</li>
</ul>
</li>
<li>活动匹配：活动中心关键业务逻辑，依赖内外部支撑（团长、poi、crm等）<ul>
<li>根据用户信息与活动配置进行匹配，决定用户是否为活动目标人群</li>
</ul>
</li>
<li>用户实例管理：可以理解为活动配置的对象<ul>
<li>管理用户参与活动过程中的信息</li>
<li>决定用户一次活动参与的持续时间</li>
</ul>
</li>
<li>活动流水：活动参与过程中产生的业务数据</li>
</ul>
<p>分为三层：</p>
<ul>
<li>shapherd层：用于活动保存&#x2F;更新接口，活动详情接口</li>
<li>mapi层：用于活动保存&#x2F;更新，活动详情查看，活动列表，活动上下线<ul>
<li>convert VO to DTO</li>
<li>要做好所有的参数校验，防止因前端的配置问题导致的C端问题</li>
</ul>
</li>
<li>core层：活动保存&#x2F;更新，活动查询，活动状态管理，活动列表<ul>
<li>活动配置：定义DTO即可</li>
</ul>
</li>
</ul>
<h4 id="合成玩法"><a href="#合成玩法" class="headerlink" title="合成玩法"></a>合成玩法</h4><img src="https://pic.imgdb.cn/item/62a06ca1094754312925ed7e.jpg" style="zoom:50%;" />

<p>依赖服务：</p>
<ul>
<li>营销玩法活动中心服务 <code>com.sankuai.grocerymkthd.interact.core</code>：用于管理用户活动配置与实例<ul>
<li><code>ActivityInstanceCPService:queryInstanceWithMode</code>：查询用户活动实力</li>
<li><code>ActivityInstanceFlowRecordService:recordUserInstanceFlow</code>：记录用户参与活动的流水信息</li>
</ul>
</li>
<li>虚拟资产服务 <code>com.sankuai.grocerymkthd.interact.assets</code>：用于管理用户各玩法与游戏的虚拟资产</li>
<li>奖励中心 <code>com.sankuai.grocerymkthd.interact.lottery</code>：是美团优选营销互动平台-抽奖活动中心，聚合规则和奖励，以及投放能力</li>
<li>任务中心 <code>com.sankuai.grocerymkthd.interact.taskcenter</code>：优选营销玩法任务中心，为外部系统提供任务相关的通用能力，如查询任务、领取任务、更新任务、作废任务等</li>
</ul>
<h4 id="鸡蛋玩法"><a href="#鸡蛋玩法" class="headerlink" title="鸡蛋玩法"></a>鸡蛋玩法</h4><img src="https://pic.imgdb.cn/item/62a06ce40947543129264503.jpg" style="zoom:50%;" />

<ul>
<li>短链http网关服务： <code>com.sankuai.grocerymkt.activity.gamecapi</code></li>
<li>长链网关服务</li>
<li>核心service服务： <code>com.sankuai.grocerymkt.growth</code>，天天领鸡蛋核心服务，提供任务、养成、兑换等核心模块功能</li>
</ul>
<p>依赖服务：</p>
<ul>
<li>营销玩法活动中心服务 <code>com.sankuai.grocerymkthd.interact.core</code>：用于管理用户活动配置与实例<ul>
<li><code>ActivityInstanceCPService:queryInstanceWithMode</code>：查询用户活动实力</li>
<li><code>ActivityInstanceFlowRecordService:recordUserInstanceFlow</code>：记录用户参与活动的流水信息</li>
</ul>
</li>
<li>虚拟资产服务 <code>com.sankuai.grocerymkthd.interact.assets</code>：用于管理用户各玩法与游戏的虚拟资产</li>
<li>奖励中心 <code>com.sankuai.grocerymkthd.interact.lottery</code>：是美团优选营销互动平台-抽奖活动中心，聚合规则和奖励，以及投放能力</li>
<li>任务中心 <code>com.sankuai.grocerymkthd.interact.taskcenter</code>：优选营销玩法任务中心，为外部系统提供任务相关的通用能力，如查询任务、领取任务、更新任务、作废任务等</li>
</ul>
]]></content>
      <categories>
        <category>MeiTuan</category>
      </categories>
      <tags>
        <tag>MeiTuan</tag>
      </tags>
  </entry>
  <entry>
    <title>UML类图和时序图</title>
    <url>/2022/06/05/UML-Basic/</url>
    <content><![CDATA[<p>在学习设计模式之前，需要能够看懂UML类图和时序图。本文不会将UML整体介绍一遍，而是为了以看懂设计模式结构图为目的简单进行介绍</p>
<span id="more"></span>



<h3 id="一个示例"><a href="#一个示例" class="headerlink" title="一个示例"></a>一个示例</h3><p>注意观察以下这个类图中类之间的关系：</p>
<img src="https://pic.imgdb.cn/item/629c555c0947543129a34a39.jpg" style="zoom:80%;" />

<ul>
<li>车的类图结构为<code>&lt;&lt;abstract&gt;&gt;</code>，表示车是一个抽象类；</li>
<li>它有两个继承类：小汽车和自行车；它们之间的关系为<strong>实现关系</strong>，使用<u>带空心箭头的虚线</u>表示；</li>
<li>小汽车为与SUV之间也是<strong>继承关系</strong>，它们之间的关系为<strong>泛化关系</strong>，使用带<u>空心箭头的实线</u>表示；</li>
<li>小汽车与发动机之间是<strong>组合关系</strong>，使用带<u>实心箭头的实线</u>表示；</li>
<li>学生与班级之间是<strong>聚合关系</strong>，使用带<u>空心箭头的实线</u>表示；</li>
<li>学生与身份证之间为<strong>关联关系</strong>，使用<u>一根实线</u>表示；</li>
<li>学生上学需要用到自行车，与自行车是一种<strong>依赖关系</strong>，使用<u>带箭头的虚线</u>表示；</li>
</ul>
<h3 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h3><h4 id="泛化关系（generalization）"><a href="#泛化关系（generalization）" class="headerlink" title="泛化关系（generalization）"></a>泛化关系（generalization）</h4><p>类的继承结构表现在UML中为：泛化(generalize)与实现(realize)：</p>
<p>继承关系为 is-a的关系；两个对象之间如果可以用 is-a 来表示，就是继承关系：（..是..)</p>
<p>eg：自行车是车、猫是动物</p>
<p>泛化关系用一条带空心箭头的直接表示；如下图表示（A继承自B）；</p>
<img src="https://pic.imgdb.cn/item/629c577f0947543129a6577a.jpg" style="zoom:80%;" />

<p>eg：汽车在现实中有实现，可用汽车定义具体的对象；汽车与SUV之间为泛化关系；</p>
<p><strong>注：最终代码中，泛化关系表现为继承非抽象类；</strong></p>
<h4 id="实现关系（realize）"><a href="#实现关系（realize）" class="headerlink" title="实现关系（realize）"></a>实现关系（realize）</h4><p>实现关系用一条带空心箭头的虚线表示；</p>
<p>eg：”车”为一个抽象概念，在现实中并无法直接用来定义对象；只有指明具体的子类(汽车还是自行车)，才可以用来定义对象（”车”这个类在C++中用抽象类表示，在JAVA中有接口这个概念，更容易理解）</p>
<img src="https://pic.imgdb.cn/item/629c58bf0947543129a815b3.jpg" style="zoom:80%;" />

<p><strong>注：最终代码中，实现关系表现为继承抽象类；</strong></p>
<h4 id="聚合关系（aggregation）"><a href="#聚合关系（aggregation）" class="headerlink" title="聚合关系（aggregation）"></a>聚合关系（aggregation）</h4><p>聚合关系用一条带空心菱形箭头的直线表示，如下图表示A聚合到B上，或者说<strong>B由A组成</strong>；</p>
<img src="https://pic.imgdb.cn/item/629c58fc0947543129a86f47.jpg" style="zoom:80%;" />

<p>聚合关系用于表示实体对象之间的关系，表示整体由部分构成的语义；例如一个部门由多个员工组成；</p>
<p>与组合关系不同的是，整体和部分<strong>不是强依赖的</strong>，即使整体不存在了，部分仍然存在；例如， 部门撤销了，人员不会消失，他们依然存在；</p>
<h4 id="组合关系（composition）"><a href="#组合关系（composition）" class="headerlink" title="组合关系（composition）"></a>组合关系（composition）</h4><p>组合关系用一条带实心菱形箭头直线表示，如下图表示A组成B，或者B由A组成；</p>
<img src="https://pic.imgdb.cn/item/629c596e0947543129a91341.jpg" style="zoom:80%;" />

<p>与聚合关系一样，组合关系同样表示整体由部分构成的语义；比如公司由多个部门组成；</p>
<p>但组合关系是一种<strong>强依赖的特殊聚合关系</strong>，如果<u>整体不存在了，则部分也不存在了</u>；例如， 公司不存在了，部门也将不存在了；</p>
<h4 id="关联关系（association）"><a href="#关联关系（association）" class="headerlink" title="关联关系（association）"></a>关联关系（association）</h4><p>关联关系是用一条直线表示的；它描述不同类的对象之间的结构关系；它是一种静态关系， 通常与运行状态无关，一般由常识等因素决定的；它一般用来定义对象之间静态的、天然的结构； 所以，关联关系是一种“强关联”的关系；</p>
<p>比如，乘车人和车票之间就是一种关联关系；学生和学校就是一种关联关系；</p>
<p>关联关系默认不强调方向，表示对象间相互知道；如果特别强调方向，如下图，表示A知道B，但 B不知道A；</p>
<img src="https://pic.imgdb.cn/item/629c5a660947543129aa7651.jpg" style="zoom:80%;" />

<p><strong>注：在最终代码中，关联对象通常是以成员变量的形式实现的</strong>；</p>
<h4 id="依赖关系（dependency）"><a href="#依赖关系（dependency）" class="headerlink" title="依赖关系（dependency）"></a>依赖关系（dependency）</h4><p>依赖关系是用一套带箭头的虚线表示的；如下图表示A依赖于B；他描述<u>一个对象在运行期间会用到另一个对象的关系</u>；</p>
<img src="https://pic.imgdb.cn/item/629c5ab00947543129aad302.jpg" style="zoom:80%;" />

<p>与关联关系不同的是，它是一种<u>临时性的关系</u>，通常在运行期间产生，并且随着运行时的变化； 依赖关系也可能发生变化；</p>
<p>显然，依赖也有方向，双向依赖是一种非常糟糕的结构，<u>我们总是应该保持单向依赖，杜绝双向依赖的产生</u>；</p>
<p>注：在最终代码中，<strong>依赖关系体现为类构造方法及类方法的传入参数</strong>，箭头的指向为调用关系；依赖关系除了临时知道对方外，还是“使用”对方的方法和属性；</p>
<h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p>时序图（Sequence Diagram）是显示对象之间交互的图，这些对象是按时间顺序排列的。时序图中显示的是参与交互的对象及其对象之间消息交互的顺序。</p>
<p>时序图包括的建模元素主要有：</p>
<ul>
<li><p>角色（Actor）：系统角色，可以是人、及其甚至其他的系统或者子系统。</p>
</li>
<li><p>对象（Object）：对象包括三种命名方式：</p>
<ul>
<li><p>第一种方式包括对象名和类名；</p>
</li>
<li><p>第二种方式只显示类名不显示对象名，即表示他是一个匿名对象；</p>
</li>
<li><p>第三种方式只显示对象名不显示类名。</p>
<img src="https://pic.imgdb.cn/item/629c5cab0947543129ad9d9e.jpg" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>生命线（Lifeline）：生命线在顺序图中表示为从对象图标向下延伸的一条虚线，表示对象存在的时间，如下图</p>
<img src="https://pic.imgdb.cn/item/629c5cdc0947543129ade036.jpg" style="zoom:80%;" />
</li>
<li><p>控制焦点（Focus of control）： 控制焦点是顺序图中表示时间段的符号，在这个时间段内对象将执行相应的操作。用小矩形表示，如下图。</p>
<img src="https://pic.imgdb.cn/item/629c5d390947543129ae768b.jpg" style="zoom:80%;" />
</li>
<li><p>消息（Message）：消息一般分为同步消息（Synchronous Message），异步消息（Asynchronous Message）和返回消息（Return Message）.如下图所示：</p>
<img src="https://pic.imgdb.cn/item/629c5d5e0947543129aea9b3.jpg" style="zoom:80%;" />

<ul>
<li><p><strong>同步消息&#x3D;调用消息</strong>（Synchronous Message）</p>
<p>消息的发送者把控制传递给消息的接收者，然后停止活动，等待消息的接收者放弃或者返回控制。用来表示同步的意义。 </p>
</li>
<li><p><strong>异步消息</strong>（Asynchronous Message）</p>
<p>消息发送者通过消息把信号传递给消息的接收者，然后继续自己的活动，不等待接受者返回消息或者控制。异步消息的接收者和发送者是并发工作的。 </p>
</li>
<li><p><strong>返回消息</strong>（Return Message）</p>
<p>返回消息表示从过程调用返回</p>
</li>
</ul>
</li>
<li><p>自关联消息（Self-Message）：表示方法的自身调用以及一个对象内的一个方法调用另外一个方法</p>
<img src="https://pic.imgdb.cn/item/629c5e0f0947543129afa66d.jpg" style="zoom:80%;" />
</li>
<li><p>Combined Fragments</p>
<img src="https://pic.imgdb.cn/item/629c5e460947543129aff37f.jpg" style="zoom:80%;" />

<ul>
<li>Alternative fragment（denoted “alt”） 与 if…then…else对应</li>
<li>Option fragment (denoted “opt”) 与 Switch对应</li>
<li>Parallel fragment (denoted “par”) 表示同时发生</li>
<li>Loop fragment(denoted “loop”) 与 for 或者 Foreach对应</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>UML</category>
      </categories>
      <tags>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title>project_in_meituan_03</title>
    <url>/2022/06/02/project-in-meituan-03/</url>
    <content><![CDATA[<p>一个简单（又不简单的）需求，涉及到的模块和服务和之前的不太一样，代码结构熟悉起来花了很多时间</p>
<span id="more"></span>



<h3 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h3><p>养鸡、地摊游戏任务系统：特殊类型-外跳计时浏览</p>
<ul>
<li>当渠道选择”优选微信小程序”时，下方增加中转页上传。图片像素750*1624，jpg&#x2F;png&#x2F;jpeg</li>
<li>当渠道为美团app&amp;美团小程序、优选app时，不展示中转页承接框。</li>
</ul>
<p><strong>找到接口</strong>：</p>
<p>在【Shepherd】通过【path】找到API接口后可以在【后端请求定义】中找到接口对应的名称，从而定位到了具体的代码（服务和方法）</p>
<p>通过<code>/taskcenter/config/detail</code>找到了 <code>.client.service.taskcenter.TaskConfigDataMTService</code>中的 <code>queryTaskConfigDetail</code>方法</p>
<h3 id="M端修改"><a href="#M端修改" class="headerlink" title="M端修改"></a>M端修改</h3><p>1、芥末端新增字段：</p>
<p>ruleConfig.displayExtraConfig中新增transImg字段</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;viewTime&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;transImg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://www.xxx.com&quot;</span><span class="punctuation">,</span> <span class="comment">//新增字段，中转页跳转图片URL</span></span><br><span class="line">    </span><br><span class="line">    <span class="attr">&quot;jumpConfigList&quot;</span><span class="punctuation">:</span><span class="comment">//...</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>似乎不存在模型的转换问题</p>
<p>#————废弃————–</p>
<p>interact-mapi包下：</p>
<ul>
<li><code>TaskRuleConfigVO</code>中增加一个transImg字段用作中转页图片</li>
<li>在 <code>buildRuleConfig</code>方法中添加DTO到VO的转换</li>
<li><code>transformToDisplayConfig</code>方法中添加VO到DTO的转换</li>
</ul>
<p>interact-taskcenter包下：</p>
<ul>
<li>entity中的 <code>TaskDisplayConfigDTO</code> 新增transImg字段和对应方法</li>
<li>在相关的pom.xml中修改版本</li>
</ul>
<p>#———————————-</p>
<h3 id="C端修改"><a href="#C端修改" class="headerlink" title="C端修改"></a>C端修改</h3><p>地摊玩法：game-center-composite下</p>
<ul>
<li>CGTaskAdapter 751</li>
<li>TaskViewModelResp 136</li>
<li>TaskViewTimeBO</li>
</ul>
<p>鸡蛋玩法：</p>
<ul>
<li>activity-growth下<ul>
<li>CEViewTimeRewardDTO</li>
<li>CETaskCenterBuildUtil  320 可以注意到要更改的返回值</li>
</ul>
</li>
<li>capi下<ul>
<li>CETaskConverter.convertViewTImeRewardDTO</li>
</ul>
</li>
<li>pom</li>
</ul>
<h3 id="远程debug方法"><a href="#远程debug方法" class="headerlink" title="远程debug方法"></a>远程debug方法</h3><ol>
<li>找到机器的IP地址</li>
<li>配置remote：取名，改IP地址，配置端口号（44399）</li>
<li>设置断点，选择对应的运行配置，执行debug</li>
<li>泳道请求任务列表</li>
</ol>
<p>注意如果显示无法连接，要重新部署一下服务</p>
<h3 id="搜寻服务的另外一种方法"><a href="#搜寻服务的另外一种方法" class="headerlink" title="搜寻服务的另外一种方法"></a>搜寻服务的另外一种方法</h3><ul>
<li>打开Raptor</li>
<li>进入Transaction</li>
<li>进入octo</li>
<li>查找需要的api进行定位</li>
</ul>
]]></content>
      <categories>
        <category>Projects</category>
        <category>MeiTuan</category>
      </categories>
      <tags>
        <tag>MeiTuan</tag>
        <tag>Projects</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka</title>
    <url>/2022/05/30/kafka/</url>
    <content><![CDATA[<p>本文记录了Kafka消息引擎系统（Messaging System）的大致原理和用途及一些细节</p>
<span id="more"></span>

<h3 id="消息引擎系统"><a href="#消息引擎系统" class="headerlink" title="消息引擎系统"></a>消息引擎系统</h3><p>维基定义：消息引擎系统是一组规范。企业利用这组规范在不同系统之间传递语义准确的消息，实现松耦合的异步式数据传递</p>
<p>民间定义：<u>系统A发送消息给消息引擎系统，系统B从消息引擎系统中读取A发送的消息</u></p>
<p>因此：</p>
<ul>
<li>消息引擎传输的对象是消息</li>
<li>如何传输消息属于消息引擎设计机制的一部分</li>
</ul>
<p>既然消息引擎是用于在不同系统之间传输消息的，那么如何设计待传输消息的格式就变得特别重要。一个比较容易想到的是使用已有的一些成熟解决方案，比如使用CSV、XML或是JSON；又或者是国外大厂开源的一些序列化框架，如Google的Protocol Buffer或Facebook的Thrift。</p>
<p>而Kafka的选择：使用纯二进制的字节序列。当然消息还是结构化的，只是在使用之前都要将其转换成二进制的字节序列</p>
<p>消息设计出来之后还不够，消息引擎系统还要设定具体的<strong>传输协议</strong>，即我用什么方法把消息传输出去。常见有两种方法：</p>
<ul>
<li><strong>点对点模型</strong>：也叫消息队列模型。按“民间定义”来说，就是系统A发送的消息<strong>只能</strong>被系统B接受，其他任何系统都不能读取A发送的消息。日常生活的例子比如电话客服就属于这种模型：同一个客户呼入电话只能被一位客服人员处理，第二个客服人员不能为该客户服务</li>
<li><strong>发布&#x2F;订阅模型</strong>：与上面不同的是，它有一个主题（topic）的概念，可以理解为逻辑语义相近的消息容器。该模型也有发送方和接收方，只不过提法不同。发送者也称为发布者（Publisher），接收方称为订阅者（Subscriber）。和点对点模型不同的是，这个模型可能存在多个发布者向相同的主题发送消息，而订阅者也可能存在多个，它们都能接收到相同主题的消息。生活中的报纸订阅就是一种典型的发布&#x2F;订阅模型。</li>
</ul>
<p>Kafka同时支持这两种消息引擎模型。</p>
<p><strong>为什么要使用消息引擎，而不能让系统A直接发送消息给系统B？</strong></p>
<p>答案是“<strong>削峰填谷</strong>”！这是指缓冲上下游瞬时突发流量，使其更平滑。特别是对于那些发送能力很强的上游系统，如果没有消息引擎的保护，“脆弱”的下有系统可能会直接被压垮导致全链路服务“雪崩”。但是一旦有了消息引擎，它能够有效地对抗上游的流量冲击，真正做到将上游的“峰”填满到“谷”中，避免了流量的震荡。（上游操作比较简单，TPS远高于处理订单的下游，因此需要Kafka这样的消息引擎系统来对抗这种上下游系统TPS的错配以及瞬时峰值流量）</p>
<p>消息引擎系统的另一大好处在与发送方和接收方的松耦合，这也在一定程度上简化了应用的开发，减少了系统间不必要的交互。</p>
<p>当引入Kafka之后，上游服务不再直接与下游服务进行交互。上游向Kafka Broker发送一条消息即可，下游的各个子服务订阅Kafka中的对应主题，并实时从该主题的各个分区（Partition）中获取到消息进行处理，从而实现了上游服务与下游处理服务的解耦。</p>
<h3 id="Kafka相关术语"><a href="#Kafka相关术语" class="headerlink" title="Kafka相关术语"></a>Kafka相关术语</h3><ul>
<li>主题（Topic），在Kafka中发布订阅的对象。可以为每个业务、应用设置是每类数据都创建专属的主题</li>
<li>生产者（Producer），向主题发布消息的客户端应用程序。生产者程序通常持续不断地向一个或多个主题发送消息。</li>
<li>消费者（Consumer），订阅这些主题消息的客户端应用程序。和生产者类似，消费者也能够同时订阅多个主题的消息。</li>
<li>客户端（Clients），把生产者和消费者统称为客户端。</li>
</ul>
<p>可以同时运行多个生产者和消费者实例，这些实例会不断地向Kafka集群中的多个主题生产和消费消息。</p>
<p>有客户端自然也就有服务器端：</p>
<ul>
<li><p>Broker，Kafka的服务器端由被称为Broker的服务进程构成，即一个Kafka集群由多个Broker组成，Broker负责接收和处理客户端发送过来的请求，以及对消息进行持久化。虽然Broker进程能够运行在同一台机器上，但更常见的做法是将不同的Broker分散运行在不同的机器上，这样如果集群中某一台机器宕机，即使在它上面运行的所有Broker进程都挂掉了，其他机器上的Broker也依然能够对外提供服务。这其实就是Kafka提供高可用的手段之一</p>
</li>
<li><p>备份机制（Replication），是实现高可用的另一个手段。备份的思想很简单，就是把相同的数据拷贝到多台机器上，而这些相同的数据拷贝在Kafka中被称为副本（Replica）。副本的数量是可以配置的，这些副本保存着相同的数据，但却有不同的角色和作用。Kafka定义了两类副本：</p>
<ul>
<li>领导者副本（Leader Replica），对外提供服务（指与客户端程序进行交互）</li>
<li>追随者副本（Follower Replica），被动地追随领导者副本，不能与外界进行交互</li>
</ul>
<p>副本的工作机制也很简单：生产者总是向领导者副本写消息；而消费者总是从领导者副本读消息。至于追随者副本，它只做一件事：向领导者副本发送请求，请求领导者把最新生产的消息发给它，这样它能保持与领导者的同步</p>
</li>
<li><p>伸缩性（Scalability），虽然有了副本机制可以保证数据的持久化或消息不丢失，但是没有解决伸缩性问题，。拿副本来说，虽然现在有了领导者副本和追随者副本，但倘若领导者副本积累了太多的数据以至于单台Broker及其都无法容纳了。</p>
</li>
<li><p>分区（Partitioning），为了解决伸缩性的问题，此时应该把数据分割成多份保存在不同的Broker上，Kafka也是这么设计的。Kafka中的分区机制指的是将每个主题划分为多个分区，每个分区是一组有序的消息日志。生产者生产的每条消息只会被发送到一个分区中，也就是说如果向一个双分区的主题发送一条消息，这条消息要么在分区0中，要么在分区1中。注意Kafka的分区编号是从0开始的，如果Topic有100个分区，那么分区编号就是从0到99.</p>
<p>注意副本是在分区这个层级定义的。每个分区下可以配置若干个副本，其中只能有一个领导者副本和N-1个追随者副本。生产者向分区写入消息，每条消息在分区中的位置信息由一个叫位移（Offset）的数据来表征。分区位移总是从0开始，假设一个生产者向一个空分区写入了10条消息，那么这10条消息的位移依次是0,1,2 … 9</p>
</li>
</ul>
<p>至此能完整串联起Kafka的<strong>三层消息架构</strong>：</p>
<ul>
<li>第一层是主题层，每个主题可以配置M个分区，而每个分区又可以配置N个副本</li>
<li>第二层是分区层，每个分区的N个副本中只能有一个充当领导者角色，对外提供服务；其他N-1个副本是追随者副本，只是提供数据冗余之用</li>
<li>第三层是消息层，分区中包含若干条消息，每条消息的位移从0开始，依次递增</li>
<li>最后，客户端程序只能与分区的领导者副本进行交互</li>
</ul>
<p><strong>Kafka Broker如何持久化数据？</strong></p>
<p>Kafka使用消息日志（Log）来保存数据，一个日志就是磁盘上一个只能追加写（Append-only）消息的物理文件。因为只能追加写入，故避免了缓慢的随机I&#x2F;O操作，改为性能较好的顺序I&#x2F;O写操作，这也是实现Kafka高吞吐量特性的一个重要手段。不过如果不停地向一个日志写入消息，最终也会耗尽所有的磁盘空间，因此Kafka要定期地删除消息以回收磁盘。</p>
<p>具体就是通过日志段（Log Segment）机制。在Kafka底层，一个日志又进一步细分成多个日志段，消息被追加写到当前最新的日志段中，当写满了一个日志段，Kafka会自动切分出一个新的日志段，并将老的日志段封存起来。Kafka在后台还有定时任务会定期地检查老的日志段是否能够被删除，从而实现回收磁盘的目的。</p>
<p><strong>消费者细节</strong></p>
<p>前面提过两种消息模型，即点对点模型（Peer to Peer, P2P）和发布订阅模型。</p>
<ul>
<li><p>点对点指得是同一条消息只能被下游的一个消费者消费，其他消费者则不能染指。在Kafka中实现这种P2P模型的方法就是引入了消费者组（Consumer Group）。所谓的消费者组，指的是多个消费者实例共同组成一个组来消费一组主题。这组主题中的每个分区都只会被组内的一个消费者实例消费，其他消费者实例不能消费它。</p>
<p>为什么要引入消费者组？主要是为了提升消费者端的吞吐量。多个消费者实例（Consumer Instance，可以是运行消费者应用的进程，也可以是一个线程）同时消费，加速整个消费端的吞吐量（TPS）。</p>
</li>
<li><p>消费者组里面的所有消费者实例不仅“瓜分”订阅主题的数据，而且它们还能彼此协助。假设组内某个实例挂掉了，Kafka能够自动检测到，然后把这个Failed实例之前负责的分区转移给其他或者的消费者。这个过程就是Kafka中大名鼎鼎的“重平衡”（Rebalance）。但是其实由重平衡引发的消费者问题比比皆是，事实上很多重平衡的Bug社区都无力解决。</p>
</li>
<li><p>每个消费者在消费消息的过程中必然需要有个字段记录它当前消费到了分区的哪个位置上，这个字段就是消费者位移（Consumer Offset）。注意，这和上面所说的位移完全不是一个概念。上面的Offset表征的是分区内的消息为止，它是不变的，即一旦消息被成功写个消费者有着自己的消费者位移，因此一定要区分这两类的区别。</p>
</li>
</ul>
<h3 id="Kafka只是消息引擎系统？"><a href="#Kafka只是消息引擎系统？" class="headerlink" title="Kafka只是消息引擎系统？"></a>Kafka只是消息引擎系统？</h3><p>注意，<strong>Apache Kafka是消息引擎系统，也是一个分布式流处理平台</strong>（Distributed Streaming Platform）</p>
<p>Kafka在设计之初就旨在提供三个方面的特性：</p>
<ul>
<li>提供一套API实现生产者和消费者</li>
<li>降低网络传输和磁盘存储开销</li>
<li>实现高伸缩性架构</li>
</ul>
<p>作为流处理平台，Kafka与其他主流大数据流式计算框架相比的优势：</p>
<ul>
<li><p>更容易实现端到端的正确性（Correctness）。实现正确性是流处理能够匹敌批处理的基石。</p>
<p>正确性一直是批处理的强项，而实现正确性的基石是要求框架能提供精确一次（Exactly-once）处理语义，即处理一条消息有且只有一次机会能够影响系统状态。目前主流的大数据流处理框架只能实现框架内的精确一次处理语义</p>
</li>
<li><p>Kafka自己对于流式计算的定位是一个用于搭建实时流处理的客户端库而非一个完整的功能系统。这意味着对于一些中小企业，流处理数据量不大，逻辑也不复杂，无需使用重量级的完整性平台，这时就可以使用Kafka流处理组件。</p>
</li>
</ul>
<p>除此之外，Kafka能够被用作分布式存储系统，不过这方面应用较少。</p>
<h3 id="应该选择哪种Kafka？"><a href="#应该选择哪种Kafka？" class="headerlink" title="应该选择哪种Kafka？"></a>应该选择哪种Kafka？</h3><p>Kafka是一个开源框架，但是存在多个组织或公司发布不同的Kafka，类似于Linux的不同发行版的概念（CentOS、Ubuntu…）</p>
<ul>
<li><p>Apache Kafka</p>
<ul>
<li>最“正宗”的版本，是后面其他所有版本的基础。即后面的版本要么原封不动地继承了Apache Kafka，要么是在此之上扩展了新功能。</li>
<li>优势：开发人数最多、版本迭代速度最快，社区响应及时</li>
<li>劣势：仅提供最基础的组件，并且没有提供任何监控框架或工具</li>
</ul>
</li>
<li><p>Confluent Kafka</p>
<ul>
<li>提供了一些Apache Kafka没有的高级特性，比如跨数据中心备份、Schema注册中心以及集群监控工具等。</li>
</ul>
</li>
<li><p>Cloudera&#x2F;Hortonworks Kafka</p>
<ul>
<li>Cloudera提供的CDH和Hortonworks提供的HDP是非常著名的大数据平台，里面集成了目前主流的大数据框架，能够帮助用户实现从分布式存储、集群调度、流处理到机器学习、实时数据库等全方位的数据处理</li>
</ul>
</li>
</ul>
<p><strong>Kafka的版本更迭</strong></p>
<ul>
<li>0.7版本：只提供了最基础的消息队列功能</li>
<li>0.8版本：引入了副本机制，至此Kafka成为了一个真正意义上完备的分布式高可靠消息队列解决方案</li>
<li>0.9.0.0版本：增加了基础的安全认证&#x2F;权限功能；使用Java重写了新版本消费者API；引入了Kafka Connect组件</li>
<li>0.10.0.0版本：引入了Kafka Streams，正式升级成分布式流处理平台</li>
<li>0.11.0.0版本：提供了幂等性Producer API以及事务API；对Kafka消息格式做了重构</li>
<li>1.0和2.0版本：主要还是Kafka Streams的各种改进</li>
</ul>
<h3 id="Kafka的线上集群部署方案"><a href="#Kafka的线上集群部署方案" class="headerlink" title="Kafka的线上集群部署方案"></a>Kafka的线上集群部署方案</h3><p><strong>操作系统</strong></p>
<p>Linux系统的优势：</p>
<ul>
<li>I&#x2F;O模型的使用：在Linux上能获得更高效的I&#x2F;O性能</li>
<li>数据网络传输效率：在Linux上能够享受到零拷贝技术所带来的的快速数据传输特性</li>
<li>社区支持度：社区对Windows平台上的Bug不做任何承诺，因此不能用于生产环境</li>
</ul>
<p><strong>磁盘</strong></p>
<p>机械磁盘：成本低容量大，但易损坏</p>
<p>固态硬盘：性能优势大，但单价高</p>
<p>由于Kafka使用磁盘大多是顺序读写操作，一定程度上规避了机械磁盘最大的劣势，即随机读写操作慢。因此推荐使用机械磁盘即可，而可靠性差的缺点可以由Kafka在软件层面提供机制来保证。</p>
<p><strong>磁盘容量</strong></p>
<p>考虑以下几个因素：</p>
<ul>
<li>新增消息数</li>
<li>消息留存时间</li>
<li>平均消息大小</li>
<li>备份数</li>
<li>是否启用压缩</li>
</ul>
<p>实际使用中建议预留20%-30%的磁盘空间</p>
<p><strong>带宽</strong></p>
<p>根据实际带宽资源和业务SLA预估服务器数量</p>
<p>对于千兆网络，建议每台服务器按照700Mbps来计算，避免大流量下的丢包</p>
<h3 id="集群参数配置（重要！）"><a href="#集群参数配置（重要！）" class="headerlink" title="集群参数配置（重要！）"></a>集群参数配置（重要！）</h3><p>包括Kafka服务端的配置，其中既有Broker端参数，也有主题（Topic）级别的参数、JVM端参数和操作系统级别的参数。</p>
<p>Broker端的参数也被称为静态参数（Static Config）。所谓静态参数，是指你必须在Kafka的配置文件server.properties中进行设置的参数，不管是新增、修改还是删除。同时，必须重启Broker进程才能令它们生效。</p>
<p>而主题级别的参数设置有所不同，Kafka提供了专门的kafka-configs领命来修改它们。</p>
<p>置于JVM和操作系统级别参数，它们的设置方法比较通用化。</p>
<h4 id="Broker端参数"><a href="#Broker端参数" class="headerlink" title="Broker端参数"></a>Broker端参数</h4><p>Kafka Broker提供了近200个参数，按照大的用途类别来介绍：</p>
<p><strong>信息存储重要参数</strong></p>
<ul>
<li><code>log.dirs</code>：非常重要的参数，制定了Broker需要使用的若干个文件目录路径。这个参数是没有默认值的，这说明它必须亲自指定</li>
<li><code>log.dir</code>：注意结尾没有s，说明它只能表示单个路径，它是补充上一个参数用的</li>
</ul>
<p>这两个参数中只要设置 <code>log.dirs</code>就好了。更重要的是，在线上生产环境中一定要为 <code>log.dirs</code>配置多个路径，具体格式是一个CSV格式，也就是用逗号分隔的多个路径。如果有条件最好保证这些目录挂载到不同的物理磁盘上，这样做的好处：</p>
<ul>
<li>提升读写性能：多块物理磁盘同时读写数据有更高的吞吐量</li>
<li>实现故障转移：即Failover。自1.1版本开始，坏掉的磁盘上的数据会自动地转移到其他正常的磁盘上，而且Broker还能正常工作</li>
</ul>
<p><strong>ZooKeeper相关设置</strong></p>
<p>ZooKeeper是一个分布式协调框架，负责协调管理并保存Kafka集群的所有元数据信息，比如集群都有哪些Broker在运行、创建了哪些Topic，每个Topic有多少分区以及这些分区的Leader副本都在哪些机器上等等。</p>
<ul>
<li><code>zookeeper.connect</code>：Kafka与ZooKeeper相关的最重要参数。这是一个CSV格式的参数，可以指定它的值为 <code>zk1:2181, zk2:2181,zk3:2181</code>。2181是ZooKeeper的默认端口</li>
</ul>
<p>如果让多个Kafka集群使用同一套ZooKeeper集群，这个时候就要用到chroot（在ZooKeeper中类似别名的概念）：</p>
<p>如果有两套Kafka集群，假设分别叫kafka1和kafka2，那么两套集群的 <code>zookeeper.connect</code>参数可以这样指定：<code>zk1:2181,zk2:2181,zk3:2181/kafka1</code>和 <code>zk1:2181,zk2:2181,zk3:2181/kafka2</code>切记chroot只需要写一次，而且是加到最后的。经常碰到有人这样指定：<code>zk1:2181/kafka1,zk2:2181/kafka2,zk3:2181/kafka3</code>，这样的格式是不对的</p>
<p><strong>Broker连接相关</strong></p>
<p>关于客户端程序或其他Broker如何与该Broker进行通信的设置。有以下三个参数：</p>
<ul>
<li><code>listeners</code>：监听器，其实就是告诉外部连接者要通过什么协议访问指定主机名和端口开放的kafka服务</li>
<li><code>advertised.lisenters</code>：多了个advertised，表示宣称的、公平的，就是说这组监听器是Broker用于对外发布的</li>
<li><code>host.name/port</code>：列出这两个参数就是想说把它们忘掉吧，压根不要为它们指定值，毕竟都是过期的参数了</li>
</ul>
<p>具体说说监听器的概念，从构成上说，它是若干个逗号分隔的三元组，每个三元组的格式为 <code>&lt;协议名称, 主机名, 端口号&gt;</code>：</p>
<ul>
<li><p>协议名称可能是标准的名字，比如PLAINTEXT表示明文传输、SSL表示使用SSL或TLS加密传输等；也可能是自己定义的协议名字，比如 <code>CONTROLLER://localhost:9092</code></p>
<p>一旦自己定义了协议名称，必须还要指定 <code>listener.security.protocol.map</code>参数告诉这个协议底层使用了哪种安全协议，比如指定 <code>listener.security.protocal=CONTROLLER:PLAINTEXT</code>表示CONTROLLER这个自定义协议底层使用明文不加密传输数据</p>
</li>
<li><p>主机号和端口号比较直观。不过注意主机名这个设置中可以使用IP地址或主机名，但是建议最好全部使用主机名，即Broker端和Client端应用配置中全部填写主机名。Broker源代码中也使用的是主机名，如果在某些地方使用了IP地址进行连接，可能会发生无法连接的问题</p>
</li>
</ul>
<p><strong>Topic管理相关</strong></p>
<ul>
<li><code>auto.create.topics.enable</code>：是否允许自动创建Topic。建议设置成false，防止因为拼写错误自动生成了一个新的Topic</li>
<li><code>unclean.leader.election.enable</code>：是否允许Unclean Leader选举，建议显式设置成false</li>
<li><code>auto.leader.rebalance.enable</code>：是否允许定期进行Leader选举，建议设置成false（换Leader代价很高并且本质上没有任何性能收益）</li>
</ul>
<p><strong>数据留存相关</strong></p>
<ul>
<li><p><code>log.retention.&#123;hours|minutes|ms&#125;</code>：这是个”三兄弟“，都是控制一条消息数据被保存多长时间。从优先级上来说ms设置最高、minutes次之、hours最低。</p>
<p>但是通常情况下还是设置hours级别多一点，比如 <code>log.retention.hours=168</code>表示默认保存7天的数据，自动删除7天前的数据。很多公司把Kafka当做存储来使用，那么这个值就要相应地调大。</p>
</li>
<li><p><code>log.retention.bytes</code>：这是指定Broker为消息保存的总磁盘容量大小。</p>
<p>默认是-1，表明想在这台Broker上保存多少数据都可以，至少在容量方面Broker绝对不做任何阻拦。这个参数真正发挥作用的场景其实是在云上构建多租户的Kafka集群：设想要做一个云上Kafka服务，每个租户只能使用100GB的磁盘空间，为了避免有个“恶意”租户使用过多的磁盘空间，设置这个参数就显得很重要了。</p>
</li>
<li><p><code>message.max.byte</code>：控制Broker能够接收的最大消息大小</p>
<p>这个参数不能使用默认值，默认的1000012太少了，还不到1MB。实际场景中突破1MB的消息都是屡见不鲜的，因此在线上环境中设置一个比较大的值还是比较保险的做法。</p>
</li>
</ul>
<h4 id="Topic级别参数"><a href="#Topic级别参数" class="headerlink" title="Topic级别参数"></a>Topic级别参数</h4><p>注意如果同时设置了Topic参数和全局Broker参数，Topic级别参数会覆盖全局Broker参数的值，而每个Topic都能设置自己的参数值。</p>
<p>例如前面提到的消息数据的留存时间参数，在实际环境中，如果为所有Topic数据都保存相当长的时间，这样做既不高效也无必要。更适当的做法是允许不同部门的Topic根据自身也无需要，设置自己的留存时间。如果只能设置全局Broker参数，那么势必要提取所有业务留存时间的最大值作为全局参数值，此时设置Topic级别参数把它覆盖是一个不错的选择。</p>
<p>依旧按照用途分组引出重要的Topic级别参数：</p>
<p><strong>消息保存相关</strong></p>
<ul>
<li><code>retention.ms</code>：规定了该Topic消息被保存的时长，默认是7天，即该Topic只保存最近7天的消息。一旦设置了这个值，它会覆盖掉Broker端的全局参数值</li>
<li><code>retention.bytes</code>：规定了要为该Topic预留多大的磁盘空间。和全局参数作用相似，通常在多租户的Kafka集群中有用武之地，默认为-1</li>
</ul>
<p><strong>如何设置Topic级别参数</strong></p>
<ul>
<li><p>创建Topic时进行设置</p>
<p>假设你的部门需要将交易数据发送到Kafka进行处理，需要保存最近半年的交易数据，同时这些数据很大，通常都有几MB，但一般不会超过5MB，那么可以用以下命令创建Topic：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh --bootstrap-server localhost:9092 --create --topic transaction --partions 1 --replication-factor 1 --cofig retention.ms=15552000000 --config max.message.bytes=5242880</span><br></pre></td></tr></table></figure>

<p>我们只需知道Kafka开放了kafka-topics命令供我们来创建Tipic即可。注意结尾处的–config设置，就是在config后面制定了想要设置的Topic级别参数。</p>
</li>
<li><p>修改Topic时设置</p>
<p>可以使用另一个自带的命令kafka-configs来修改Topic级别参数。假设我们现在要发送最大值10MB的消息，修改的命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/kafka-configs.sh --zookeeper localhost:2181 --entity-type topics --entity-name transaction --alter --add-config max.message.bytes=10485760</span><br></pre></td></tr></table></figure></li>
</ul>
<p>总体来说只有这两种方式进行设置，推荐始终坚持使用第二种方式来设置</p>
<h4 id="JVM参数"><a href="#JVM参数" class="headerlink" title="JVM参数"></a>JVM参数</h4><ul>
<li>堆大小的设置：通用建议，将JVM堆大小设置成6GB，默认的Heap Size为1GB，有点小。由于Kafka Broker在与客户端进行交互时会在JVM堆上创建大量的ByteBuffer实例，Heap Size不能太小。</li>
<li>垃圾回收器的设置（GC设置）：如果使用Java 8，使用默认的G1收集器就好了。在没有任何调优的情况下，主要体现在更少的Full GC，需要调整的参数更少等</li>
</ul>
<p><strong>如何设置</strong></p>
<p>只需要设置两个环境变量即可：</p>
<ul>
<li><code>KAFKA_HEAP_OPTS</code>：指定堆大小</li>
<li><code>KAFKA_JVM_PERFORMANCE_OPTS</code>：指定GC参数</li>
</ul>
<p>例如可以这样启动Kafka Broker，即在启动Kafka Broker之前，先设置上这两个环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export KAFKA_HEAP_OPTS=--Xms6g --Xms6g</span><br><span class="line">export KAFKA_JVM_PERFORMANCE_OPTS= -server -XX:+UseG1GC -XX:MaxGCPauseMillis=20 -XX:InitiatingHeapOccupancyPercent=35 -XX:+ExplicitGCInvokeConcurrent -Djava.awt.headless=true</span><br><span class="line"></span><br><span class="line">bin/kafka-server-start.sh config/server.properties</span><br></pre></td></tr></table></figure>

<h4 id="操作系统参数"><a href="#操作系统参数" class="headerlink" title="操作系统参数"></a>操作系统参数</h4><p>通常情况下Kafka并不需要设置太多的OS参数，但有些因素还是需要关注一下：</p>
<ul>
<li>文件描述符限制<ul>
<li><code>ulimit -n</code>：推荐任何一个Java项目调整一下这个值，实际上文件描述系统资源并不像想象中那样昂贵，不用太担心调大此值会有什么不利影响。通常情况下将它设置成一个超大的值是合理的做法，比如 <code>ulimit -n 1000000</code>。如果不设置的话会经常看到“Too many open files”的错误</li>
</ul>
</li>
<li>文件系统类型<ul>
<li>文件系统指的是如ext3、ext4或XFS这样的日志型文件系统。根据官网的测试报告，XFS的性能强于ext4，所以生产环境最好还是使用XFS</li>
</ul>
</li>
<li>Swappiness<ul>
<li>对于swap的调优，很多文章提到设置其为0，个人推荐设置成一个较小的值。因为一旦设置为0，当物理内存耗尽，操作系统会出发OOM killer组件，它会随机挑选一个进程然后kill掉，根本不给用户任何的预警。但如果设置成一个较小的值比如1，当开始使用swap空间时，至少能观测到Broker性能开始出现急剧下降，从而给你进一步调优和诊断问题的时间</li>
</ul>
</li>
<li>提交时间<ul>
<li>或说是Flush落盘时间。默认为5秒，一般认为太频繁了，可以适当增加提交间隔来降低物理磁盘的写操作。</li>
</ul>
</li>
</ul>
<h3 id="无消息丢失配置"><a href="#无消息丢失配置" class="headerlink" title="无消息丢失配置"></a>无消息丢失配置</h3><p>最佳实践：</p>
<ul>
<li>不要使用producer.send(msg)，而要使用producer.send(msg, callback)。记住，一定要使用带有回调通知的send方法</li>
<li>设置acks&#x3D;all。acks是Producer的一个参数，代表了你对“已提交”消息的定义。如果设置成all，则表明所有副本Broker都要接收到消息，该消息才算是“已提交”、这是最高等级的“已提交”定义</li>
<li>设置retries为一个较大的值。这里的retries同样是Producer的参数，对应Producer的自动重试。当出现网络的瞬时抖动时，消息发送可能会失败，此时配置了retries&gt;0的Producer能够自动重试消息发送，避免消息丢失</li>
<li>设置unclean.leader.election.enable&#x3D;false。这是Broker端的参数，它控制的是哪些Broker有资格竞选分区的Leader。如果一个Broker落后原先的Leader太多，那么它一旦成为新的Leader，必然会造成消息的丢失。故一般设置成false不允许该情况发生</li>
<li>设置replication.factor&gt;&#x3D;3。这也是Broken端的参数。其实这里想表述的是，最好将消息多保存几份，毕竟目前防止消息丢失的主要机制就是冗余</li>
<li>设置min.insync.replicas&gt;1。仍然是Broker端参数，控制的是消息至少要被写入到多少个副本才算是“已提交”。设置成大于1可以提升消息持久性。在实际环境中千万不要使用默认值1.</li>
<li>确保replication.factot&gt;min.insync.replicas。如果两者相等，那么只要有一个副本挂机，整个分区就无法正常工作了。我们不仅要改善消息的持久性，防止数据丢失，还要再不降低可用性的基础上完成。推荐设置成replication.factot&#x3D;min.insync.replicas+1。</li>
<li>确保消息消费完成再提交。Consumer端有个参数enable.auto.commit，最好设置成false，并采用手动提交位移的方式。这对于单Consumer多线程处理的场景而言是至关重要的。</li>
</ul>
<h3 id="Java生产者是如何管理TCP连接的"><a href="#Java生产者是如何管理TCP连接的" class="headerlink" title="Java生产者是如何管理TCP连接的"></a>Java生产者是如何管理TCP连接的</h3><p><strong>为何采用TCP？</strong></p>
<p>Apache Kafka的所有通信都是基于TCP的，而不是HTTP或其他协议。无论是生产者、消费者，还是Broker之间的通信都是如此。</p>
<p>主要原因在与TCP和HTTP之间的区别：</p>
<ul>
<li>从社区角度看，在开发客户端时，人们能够利用TCP本身的一些高级功能，比如多路复用请求以及同时轮询多个连接的能力<ul>
<li>所谓的多路复用请求，即multiplexing request，是指将两个或多个数据流合并到底层单一物理连接中的过程。TCP的多路复用请求会在一条物理连接上创建若干个虚拟连接，每个虚拟连接负责流转各自对应的数据流。</li>
<li>其实严格来说，TCP并不能多路复用，它只是提供可靠的消息交付语义保证，比如自动重传丢失的报文。更严谨地说，作为一个基于报文的协议，TCP能够被用于多路复用连接场景的前提是，上层的应用协议（如HTTP）允许发送多条消息。</li>
</ul>
</li>
<li>除了这些高级功能有可能被Kafka客户端的开发人员使用之外，社区还发现，目前已知的HTTP库在很多编程语言中都略显简陋</li>
</ul>
<p><strong>Kafka生产者程序</strong></p>
<p>Kafka的Java生产者API主要的对象就是KafkaProducer。通常开发一个生产者的步骤有4步：</p>
<ul>
<li>构造生产者对象所需的参数对象</li>
<li>利用第一步的参数对象，创建KafkaProducer对象实例</li>
<li>使用KafkaProducer的send方法发送消息</li>
<li>调用KafkaProducer的close方法关闭生产者并释放各种系统资源</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码实现</span></span><br><span class="line"><span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">props.put(<span class="string">&quot;参数1&quot;</span>,<span class="string">&quot;参数1的值&quot;</span>);</span><br><span class="line">props.put(<span class="string">&quot;参数2&quot;</span>,<span class="string">&quot;参数2的值&quot;</span>);</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line"><span class="keyword">try</span>(<span class="type">Producer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">KafkaProducer</span>&lt;&gt;(props))&#123;</span><br><span class="line">    <span class="comment">//producer.send(msg,callback);</span></span><br><span class="line">    producer.send(<span class="keyword">new</span> <span class="title class_">ProducerRecord</span>(......),callback);</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码使用了Java 7提供的try-with-resource特性，所以并没有显式调用producer.close()方法。无论是否显式调用close方法，所有生产者程序大致都是这个路数。</p>
<p>现在有一个问题，当我们开发一个Producer应用时，生产者会向Kafka集群中指定的主题（Topic）发送消息，这必然涉及与Kafka Broker创建TCP连接。那么，Kafka的Producer客户端是如何管理这些TCP连接的呢？</p>
<p><strong>何时创建TCP连接</strong></p>
<p>在<strong>创建KafkaProducer实例时</strong>，生产者应用会在后台创建并启动一个名为Sender的线程，该Sender线程开始运行时首先会创建与Broker的连接。</p>
<p>当不调用send方法时，这个Producer不知道给哪个主题发送消息，也不知道连接哪个Broker，因此它会连接bootstrap.servers参数指定的所有Broker。</p>
<p>bootstrap.servers是Producer的核心参数之一，指定了这个Producer启动时要连接的Broker地址。因此如果制定了1000个Broker连接信息，那么Producer启动时会首先创建与这1000个Broker的TCP连接。</p>
<p>实际使用中不推荐把集群中所有的Broker信息都配置到bootstrap.servers中，通常指定3-4台就够了。因为Producer一旦连接到集群中的任一台Broker，就能拿到整个集群的Broker信息。</p>
<p>此外TCP连接还<strong>可能</strong>在两个地方被创建：</p>
<ul>
<li>一个是在<strong>更新元数据后</strong>，如果发现与某些Broker当前没有连接，那么它就会创建一个TCP连接</li>
<li>另一个是在<strong>消息发送时</strong>，如果Producer发现尚不存在与目标Broker的连接，也会创建一个</li>
</ul>
<p><strong>何时关闭TCP连接</strong></p>
<ul>
<li><p>用户主动关闭。包括用户调用kill -9主动“杀掉”Producer应用。当然最推荐的还是调用producer.close()方法来关闭</p>
</li>
<li><p>Kafka自动关闭。这与Producer端参数connection.max.idle.ms的值有关。默认情况下该参数值是9分钟，即如果在9分钟内没有任何请求“流过”TCP连接，那么Kafka会主动帮你把该TCP连接关闭。可通过设置为-1禁掉这种机制。</p>
<p>注意这种方式的TCP连接是在Broker端被关闭的，但其实这个TCP连接的发起方是客户端，因此在TCP看来属于被动关闭（passive close）的场景。后果是会产生大量的CLOSE_WAIT，因此Producer端或Client端没有机会显式地观测到此连接已被中断</p>
</li>
</ul>
<h3 id="Java消费者是如何管理TCP连接的"><a href="#Java消费者是如何管理TCP连接的" class="headerlink" title="Java消费者是如何管理TCP连接的"></a>Java消费者是如何管理TCP连接的</h3><p><strong>何时创建TCP连接</strong></p>
<p>消费者端主要的程序入口是KafkaConsumer类。和生产者不同的是，构建KafkaConsumer实例时是不会创建任何TCP连接的，也就是说当执行完new KafkaConsumer(properties)语句后，会发现没有Socket连接被创建出来。这一点和Java生产者是有区别的。</p>
<p>实际上TCP连接是在调用KafkaConsumer.poll方法时被创建的。再细粒度地说，在poll方法内部有3个时机可以创建TCP连接：</p>
<ul>
<li><p>发起FindCoordinator请求时</p>
<p>消费者端有个组件叫协调者（Coordinator），它驻留在Broker端的内存中，负责消费者组的组成员管理和各个消费者的位移提交管理。当消费者程序首次启动调用poll方法时，它需要向Kafka集群发送一个名为FindCoordinator的请求，希望Kafka集群告诉它哪个Broker是管理它的协调者。消费者会向集群中当前负载最小的那台Broker发送请求。</p>
</li>
<li><p>连接协调者时</p>
<p>Broker处理完上一步发送的FindCoordinator请求之后，会返还对应的响应结果（Response），显式地告诉消费者哪个Broker是真正的协调者，因此在这一步，消费者知晓了真正的协调者后，会创建连向该Broker的Socket连接。只有成功连入协调者，协调者才能开启正常的组协调操作，比如加入组、等待组分配方案、心跳请求处理、位移获取、位移提交等</p>
</li>
<li><p>消费数据时</p>
<p>消费者会为每个要消费的分区创建与该分区领导者副本所在Broker连接的TCP。</p>
</li>
</ul>
<h3 id="Mafka的学习"><a href="#Mafka的学习" class="headerlink" title="Mafka的学习"></a>Mafka的学习</h3><p>Producer Demo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoSyncProducer</span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * producer实例请使用长链接，启动一个实例一直发消息</span></span><br><span class="line"><span class="comment">     * 请不要使用短连接：发送一条消息初始化一次，一是性能不好，而是服务端会限制连接次数影响消息发送</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> IProducerProcessor producer;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注意：执行main函数若抛出ERROR级别异常，请务必进行观察处理</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">//设置业务所在BG的namespace</span></span><br><span class="line">        properties.setProperty(ConsumerConstants.MafkaBGNamespace, <span class="string">&quot;common&quot;</span>);</span><br><span class="line">        <span class="comment">//设置生产者appkey</span></span><br><span class="line">        properties.setProperty(ConsumerConstants.MafkaClientAppkey, <span class="string">&quot;notify&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建topic对应的producer对象（注意每次build调用会产生一个新的实例）</span></span><br><span class="line">        <span class="comment">//请注意：若调用MafkaClient.buildProduceFactory()创建实例抛出有异常，请重点关注并排查异常原因，不可频繁调用该方法给服务端带来压力</span></span><br><span class="line">        producer = MafkaClient.buildProduceFactory(properties, <span class="string">&quot;notify.message.send&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//同步发送，注意：producer只实例化一次，不要每次调用sendMessage方法前都创建producer实例</span></span><br><span class="line">                <span class="type">ProducerResult</span> <span class="variable">result</span> <span class="operator">=</span> producer.sendMessage(<span class="string">&quot;send sync message&quot;</span> + i);</span><br><span class="line">                System.out.println(<span class="string">&quot;send &quot;</span> + i + <span class="string">&quot; status: &quot;</span> + result.getProducerStatus());</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                e.printStackTrace(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Consumer Demo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoConsumer</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> IConsumerProcessor consumer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">//设置业务所在BG的namespace</span></span><br><span class="line">        properties.setProperty(ConsumerConstants.MafkaBGNamespace, <span class="string">&quot;common&quot;</span>);</span><br><span class="line">        <span class="comment">//设置消费者appkey</span></span><br><span class="line">        properties.setProperty(ConsumerConstants.MafkaClientAppkey, <span class="string">&quot;notify&quot;</span>);</span><br><span class="line">        <span class="comment">//设置订阅组group</span></span><br><span class="line">        properties.setProperty(ConsumerConstants.SubscribeGroup, <span class="string">&quot;notify.message.send&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建topic对应的consumer对象（注意每次build调用会产生一个新的实例）</span></span><br><span class="line">        consumer = MafkaClient.buildConsumerFactory(properties, <span class="string">&quot;notify.message.send&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//调用recvMessageWithParallel设置listener</span></span><br><span class="line">        <span class="comment">//注意1：可以修改String.class以支持自定义数据类型</span></span><br><span class="line">        <span class="comment">//注意2：针对同一个consumer对象，只能调用一次该方法；多次调用的话，后面的调用都会报异常</span></span><br><span class="line">        consumer.recvMessageWithParallel(String.class, <span class="keyword">new</span> <span class="title class_">IMessageListener</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ConsumeStatus <span class="title function_">recvMessage</span><span class="params">(MafkaMessage message, MessageContext context)</span>&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;message=[&quot;</span> + message.getBody() + <span class="string">&quot;] partition=&quot;</span> + message.getPartition());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeStatus.CONSUME_SUCCESS;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意点：</p>
<ul>
<li>将producer资源在业务应用初始化的时候创建好</li>
<li>producer资源创建好后，再开放业务流量</li>
<li>不要频繁创建producer，即不要每次发送消息的时候，创建一个producer。发送完毕后，进行close</li>
<li>若调用MafkaClient.buildProduceFactory()创建实例抛出有异常，请充电关注并排查异常原因，不可频繁调用该方法给服务端带来压力</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>project in meituan 02</title>
    <url>/2022/05/20/project-in-meituan-02/</url>
    <content><![CDATA[<p>一个较为复杂的需求，我只负责芥末端的部分</p>
<span id="more"></span>



<h3 id="明确需求"><a href="#明确需求" class="headerlink" title="明确需求"></a>明确需求</h3><h4 id="M端"><a href="#M端" class="headerlink" title="M端"></a>M端</h4><p>新增【渠道来源奖励】：</p>
<ul>
<li>点击【新建来源奖励】和删除：增删交互同banner区，新增条目为【来源N】和【来源配置】</li>
<li>每一条配置右侧展示所配置的来源参数，多条目下便于识别</li>
<li>点击【来源配置】，拉起二级配置窗口</li>
<li>当前最多支持配置10条</li>
<li>删除：需要重置该来源的总领取上限和每日上限</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;retainWindow&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        .....</span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span>   </span><br><span class="line">    <span class="attr">&quot;sourceConfigList&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span><span class="comment">//来源配置</span></span><br><span class="line">        <span class="punctuation">&#123;</span> </span><br><span class="line">          <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="string">&quot;xxxxxx&quot;</span><span class="punctuation">,</span><span class="comment">//服务端生成，编辑的时候前端带过来</span></span><br><span class="line">          <span class="attr">&quot;crowdConfig&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;crowdType&quot;</span> <span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span>   <span class="comment">//人群类型 0:&quot;不限制&quot;， 3:&quot;按人群限制&quot;</span></span><br><span class="line">            <span class="attr">&quot;crowdIds&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">111</span><span class="punctuation">,</span><span class="number">222</span><span class="punctuation">,</span><span class="number">333</span><span class="punctuation">]</span> <span class="comment">//crmid list</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;totalLimit&quot;</span> <span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span>   <span class="comment">//每人总领取上限，-1代表不限制次数</span></span><br><span class="line">          <span class="attr">&quot;dailyLimit&quot;</span> <span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span>  <span class="comment">//每日次数限制，不可填-1</span></span><br><span class="line">          <span class="attr">&quot;userSource&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;aaa&quot;</span><span class="punctuation">,</span> <span class="comment">//链接来源参数，最长30字符</span></span><br><span class="line">          <span class="attr">&quot;rewardNumType&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span><span class="comment">//奖励数值模型</span></span><br><span class="line">          <span class="attr">&quot;lotteryId&quot;</span> <span class="punctuation">:</span> <span class="number">111</span><span class="punctuation">,</span> <span class="comment">//发放奖励</span></span><br><span class="line">          <span class="attr">&quot;imgUrl&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;1.gif&quot;</span> <span class="comment">//上传图片支持gif，尺寸[w590,h790]</span></span><br><span class="line">       <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<h4 id="C端"><a href="#C端" class="headerlink" title="C端"></a>C端</h4><img src="https://pic.imgdb.cn/item/628f1e270947543129d7acc7.jpg" style="zoom:80%;" />



<h3 id="M端开发"><a href="#M端开发" class="headerlink" title="M端开发"></a>M端开发</h3><p>整体流程与之前的需求修改的地方差别不大</p>
<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><p>这次遇到的问题明显比上次多了不少，总结一下遇到的几个需要注意的地方</p>
<h5 id="测试问题"><a href="#测试问题" class="headerlink" title="测试问题"></a>测试问题</h5><ul>
<li>使用 <code>JsonUtil.deserializeObject</code>并传入Json字符串来构造对象，并且要非常注意其中的每一项都要与对象中的字段一一对应</li>
<li>注意静态方法不能在方法外使用@Resource来使用，而是直接通过类名来调用</li>
<li>注意UT类必须继承BaseTest类</li>
</ul>
<h5 id="校验重复问题"><a href="#校验重复问题" class="headerlink" title="校验重复问题"></a>校验重复问题</h5><ul>
<li>相较于使用循环，更好的办法是使用哈希表并传入所有对象，然后再判断哈希表的大小与列表是否相等</li>
<li>但是使用哈希表（在不重写equals和hashcode方法的情况下）出现了对象内容完全相同，却无法判断出相等的结果的问题，存在问题，后面经过提示发现原来只要判断其中一个字段的重复性。所以以后必须先理解清楚需求！！</li>
</ul>
<h5 id="字段设置问题"><a href="#字段设置问题" class="headerlink" title="字段设置问题"></a>字段设置问题</h5><ul>
<li>由于本次需求需要使用一个列表的字段，我一开始自然而然地跟前一个需求一样，使用一个对象来表示，然后再在这个对象中储存一个列表。这样其实会用到两个类型的对象，其实是不必要的，实际上可以直接使用<code>List&lt;ObjectName&gt;</code>来表示。</li>
</ul>
<h3 id="C端开发"><a href="#C端开发" class="headerlink" title="C端开发"></a>C端开发</h3><p>更改的地方：</p>
<ul>
<li><p>在 client包和common包下的pom中将 <code>grocerymkthd-game-center-common</code> 修改版本为SNAPSHOT，在总的pom下将 <code>interactcommon.activity.version</code>修改版本为SNAPSHOT</p>
</li>
<li><p>增加一个 <code>GameLoginRewardDTO</code>，用于表示C端的字段，其中有<code>String toast</code>和<code>String imgUrl</code>两个信息，使用 <code>@ThriftStruct</code>并加入相应方法</p>
</li>
<li><p><code>MainSceneResp</code>中加入这个 <code>GameLoginRewardDTO loginReward</code>字段，并加入相应 <code>getter</code>和 <code>setter</code></p>
</li>
<li><p><code>MainSceneReq</code>加入一个<code>loginSource</code>的String字段</p>
</li>
<li><p>在<code>UserRewardService</code>下增加一个 <code>buildLoginReward</code>的方法。这里是整个需求逻辑的关键和核心！</p>
<ul>
<li><p>入参分析：</p>
<ul>
<li><code>MainSceneReq</code>：继承了 <code>BaseRequest</code>（包含userId，poi，channel），自身包含幂等ID idempotent，loginSource（新加）</li>
<li><code>MainSceneResponse</code>：继承了 <code>BaseResponse</code>（包含code，message），自身包含userAssets， activityId…. retainPopDisplay等等配置内容，另外新增loginReward</li>
<li><code>ActivityDTO</code>： 包含activityId， commonConfig，strategyConfigList， bizConfig， activityStatus， featureMap， version</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登陆奖励</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resp</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> activityDto</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildLoginReward</span><span class="params">(MainSceneReq request, MainSceneResp resp, ActivityDTO activityDto)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(request.getLoginSource()) || mccConfig.isDegradeLoginAward()) &#123;</span><br><span class="line">        <span class="comment">//无登陆来源标志,属于未更新的状态</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">GameCenterExtraConfigDTO</span> <span class="variable">extraConfigDto</span> <span class="operator">=</span> GsonUtil.parseObject(activityDto.getBizConfig(), GameCenterExtraConfigDTO.class);</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(extraConfigDto.getSourceConfigList())) &#123;</span><br><span class="line">        <span class="comment">//未配置登陆奖励信息</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//过滤出来源配置相同的sourceConfig</span></span><br><span class="line">    <span class="type">SourceConfigDTO</span> <span class="variable">sourceConfigDTO</span> <span class="operator">=</span> extraConfigDto.getSourceConfigList().stream()</span><br><span class="line">        .filter(sourceConfig -&gt; request.getLoginSource().equals(sourceConfig.getUserSource()))</span><br><span class="line">        .findAny().orElse(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == sourceConfigDTO) &#123;</span><br><span class="line">        <span class="comment">//未匹配到对应的source配置信息</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!crowdCheck(sourceConfigDTO.getCrowdConfig(), request.getUserId())) &#123;</span><br><span class="line">        <span class="comment">//人群不匹配</span></span><br><span class="line">        log.info(<span class="string">&quot;登陆奖励匹配失败，人群ID不符，userId:&#123;&#125;&quot;</span>, request.getUserId());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    resp.setLoginReward(buildLoginReward(request, sourceConfigDTO));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">TODO:</span></span></span><br><span class="line"><span class="comment"> * 1. 库存校验，总库存与日库存</span></span><br><span class="line"><span class="comment"> * 2. toast构建</span></span><br><span class="line"><span class="comment"> * 3. 用户奖励发放</span></span><br><span class="line"><span class="comment"> * 4. 消耗库存，总库存与日库存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> GameLoginRewardDTO <span class="title function_">buildLoginReward</span><span class="params">(MainSceneReq request, SourceConfigDTO sourceConfigDTO)</span> &#123;</span><br><span class="line">    <span class="type">GameLoginRewardDTO</span> <span class="variable">loginRewardDTO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GameLoginRewardDTO</span>();</span><br><span class="line">    <span class="comment">// toast构建</span></span><br><span class="line">    <span class="type">SourceAwardToastEnum</span> <span class="variable">toastEnum</span> <span class="operator">=</span> buildAwardStockToast(request.getUserId(), sourceConfigDTO);</span><br><span class="line">    <span class="comment">// 库存校验</span></span><br><span class="line">    <span class="keyword">if</span> (toastEnum != SourceAwardToastEnum.NO_LIMIT) &#123;</span><br><span class="line">        <span class="comment">//已没有奖励</span></span><br><span class="line">        loginRewardDTO.setToast(toastEnum.getDesc());</span><br><span class="line">        <span class="keyword">return</span> loginRewardDTO;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用户奖励发放</span></span><br><span class="line">    <span class="keyword">if</span> (!issueLoginAward(request, sourceConfigDTO)) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;UserRewardService 登陆奖励发放失败，userId:&#123;&#125;&quot;</span>, request.getUserId());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    loginRewardDTO.setImgUrl(sourceConfigDTO.getImgUrl());</span><br><span class="line">    <span class="comment">// 消耗库存</span></span><br><span class="line">    <span class="keyword">if</span> (userStockService.increaseSourceAwardStock(request.getUserId(), sourceConfigDTO)) &#123;</span><br><span class="line">        Cat.logMetricForCount(<span class="string">&quot;奖励库存扣减失败&quot;</span>);</span><br><span class="line">        log.error(<span class="string">&quot;UserRewardService increaseSourceAwardStock 奖励库存扣减失败，userId:&#123;&#125;&quot;</span>, request.getUserId());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loginRewardDTO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Boolean <span class="title function_">issueLoginAward</span><span class="params">(MainSceneReq request, SourceConfigDTO sourceConfigDTO)</span> &#123;</span><br><span class="line">    <span class="type">UserLotteryQuery</span> <span class="variable">lotteryRequest</span> <span class="operator">=</span> buildUserLotteryRequest(request, sourceConfigDTO.getLotteryId());</span><br><span class="line">    <span class="type">UserLotteryResponse</span> <span class="variable">lotteryResult</span> <span class="operator">=</span> lotteryGateway.userLottery(lotteryRequest);</span><br><span class="line">    <span class="keyword">if</span> (lotteryResult == <span class="literal">null</span> || lotteryResult.getStatusCode() != StatusCodeEnum.SUCCESS.getCode()) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;UserRewardService.issueLoginAward error,request:&#123;&#125;,lotteryRequest:&#123;&#125;&quot;</span>, request, lotteryRequest);</span><br><span class="line">        <span class="keyword">return</span> Boolean.FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">LotteryResultDTO</span> <span class="variable">lotteryResultDTO</span> <span class="operator">=</span> lotteryResult.getLotteryResultDTOMap().get(String.valueOf(sourceConfigDTO.getLotteryId()));</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == lotteryResultDTO || Boolean.FALSE.equals(lotteryResultDTO.getLucky())) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;UserRewardService.issueLoginAward error, request:&#123;&#125;, lotteryRequest:&#123;&#125;, lotteryResult:&#123;&#125;&quot;</span>, request, lotteryRequest, lotteryResult);</span><br><span class="line">        <span class="keyword">return</span> Boolean.FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    CatMetricReporter.reportMetricForCount(CatMetricConstant.ISSUE_POINT_AMOUNT, lotteryResultDTO.getPrizeResultDTOS().get(<span class="number">0</span>).getPrizeAmount());</span><br><span class="line">    <span class="keyword">return</span> Boolean.TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 已消耗完「总领取次数」，展示toast1“你已领取完奖励”</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 未消耗完「总领取次数」但已消耗完「每日可领取次数」，展示toast2“你今天已领取过奖励，请明天再来”</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sourceConfigDTO</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">private</span> SourceAwardToastEnum <span class="title function_">buildAwardStockToast</span><span class="params">(Long userId, SourceConfigDTO sourceConfigDTO)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">totalLimit</span> <span class="operator">=</span> sourceConfigDTO.getTotalLimit();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">dailyLimit</span> <span class="operator">=</span> sourceConfigDTO.getDailyLimit();</span><br><span class="line">    <span class="keyword">if</span> (totalLimit &lt; <span class="number">0</span> &amp;&amp; dailyLimit &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//不限制库存</span></span><br><span class="line">        <span class="keyword">return</span> SourceAwardToastEnum.NO_LIMIT;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;String, Integer&gt; stockMap = userStockService.getSourceAwardStock(userId, sourceConfigDTO);</span><br><span class="line">    <span class="keyword">if</span> (totalLimit &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">totalCount</span> <span class="operator">=</span> stockMap.get(userStockService.genPersonTotalStockSubKey(sourceConfigDTO.getId()));</span><br><span class="line">        <span class="keyword">if</span> (totalCount &gt;= totalLimit) &#123;</span><br><span class="line">            <span class="comment">//已达总库存限制</span></span><br><span class="line">            <span class="keyword">return</span> SourceAwardToastEnum.TOTAL_OVER;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dailyLimit &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">dailyCount</span> <span class="operator">=</span> stockMap.get(userStockService.genPersonTotalStockSubKey(sourceConfigDTO.getId()));</span><br><span class="line">        <span class="keyword">if</span> (dailyCount &gt;= dailyLimit) &#123;</span><br><span class="line">            <span class="comment">//已达日库存限制</span></span><br><span class="line">            <span class="keyword">return</span> SourceAwardToastEnum.DAILY_OVER;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> SourceAwardToastEnum.NO_LIMIT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Boolean <span class="title function_">crowdCheck</span><span class="params">(CrowdConfigDTO crowdConfig, Long userId)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == crowdConfig.getCrowdType()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Boolean.FALSE;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (CrowdTypeEnum.NO_LIMIT.getValue() == crowdConfig.getCrowdType()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (CrowdTypeEnum.CROWD_USER.getValue() == crowdConfig.getCrowdType()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(crowdConfig.getCrowdIds())) &#123;</span><br><span class="line">            <span class="keyword">return</span> Boolean.FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//人群类型为Crowd_User，需要按id匹配</span></span><br><span class="line">        Map&lt;Long, Boolean&gt; crowdIdMap = crowdGateway.checkUserBelongToCrowdIds(userId, crowdConfig.getCrowdIds());</span><br><span class="line">        <span class="keyword">if</span> (MapUtils.isEmpty(crowdIdMap)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Boolean.TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Long, Boolean&gt; entry : crowdIdMap.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Boolean.TRUE.equals(entry.getValue())) &#123;</span><br><span class="line">                <span class="keyword">return</span> Boolean.TRUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Boolean.FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>涉及到的要更改&#x2F;新增的其它类：</p>
<ul>
<li><p>在core.enums下建立一个枚举类 <code>SourceAwardToastEnum</code>用于表示游戏中心人群类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SourceAwardToastEnum</span>&#123;	</span><br><span class="line">    <span class="comment">//可以发放奖励</span></span><br><span class="line">    NO_LIMIT(<span class="number">0</span>,<span class="string">&quot;无限制&quot;</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">//已消耗完【总领取次数】</span></span><br><span class="line">    TOTAL_OVER(<span class="number">1</span>,<span class="string">&quot;你已领取完奖励&quot;</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">//未消耗完【总领取次数】，但已消耗完【每日领取次数】</span></span><br><span class="line">    DAILY_OVER(<span class="number">2</span>,<span class="string">&quot;你今天已领取过奖励，请明天再来&quot;</span>),</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    SourceAwardToastEnum(<span class="type">int</span> code, String desc)&#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ThriftEnumValue</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span>&#123;<span class="keyword">return</span> code;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span>&#123;<span class="keyword">return</span> desc;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>新增一个UserStockService类，注入CellarGateway，</p>
</li>
</ul>
</li>
<li><p>在 <code>GameCenterLocalService</code>的“合并奖励结果”部分加入一条</p>
<p><code>userRewardService.buildLoginReward(req, resp, activityDto);</code></p>
</li>
</ul>
<h3 id="语法学习记录"><a href="#语法学习记录" class="headerlink" title="语法学习记录"></a>语法学习记录</h3><ul>
<li><p>java8使用stream().filter()来过滤list对象（查找符合条件的对象集合）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匹配来源配置相同的！因为来源配置保证不重复，因此只会取出一个对象</span></span><br><span class="line"><span class="type">SourceConfigDTO</span> <span class="variable">sourceConfigDTO</span> <span class="operator">=</span> extraConfigDto.getSourceConfigList().stream()</span><br><span class="line">    .filter(sourceConfig -&gt; request.getLoginSource().equals(sourceConfig.getUserSource()))</span><br><span class="line">    .findAny().orElse(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Projects</category>
        <category>MeiTuan</category>
      </categories>
      <tags>
        <tag>MeiTuan</tag>
        <tag>Projects</tag>
      </tags>
  </entry>
  <entry>
    <title>Advanced topics in electrical and electronic engineering</title>
    <url>/2022/05/19/ELEC7078/</url>
    <content><![CDATA[<p>Hong Kong University 2022 summer semester class review —— ELEC7078 Advanced topics in electrical and electronic engineering</p>
<span id="more"></span>



<h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h3><h4 id="1-1-Distributed-System"><a href="#1-1-Distributed-System" class="headerlink" title="1.1 Distributed System"></a>1.1 Distributed System</h4><ul>
<li>A distributed system is defined as a collection of autonomous computers linked by a network with software designed to produce an integrated computing facility.</li>
<li>A distributed system is a collection of independent computers that appear to the system as a single computer.</li>
<li>Distributed System &#x3D; Collection of computers + Communication Network + Transparency</li>
</ul>
<img src="https://pic.imgdb.cn/item/628532c40947543129f036da.jpg" style="zoom: 50%;" />

<h4 id="1-2-Advantages-of-Distributed-Systems"><a href="#1-2-Advantages-of-Distributed-Systems" class="headerlink" title="1.2 Advantages of Distributed Systems"></a>1.2 Advantages of Distributed Systems</h4><ul>
<li>Price&#x2F;performance<ul>
<li>A cost-effective way to build larger system is to use a larger number of cheap CPUs.</li>
</ul>
</li>
<li>Nature of some applications<ul>
<li>Some applications are inherently distributed (e.g. banking and supermarket chain).</li>
</ul>
</li>
<li>Reliability<ul>
<li>If one machine crashes, the system as a whole can still survive.</li>
</ul>
</li>
<li>Incremental growth    <ul>
<li>Computing power can be added in small increments.</li>
</ul>
</li>
<li>Data sharing<ul>
<li>It allows many users access to a common database;</li>
</ul>
</li>
<li>Device sharing<ul>
<li>It allows many users to share expensive peripherals;</li>
</ul>
</li>
<li>Communication<ul>
<li>It provides communication facilities;</li>
</ul>
</li>
<li>Flexibility    <ul>
<li>It spreads the workload over the available machines in the most cost-effective way.</li>
</ul>
</li>
</ul>
<h4 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise(1)"></a>Exercise(1)</h4><p><strong>Give five types of hardware resource and five types of data or software resource that can usefully be shared. Give examples of their sharing as it occurs in practice in distributed systems.</strong></p>
<img src="https://pic.imgdb.cn/item/628a1c7c0947543129184fe0.jpg" style="zoom: 80%;" />

<img src="https://pic.imgdb.cn/item/628a1caf09475431291872b1.jpg" style="zoom:80%;" />





<h4 id="1-3-Characteristics"><a href="#1-3-Characteristics" class="headerlink" title="1.3 Characteristics"></a>1.3 Characteristics</h4><p><strong>Resource Sharing</strong></p>
<ul>
<li>What to share?<ul>
<li>Hardware devicesData</li>
</ul>
</li>
<li>How to share?<ul>
<li>Resources are stored in workstations and can be accessed via communications by a resource manager</li>
</ul>
</li>
<li>Resource Manager<ul>
<li>A program that offers a communication interface enabling the resource to be accessed, manipulated and updated reliably and consistently.</li>
</ul>
</li>
</ul>
<img src="https://pic.imgdb.cn/item/628533b60947543129f0a7a2.jpg" style="zoom:80%;" />

<p><strong>Openness</strong></p>
<ul>
<li>Characteristic that determines whether the system can be extended in various ways</li>
<li>Hardware: Additional peripherals, memory or communication interfaces;</li>
<li>Software: Additional operating system features, communication protocols and resource-sharing services.</li>
</ul>
<p><strong>Concurrency</strong></p>
<ul>
<li>In a distributed system with M computers (cores) , up to M processes can be executed in parallel.</li>
<li>Parallel executions occur for two reasons:<ul>
<li>More than one users simultaneously invoke commands or interact with application programs</li>
<li>Many server processes run concurrently, each responding to different requests from client processes.</li>
</ul>
</li>
</ul>
<p><strong>Scalability</strong></p>
<ul>
<li>DS can be existed in different scale:</li>
<li>The smallest: 2 workstations + 1 file server</li>
<li>Local area network (LAN): <ul>
<li>hundreds workstations </li>
<li>Several file servers</li>
<li>Print servers</li>
</ul>
</li>
<li>Internetwork:<ul>
<li>Several LANS interconnected</li>
</ul>
</li>
</ul>
<p><strong>Fault Tolerance</strong></p>
<ul>
<li>The design of fault-tolerant computer systems is based on:<ul>
<li>Hardware redundancy: the use of redundant components</li>
<li>Software recovery: the design of programs to tolerate (process group) or recover from faults</li>
</ul>
</li>
</ul>
<p><strong>Transparency</strong></p>
<ul>
<li>Hidden from the user (application) programmer of separation of components;</li>
<li>Achieve a single system image to make everyone into thinking that the collection of machines is simply an old-fashioned time-sharing system.</li>
<li>Access transparency <ul>
<li>Enable local and remote information to be accessed using identical operations.</li>
</ul>
</li>
<li>Location transparency <ul>
<li>Enable the information objects to be accessed without knowledge of their location (users need not tell where resources are located).</li>
</ul>
</li>
<li>Concurrency transparency <ul>
<li>Enable several processes to operate concurrently using shared information objects without interference (multiple users can share resources automatically).</li>
</ul>
</li>
<li>Replication transparency <ul>
<li>Enable multiple replicas to be used to increase reliability and performance without user knowledge of how many replicas exist.</li>
</ul>
</li>
<li>Failure transparency <ul>
<li>Enable concealment of faults, allowing users to complete their tasks despite the failure of hardware or software components.</li>
</ul>
</li>
<li>Migration transparency <ul>
<li>Allow information objects move within a system without changing their name or affecting users.</li>
</ul>
</li>
<li>Performance transparency <ul>
<li>Allow the system to be configured to improve performance as loads vary.</li>
</ul>
</li>
<li>Scaling transparency <ul>
<li>Allow the system and applications to expand in scale without change to the system structure or the application algorithms.</li>
</ul>
</li>
<li>Parallelism transparency <ul>
<li>Allow the program to be executed in parallel without users knowledge.</li>
</ul>
</li>
</ul>
<h4 id="1-4-User-Requirements"><a href="#1-4-User-Requirements" class="headerlink" title="1.4 User Requirements"></a>1.4 User Requirements</h4><p><strong>Functionality</strong></p>
<p>A distributed system should bring an improvement over the services provided by any single computer through enhancements of:</p>
<ul>
<li>Sharing across a network can bring access to a richer variety of resources.</li>
<li>Parallel and Fault-tolerant applications.</li>
</ul>
<p>How to migrate a multi-user centralized computing to distributed computing? </p>
<ul>
<li>Adapt existing operating systems<ul>
<li>Continue to use existing operating system software that has been adapted for networking.</li>
<li>e.g. add servers to UNIX or Sun Network File System.</li>
</ul>
</li>
<li>Move to an entirely new operating system designed specifically for distributed system.<ul>
<li>Existing software becomes unusable.</li>
</ul>
</li>
<li>Emulation<ul>
<li>Move to a new OS designed for DS which can emulate one or more existing OS.</li>
<li>Existing and new distribution software can run side-by-side.</li>
</ul>
</li>
</ul>
<p><strong>Re-configurability</strong></p>
<ul>
<li>Short-term<ul>
<li>A failed process, computer or network component is replaced by another, working counterpart.</li>
<li>Overload is shifted from over-loaded to less-loaded machines to increase the total throughput of the DS.</li>
<li>To reduce network communications, data are moved from a machines to the others to make the data accessible.</li>
</ul>
</li>
<li>Medium&#x2F;long term evolution<ul>
<li>To accommodate heterogeneous components and assign new task or to upgrade the existing machines.</li>
</ul>
</li>
</ul>
<p><strong>Quality of Service</strong></p>
<ul>
<li>Performance<ul>
<li>Speed up the response of software components in a distributed system;</li>
</ul>
</li>
<li>Reliability and availability<ul>
<li>Fault-tolerance;</li>
</ul>
</li>
<li>Security<ul>
<li>Apply a reasonable degree of security applied to the data stored and transmitted with a distributed system.</li>
</ul>
</li>
</ul>
<h4 id="1-5-Basic-Design-Issues"><a href="#1-5-Basic-Design-Issues" class="headerlink" title="1.5 Basic Design Issues"></a>1.5 Basic Design Issues</h4><ul>
<li>Naming<ul>
<li>Name resources or objects in order to access them.</li>
</ul>
</li>
<li>Communication<ul>
<li>Optimize the communication implementations in distributed systems while retaining a high level programming model for its use.</li>
</ul>
</li>
<li>Software structure<ul>
<li>Define interface and good abstraction of data and services.</li>
</ul>
</li>
<li>Workload allocation<ul>
<li>Deploy computers and communications to achieve optimum performance and use of resources.</li>
</ul>
</li>
<li>Consistency maintenance<ul>
<li>How to balance consistency &amp; performance?</li>
</ul>
</li>
<li>Security<ul>
<li>How to secure message transfer in a distributed system?</li>
</ul>
</li>
</ul>
<h4 id="Exercise-2-3"><a href="#Exercise-2-3" class="headerlink" title="Exercise(2)(3)"></a>Exercise(2)(3)</h4><p><strong>List the three main software components that may fail when a client process invokes a method in a server object, giving an example of a failure in each case. To what extent are these failures independent of one another?</strong> </p>
<p>The three main software components that may fail are:</p>
<ul>
<li>the client process e.g. it may crash</li>
<li>the server process e.g. the process may crash</li>
<li>the communication software e.g. a message may fail to arrive</li>
</ul>
<p>The failures are generally caused independently of one another. Examples of dependent failures:</p>
<ul>
<li>if the loss of a message causes the client or server process to crash. (The crashing of a server would cause a client to perceive that a reply message is missing and might indirectly cause it to fail).</li>
<li>if clients crashing cause servers problems.</li>
<li>if the crash of a process causes a failures in the communication software.</li>
</ul>
<p><strong>Suggest how the components can be made to tolerate one another’s failures.</strong> </p>
<p>Both processes should be able to tolerate missing messages. </p>
<ul>
<li>The client must tolerate a missing reply message after it has sent an invocation request message. Instead of making the user wait forever for the reply, a client process could use a timeout and then tell the user it has not been able to contact the server.</li>
<li>A simple server just waits for request messages, executes invocations and sends replies. It should be absolutely immune to lost messages. But if a server stores information about its clients it might eventually fail if clients crash without informing the server (so that it can remove redundant information). </li>
<li>The communication software should be designed to tolerate crashes in the communicating processes.</li>
</ul>
<p>For example, the failure of one process should not cause problems in the communication between the surviving<br>processes.</p>
<p><strong>Compare and contrast cloud computing with more traditional client server computing, what is novel about cloud computing as a concept?</strong></p>
<p>Hardware: </p>
<ul>
<li>CPU: compute server (executes processor-intensive applications for clients), remote object server (executes methods on behalf of clients), worm program (shares cpu capacity of desktop machine with the local user). Most other servers, such as file servers, do some computation for their clients, hence their cpu is a shared resource. </li>
<li>memory: cache server (holds recently-accessed web pages in its RAM, for faster access by other local computers) </li>
<li>disk: file server, virtual disk server (see Chapter 8), video on demand server (see Chapter 15). </li>
<li>screen: Network window systems, such as X-11, allow processes in remote computers to update the content of windows. </li>
<li>printer: networked printers accept print jobs from many computers. managing them with a queuing system. </li>
<li>network capacity: packet transmission enables many simultaneous communication channels (streams of data) to be transmitted on the same circuits.</li>
</ul>
<p>Data&#x2F;software: </p>
<ul>
<li>web page: web servers enable multiple clients to share read-only page content (usually stored in a file, but sometimes generated on-the-fly). </li>
<li>file: file servers enable multiple clients to share read-write files. Conflicting updates may result in inconsistent results. Most useful for files that change infrequently, such as software binaries. </li>
<li>object: possibilities for software objects are limitless. E.g. shared whiteboard, shared diary, room booking system, etc</li>
<li>database: databases are intended to record the definitive state of some related sets of data. They have been shared ever since multi-user computers appeared. They include techniques to manage concurrent updates. </li>
<li>newsgroup content: The netnews system makes read-only copies of the recently-posted news items available to clients throughout the Internet. A copy of newsgroup content is maintained at each netnews server that is an approximate replica of those at other servers. Each server makes its data available to multiple clients. </li>
<li>video&#x2F;audio stream: Servers can store entire videos on disk and deliver them at playback speed to multiple clients simultaneously. </li>
<li>exclusive lock: a system-level object provided by a lock server, enabling several clients to coordinate their use of a resource (such as printer that does not include a queuing scheme).Distributed</li>
</ul>
<h3 id="2-Inter-process-Communication"><a href="#2-Inter-process-Communication" class="headerlink" title="2. Inter-process  Communication"></a>2. Inter-process  Communication</h3><p>进程间通信IPC</p>
<p><strong>Why we need Inter-process Communication (IPC)?</strong></p>
<ul>
<li>The components of a distributed system are <u>both logically and physically separated</u></li>
<li>They must communicate in order to interact.</li>
</ul>
<img src="https://pic.imgdb.cn/item/628537cb0947543129f29b82.jpg" style="zoom:67%;" />

<h4 id="2-1-Communication-Patterns"><a href="#2-1-Communication-Patterns" class="headerlink" title="2.1 Communication Patterns"></a>2.1 Communication Patterns</h4><ul>
<li><p>Client-server communication </p>
<ul>
<li>request and reply messages provide the basis for communication between clients and servers.</li>
<li>The idea of the model is to structure the distributed systems as a group of cooperating processes, i.e. the servers, that offer services to the users, namely, the clients.</li>
</ul>
<img src="C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20220519024605386.png" alt="image-20220519024605386" style="zoom:67%;" />
</li>
<li><p>Group communication</p>
<ul>
<li><p>some messages are sent to several processes in a group.</p>
</li>
<li><p>Applications are composed of large numbers of peer processes running on separate computers and the pattern of communication between them depends entirely on application requirements.</p>
<img src="https://pic.imgdb.cn/item/62853f710947543129f5f028.jpg" style="zoom: 50%;" /></li>
</ul>
</li>
</ul>
<h4 id="2-2-Data-Passing"><a href="#2-2-Data-Passing" class="headerlink" title="2.2 Data Passing"></a>2.2 Data Passing</h4><ul>
<li>For any two computers to exchange data value, we need to map data structures and data items to messages.</li>
<li>Data structure must be flattened before transmission and rebuilt on arrival.  (I.e., flattening of structured data into a sequence of basic data)</li>
<li>On receiving data stream, the data structure must be rebuilt.</li>
<li>Marshalling<ul>
<li>the process of taking a collection of data items and assembling them into a form suitable for transmission in a message;</li>
</ul>
</li>
<li>Unmarshalling<ul>
<li>the process of disassembling them on arrival to produce an equivalent collection of data items at the destination;</li>
</ul>
</li>
<li>Usually a language preprocessor (interface compiler) can be used to generate marshalling &#x2F; unmarshalling operations automatically.</li>
<li>When an IPC primitive is encountered involving data item of the above type, the preprocessor generates code to do the marshalling (for a send) or unmarshalling (for a receive) based on the type description.</li>
</ul>
<p><strong>JSON (JavaScript Object Notation)</strong></p>
<img src="https://pic.imgdb.cn/item/628540bd0947543129f678bf.jpg" style="zoom:67%;" />

<h4 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise"></a>Exercise</h4><p><strong>Describe and illustrate the client-server architecture of one or more major Internet applications</strong></p>
<p><strong>Web</strong></p>
<img src="https://pic.imgdb.cn/item/628a23fe09475431291dbee4.jpg" style="zoom:80%;" />

<p>Browsers are clients of Domain Name Servers (DNS) and web servers (HTTP). Some intranets are configured to interpose a Proxy server. Proxy servers fulfil several purposes – when they are located at the same site as the client, they reduce network delays and network traffic. When they are at the same site as the server, they form a security checkpoint (see pp. 107 and 271) and they can reduce load on the server. </p>
<p>N.B. DNS servers are also involved in all of the application architectures described below, but they ore omitted from the discussion for clarity</p>
<p><strong>Describe and illustrate the peer-to-peer architecture of one or more major Internet applications</strong></p>
<h4 id="2-3-Synchronization"><a href="#2-3-Synchronization" class="headerlink" title="2.3 Synchronization"></a>2.3 Synchronization</h4><p>同步</p>
<ul>
<li>A central issue in the communication structure;</li>
<li>2 types of operations<ul>
<li>Blocking: the invocation blocks the execution of its invoker.</li>
<li>Non-blocking: the invocation does not block the execution of its invoker.</li>
</ul>
</li>
</ul>
<p><strong>Blocking</strong></p>
<p>阻塞</p>
<ul>
<li><p>Blocking Send</p>
<ul>
<li>Issuing process blocks (i.e., control is not passed back) until the message has been sent and received.</li>
</ul>
</li>
<li><p>Blocking Receive</p>
<ul>
<li>Issuing process blocks until a message has arrived and passed to the process.</li>
</ul>
<img src="https://pic.imgdb.cn/item/6285420d0947543129f6f1cc.jpg" style="zoom: 67%;" /></li>
</ul>
<h5 id="Blocking-vs-Non-blocking"><a href="#Blocking-vs-Non-blocking" class="headerlink" title="Blocking vs. Non-blocking"></a>Blocking vs. Non-blocking</h5><p><strong>Non-blocking</strong></p>
<ul>
<li><p>Non-blocking send</p>
<ul>
<li>Issuing process continues (i.e. control is passed back) execution after the message has been copied out of the process’s environment.</li>
</ul>
</li>
<li><p>Non-blocking receive</p>
<ul>
<li>Issuing process continues if there is no message waiting to be received. Receiver process will have to be notified later on message arrival, either by polling or interrupt mechanism.</li>
</ul>
<img src="C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20220519030126394.png" alt="image-20220519030126394" style="zoom: 67%;" /></li>
</ul>
<h5 id="Synchronous-vs-Asynchronous-Communication"><a href="#Synchronous-vs-Asynchronous-Communication" class="headerlink" title="Synchronous vs. Asynchronous Communication"></a>Synchronous vs. Asynchronous Communication</h5><ul>
<li>Drawback: Can lead to inefficiency due to waiting<ul>
<li>high overhead and less efficiency.</li>
</ul>
</li>
<li>Solution: time-out<ul>
<li>Receive (A, msg, TO);<ul>
<li>If a message is not arrived in TO seconds, the process will be unblocked (and the receive operation aborted).</li>
</ul>
</li>
<li>Send (B, msg, TO)<ul>
<li>Sender blocks and if the message is not received in TO seconds, the process will be unblocked.</li>
</ul>
</li>
</ul>
</li>
<li>Synchronous communication<ul>
<li>Blocking send and blocking receive;</li>
<li>Sender and receiver synchronize at point of message transfer.</li>
<li>Advantage: <ul>
<li>Can make definite assumptions on message send and receipt </li>
<li>Easy design and control of the distributed processes</li>
</ul>
</li>
</ul>
</li>
<li>Asynchronous communication<ul>
<li>Sender and receiver do not synchronize at message transfer.</li>
<li>Non-blocking send + non-blocking receive;</li>
<li>Non-blocking send + blocking receive (usual combination);</li>
</ul>
</li>
<li>More flexible and potentially more parallelism;</li>
<li>Less assumption can be said about sending and receiving - more difficult to verify program properties.</li>
<li>Non-blocking send requires buffering of messages.</li>
</ul>
<h4 id="2-4-Implementation"><a href="#2-4-Implementation" class="headerlink" title="2.4 Implementation"></a>2.4 Implementation</h4><p><strong>Process Location</strong></p>
<ul>
<li><p>A port is a location independent identifier which can be mapped into low-level address in order to deliver message.</p>
</li>
<li><p>In TCP&#x2F;IP, message destination addresses are Port number (used by the process) and Internet address of the computer (the process resides on), </p>
<ul>
<li>Send (portB, msg); </li>
<li>Receive(portB, msg);</li>
</ul>
<img src="https://pic.imgdb.cn/item/6285473f0947543129f8ece7.jpg" style="zoom:50%;" /></li>
</ul>
<p><strong>Unreliable vs. Reliable Messages</strong></p>
<ul>
<li>Unreliable message is used to refer to a single message transmitted from sender to receiver, without acknowledgement or retries. <ul>
<li>e.g. UDP only makes its “best effort” to deliver a message.</li>
</ul>
</li>
<li>Reliable message delivery may be constructed from an unreliable one by using acknowledgement.<ul>
<li>Positive ack: receivers send ack message whenever a message is received.</li>
<li>Negative ack: Receivers do not send ack message until something wrong (timeout or receiving any incorrect message).</li>
</ul>
</li>
</ul>
<p><strong>Client-Server Communication Protocol</strong></p>
<ul>
<li><p>Client-server model uses request-reply communication.</p>
<ul>
<li>Request-reply is normally synchronous because a client will wait for the reply.</li>
<li>Request-reply can be asynchronous in case that the client can afford to retrieve replies later.</li>
</ul>
<img src="https://pic.imgdb.cn/item/628549210947543129f97a72.jpg" style="zoom:67%;" />
</li>
<li><p>Communication failures</p>
<ul>
<li><u>Loss of request message</u>: communication link fails &#x2F; network switch fails &#x2F; receiver’s node is down.</li>
<li><u>Loss of reply message</u>: communication link fails &#x2F; network switch fails &#x2F; sender’s node is down.</li>
<li><u>Unsuccessful execution of the request</u>: server crashes while executing the request.</li>
</ul>
</li>
<li><p>In the presence of communication failures three protocols are used for implementing various type of client-server communication.</p>
</li>
<li><p>The <strong>request (R)</strong> protocol</p>
<ul>
<li>Client issues a Send (server-id, request) and continues. It is suitable for cases in which there is no reply required from the server and that the client requires no confirmation that the request has been carried out.</li>
</ul>
<img src="https://pic.imgdb.cn/item/628549930947543129f9a33f.jpg" style="zoom:50%;" />
</li>
<li><p>The <strong>request-reply (RR)</strong> protocol</p>
<ul>
<li>Most commonly used; </li>
<li>The reply message from the server also acts as acknowledgment to the original request message.</li>
<li>A subsequent request from the client may be regarded as an acknowledgment of the server’s message.</li>
</ul>
<img src="https://pic.imgdb.cn/item/628549e40947543129f9b76d.jpg" style="zoom: 50%;" />
</li>
<li><p>The <strong>request-reply-acknowledge reply (RRA)</strong> protocol</p>
<ul>
<li>An acknowledgement will be sent back to the server after received the reply</li>
<li>The ack includes the request-Id and acknowledges all request messages up to that request-Id.</li>
<li>Although the exchange involves an additional message, it need not block the client as the acknowledgement may be transmitted after the reply has been given to the client, but it does use processing and network resources.</li>
</ul>
<img src="https://pic.imgdb.cn/item/62854a230947543129f9c86c.jpg" style="zoom:50%;" /></li>
</ul>
<h4 id="2-5-Other-Issues"><a href="#2-5-Other-Issues" class="headerlink" title="2.5 Other Issues"></a>2.5 Other Issues</h4><ul>
<li><p><strong>Time-out</strong> </p>
<ul>
<li><p>occur when a request message is lost or the network becomes partitioned, or the server is overloaded (and hence slow); or the reply message is lost.</p>
</li>
<li><p>DoOperation repeats sending the request message N times (time-outs) before reporting failure.</p>
</li>
<li><p>It is impossible to distinguish between a process failure and a communication failure. When process does not reply after some agreed number, N of attempts to communicate with it, it is assumed to be unavailable. </p>
</li>
<li><p>The choice of N is difficult (?).</p>
</li>
</ul>
</li>
<li><p><strong>Duplicated request messages</strong></p>
<ul>
<li>Occur when request message is retransmitted (on time-outs).</li>
<li>Duplicates can be detected using Request-Id (like a sequence number) and discarded.</li>
</ul>
</li>
<li><p><strong>Lost reply messages</strong></p>
<ul>
<li>If the server has already sent the reply message, it may need to execute the request again to obtain the result. Re-executing is only possible for idempotent operation.</li>
</ul>
</li>
<li><p>An <u>idempotent operation</u>（幂等运算） is an operation that <u>can be performed repeatedly with the same effect</u> as if it had been performed exactly once.</p>
</li>
<li><p>If server operation is not idempotent a record of past results (called history) can be kept. History can be kept from growing too large by using the RAA protocol, or discarding results which have passed a certain time limit.</p>
</li>
<li><p>Multipacket  messages</p>
<ul>
<li>Datagram with limited length (often as 8 kbytes).</li>
<li>Not enough if a request or reply is too large.</li>
<li>Solution with multipacket: a message made up of a sequence of datagrams.</li>
<li>Drawbacks: complicated in design and control (receive in sequence), low efficiency in retransmission.</li>
</ul>
</li>
</ul>
<h3 id="3-Time-in-Distributed-Systems"><a href="#3-Time-in-Distributed-Systems" class="headerlink" title="3. Time in Distributed Systems"></a>3. Time in Distributed Systems</h3><p>Time is an important and interesting issue in distributed systems because</p>
<ul>
<li>Internal (computer-to-computer) and external (computer-to-external)  synchronization;</li>
<li>Many algorithms depend upon clock synchronization, e.g. transaction.</li>
</ul>
<h4 id="3-1-Synchronizing-Physical-Clocks"><a href="#3-1-Synchronizing-Physical-Clocks" class="headerlink" title="3.1 Synchronizing Physical Clocks"></a>3.1 Synchronizing Physical Clocks</h4><ul>
<li>Physical clocks</li>
<li>Electronic devices that count oscillations occurring in a crystal at a definite frequency. </li>
<li>It is useful for keeping accurate time and time-stamping events, e.g., time in accounting records of connection. </li>
<li><u>Event is an action that appears to occur indivisibly（不可分割地）.</u></li>
<li><strong>Sources of accurate timing signals:</strong> <ul>
<li>coordinated universal time (UTC)</li>
<li>Radio broadcast accuracy: 0.1 - 10 ms Satellite (Geostationary Operational Environment Satellite GOES) accuracy: 1 ms</li>
<li>Satellite (Global Positional System GPS) accuracy: 0.1 ms</li>
</ul>
</li>
<li><strong>Difficulties in distributed systems</strong><ul>
<li><u>Not all sites have direct access to accurate time sources</u> such as GPS receivers.</li>
<li>Sites have to synchronize their local clocks with those have more accurate time. </li>
<li>Synchronization needs to be done periodically due to clock drift: they count time at different rates, and so diverge.（需要周期性同步）</li>
</ul>
</li>
</ul>
<h5 id="Cristian’s-method"><a href="#Cristian’s-method" class="headerlink" title="Cristian’s method"></a>Cristian’s method</h5><p>A central time server process S supplies the time according to its clock upon request.</p>
<img src="https://pic.imgdb.cn/item/62854d0d0947543129fa8e50.jpg" style="zoom:67%;" />

<img src="https://pic.imgdb.cn/item/62854d320947543129fa976c.jpg" style="zoom:67%;" />

<ul>
<li>If a process P requests the time in a message m<sub>r</sub>, and receives the time value t  in a message m<sub>t</sub>, then it could set its clock to the time t + T<sub>trans</sub>, where T<sub>trans</sub> is the time taken to transmit m<sub>t</sub> from the server S to P.</li>
<li>T<sub>trans</sub> can be variant. We may say, T<sub>trans</sub> &#x3D; min + x, where x &#x3D; 0 and min is the time of message transmission if no other processes and no other messages. </li>
<li>min can be measured or conservatively estimated but x is still unknown!</li>
</ul>
<img src="https://pic.imgdb.cn/item/62865cdb0947543129c30757.jpg" style="zoom:67%;" />

<img src="https://pic.imgdb.cn/item/62865cf60947543129c3131e.jpg" style="zoom:67%;" />

<ul>
<li>Let T<sub>round</sub> be the total round trip time to send the request m<sub>r</sub> and receive the reply m<sub>t</sub>, then <strong>P should estimate its clock as t + T<sub>round</sub> &#x2F; 2</strong> (T<sub>round</sub> can be measured or conservatively estimated ).</li>
<li><strong>The accuracy is ±(T<sub>round</sub> &#x2F; 2 - min).</strong></li>
<li>Problem: single-server failure.</li>
<li>Solution: group synchronization time server.</li>
</ul>
<img src="https://pic.imgdb.cn/item/628660320947543129c4717a.jpg" style="zoom:67%;" />

<h5 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise"></a>Exercise</h5><p>Consider a host using Cristian’s method to synchronize its clock with a time server T and got the following records. Assume the total delay of transmitting a message from the host to the time server or vice versa is 10ms.</p>
<img src="https://pic.imgdb.cn/item/6286622c0947543129c52ac0.jpg" style="zoom:80%;" />

<ul>
<li><p>Which of these times should be used to set its clock?  To what time should it set? Estimate the accuracy of the setting.</p>
<p><strong>The message with minimal delay should be chosen, which is message 2 — 24ms (14:22:10.564)</strong></p>
<p><strong>Time&#x3D;14:22:10.564+12ms&#x3D;14:22:10.576</strong></p>
<p><strong>Accuracy: 12-min&#x3D;+&#x2F;- 2ms</strong></p>
</li>
<li><p>What will the answer of part (a) change if the total delay is 9ms?</p>
<p><strong>Time&#x3D;No change</strong></p>
<p><strong>Accuracy: +&#x2F;-3ms</strong></p>
</li>
<li><p>If it is required to synchronize the host’s to within +&#x2F;- 1 ms. Discuss how to achieve it. Assume 9ms total delay is used</p>
<p><strong>Keep synchronize until the round-trip is 20ms</strong></p>
</li>
</ul>
<h5 id="The-Berkeley-algorithm"><a href="#The-Berkeley-algorithm" class="headerlink" title="The Berkeley algorithm"></a>The Berkeley algorithm</h5><ul>
<li><p>An algorithm for internal synchronization in BSD UNIX.</p>
</li>
<li><p>(Unlike Cristian’s) In a group sites, <u>one is chosen as coordinator (master)</u>. It periodically polls the other sites (slaves) to synchronize their clocks.</p>
</li>
<li><p>Master estimates the slaves’ clock times by observing round trip time (like Cristian’s). It averages the time obtained (including its own).</p>
</li>
<li><p>The average (with probabilities) can cancel out individual clock’s run fast or slow.</p>
</li>
<li><p>Accuracy depends on round-trip time between master and slaves.</p>
</li>
<li><p>Master sends time rate adjust value (+ or -) to slaves, requesting them to adjust their time rates.</p>
</li>
<li><p>Master takes fault-tolerant average.</p>
</li>
</ul>
<img src="https://pic.imgdb.cn/item/628665af0947543129c6a016.jpg" style="zoom:67%;" />

<h5 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise"></a>Exercise</h5><p>A group of servers using Berkeley algorithm to synchronize their physical clocks.  The coordinator received the following replies:</p>
<img src="https://pic.imgdb.cn/item/628668a60947543129c7f470.jpg" style="zoom: 80%;" />

<ul>
<li><p>What is the clock difference between the coordinator and members?  Give the answer with respect to the coordinator.</p>
<img src="https://pic.imgdb.cn/item/628669090947543129c81cdc.jpg" style="zoom:80%;" />
</li>
<li><p>Draft the messages to be sent to each member and what should the member do after receiving the message?</p>
<img src="https://pic.imgdb.cn/item/62866b140947543129c8e8d4.jpg" style="zoom:80%;" />
</li>
<li><p>What if the clock of member C is running faster than the coordinator by 100ms? What is the potential problem of setting the clock value immediately based on the new adjustment?</p>
</li>
</ul>
<img src="https://pic.imgdb.cn/item/62866d7b0947543129c9d862.jpg" style="zoom:80%;" />

<h5 id="Network-Time-Protocol-NTP"><a href="#Network-Time-Protocol-NTP" class="headerlink" title="Network Time Protocol (NTP)"></a>Network Time Protocol (NTP)</h5><ul>
<li>A standard for clock synchronization throughout the Internet</li>
<li>Design aims and features<ul>
<li>To provide a service enabling clients across the Internet to be synchronized accurately to UTC;<ul>
<li>Employs statistical techniques for the filtering of timing data and it discriminates between the quality of timing data from different servers</li>
</ul>
</li>
<li>To provide a reliable service to losses of connectivity;<ul>
<li>Redundant servers and paths</li>
</ul>
</li>
<li>To enable clients to resynchronize sufficiently frequently;<ul>
<li>Scale to large numbers of client and servers</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="https://pic.imgdb.cn/item/628671f10947543129cc387c.jpg" style="zoom: 67%;" />

<ul>
<li>NTP server synchronize - UDP<ul>
<li>Multicast mode <ul>
<li>high speed LAN</li>
<li>Multicast periodically</li>
</ul>
</li>
<li>Procedure call mode<ul>
<li>Similar to the operation of Cristian’s algorithm</li>
<li>More accurate than multicast mode</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-2-Casual-Ordering-Happens-before"><a href="#3-2-Casual-Ordering-Happens-before" class="headerlink" title="3.2 Casual Ordering (Happens-before)"></a>3.2 Casual Ordering (Happens-before)</h4><p>Causal ordering</p>
<ul>
<li>x &lt;  y <ul>
<li>x and y are different events of the same process and x occurs before y</li>
</ul>
</li>
<li>s  &lt;  r<ul>
<li>s is a send event and r is the corresponding receive event</li>
</ul>
</li>
<li>y &lt; r <ul>
<li>y&lt;s and s&lt;r</li>
</ul>
</li>
</ul>
<p>Happen before: if  a &lt; b</p>
<img src="https://pic.imgdb.cn/item/6286761f0947543129cd9c26.jpg" style="zoom: 67%;" />

<img src="https://pic.imgdb.cn/item/6286763d0947543129cda652.jpg" style="zoom: 50%;" />

<ul>
<li><p>a &#x3D;&gt; b, b &#x3D;&gt; c, c &#x3D;&gt; d, d &#x3D;&gt; f  &#x3D;&#x3D;&#x3D;&gt; a &#x3D;&gt; f.</p>
<ul>
<li>a and e that are not ordered by &#x3D;&gt; are concurrent（并行的）, and write this a||e.</li>
<li>Logical clock can capture happened-before relation.</li>
<li>It is a monotonically increasing software counter, whose value need bear no particular relationship to any physical clock.</li>
</ul>
</li>
<li><p>Causal Order : If a &#x3D;&gt; b then a &lt; b</p>
<ul>
<li>a and b are causally related if  a &#x3D;&gt; b  or b &#x3D;&gt; a</li>
<li>a and b are independent if not a &#x3D;&gt; b  and not b &#x3D;&gt; a</li>
</ul>
</li>
</ul>
<h4 id="3-3-Logical-Time-x2F-Virtual-Time-x2F-Logical-Clock"><a href="#3-3-Logical-Time-x2F-Virtual-Time-x2F-Logical-Clock" class="headerlink" title="3.3 Logical Time &#x2F; Virtual Time &#x2F; Logical Clock"></a>3.3 Logical Time &#x2F; Virtual Time &#x2F; Logical Clock</h4><ul>
<li>Objective:<ul>
<li>Create virtual time without generating additional message</li>
</ul>
</li>
<li>Each entity x creates and maintains a logical clock C<sub>x</sub></li>
<li>For each event a occurring at x, C(a)&#x3D;C<sub>x</sub>(a)</li>
<li>Denote the timestamp of event a at p by C<sub>p</sub>(a) and the timestamp of event b at whatever process it occurred by C(b).</li>
</ul>
<p><strong>To capture the happened-before relation &#x3D;&gt;, we have the following rules:</strong></p>
<ul>
<li>LC1: <strong>C<sub>p</sub> is incremented before each event is issued at process p: C<sub>p</sub> :&#x3D; C<sub>p</sub> + 1.</strong></li>
<li>LC2:  When a process <strong>p</strong> sends a message <strong>m</strong>, it piggybacks on m the value <strong>t &#x3D; C<sub>p</sub></strong>.    On receiving (m,t), a process q computes <strong>C<sub>q</sub> :&#x3D; max(C<sub>q</sub>, t)</strong> and then applies LC1 before timestamping the event rcv(m).</li>
</ul>
<p>It guarantees a &#x3D;&gt; b     C(a) &lt; C(b).</p>
<img src="https://pic.imgdb.cn/item/628677750947543129ce0aa4.jpg" style="zoom:67%;" />

<img src="https://pic.imgdb.cn/item/628677950947543129ce179e.jpg" style="zoom:67%;" />

<p><strong>Logical Clock</strong></p>
<img src="https://pic.imgdb.cn/item/628678020947543129ce37c8.jpg" style="zoom: 67%;" />

<h4 id="3-4-Vector-Clock"><a href="#3-4-Vector-Clock" class="headerlink" title="3.4 Vector Clock"></a>3.4 Vector Clock</h4><img src="https://pic.imgdb.cn/item/628678730947543129ce5851.jpg" style="zoom:67%;" />

<ul>
<li><p>Each entity x<sub>i</sub> is equipped with a local integer counter C<sub>i</sub> and increment its value by 1 at the beginning of every event like logical clock</p>
</li>
<li><p>Each entity X<sub>i</sub> is equipped with a n-dimensional vector V<sub>i</sub> of values, one for each entity in the network. The value of V<sub>i</sub>[i] is equal to C<sub>i</sub></p>
</li>
<li><p>The value of V<sub>i</sub>[j], i≠j is initially 0 and change only when a message arrives of X<sub>i</sub></p>
</li>
<li><p>Whenever an entity X<sub>i</sub> sends a message to a neighbor X<sub>j</sub>, it encloses the message the vector of values V<sub>i</sub></p>
</li>
<li><p>Whenever an entity X<sub>j</sub> processes the arrival of a message with a vector vect of values, it updates its local vector V<sub>j</sub> as follows: for all i≠j, it sets V<sub>j</sub>[i]:&#x3D;max{vect[i],V<sub>j</sub>[i]}</p>
</li>
<li><p>Partial Order</p>
<ul>
<li>A ≤ B if A[i] ≤ B[i] for all indices i</li>
</ul>
</li>
<li><p>Complete Causal Order</p>
<ul>
<li>A &lt; B if and only if A ≤ B and A[i] &lt; B[i] for at least an index i e.g. [2,4,3] &lt;[3,4,3]</li>
</ul>
</li>
<li><p>Property </p>
<ul>
<li>For any two events a and b at Xi, Vi(a)&lt;Vi(b) if and only if t(a)&lt;t(b)</li>
<li>If a is a sending event and b is a receiving event, then Vi(a)&lt;Vi(b)</li>
<li>a → b , then V(a)&lt;V(b)</li>
<li>V(a)&lt;V(b), then a → b??</li>
</ul>
</li>
</ul>
<h4 id="3-5-Exercise"><a href="#3-5-Exercise" class="headerlink" title="3.5 Exercise"></a>3.5 Exercise</h4><p>Consider the following events :</p>
<img src="https://pic.imgdb.cn/item/628679e30947543129ced4a5.jpg" style="zoom:67%;" />

<ul>
<li><p><strong>Assume the initial logical clocks of all process is zero, what are the logical clock values of E1, E4, E5, E8, E9 and E11?</strong></p>
<img src="https://pic.imgdb.cn/item/62867a230947543129cee7cf.jpg" style="zoom:80%;" />
</li>
<li><p><strong>What are the causal orders of E5 and E8, E6 and E9, and E2 and E11?</strong></p>
<p>E5 || E8, E6 -&gt; E9, E2-&gt;E11</p>
</li>
<li><p><strong>Can we work out the causal order of E2 and E11 by their logical clocks?</strong></p>
<p>No, although the clock value of E11 (11) is greater than E2 (1), there is no guarantee that E2 is happen before E11 (even E2 is actually happened before E11).  Consider E2 and E4, the clock value of E4 is greater than E2 but E2 and E4 are not causally related.  </p>
</li>
<li><p><strong>What are the vector clocks of E2 and E11? Can we work out the causal order of E2 and E11 by based on the vector clocks?</strong></p>
</li>
</ul>
<img src="https://pic.imgdb.cn/item/62867a7d0947543129cf01bb.jpg" style="zoom: 80%;" />

<p>quiz:</p>
<img src="https://pic.imgdb.cn/item/6289dcd60947543129ec0c12.jpg" style="zoom:80%;" />



<h3 id="4-Distributed-Coordination"><a href="#4-Distributed-Coordination" class="headerlink" title="4. Distributed Coordination"></a>4. Distributed Coordination</h3><p>Wave and Traversal Algorithms</p>
<ul>
<li>Wave algorithms: Message passing schemes<ul>
<li>Broadcasting, synchronization and computing global functions</li>
</ul>
</li>
<li>Traversal algorithms: wave algorithms that the events of     <ul>
<li>computation are totally ordered by casuality</li>
</ul>
</li>
<li>Elementary tasks of most distributed algorithms<ul>
<li>Election, termination detection, mutual  exclusion</li>
</ul>
</li>
</ul>
<h4 id="4-1-Wave-Algorithms"><a href="#4-1-Wave-Algorithms" class="headerlink" title="4.1 Wave Algorithms"></a>4.1 Wave Algorithms</h4><ul>
<li><p>Distributed algorithms → collection of possible computations→ collection of events</p>
</li>
<li><p>Events are ordered partially (casual precedence relation)</p>
</li>
<li><p>A computation is a collection of events, partially ordered by the causal precedence relation</p>
</li>
<li><p>|C| &#x3D; number of events of computation C</p>
</li>
<li><p>C<sub>p</sub> &#x3D; event occur in process p</p>
</li>
<li><p>decide (event) &#x3D; internal event</p>
</li>
</ul>
<p>A wave algorithm exchanges a finite number of messages and then makes a decision</p>
<p><strong>Wave Algorithm Requirements</strong></p>
<img src="C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20220520011829964.png" alt="image-20220520011829964" style="zoom: 50%;" />

<ul>
<li><p>Initiators &#x2F; Starters</p>
<ul>
<li>Starts the execution of its local algorithm spontaneously i.e. triggered by some condition internal to the process</li>
<li>First event: internal&#x2F; send</li>
</ul>
</li>
<li><p>Non-initiators &#x2F; followers</p>
<ul>
<li>Become involved in the algorithm only when a message of the algorithm arrives and triggers the execution of the process algorithm</li>
<li>First event: receive</li>
</ul>
</li>
<li><p>Centralization vs Decentralized</p>
<ul>
<li>Centralized &#x2F; single source: Exactly one </li>
<li>Decentralized &#x2F; multi-source: initiator are subset of the process</li>
</ul>
</li>
<li><p>Topology : ring, tree, clique</p>
<img src="https://pic.imgdb.cn/item/62867c520947543129cfa2f6.jpg" style="zoom: 50%;" />
</li>
<li><p>Initial Knowledge </p>
<ul>
<li>Process identities : each process initially knows its own unique name</li>
<li>Neighbors’ identities: each process initially knows the name of its neighbors</li>
<li>Sense of direction</li>
<li>Number of decisions: number of process execute a decide event</li>
<li>Complexity: number of exchanged messages</li>
</ul>
</li>
</ul>
<p><strong>Application of Wave</strong></p>
<ul>
<li>Propagation of Information with feedback (PIF)<ul>
<li>Some information must be broadcast to all processes and certain processes must receive a notification of when the broadcast is complete</li>
</ul>
</li>
<li>Synchronization<ul>
<li>In each process q an event aq must be executed and in some processes an event bp must be executed, such that the execution of all aq events must have taken place temporally before any of the bp events is executed. In SYN algorithm the bp events will be considered as decide events.</li>
</ul>
</li>
<li>Computation of Infimum Function<ul>
<li>Function must be computed whose value depends essentially on the input of every process.</li>
</ul>
</li>
</ul>
<h4 id="4-2-Ring-Algorithm"><a href="#4-2-Ring-Algorithm" class="headerlink" title="4.2 Ring Algorithm"></a>4.2 Ring Algorithm</h4><img src="https://pic.imgdb.cn/item/6286817d0947543129d1df00.jpg" style="zoom: 50%;" />

<img src="https://pic.imgdb.cn/item/628681a10947543129d1e7f8.jpg" style="zoom: 50%;" />

<h4 id="4-3-Tree-Algorithm"><a href="#4-3-Tree-Algorithm" class="headerlink" title="4.3 Tree Algorithm"></a>4.3 Tree Algorithm</h4><ul>
<li>All leaves of the tree initiate the algorithm</li>
<li>If a process has received a message via each of its incident channels except one, the process sends a message via the remaining channel</li>
<li>Each process sends exactly one message in the algorithm</li>
<li>If a process has received a message via all of its incident channels it decides</li>
</ul>
<img src="https://pic.imgdb.cn/item/628682350947543129d2107f.jpg" style="zoom:67%;" />

<h4 id="4-4-Echo-Algorithm"><a href="#4-4-Echo-Algorithm" class="headerlink" title="4.4 Echo Algorithm"></a>4.4 Echo Algorithm</h4><p>回波算法</p>
<ul>
<li>Initiator sends messages to all its neighbors</li>
<li>Upon receipt of the first message a non-initiator forwards messages to all its neighbors except the one from which the message was received</li>
<li>When a non-initiator has received messages from all its neighbors an echo is sent to the father</li>
<li>When the initiator has received a message from all its neighbors it decides.</li>
</ul>
<img src="https://pic.imgdb.cn/item/628682c30947543129d23785.jpg" style="zoom: 50%;" />

<img src="https://pic.imgdb.cn/item/628682df0947543129d23e0e.jpg" style="zoom:50%;" />

<h4 id="4-5-Polling-Algorithm"><a href="#4-5-Polling-Algorithm" class="headerlink" title="4.5 Polling Algorithm"></a>4.5 Polling Algorithm</h4><p>轮询算法</p>
<p>A process can decide if it has received a message from each neighbor</p>
<img src="https://pic.imgdb.cn/item/628683030947543129d2470b.jpg" style="zoom: 67%;" />

<h4 id="4-6-Phase-Algorithm"><a href="#4-6-Phase-Algorithm" class="headerlink" title="4.6 Phase Algorithm"></a>4.6 Phase Algorithm</h4><ul>
<li><p>The phase algorithm can be used in arbitrary directed networks, where channels can carry messages in one direction only</p>
</li>
<li><p>In-neighbors: processes that can send message to the node</p>
</li>
<li><p>Out-neighbors: processes to which the node can send message</p>
</li>
<li><p>Diameter of the network must be known</p>
</li>
<li><p>In the phase algorithm, each process sends exactly D messages to each out-neighbors</p>
<img src="https://pic.imgdb.cn/item/6286836e0947543129d265dd.jpg" style="zoom:80%;" /></li>
</ul>
<h4 id="4-7-Traversal-Algorithms"><a href="#4-7-Traversal-Algorithms" class="headerlink" title="4.7 Traversal Algorithms"></a>4.7 Traversal Algorithms</h4><p>遍历算法</p>
<p>The traversal algorithms has the following properties:</p>
<ul>
<li>In each computation there is one initiator which starts the algorithm by sending out exactly one message</li>
<li>A process, upon receipt of a message, either sends out one message or decides</li>
<li>The algorithm terminates in the initiator and when this happens, each process has sent a message at least once</li>
</ul>
<p>The first two properties imply that in each finite computation exactly one process decides. The algorithm is said to terminate in the single process that decides</p>
<p><strong>Traversing Cliques: Sequential Polling Algorithm</strong></p>
<img src="https://pic.imgdb.cn/item/6286848f0947543129d2b2d7.jpg" style="zoom:67%;" />

<img src="https://pic.imgdb.cn/item/628685a20947543129d2f2eb.jpg" style="zoom:67%;" />

<p><strong>Traversing Connected Network: Tarry’s Algorithm</strong></p>
<ul>
<li>R1. A process never forwards the token twice through the same channel</li>
<li>R2. A non-initiator forwards the token to its father (the neighbor from which it first received the token) only if there is no other channel possible according to rule R1</li>
</ul>
<img src="https://pic.imgdb.cn/item/6286877e0947543129d36b31.jpg" style="zoom:50%;" />

<img src="https://pic.imgdb.cn/item/628687930947543129d37101.jpg" style="zoom:50%;" />

<img src="https://pic.imgdb.cn/item/628687ad0947543129d37796.jpg" style="zoom:50%;" />

<h3 id="5-Distributed-Mutual-Exclusion-and-Election"><a href="#5-Distributed-Mutual-Exclusion-and-Election" class="headerlink" title="5. Distributed Mutual Exclusion and Election"></a>5. Distributed Mutual Exclusion and Election</h3><p>分布式互斥与选举</p>
<h4 id="5-1-Distributed-Coordination"><a href="#5-1-Distributed-Coordination" class="headerlink" title="5.1 Distributed Coordination"></a>5.1 Distributed Coordination</h4><p>分布式协作</p>
<ul>
<li>Why do we need distributed coordination?<ul>
<li>To prevent interference and ensure consistency before accessing resources, e.g. NFS file system to share a common text file.</li>
</ul>
</li>
<li>Distributed Mutual Exclusion (DME)<ul>
<li>A single process being given a privilege - the right to access shared resources - temporarily before another process is granted it.</li>
</ul>
</li>
</ul>
<h4 id="5-2-Distributed-Mutual-Exclusion"><a href="#5-2-Distributed-Mutual-Exclusion" class="headerlink" title="5.2 Distributed Mutual Exclusion"></a>5.2 Distributed Mutual Exclusion</h4><p>分布式互斥</p>
<p>Basic requirements for DME concerning some resources:</p>
<ul>
<li><strong>ME1</strong>: (safety) At most one process may execute in the critical section (CS) at a time.</li>
<li><strong>ME2</strong>: (liveness and deadlock-free) A process requesting entry to the CS is eventually granted it (so long as any process executing in the CS eventually leaves it.)</li>
<li><strong>ME3</strong>: (ordering) Entry to the CS should be granted in happened-before order.</li>
</ul>
<p><strong>The central server algorithm: server manages a mutual exclusion token for a set of processes</strong></p>
<p>中央服务器算法:服务器为一组进程管理一个互斥令牌</p>
<img src="https://pic.imgdb.cn/item/62868b390947543129d456f8.jpg" style="zoom: 80%;" />

<ul>
<li><p>To employ a server that grants permission to enter a CS.</p>
</li>
<li><p>Assume only one CS is managed. The protocol is as follows:</p>
<img src="https://pic.imgdb.cn/item/62868b640947543129d479c1.jpg" style="zoom:67%;" />
</li>
<li><p>Satisfy ME1, ME2 and ME3.</p>
</li>
<li><p>Problem 1: the server could be performance bottleneck.</p>
</li>
<li><p>Problem 2: single point of failure.</p>
</li>
</ul>
<h5 id="5-2-1-DME-Ricart-and-Agrawala’s-algorithm"><a href="#5-2-1-DME-Ricart-and-Agrawala’s-algorithm" class="headerlink" title="5.2.1 DME: Ricart and Agrawala’s algorithm"></a>5.2.1 DME: Ricart and Agrawala’s algorithm</h5><ul>
<li><p>Based on distributed agreement;</p>
</li>
<li><p>No center server is required.</p>
</li>
<li><p>The basic idea is that processes that require entry to a critical section multicast a request message, and can enter it only when all the other processes have replied to this message. （需要进入临界区的进程多播请求消息，并且只有当所有其他进程都对该消息作出了响应时才能进入该消息）</p>
</li>
<li><p>Assumption: </p>
<ul>
<li>p<sub>1</sub>, …, p<sub>n</sub> know one another addresses. </li>
<li>All messages sent are eventually received and delivered</li>
<li>each pi keeps a logical clock, updated according to rules LC1 and LC2.</li>
</ul>
</li>
<li><p>Messages requesting the token are in the form &lt;T,pi&gt; where T is the sender timestamp and pi is the sender id.</p>
</li>
<li><p>Only one CS is concerned.</p>
</li>
<li><p>3 states: RELEASED, WANTED, HELD.</p>
</li>
</ul>
<img src="https://pic.imgdb.cn/item/62879abe09475431297389bb.jpg" style="zoom:67%;" />

<p>**Protocol: **</p>
<img src="https://pic.imgdb.cn/item/62879aea0947543129739c3d.jpg" style="zoom:67%;" />

<img src="https://pic.imgdb.cn/item/62879b0b094754312973acd7.jpg" style="zoom:67%;" />

<ul>
<li>Satisfy ME1, ME2 and ME3.</li>
<li>Protocol: to enter CS is associated with possession of a token.</li>
<li>Example: consider three processes p1, p2 and p3.<ul>
<li>p3 is not interested in the token.</li>
<li>p1 and p2 request it concurrently.</li>
<li>Timestamps of p1’ and p2’s requests are 41 and 34 respectively.</li>
<li>p3 replies all requests. p2 does not reply p1’s request since its timestamp is lower while p1 does.</li>
</ul>
</li>
</ul>
<h5 id="5-2-2-DME-Ring-based-Algorithm"><a href="#5-2-2-DME-Ring-based-Algorithm" class="headerlink" title="5.2.2 DME: Ring-based Algorithm"></a>5.2.2 DME: Ring-based Algorithm</h5><ul>
<li>One of the simple algorithm is to arrange the n processes into a logical ring.</li>
<li>There is a logical token circulate on the ring (say in clockwise direction).</li>
<li>If a process does not need to enter CS, it immediately forwards the token to its neighbor.</li>
</ul>
<img src="https://pic.imgdb.cn/item/62879bea0947543129741a70.jpg" style="zoom:67%;" />

<ul>
<li>A process wishes to enter the CS waits until it holds the token and retains it. </li>
<li>To leave the CS, the process releases the token to its neighbour. </li>
<li>If a process holding the token fails, an election is required to pick a unique process from the surviving members which regenerate the token and transmit it as before.</li>
<li>Care must be taken if the process is really failed. Two tokens may circulate on the ring!</li>
</ul>
<h5 id="5-2-3-Exercise"><a href="#5-2-3-Exercise" class="headerlink" title="5.2.3 Exercise"></a>5.2.3 Exercise</h5><p><strong>Discuss and compare the performance characteristics of two distributed mutual exclusion algorithms,</strong> </p>
<p><strong>(i) the central server algorithm</strong> </p>
<p><strong>(ii) the Ricard and Agrawala’s algorithm,</strong> </p>
<p><strong>in terms of message overheads, response time of requests, and reliability.</strong></p>
<img src="https://pic.imgdb.cn/item/62879ca40947543129747a28.jpg" style="zoom: 80%;" />



<p><strong>Message overheads</strong></p>
<p>For each token request:</p>
<ul>
<li>The central server algorithm: 3 messages (request, token, release)</li>
<li>The distributed algorithm: 2(N-1) messages.</li>
</ul>
<p>For N clients and all will access the CS</p>
<ul>
<li>The central server algorithm: 3N messages</li>
<li>The distributed algorithm: 2N(N-1) messages -&gt; 2N^2-2</li>
</ul>
<p><strong>Response Time:</strong></p>
<ul>
<li>In the central server algorithm, every token request from client requires two messages (request and grant). It waits for a round-trip message time to receive a reply from the server. </li>
<li>In the distributed algorithm using logical clocks, every token sends out (N-1) messages and waits for (N-1) replies. It waits for (N-1) servers.</li>
</ul>
<p>So, the response time of the central server algorithm is faster.</p>
<p><strong>Reliability:</strong></p>
<ul>
<li>The central server algorithm is more reliable since only the failure of the central server will make the system stop working.</li>
<li>For the distributed algorithm, any node failure will stop others from entering the critical section.</li>
</ul>
<h5 id="5-2-4-Exercise-2-quiz"><a href="#5-2-4-Exercise-2-quiz" class="headerlink" title="5.2.4 Exercise 2 (quiz)"></a>5.2.4 Exercise 2 (quiz)</h5><p><strong>The following system uses central server algorithm to achieve distributed mutual exclusion.</strong></p>
<img src="https://pic.imgdb.cn/item/6289ff7c0947543129042ce0.jpg" style="zoom:67%;" />

<p><strong>a. Which clock, real-time clock of server S or logical clocks in the system, should be used to order the requests in the Request Queue?  Briefly explain your answer.</strong></p>
<p>As the order of granting token is based on the request arrival time, the order is based on the real-time clock of server S.  Maintaining logical clocks in the system (S, P1, P2 and P3) do not have significant benefit in this case.</p>
<p><strong>b. Briefly suggest how the system recovers from the following situations (consider each situation independently):</strong></p>
<ul>
<li><p><strong>P2 is temporary disconnected from the network.</strong></p>
<p>Assume a timer is assigned to the token which define its validity.  If the process doesn’t release the token before time out, the server will regenerate a new token for the next request.  The work done by the invalid token should be undo.  </p>
<p>If the p2 is temporary disconnect from the system and reconnect to the network before time-out, it should have no effect on the system.</p>
<p>However, if p2 only reconnect after time-out, the update associated with the token must be undo.</p>
</li>
<li><p><strong>P2 is crashed and restarted immediately</strong></p>
<p>P2 probably will lost its memory after restart and new token should be generated after time out.  P2 should undo any operation associated with the lost token</p>
</li>
<li><p><strong>S is crashed</strong></p>
<p>The system can only be recovered after a new server is elected.</p>
</li>
</ul>
<h4 id="5-3-Distributed-Coordination-Election"><a href="#5-3-Distributed-Coordination-Election" class="headerlink" title="5.3 Distributed Coordination: Election"></a>5.3 Distributed Coordination: Election</h4><ul>
<li>A method to choose a unique process to play a particular role is called an election algorithm.</li>
<li>Main requirement is for the choice of elected process to be unique, even several processes call elections concurrently</li>
</ul>
<h5 id="Election-Bully-Algorithm"><a href="#Election-Bully-Algorithm" class="headerlink" title="Election: Bully Algorithm"></a>Election: Bully Algorithm</h5><ul>
<li><p>It can be used when the members of a group know the identities and addresses of the other members. </p>
</li>
<li><p>The algorithm selects the surviving member with the largest identity to be coordinator.</p>
</li>
<li><p>Assumption: communication is reliable but processes can fail during an election. </p>
</li>
<li><p>Three types of message:    </p>
<ul>
<li>election message - sent to announce an election, await for answer.</li>
<li>answer message - sent in response to an election message.</li>
<li>coordinator message - sent to announce the identity of the new coordinator.</li>
</ul>
</li>
<li><p>A process begins an election if it notices coordinator has failed.</p>
</li>
<li><p>The process that knows it has the highest identifier can elect itself as the coordinator simply by sending a coordinator message to all processes with lower identifiers. </p>
</li>
<li><p>Otherwise, a process can begin an election by sending an election message to those processes that have a higher identifier. </p>
</li>
<li><p>It then awaits an answer message in response. </p>
</li>
<li><p>If none arrives within a certain time, the process considers itself the coordinator, and sends a coordinator message to all processes with lower identifiers announcing this fact. </p>
</li>
<li><p>Otherwise (the process receives answer message(s)), the process waits a further limited period for a coordinator message to arrive from the new coordinator.</p>
</li>
<li><p>If none arrives, it begins another election.</p>
</li>
<li><p>If a process receives a coordinator message, it sets the identifier in the message as the new coordinator. </p>
</li>
<li><p>When an election message arrives to a node (with higher identifier), the node sends an answer and starts its own election (i.e. send election message to nodes with higher identifiers). </p>
</li>
<li><p>When the failed process is restarted, it begins election, if it has the highest identity, then it will decide it is coordinator, and announce this to other processes.</p>
</li>
<li><p>It becomes the coordinator even the current coordinator is functioning (so called bully).</p>
</li>
</ul>
<p>Stage 1: p1 detects the failure of the coordinator p4, so p1 and announces an election. (priority: p1&lt;p2&lt;p3)</p>
<img src="https://pic.imgdb.cn/item/6287a87609475431297a4cdc.jpg" style="zoom:80%;" />

<p>Stage 2: p2 and p3 send answer message to p1 and then begin their own elections.</p>
<img src="https://pic.imgdb.cn/item/6287a8a009475431297a6479.jpg" style="zoom:80%;" />

<p>Stage 3: Since p3 will receive no answer messages from p4 , it therefore decides it is the coordinator. But it fails before it sends out the coordinator message. Thus p1 timeouts. </p>
<img src="https://pic.imgdb.cn/item/6287a8c109475431297a75f4.jpg" style="zoom:80%;" />

<p>Stage 4: Since p1 notices the absence of a coordinator message and begins another election. This time p2 is elected coordinator.</p>
<img src="https://pic.imgdb.cn/item/6287a8dc09475431297a8720.jpg" style="zoom:80%;" />

<h5 id="Election-Ring-based-Election"><a href="#Election-Ring-based-Election" class="headerlink" title="Election: Ring-based Election"></a>Election: Ring-based Election</h5><ul>
<li>Assumption:<ul>
<li>processes are arranged in a logical ring</li>
<li>each process knows only how to communicate with its neighbor in, say, the clockwise direction. The process does not know the other processes.</li>
<li>All the processes remain functional and reachable</li>
</ul>
</li>
</ul>
<img src="C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20220520224346234.png" alt="image-20220520224346234" style="zoom: 67%;" />

<img src="https://pic.imgdb.cn/item/6287a93c09475431297ab893.jpg" style="zoom: 67%;" />

<ul>
<li><p>Initially, every process is marked as a non-participant</p>
</li>
<li><p>Any process can begin an election by marking itself as a participant, placing its ID in an election msg and sending it to its neighbor.</p>
</li>
<li><p>When a process receives an election msg:</p>
<ul>
<li>if the arrived ID is greater, it forwards the msg to its neighbor</li>
<li>If the arrived ID is smaller and the process is not a participant then it substitutes its own ID in the msg and forwards it; but it does not forward the msg  if it is already a participant.</li>
</ul>
</li>
<li><p>On forwarding an election msg, the process marks itself as a participant</p>
</li>
<li><p><strong>If the received ID is that of the receiver itself, this process’s ID must be the greatest and it becomes the coordinator.</strong></p>
</li>
<li><p>The coordinator marks itself as a non-participant once more and sends an elected msg with its ID to its neighbour.</p>
</li>
<li><p>When a process other than the coordinator receives an elected msg, it marks itself as a non-participant and forwards the msg to its neighbor</p>
</li>
<li><p>Marking processes as participant or non-participant is to extinguish the concurrent election messages as soon as possible.</p>
</li>
<li><p>In the worst case, 3n-1 msg are needed to complete an election.</p>
</li>
</ul>
<p>**An Example with two concurrent tokens **</p>
<img src="https://pic.imgdb.cn/item/6287aaa609475431297b7b9a.jpg" style="zoom: 67%;" />

<h5 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise"></a>Exercise</h5><p><strong>In the ring-based election algorithm, the processes need to mark participant or non-participant in an election process.  Explain why.</strong></p>
<p>Ans: Two processes may start the election process at the same time leading to more than one election message.  The purpose of marking participant or non-participant is to extinguish the concurrent election message as soon as possible and always before the “winning” result has been announced.</p>
<h3 id="6-Replication"><a href="#6-Replication" class="headerlink" title="6. Replication"></a>6. Replication</h3><p>Replication is the maintenance of on-line copies of data and other resources.</p>
<img src="https://pic.imgdb.cn/item/6287abe809475431297c2cc7.jpg" style="zoom: 80%;" />

<p><strong>Motivation</strong></p>
<ul>
<li>Performance enhancement<ul>
<li>fast response time and increased throughput</li>
</ul>
</li>
<li>High availability <ul>
<li>clients can access an alternative server if the default server fails or becomes unreachable</li>
</ul>
</li>
<li>Fault tolerance<ul>
<li>provide guarantees of correct request processing even though one of the servers in a group fails</li>
</ul>
</li>
</ul>
<p><strong>Replication: Requirement</strong></p>
<ul>
<li>Replication transparency<ul>
<li>clients should not be aware that multiple physical copies of data exist.</li>
</ul>
</li>
<li>Consistency transparency<ul>
<li>unacceptable for different clients to obtain differing results</li>
<li>dealt with how to apply updates to different replica</li>
</ul>
</li>
</ul>
<p><strong>Ordering Models: Asynchronous</strong></p>
<ul>
<li>All client requests are processed by the local replica server</li>
<li>The local replica servers communicate updates to all other replica servers. Servers process updates as they arrive</li>
</ul>
<img src="https://pic.imgdb.cn/item/6287ac9109475431297c8b7f.jpg" style="zoom:67%;" />

<p><strong>Ordering Models: Totally Synchronous</strong></p>
<ul>
<li>All update requests are totally ordered. That is, requests are processed at all replicas in the same order.</li>
<li>A next request can be processed only after the previous update has been processed at all servers</li>
<li>Poor performance in response time and throughput</li>
<li>Scheme in between: Quorum-based Schemes (Min. vote for a decision&#x2F;event) and causality</li>
</ul>
<p><strong>Ordering Models</strong></p>
<img src="https://pic.imgdb.cn/item/6287ad9709475431297d1391.jpg" style="zoom:67%;" />

<h4 id="6-1-Basic-Architectural-Model"><a href="#6-1-Basic-Architectural-Model" class="headerlink" title="6.1 Basic Architectural Model"></a>6.1 Basic Architectural Model</h4><p>Three entities:</p>
<ul>
<li>Replica manager: maintains a physical copy of every logical data item</li>
<li>Client: makes a series of requests.</li>
<li>Front end: handles the requests of clients<ul>
<li>to communicate with replica managers  for clients’ requests</li>
</ul>
</li>
</ul>
<img src="https://pic.imgdb.cn/item/6287adeb09475431297d380b.jpg" style="zoom:67%;" />

<img src="https://pic.imgdb.cn/item/6287ae1509475431297d55eb.jpg" style="zoom:67%;" />

<h4 id="6-2-Ordering"><a href="#6-2-Ordering" class="headerlink" title="6.2 Ordering"></a>6.2 Ordering</h4><p>Total ordering</p>
<ul>
<li>If r1 and r2 are requests, then either r1 is processed before r2 at all replica managers or r2 is processed before r1 at all replica managers.</li>
</ul>
<p>Causal ordering</p>
<ul>
<li>If r1 and r2 are requests and r1 happened-before r2, then r1 is processed before r2 at all replica managers</li>
</ul>
<img src="https://pic.imgdb.cn/item/6287ae8609475431297db1de.jpg" style="zoom:67%;" />

<p><strong>Implementation Techniques for Ordering</strong></p>
<ul>
<li>Hold-Back: a received request is not processed by a replica manager until ordering constraints can be met.</li>
<li>E.g. a bulletin board item Re:Microkernels may be held back until an item concerning Microkernels has already appeared.</li>
</ul>
<img src="https://pic.imgdb.cn/item/6287b1630947543129801292.jpg" style="zoom:67%;" />

<p><strong>Implementing Total Ordering</strong></p>
<ul>
<li>Basic approach: assigns totally ordered identifiers to requests so that each RM (replica manager) site makes the same ordering decision based on these identifiers</li>
<li>Simple technique: use a process called sequencer to assign identifiers</li>
<li>All requests are sent to the sequencer as well as to the RM sites</li>
<li>The sequencer assigns consecutive increasing identifiers to requests and forwards them to the RM sites</li>
<li>Requests arriving at an RM site are held back until they are next in sequence.</li>
</ul>
<h4 id="6-3-Another-Algorithm-for-Total-Ordering"><a href="#6-3-Another-Algorithm-for-Total-Ordering" class="headerlink" title="6.3 Another Algorithm for Total Ordering"></a>6.3 Another Algorithm for Total Ordering</h4><ul>
<li>RM sites propose identifiers for requests to the corresponding FE (front end) sites as they arrive</li>
<li>The FE site use them to generate final identifiers</li>
<li>Each RM sites have:<ul>
<li>Fmax: the largest final identifier agreed so far</li>
<li>Pmax: its own largest proposed identifier</li>
</ul>
</li>
</ul>
<img src="https://pic.imgdb.cn/item/6287b22709475431298090fb.jpg" style="zoom:80%;" />

<ul>
<li><p>The FE site sends the request bearing a temporary identifier (larger than previously-used ones (F)) to all RM sites</p>
</li>
<li><p>Each RM at site i replies the proposed identifier (P)</p>
</li>
<li><p>Max(Fmax,Pmax) +1 + i&#x2F;N</p>
<ul>
<li>where N is the number of RM sites</li>
</ul>
</li>
<li><p>Each RM places the request on its hold-back queue which is ordered with the smallest request identifier</p>
</li>
<li><p>The FE site selects the largest proposed identifiers as the next agreed identifier.</p>
</li>
<li><p>The term i&#x2F;N makes the selected identifier unique</p>
</li>
<li><p>The FE site then notifies all the RM sites of the final identifier (Agreed ID)</p>
</li>
<li><p>The RM sites attach the final identifier to the request and re-order the request on the hold-back queue. Note that the final identifier may differ from the proposed identifier.</p>
</li>
<li><p>When the request at the front of the hold-back queue has been assigned its final identifier, it is transferred to the tail of the delivery queue.</p>
</li>
</ul>
<p>Advantages:</p>
<ul>
<li>straightforward to implement</li>
<li>no bottleneck or single point of failure</li>
</ul>
<p><strong>Implementing Causal Ordering</strong></p>
<ul>
<li>A bulletin board system with several replica as an example</li>
<li>Assumptions:<ul>
<li>bulletin board items are never removed</li>
<li>it is updated only by the addition of new items</li>
</ul>
</li>
<li>Vector Clock</li>
</ul>
<h4 id="6-4-Deadlocks"><a href="#6-4-Deadlocks" class="headerlink" title="6.4 Deadlocks"></a>6.4 Deadlocks</h4><ul>
<li>The use of locks (for exclusive use) can lead to deadlock.</li>
<li>Deadlock is a state in which each member of a group of transactions is waiting for some other member to release a lock.</li>
<li>A wait-for graph can be used to capture this waiting relationship.</li>
<li>A directed edge is added from node T to node U if transaction T is waiting for transaction U to release a lock.</li>
<li>As each transaction can wait for only one data item, the wait-for graph can be simplified to contain transactions only.</li>
</ul>
<p><strong>Deadlock with Read and Write Locks</strong></p>
<img src="https://pic.imgdb.cn/item/6287b400094754312981bc78.jpg" style="zoom: 67%;" />

<img src="https://pic.imgdb.cn/item/6287b45b09475431298203a7.jpg" style="zoom: 67%;" />

<img src="https://pic.imgdb.cn/item/6287b47609475431298216d9.jpg" style="zoom:67%;" />

<h5 id="Deadlock-Resolution"><a href="#Deadlock-Resolution" class="headerlink" title="Deadlock Resolution"></a>Deadlock Resolution</h5><ul>
<li>Deadlock prevention<ul>
<li>a transaction needs to get all locks when it starts</li>
<li>a transaction requests locks in a predefined order</li>
</ul>
</li>
<li>Deadlock detection<ul>
<li>find cycles in the wait-for graph and break the cycle</li>
<li>the choice of the transaction to abort is not simple</li>
</ul>
</li>
<li>Timeouts<ul>
<li>commonly used</li>
<li>the transaction is aborted to release the lock after timeout if there is another requesting transaction.</li>
</ul>
</li>
</ul>
<h5 id="Distributed-Deadlock"><a href="#Distributed-Deadlock" class="headerlink" title="Distributed Deadlock"></a>Distributed Deadlock</h5><ul>
<li>Detection of a distributed deadlock requires a global wait-for cycle to be found.</li>
<li>A simple solution: one server is dedicated to detect global deadlocks periodically<ul>
<li>combine local wait-for graphs to check for cycles</li>
<li>disadvantages: single point of failure, lack of fault tolerance and no ability to scale.</li>
<li>How often to detect deadlocks?</li>
</ul>
</li>
</ul>
<img src="https://pic.imgdb.cn/item/6287b5b1094754312982f619.jpg" style="zoom: 67%;" />

<img src="https://pic.imgdb.cn/item/6287b5c709475431298304a2.jpg" style="zoom:67%;" />

<img src="https://pic.imgdb.cn/item/6287b6a60947543129839121.jpg" style="zoom:67%;" />

<h5 id="Phantom-Deadlocks"><a href="#Phantom-Deadlocks" class="headerlink" title="Phantom Deadlocks"></a>Phantom Deadlocks</h5><ul>
<li>A deadlock is “detected” but is not really a deadlock</li>
<li>Phantom deadlocks occur due to the transmission delay of wait-for information</li>
<li>In the course of detection, a transaction that holds a lock will meanwhile have released.</li>
<li>If transactions are using two-phase locks, can phantom deadlock occur?</li>
</ul>
<img src="https://pic.imgdb.cn/item/6287b727094754312983e247.jpg" style="zoom:80%;" />

<h5 id="Edge-Chasing"><a href="#Edge-Chasing" class="headerlink" title="Edge Chasing"></a>Edge Chasing</h5><ul>
<li>Also called path pushing</li>
<li>The global wait-for graph is not constructed.</li>
<li>Instead, the servers forward messages called Probes that follow the edges of the wait-for graph.</li>
<li>A probe message consists of transaction wait-for relationships representing a path in the global wait-for graph.</li>
</ul>
<img src="https://pic.imgdb.cn/item/6287ba49094754312985c645.jpg" style="zoom:80%;" />

<ul>
<li>Initiation<ul>
<li>When a transaction T starts waiting for another transaction U which is waiting to access a data item at another server, the edge &lt;T-&gt;U&gt; is sent to the server of the data item where U is blocked.</li>
</ul>
</li>
<li>Detection<ul>
<li>On receiving probes, the server adds paths to the probes</li>
<li>If no cycle and a transaction is waiting for a data item at another server, probes are sent to the server.</li>
</ul>
</li>
<li>Resolution<ul>
<li>When deadlock is detected, a transaction is selected to abort.</li>
</ul>
</li>
</ul>
<h5 id="More-Than-One-Transaction-Aborted"><a href="#More-Than-One-Transaction-Aborted" class="headerlink" title="More Than One Transaction Aborted"></a>More Than One Transaction Aborted</h5><ul>
<li>Every transaction involved in a deadlock cycle can initiate the deadlock detection</li>
<li>This concurrent detection may lead to the abortions of more than one transaction</li>
<li>To solve it, transactions are given totally-ordered priorities.</li>
<li>The transaction with the lowest priority is aborted to break the deadlock</li>
</ul>
<h4 id="6-5-Exercise"><a href="#6-5-Exercise" class="headerlink" title="6.5 Exercise"></a>6.5 Exercise</h4><p><strong>A front end has vector timestamp (3,5,7) representing the data it has received from members of a group of three replica managers. The three replica managers have vector timestamps (5,2,8), (4,5,6) and (4,5,8), respectively. Which replica manager(s) could immediately satisfy a query from the front end, and what is the resultant time stamp of the front end? Which replica manager could incorporate an update from the front end immediately?</strong></p>
<p>Ans: The replica manager with the timestamp (4,5,8) can satisfy the query because the others have not yet processed at least one update seen by the front end.  The resulting timestamp of the front end will be (4,5,8). The replica manager with the timestamp (4,5,8) could incorporate the update.</p>
<h3 id="7-Distributed-File-Service"><a href="#7-Distributed-File-Service" class="headerlink" title="7. Distributed File Service"></a>7. Distributed File Service</h3><h4 id="7-1-Conventional-File-System"><a href="#7-1-Conventional-File-System" class="headerlink" title="7.1 Conventional File System"></a>7.1 Conventional File System</h4><ul>
<li>Responsible for the organization, storage, retrieval, naming, sharing and protection of files</li>
<li>Provides a set of programming operations that characterize the file abstraction</li>
<li>Design to store and manage large numbers of files, with facilities for creating, naming and deleting the files;</li>
<li>Control the access to files</li>
</ul>
<h4 id="7-2-Distributed-File-System"><a href="#7-2-Distributed-File-System" class="headerlink" title="7.2 Distributed File System"></a>7.2 Distributed File System</h4><ul>
<li>An essential component in distributed systems</li>
<li>Use to support the sharing of persistent storage and its information</li>
<li>Enable user programs to access remote files without copying them to a local disk</li>
<li>Provide access to files from diskless nodes</li>
<li>The most heavily-used services →its functionality and performance are critical</li>
</ul>
<h4 id="7-3-Design-Issues"><a href="#7-3-Design-Issues" class="headerlink" title="7.3 Design Issues"></a>7.3 Design Issues</h4><p>The features that are partially or wholly addressed by most current file services:</p>
<ul>
<li><p>Access transparency</p>
<ul>
<li>Client programs should be unaware of the distribution of files. </li>
<li>A single set of operations is provided for access to local and remote files. </li>
<li>Programs written to operate on local files are able to access remote files without modification.</li>
</ul>
</li>
<li><p>Location transparency</p>
<ul>
<li>Client programs should see a uniform file name space.</li>
<li>File or groups of files may be relocated without changing their names. </li>
<li>User programs see the same name space wherever they are executed.</li>
</ul>
</li>
<li><p>Concurrency transparency</p>
<ul>
<li>Changes to a file by one client should not interfere with the operation of other clients simultaneously accessing the same file.</li>
</ul>
</li>
<li><p>Failure transparency</p>
<ul>
<li>Correct operation of servers after failure of a client;</li>
<li>Correct operation of client programs in the face of lost message and temporary interruptions of the service.</li>
</ul>
</li>
<li><p>Performance transparency</p>
<ul>
<li>Client programs should continue to perform satisfactorily while the load on the file service varies within a specified a range.</li>
</ul>
</li>
<li><p>Scaling transparency</p>
<ul>
<li>The service can be extended by incremental growth to deal with a wide range of loads and system sizes.</li>
</ul>
</li>
<li><p>Replication transparency (for very large DS)</p>
<ul>
<li>A file may be represented by several copies of its contents at different locations. </li>
<li>It enables multiple servers to share the load of providing a service to many clients, enhancing the performance and scalability of service,</li>
<li>It enhances fault tolerance by enabling a client to locate another server that holds a copy of the file on the server that has just failed.</li>
</ul>
</li>
<li><p>Migration transparency (for very large DS)</p>
<ul>
<li>Neither client programs nor system administration tables in client nodes need to be changed when files are moved. </li>
<li>This allows file mobility - files, sets or volumes of files may be moved, either by system administrators or automatically.</li>
</ul>
</li>
<li><p>Hardware and operating system heterogeneity</p>
<ul>
<li>The service interfaces should be defined so that client and server software can be implemented for different OS and computers (for openness).</li>
</ul>
</li>
<li><p>The features that are not found in current file services but important in the future:</p>
<ul>
<li>Support for fine-grained distributed of data<ul>
<li>As the sophistication of distributed application grows, the sharing of data in small units will become necessary.</li>
<li>We need to locate individual objects near the processes that are using them and to cache them individually in those locations.</li>
</ul>
</li>
<li>Tolerance to network partitioning and detached operation<ul>
<li>When a file service includes the replication or caching of files, clients may be affected when a network partition occurs.</li>
<li>We need to handle the inconsistent database once a network partition occurs.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="7-4-File-Service-Components"><a href="#7-4-File-Service-Components" class="headerlink" title="7.4 File Service Components"></a>7.4 File Service Components</h4><img src="https://pic.imgdb.cn/item/6287c39c09475431298c0a9f.jpg" style="zoom: 67%;" />

<ul>
<li>Flat file service<ul>
<li>This service is concerned with implementing operations on the contents of files. </li>
<li>Unique file identifiers (UFIDs) are used to refer to files in all requests for flat file service operations.    (construction of UFID will be discussed later)</li>
</ul>
</li>
<li>Directory service<ul>
<li>provide a mapping between text names for files and their UFIDs. (UNIX uses hierarchic file name)</li>
</ul>
</li>
<li>Client module<ul>
<li>A single client module runs in each client computer</li>
<li>It integrates and extends operations of flat file service and directory service under a single application programming interface</li>
<li>The interface is available to user-level programs in client computers</li>
</ul>
</li>
</ul>
<h4 id="7-5-Interface-Flat-File-Service"><a href="#7-5-Interface-Flat-File-Service" class="headerlink" title="7.5 Interface (Flat File Service)"></a>7.5 Interface (Flat File Service)</h4><ul>
<li>RPC interface used by client modules</li>
<li>Not normally used directly by user-level programs</li>
</ul>
<img src="https://pic.imgdb.cn/item/6287c49d09475431298cad2f.jpg" style="zoom:67%;" />

<img src="https://pic.imgdb.cn/item/6287c4b909475431298cc07b.jpg" style="zoom:67%;" />

<img src="https://pic.imgdb.cn/item/6287c4d209475431298cd21b.jpg" style="zoom:67%;" />

<h4 id="7-6-Interface-Directory-Service"><a href="#7-6-Interface-Directory-Service" class="headerlink" title="7.6 Interface (Directory Service)"></a>7.6 Interface (Directory Service)</h4><p>To provide a service for translating text names to UFIDs.</p>
<img src="https://pic.imgdb.cn/item/6287c70a09475431298e335a.jpg" style="zoom:67%;" />

<img src="https://pic.imgdb.cn/item/6287c72409475431298e426c.jpg" style="zoom:67%;" />



<p><strong>Designed for fault tolerance</strong>:</p>
<ul>
<li>Repeatable operations: with the exception of create, the operations are idempotent. (repeated execution of create causes a space leak.)</li>
<li>Stateless servers: can be restarted after a failure and resume operation without need for clients or other server to restore any state.</li>
</ul>
<h4 id="7-7-Case-Studies-NFS"><a href="#7-7-Case-Studies-NFS" class="headerlink" title="7.7 Case Studies: NFS"></a>7.7 Case Studies: NFS</h4><ul>
<li><p>Network File System (NFS) is a distributed file system protocol originally developed by Sun Microsystems (Sun) in 1984, allowing a user on a client computer to access files over a computer network much like local storage is accessed. </p>
</li>
<li><p>Design goals:</p>
<ul>
<li>Emulation of the UNIX file system interface</li>
<li>Concurrent access</li>
<li>One-copy update semantics<ul>
<li>The file contents seen by all of the processes accessing or updating a given file are those that they would see if only single copy of the file contents existed.</li>
</ul>
</li>
</ul>
</li>
<li><p>Architecture</p>
<ul>
<li>The basic idea of NFS is to allow an arbitrary collection of clients and servers to share a common file system.</li>
<li>Each NFS server exports one or more of its directories for access by remote clients.</li>
</ul>
</li>
<li><p>The list of directories a server exports is maintained in the &#x2F;etc&#x2F;exports file, so these directories can be exported automatically whenever the server is booted. (migration transparency) </p>
</li>
<li><p>Clients access exported directories by mounting them.</p>
</li>
<li><p>When a client mounts a (remote) directory, it becomes part of its directory hierarchy. (location transparency)</p>
</li>
<li><p>Local and remote file systems accessible on an NFS client.</p>
<img src="https://pic.imgdb.cn/item/6287c83b09475431298ee785.jpg" style="zoom:67%;" />
</li>
<li><p>To access a file, there is (almost) no difference between a file located on a remote file server and a file located on the local disk. (performance transparency)</p>
</li>
<li><p>Once the mounts have been done, nothing special has to be done to achieve sharing. (access transparency)</p>
</li>
<li><p>If two or more clients mount the same directory at the same time, they can communicate by sharing files in their common directories.</p>
</li>
<li><p>The NFS service is stateless and most of the operations of the file access protocol are idempotent. (failure transparency)</p>
</li>
<li><p>It does not support replication transparency because it is a separate service.</p>
</li>
<li><p>It does not support concurrency transparency because it does not aim to improve upon the UNIX approach to the control of concurrent updates of files.</p>
<ul>
<li>NFS 4.0 has been extended to support.</li>
</ul>
</li>
<li><p>It is not scalability: maximum 50 clients, usually 5 - 10 clients.</p>
</li>
</ul>
<p>File Service Components</p>
<img src="https://pic.imgdb.cn/item/6287c8bc09475431298f2f7d.jpg" style="zoom:67%;" />



<ul>
<li><p>Virtual File System (VFS)</p>
<ul>
<li>Distinguish local and remote files;</li>
<li>Translate between UNIX-independent File Identifiers (FIDs) used by NFS and the internal file identifiers normally used in UNIX and other file systems.</li>
<li>UFID used by NFS is called file handle.</li>
<li>It is opaque (not observed) to users.</li>
<li>Filesystem identifier: a unique number that is allocated to each file system when it is created.</li>
</ul>
</li>
<li><p>NFS communication</p>
<ul>
<li>Port mapper enables Clients to bind to a service in a given host by name.</li>
<li>Clients use RPC to access Server interfaces.</li>
<li>NFS RPC interface is open.</li>
<li>Any authenticated request will be executed.</li>
<li>NFS handles the requests according to the UFIDs. (operations are similar to Read, Write, … in Flat file Service)</li>
</ul>
</li>
<li><p>i-node number: a number that serves to identify and locate the file within the file system in which the file is stored.</p>
</li>
<li><p>i-node generation number: increment each time the i-node number is reused).</p>
</li>
<li><p>file handle is made unique with i-node generation number.</p>
</li>
</ul>
<p>The format of UNIX-Independent File Identifiers (FIDs) used by NFS:</p>
<img src="https://pic.imgdb.cn/item/6287d16509475431299408a1.jpg" style="zoom: 80%;" />

<ul>
<li><p>NFS Client module</p>
<ul>
<li>Simulate UNIX standard file service;</li>
<li>Integrated with UNIX kernel;</li>
<li>Users can access files via system calls;</li>
<li>Single client module serves all user level processes (in a client machine) with shared cache.</li>
<li>Path name translation to file handle.</li>
</ul>
</li>
<li><p>NFS server module</p>
<ul>
<li>Integrated with UNIX kernel for performance, including access control and authentication.</li>
<li>E.g. Sun RPC requires client to present their User_Id &amp; Group_Id (in each RPC call), NFS server checks against access permission in file attribute.</li>
</ul>
</li>
<li><p>Mount service</p>
<ul>
<li>Mount requests are performed as a part of system initialization process. Client user process uses mount system call for further mounting when necessary.</li>
<li>Mount server uses an RPC interface, mount requests contains the pathname of a directory (to be mounted) and returns the file handle of the directory.</li>
</ul>
</li>
<li><p>Two kinds of mount services for remote file system: hard mounted or soft mounted;</p>
</li>
<li><p>Hard mounted (“try hard”): User process is suspended until request completed; If not completed (unavailable), client module retries until success. </p>
</li>
<li><p>Soft mounted (“do not try hard”): NFS client module returns a failure notification to user process after a few time-out retries. User process should handle the failure.</p>
</li>
<li><p>Most applications take hard mount (why?)</p>
</li>
<li><p>Automounter</p>
<ul>
<li>Dynamically mount a file system if “empty” mount point is referenced.The file system on the first server to respond is mounted at the client using the normal mount service.</li>
</ul>
</li>
<li><p><strong>Client caching</strong></p>
<ul>
<li>NFS client module caches results of: read, write, get-attribute, lookup and read-dir.</li>
<li>Consistency problem: Writing by a client does not result in the immediate updating of cached copies in other clients.</li>
</ul>
</li>
<li><p><strong>Server Caching</strong></p>
<ul>
<li>Enhance the performance NFS;</li>
<li>UNIX server cache<ul>
<li>File pages, directories and file attributes read from disk are retained in buffer cache.</li>
<li>Delayed-write: when a page has been altered, its page is written in disk only when the page is needed.</li>
<li>To prevent loss data, UNIX flushes altered page every 30 sec.</li>
</ul>
</li>
<li>NFS Server cache<ul>
<li>Read cache is the same as UNIX;</li>
<li>NFS flushes altered page immediately. Otherwise, clients (sharing a file) may lose some updates.</li>
</ul>
</li>
</ul>
</li>
<li><p>Solution 1: Timestamp (read)</p>
<ul>
<li>Each cache entry is associated with a Timestamp.     </li>
<li>A client requests last modification time from server;</li>
<li>Compares the time with its cache Timestamp; </li>
<li>If (time &gt; Timestamp) (time is more recent) then the cache blocks of the file are invalidated and must be re-fetched.</li>
</ul>
</li>
<li><p>Solution 2: Validation check (read)</p>
<ul>
<li>3 sec. for files &amp; 30 sec. for directories. </li>
<li>Files have vulnerability window of 3 sec. </li>
<li>Seems to be tolerable for most applications.</li>
</ul>
</li>
<li><p>Solution 3: Bio-demon( Block I&#x2F;O manager process) implemented by NFS client.</p>
<ul>
<li>Read-Ahead: a bio-demon is notified after each read request and it requests the transfer of the following file block from the server to the client cache.</li>
<li>Delayed-write: a block is sent to server if the block is filled.</li>
<li>Directory blocks are sent whenever a modification has occurred.</li>
</ul>
</li>
</ul>
<h4 id="7-8-Case-study-2-Apache-Hadoop"><a href="#7-8-Case-study-2-Apache-Hadoop" class="headerlink" title="7.8 Case study 2: Apache Hadoop"></a>7.8 Case study 2: Apache Hadoop</h4><ul>
<li>Apache Hadoop is a collection of open-source software utilities that facilitates using a network of many computers to solve problems involving massive amounts of data and computation. </li>
<li>It provides a software framework for distributed storage and processing of big data using the MapReduce programming model.</li>
<li>Hadoop File System was developed using distributed file system design. </li>
<li>It is fault-tolerant and designed using low-cost hardware.</li>
<li>To store such huge data, the files are stored across multiple machines. These files are stored in redundant fashion to rescue the system from possible data losses in case of failure.</li>
</ul>
<p><strong>Features of HDFS</strong></p>
<ul>
<li>It is suitable for the distributed storage and processing.</li>
<li>Hadoop provides a command interface to interact with HDFS.</li>
<li>The built-in servers of namenode and datanode help users to easily check the status of cluster.</li>
<li>Streaming access to file system data.</li>
<li>HDFS provides file permissions and authentication.</li>
</ul>
<img src="https://pic.imgdb.cn/item/6287db3f0947543129990545.jpg" style="zoom:67%;" />

<p><strong>Namenode</strong></p>
<ul>
<li>The namenode is the commodity hardware that contains the GNU&#x2F;Linux operating system and the namenode software.  </li>
<li>The namenode acts as the master server and it does the following tasks.</li>
<li>Manages the file system namespace.</li>
<li>Regulates client’s access to files.</li>
<li>It also executes file system operations such as renaming, closing, and opening files and directories.</li>
</ul>
<p><strong>Datanode</strong></p>
<ul>
<li>The datanode is a commodity hardware having the GNU&#x2F;Linux operating system and datanode software. For every node (Commodity hardware&#x2F;System) in a cluster, there will be a datanode. </li>
<li>These nodes manage the data storage of their system.</li>
<li>Datanodes perform read-write operations on the file systems, as per client request.</li>
<li>They also perform operations such as block creation, deletion, and replication according to the instructions of the namenode.</li>
</ul>
<p><strong>File Block</strong></p>
<ul>
<li>The file in HDFS will be divided into one or more segments and stored in individual data nodes. </li>
<li>These file segments are called as blocks. </li>
<li>In other words, the minimum amount of data that HDFS can read or write is called a Block. </li>
<li>The default block size is 64MB, but it can be increased as per the need to change in HDFS configuration.</li>
</ul>
<p><strong>Goals of HDFS</strong></p>
<ul>
<li><strong>Fault detection and recovery</strong> − Since HDFS includes a large number of commodity hardware, failure of components is frequent. Therefore HDFS should have mechanisms for quick and automatic fault detection and recovery.</li>
<li><strong>Huge datasets</strong> − HDFS should have hundreds of nodes per cluster to manage the applications having huge datasets.</li>
<li><strong>Hardware at data</strong> − A requested task can be done efficiently, when the computation takes place near the data. Especially where huge datasets are involved, it reduces the network traffic and increases the throughput.</li>
</ul>
<h4 id="7-8-Exercises"><a href="#7-8-Exercises" class="headerlink" title="7.8 Exercises"></a>7.8 Exercises</h4><p><strong>In-Class Exercise 1</strong></p>
<ul>
<li><p><strong>What kind transparency a DFS should be support? Which transparency is&#x2F;are required by large distributed system only?  Why?</strong></p>
</li>
<li><p><strong>Can you discuss how HDFS support any of the above transparency?</strong></p>
<p>Access Transparency</p>
<p>Location Transparency</p>
<p>Concurrency Transparency</p>
<p>Failure Transparency</p>
<p>Performance Transparency</p>
<p>Scaling Transparency</p>
<p>Replication Transparency</p>
<p>Migration Transparency</p>
</li>
</ul>
<p><strong>Revision Exercise 2</strong></p>
<p><strong>Consider the following diagram of NFS</strong></p>
<img src="https://pic.imgdb.cn/item/6287de3809475431299a7700.jpg" style="zoom:80%;" />

<ul>
<li><p><strong>What are the main functions of the Virtual file System and NFS Server?</strong></p>
<p>Virtual File System</p>
<ul>
<li>Distinguish local and remote files;</li>
<li>Translate between UNIX-independent File Identifiers (FIDs) used by NFS and the internal file identifiers normally used in UNIX and other file systems.</li>
</ul>
<p>NSF Server Module </p>
<ul>
<li>Integrated with UNIX kernel for performance, including access control and authentication</li>
</ul>
</li>
<li><p><strong>Which modules in the diagram may enhance by caching? Briefly explain your answer</strong></p>
<p>NFS client caching and server caching.</p>
<p>Client caching</p>
<ul>
<li>NFS client module caches results of: read, write, get-attribute, lookup and read-dir.</li>
<li>Consistency problem: Writing by a client does not result in the immediate updating of cached copies in other clients.</li>
</ul>
<p>Server Caching</p>
<p>……….see 7.7</p>
</li>
</ul>
<h3 id="8-Blockchain-and-Digital-Cash"><a href="#8-Blockchain-and-Digital-Cash" class="headerlink" title="8. Blockchain and Digital Cash"></a>8. Blockchain and Digital Cash</h3><h4 id="8-1-Fault-Tolerance"><a href="#8-1-Fault-Tolerance" class="headerlink" title="8.1 Fault Tolerance"></a>8.1 Fault Tolerance</h4><ul>
<li>Replication</li>
<li>Consistency among replicas is maintained by consensus algorithms</li>
<li>State machine replication: E.g. blockchain</li>
<li>Type of Fault<ul>
<li>Node is down</li>
<li>Node is performing malicious &#x2F; inconsistent behavior</li>
</ul>
</li>
</ul>
<h4 id="8-2-Consensus-Mechanisms"><a href="#8-2-Consensus-Mechanisms" class="headerlink" title="8.2 Consensus Mechanisms"></a>8.2 Consensus Mechanisms</h4><p><strong>Requirements</strong></p>
<ul>
<li><p>Agreement: All honest nodes decide on the same value</p>
</li>
<li><p>Termination: All honest nodes terminate execution of the consensus process and eventually reach a decision</p>
</li>
<li><p>Validity: The final agreed value must be the one proposed by at least one honest node</p>
</li>
<li><p>Fault tolerant: Allow the presence of faulty or malicious node (Byzantine node)</p>
</li>
<li><p>Byzantine fault tolerance-based</p>
<ul>
<li>Nodes publishing signed message</li>
<li>Agreement is reached when a certain number of messages are received</li>
</ul>
</li>
<li><p>Leader-based consensus mechanisms</p>
<ul>
<li>By competition</li>
<li>Winning node propose the final value</li>
</ul>
</li>
</ul>
<h4 id="8-3-CAP-Theorem"><a href="#8-3-CAP-Theorem" class="headerlink" title="8.3 CAP Theorem"></a>8.3 CAP Theorem</h4><ul>
<li>“Any distributed system cannot have <strong>Consistency, Availability, and Partition tolerance</strong> simultaneously”</li>
<li>Consistency: all nodes have the same latest copy of data </li>
<li>Availability: the system is up and running, able to serve client without failure</li>
<li>Partition tolerance:  The system is still operating correctly even group of nodes are down</li>
</ul>
<h4 id="8-4-Hashcash"><a href="#8-4-Hashcash" class="headerlink" title="8.4 Hashcash"></a>8.4 Hashcash</h4><ul>
<li><p>Introduced by Adam back in 1997</p>
</li>
<li><p>Proof of work (PoW) for control email spam</p>
</li>
<li><p>Sender must compute a hash for sending an email (as a proof that they have spent a reasonable amount of computing resources)</p>
</li>
<li><p>Generating hashcash is a compute intensive process, but easy and quick to verify (by receiver)</p>
</li>
<li><p>Acceptable to normal user Cost too much to spammer</p>
</li>
<li><p>B-Money</p>
<ul>
<li>Introduced by Wei Dai in 1998</li>
<li>Creating money via solving computational puzzles such as hashcash</li>
<li>Each node maintains its own list of transactions</li>
</ul>
</li>
<li><p>BitGold</p>
<ul>
<li>Nick Szabo, 2005</li>
<li>Solving computational puzzles to mint digital currency</li>
</ul>
</li>
<li><p>Cryptographic currency</p>
<ul>
<li>2005, Hal Finney</li>
<li>B-money + hashcash puzzles</li>
</ul>
</li>
<li><p>No clear solution to resolve conflict between nodes, must be relied on a centralized trusted authority</p>
</li>
</ul>
<h4 id="8-5-Bitcoin"><a href="#8-5-Bitcoin" class="headerlink" title="8.5 Bitcoin"></a>8.5 Bitcoin</h4><img src="https://pic.imgdb.cn/item/628881fc0947543129ff2426.jpg" style="zoom: 50%;" />

<ul>
<li>2009</li>
<li>Achieved distributed consensus in a trustless network</li>
<li>Public key cryptography with hashcash as PoW</li>
<li>Provide secure, controlled, and decentralized method of minting digital currency</li>
<li>Blockchain &#x3D; Electronic cash scheme + distributed systems</li>
</ul>
<img src="https://pic.imgdb.cn/item/6288830d0947543129fff851.jpg" style="zoom:67%;" />

<h4 id="8-6-Blockchain"><a href="#8-6-Blockchain" class="headerlink" title="8.6 Blockchain"></a>8.6 Blockchain</h4><p><strong>Tires of Blockchain Technology</strong></p>
<ul>
<li>Blockchain 1.0<ul>
<li>Cryptocurrencies</li>
</ul>
</li>
<li>Blockchain 2.0<ul>
<li>Financial services and contracts</li>
</ul>
</li>
<li>Blockchain 3.0<ul>
<li>Other Applications used in general-purpose industries such as government, health, media</li>
</ul>
</li>
</ul>
<p><strong>What is Blockchain</strong></p>
<ul>
<li>Platform for peers to exchange values using transactions without central trusted arbitrator -&gt; Decentralized consensus mechanism</li>
<li>Cryptographically secure</li>
<li>Append-only</li>
<li>Immutable</li>
<li>Updateable only via consensus among peers</li>
<li>Decentralized consensus mechanism</li>
<li>Distributed shared ledger.  Transaction are ordered and grouped into blocks</li>
<li>Data structure.  Linked list with hash pointers pointed to the previous block</li>
</ul>
<img src="https://pic.imgdb.cn/item/62888434094754312900cc68.jpg" style="zoom:67%;" />

<p><strong>Quick Question</strong></p>
<ul>
<li>How to carry a “private” communication in an open network?</li>
<li>How to identify (and prove) who are you in an open network?</li>
</ul>
<p><strong>Secure key</strong></p>
<img src="https://pic.imgdb.cn/item/628884db0947543129013d22.jpg" style="zoom:67%;" />

<p><strong>Public and Private Key</strong></p>
<img src="https://pic.imgdb.cn/item/6288851f0947543129016b8c.jpg" style="zoom:67%;" />

<img src="https://pic.imgdb.cn/item/628885390947543129018016.jpg" style="zoom:67%;" />

<p><strong>Protection Against Eavesdropping</strong></p>
<img src="https://pic.imgdb.cn/item/628886e4094754312902b569.jpg" style="zoom:67%;" />

<p><strong>Digtal signature</strong></p>
<img src="C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20220521143029919.png" alt="image-20220521143029919" style="zoom:67%;" />

<p><strong>Hash function</strong></p>
<ul>
<li>Take a string with any length</li>
<li>Output a fixed length hash code</li>
<li>Small change in the string will give a totally different hash code</li>
</ul>
<img src="https://pic.imgdb.cn/item/6288874509475431290317c2.jpg" style="zoom:67%;" />

<p><strong>Blockchain</strong></p>
<img src="https://pic.imgdb.cn/item/62888861094754312903f715.jpg" style="zoom:67%;" />

<img src="https://pic.imgdb.cn/item/6288887509475431290406bd.jpg" style="zoom:67%;" />

<p>The nonce is the number that blockchain miners are solving for.</p>
<img src="https://pic.imgdb.cn/item/628889050947543129046c4c.jpg" style="zoom:67%;" />

<p><strong>Nonce</strong></p>
<p>随机数</p>
<ul>
<li>Nonce, or a “number only used once,” refers to the first number a blockchain miner needs to discover before solving for a block in the blockchain. </li>
<li>Once the mathematical computations are solved by the miner, they are gifted cryptocurrency for their time and skill. </li>
<li>Nonces are difficult to find and are considered a way to weed out the less talented crypto miners. </li>
<li>The world of crypto mining is challenging, and one often needs excellent computational power to even begin to try and solve the nonce.</li>
</ul>
<p><strong>Generic Element of Blockchain</strong></p>
<ul>
<li>Addresses<ul>
<li>Unique identifiers used in a transaction stored in blockchain</li>
<li>Contain sender and recipient information</li>
<li>Public key or derived from a public key</li>
<li>Can be reused (for the same user) or one-off</li>
</ul>
</li>
<li>Transaction<ul>
<li>Fundamental unit of a blockchain</li>
<li>Transfer of value from one address to another</li>
</ul>
</li>
<li>Blocks<ul>
<li>A block is composed of multiple transactionsIt also contains other elements, like previous block hash, timestamp, nonce</li>
</ul>
</li>
<li>Peer-to-peer network<ul>
<li>Network topology for peer to peer communication</li>
</ul>
</li>
<li>Scripting or programming language, Virtual machine<ul>
<li>Predefined sets of commands for nodes to transfer tokens</li>
</ul>
</li>
<li>Nodes<ul>
<li>Node in a blockchain network</li>
<li>Provide various functions depending on its role<ul>
<li>Propose and validate transaction</li>
<li>Mining to facilitate consensus and secure the blockchain</li>
</ul>
</li>
</ul>
</li>
<li>Smart contracts<ul>
<li>Program runs on top of the blockchain</li>
<li>Business logic to be executed when certain conditions are met.</li>
<li>These actions could include releasing funds to the appropriate parties, registering a vehicle, sending notifications, or issuing a ticket</li>
</ul>
</li>
</ul>
<p><strong>Blockchain: Features</strong></p>
<ul>
<li>Distributed consensus<ul>
<li>Achieve a single version of truth (agreed by all parties) without the need of a central authority</li>
</ul>
</li>
<li>Transaction verification<ul>
<li>Only transaction that fulfills the predetermined set of rules can be included in a block</li>
</ul>
</li>
<li>Platforms for smart contracts<ul>
<li>Execute business logic on behalf of the user </li>
<li>Not all blockchains support the execution of smart contract</li>
<li>Desirable feature</li>
</ul>
</li>
<li>Transferring value between peers</li>
<li>Generating cryptocurrency<ul>
<li>Reward to the miners who validate the transactions and secure the blockchain</li>
</ul>
</li>
<li>Smart property<ul>
<li>Allow someone claim the ownership of property in blockchain</li>
</ul>
</li>
<li>Immutability<ul>
<li>Transaction added onto the blockchain is immutable</li>
</ul>
</li>
</ul>
<p><strong>Accumulate Blocks</strong></p>
<ul>
<li>A node uses its private key to sign a transaction </li>
<li>The transaction is propagated to peers which validate the transaction based on the pre-set criteria.  (multiple peers are generally required)</li>
<li>After validation, transaction is added to a block.  The block will propagate onto the network (Transaction confirmed)</li>
<li>Next block links to the block created in (3).  Transaction is double confirmed when the newly added block is confirmed</li>
<li>Reconfirm the transaction whenever a new block is created.  </li>
<li>After six confirmations in the bitcoin network, the transaction is final</li>
</ul>
<p><strong>Benefit</strong></p>
<ul>
<li>Decentralization</li>
<li>Transparency and trust<ul>
<li>Blockchains are shared</li>
</ul>
</li>
<li>Immutability </li>
<li>It is extremely difficult to change the confirmed data back</li>
<li>High availability <ul>
<li>Involve thousands of nodes in a peer-to-peer network</li>
<li>Data is replicated and updated on each and every node</li>
</ul>
</li>
<li>Highly secure<ul>
<li>All transactions on a blockchain are cryptographically secured and provide integrity</li>
</ul>
</li>
</ul>
<p><strong>Challenges and Limitations</strong></p>
<ul>
<li>Scalability</li>
<li>Adaptability</li>
<li>Regulation</li>
<li>Relatively immature technology</li>
<li>Privacy</li>
</ul>
<p><strong>Decentralization and Blockchain</strong></p>
<ul>
<li>Central<ul>
<li>client-server system</li>
<li>Single authority controls the system</li>
</ul>
</li>
<li>Distributed<ul>
<li>Data and computation are distributed to multiple nodes in the network</li>
<li>Central authority control all nodes and governs processing</li>
</ul>
</li>
<li>Decentralized<ul>
<li>No authority exists</li>
<li>Nodes are not dependent on a single master node</li>
<li>Decentralized consensus</li>
</ul>
</li>
<li>Disintermediation<ul>
<li>In blockchain, everyone can add a transaction into a block, no intermediary is involved</li>
</ul>
</li>
<li>Through competition<ul>
<li>Instead of eliminating the intermediary, the system provides free choice of intermediary</li>
<li>E.g. Smart contract in blockchain</li>
</ul>
</li>
</ul>
<p><strong>Blockchain and Full Ecosystem Decentralization</strong></p>
<ul>
<li>Storage<ul>
<li>Blockchain is not designed to store large amounts of data, e.g. image</li>
<li>It aims to store simple transaction </li>
<li>One can use distributed hash tables (DHTs), originally come from peer-to-peer file sharing software, e.g. BitTorrent</li>
<li>Inter Planetary File System (IPFS), Juan Benet, a decentralized World Wide Web, using Kadamlia DHT and merkle DAG(Directed Acyclic Graph) to provide the storage and searching functionality.</li>
<li>Filecoin: pays incentives to nodes that store data using the BitSwap mechanism</li>
</ul>
</li>
<li>Communication<ul>
<li>Internet is decentralized by design</li>
<li>But in practical, central authority (e.g. ISP, email server provider) is in control</li>
<li>Some apps support communication in a peer-to-peer fashion without the Internet</li>
</ul>
</li>
<li>Computation<ul>
<li>With blockchain technology, e.g. Ethereum, one can send cryptocurrency to anyone for a small fee. </li>
<li>E.g. smart contracts with embedded business logic can run on the network</li>
</ul>
</li>
</ul>
<h4 id="8-7-Bitcoin-2"><a href="#8-7-Bitcoin-2" class="headerlink" title="8.7 Bitcoin(2)"></a>8.7 Bitcoin(2)</h4><p><strong>Bitcoin Transaction</strong></p>
<ul>
<li>Bitcoin transaction tells the network that the owner of some bitcoin value has authorized the transfer of that value to another owner</li>
<li>New owner sends the bitcoin by creating another similar transaction</li>
</ul>
<img src="https://pic.imgdb.cn/item/6288943709475431290c4b3c.jpg" style="zoom:67%;" />

<ul>
<li>Each transaction contains one or more “inputs” and “outputs”</li>
<li>Inputs: bitcoin account to be debited</li>
<li>Outputs: bitcoin account to be creditedInputs and outputs are in bitcoin address</li>
<li>Unspent bitcoin is output to original owner with same &#x2F; different bitcoin address</li>
<li>Transactions move value from transaction inputs to transaction outputs</li>
</ul>
<p><strong>Common Transaction Forms</strong></p>
<img src="https://pic.imgdb.cn/item/6288950509475431290ce7fc.jpg" style="zoom:67%;" />

<p><strong>Transaction input</strong></p>
<ul>
<li>Full-node client <ul>
<li>Contains a copy of every unspent output from every transaction in the blockchain</li>
<li>Able to construct transaction inputs</li>
<li>Quickly verify incoming transaction (having correct inputs) </li>
<li>Requires a lot of disk space</li>
</ul>
</li>
<li>Lightweight client<ul>
<li>May track only the user’s own unspent outputs</li>
</ul>
</li>
<li>Wallet application without unspent transaction output<ul>
<li>Needs to query the bitcoin network or asking a full-node to retrieve unspent transaction output</li>
</ul>
</li>
</ul>
<p><strong>Transaction Output</strong></p>
<ul>
<li>Script that creates a claim on the value and can only be redeemed by the introduction of a solution to the script</li>
<li>E.g. A transaction output will contain a script that says something like “This output is payable to whoever can present a signature from the key corresponding to “B” public address”</li>
<li>Since only B’s wallet has the signature, B can present the signature and redeem the output</li>
<li>Transaction fee is outputted to miner for validating and including the transaction in a block to be recorded on the blockchain</li>
</ul>
<p>**Transaction Confirmation **</p>
<ul>
<li>Bitcoin network is a peer to peer network</li>
<li>Node connects to several other nodes in bitcoin network</li>
<li>Nodes exchange transactions and blocks</li>
<li>New transaction is flooded to all clients</li>
<li>New transaction will be validated by multiple nodes and added to the blockchain </li>
<li>Direct connection between input node and output node is not required</li>
</ul>
<p><strong>Bitcoin Mining</strong></p>
<ul>
<li>New transaction will be firstly added to the temporary pool of unverified transaction maintained by each node</li>
<li>Miner constructs a new block with the following elements<ul>
<li>Unverified transactions from temporary pool</li>
<li>Previous block reference</li>
<li>Transaction that pays his own bitcoin address as the block reward</li>
<li>Transaction fee of including all transaction in this block</li>
</ul>
</li>
<li>Miner proves the validity of his new block, which is computation intensive </li>
<li>Multiple miners are involved in the step (2) and (3), each includes a special transaction in his block (transaction fee)</li>
<li>The miners who firstly provides the proof of the validity of his block wins the competition and his block will be added to the blockchain</li>
</ul>
<p><strong>Nodes in Bitcoin Network</strong></p>
<ul>
<li>Full Nodes<ul>
<li>Core clients</li>
<li>Functionality: Wallet, miner, full blockchain storage, network routing functions</li>
</ul>
</li>
<li>SPV (Simplified Payment Verification) Nodes<ul>
<li>Lightweight clients</li>
<li>Wallet and network routing</li>
</ul>
</li>
<li>Pool protocol Servers<ul>
<li>Nonstandard nodes</li>
<li>Using alternative protocols, e.g. stratum protocol</li>
<li>Mainly for mining and compute hashes</li>
</ul>
</li>
</ul>
<p><strong>Bitcoin Wallets</strong></p>
<ul>
<li>Software which stores private or public keys and bitcoin address</li>
<li>Receiving bitcoins</li>
<li>Sending bitcoins</li>
<li>Do not store any coins</li>
<li>In bitcoin network, coins do not exist</li>
<li>Only transaction information is stored on the blockchain</li>
</ul>
<p><strong>Wallet Types</strong></p>
<ul>
<li>Non-deterministic wallets<ul>
<li>Contain randomly generated private keys (Just a bunch of Key wallets)</li>
<li>Bitcoin core client generates some keys when first started or when required</li>
<li>Managing a large number of key is very difficult and an error prone process (theft and loss of coins) and need to create regular backups</li>
</ul>
</li>
<li>Deterministic wallets<ul>
<li>Key are derived out of a seed value via hash functions</li>
<li>Seed number is generated randomly</li>
<li>Seed number is represented by human-readable mnemonic code words</li>
<li>All keys can be recovered by mnemonic code</li>
</ul>
</li>
<li>Hierarchical Deterministic Wallets<ul>
<li>Does not generate keys directly, it only produces some information that can be used to generate a sequence of private keys</li>
<li>Store keys in a tree structure derived from a seed</li>
<li>The seed generates the parent key (master key), which is used to generate child keys (which is used to generate grandchild keys</li>
<li>Easily recoverable, maintain</li>
<li>Highly portable</li>
</ul>
</li>
<li>Brain wallets<ul>
<li>Master private key is derived from the hash of passwords that are memorized</li>
<li>HD wallets derived from a single memorized password</li>
<li>Subject to password guessing and brute force attacks</li>
</ul>
</li>
<li>Paper wallets<ul>
<li>Required key material is printed on a paper</li>
</ul>
</li>
<li>Hardware wallets<ul>
<li>Use custom-built device or NFC-enabled phone to store keys</li>
</ul>
</li>
<li>Online wallets<ul>
<li>Store keys in cloud service provider</li>
<li>Users manage their keys via web interface</li>
</ul>
</li>
<li>Mobile wallets<ul>
<li>Wallets are installed on mobile device</li>
<li>Use camera to scan QR code and make payments</li>
</ul>
</li>
</ul>
<h4 id="8-8-Exercise"><a href="#8-8-Exercise" class="headerlink" title="8.8 Exercise"></a>8.8 Exercise</h4><p><strong>In-Class Exercise 1</strong></p>
<p><strong>Briefly describe how the public and private key are used in blockchain and bitcoin.</strong>  </p>
<p>Answers:</p>
<ul>
<li>Public key will be used as the address of the sender or the recipient of a transaction.  </li>
<li>Private key presents the ownership of the bitcoin and will be used to sign transactions (fund transfer).</li>
</ul>
<p><strong>In-Class Exercise 2</strong></p>
<p><strong>Consider the following Bitcoin transactions.</strong></p>
<img src="https://pic.imgdb.cn/item/6288983d09475431290f57b7.jpg" style="zoom:67%;" />

<p><strong>What is the value of X in the last transaction?</strong></p>
<p>X &#x3D; 0.3BTC （1.0 - 0.5 - 0.2）</p>
<p>**Suppose the following addresses are stored in Peter’s Wallet  **</p>
<p>**3xADF341e **</p>
<p><strong>a4Y0a23bb</strong></p>
<p><strong>What is the final balance of Peter’s Bitcoin account after all these transactions?</strong> </p>
<p>Ans &#x3D; 8.1BTC （7 + 0.9 + 0.2）</p>
]]></content>
      <categories>
        <category>HKU</category>
      </categories>
      <tags>
        <tag>HKU</tag>
      </tags>
  </entry>
  <entry>
    <title>java核心技术记录</title>
    <url>/2022/05/17/java-core/</url>
    <content><![CDATA[<p>本文记录了Java的一些核心技术和易混淆的概念</p>
<span id="more"></span>

<h4 id="对Java平台的理解"><a href="#对Java平台的理解" class="headerlink" title="对Java平台的理解"></a>对Java平台的理解</h4><p>Java本身是一种面向对象的语言，最显著的特性有两个方面：</p>
<ul>
<li><strong>“书写一次，到处运行”</strong>（Write once, run anywhere），能够非常容易地获得跨平台能力</li>
<li><strong>垃圾收集</strong>（GC, Garbage Collection），Java通过垃圾收集器（Garbage Collector）回收分配内存，大部分情况下，程序员不需要自己操心内存的分配和回收</li>
</ul>
<p>我们日常会接触到 <strong>JRE</strong>（Java Runtime Environment）或 <strong>JDK</strong>（Java Development Kit）。JRE是Java运行环境，包含了JVM和Java类库，以及一些模块等。JDK是JRE的一个超集，提供了更多工具，比如编译器，各种诊断工具等。</p>
<p>我们开发的Java的源代码，首先通过Javac编译称为字节码（bytecode），然后，在运行时，通过Java虚拟机（JVM）内嵌的解释器将字节码转换成为最终的机器码。但是常见的JVM都提供了JIT（Just-In-Time）编译器，也就是常说的动态编译器，JIT能够在运行时将热点代码编译成机器码，这种情况下部分热点代码就属于编译执行，而不是解释执行了。</p>
<p><strong>JVM的基础概念和机制</strong></p>
<ul>
<li>Java的类加载机制，常用版本JDK（如JDK8）内嵌的Class-Loader，如Bootstrap、Application和Extension Class-Loader</li>
<li>类加载大致过程：加载、验证、链接、初始化</li>
<li>自定义Class-Loader</li>
<li>垃圾收集的基本原理，最常见的垃圾收集器，如SerialGC，ParallelGC，CMS，G1等，要清楚适用于什么样的工作负载</li>
<li>JDK包含的各种工具：编译器、运行时环境、安全工具、诊断和监控工具</li>
</ul>
<h4 id="Exception和Error的区别"><a href="#Exception和Error的区别" class="headerlink" title="Exception和Error的区别"></a>Exception和Error的区别</h4><p>Exception和Error都是继承了Throwable类，在Java中只有Throwable类型的实例才可以被抛出（throw）或者捕获（catch），它是异常处理机制的基本组成类型。</p>
<p>Exception和Error体现了Java平台设计者对不同异常情况的分类。</p>
<ul>
<li>Exception是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应处理。</li>
<li>Error是指在正常情况下，不大可能出现的情况，绝大部分的Error都会导致程序（比如JVM自身）处于非正常的、不可恢复状态。既然是非正常情况，所以不便于也不需要捕获，常见的比如OutOfMemoryError之类，都是Error的子类。</li>
</ul>
<p>Exception又分为可检查（checked）异常和不检查（unchecked）异常，可检查异常在源代码里必须显式地进行捕获处理，这是编译期检查的一部分。前面说的不可查的Error，是Throwable不是Exception。</p>
<p>不检查异常就是所谓的运行时异常，类似NullPointerException、ArrayIndexOutOfBoundsException之类，通常是可以编码避免的逻辑错误，具体根据需要来判断是否需要捕获，并不会在编译器强制要求。</p>
<p>理解Throwable，Exception，Error的设计和分类。比如，掌握那些应用最为广泛的子类，以及如何自定义异常等。</p>
<img src="https://pic.imgdb.cn/item/628f36cc0947543129fb1a24.jpg" style="zoom:80%;" />

<p>其中有些子类型，要重点理解一下，比如<br>NoClassDefFoundError和ClassNotFoundException有什么区别，这也是一个经典的入门问题。</p>
<img src="https://pic.imgdb.cn/item/628f379e0947543129fc7ec9.jpg" style="zoom: 80%;" />



<p>从性能角度来审视一下java的异常处理机制，这里有两个可能会相对昂贵的地方：</p>
<ul>
<li>try-catch代码段会产生额外的性能开销，或者换个角度说，他往往会影响JVM对代码进行优化，所以建议仅捕获有必要的代码段，尽量不要一个大的try包住整段的代码；与此同时，利用异常控制代码流程，也不是一个好主意，远比我们通常意义上的条件语句（if&#x2F;else,switch）要低效</li>
<li>java每实例化一个Exception，都会对当时的栈进行快照，这是一个相对比较重的操作。如果发生的非常的频繁，这个开销可能就不能被忽略了。</li>
</ul>
<h4 id="final、finally、finalize的区别"><a href="#final、finally、finalize的区别" class="headerlink" title="final、finally、finalize的区别"></a>final、finally、finalize的区别</h4><ul>
<li>final可以用来修饰类、方法、变量，分别有不同的意义，final修饰的class代表不可以继承扩展，final的变量是不可以修改的，而final的方法也是不可以重写的（override）</li>
<li>finally则是保证重点代码一定要被执行的一种机制。我们可以使用try-finally或者try-catch-finally来进行类似关闭JDBC连接、保证unlock锁等动作。</li>
<li>finalize是基础类java.lang.Object的一个方法，它的设计目的是保证对象在被垃圾收集前完成特定资源的回收。finalize机制现在已经不推荐使用，并在JDK 9 开始被标记为deprecated</li>
</ul>
<p>可以发现Java核心类库的定义或源码下（java.lang包下的很多类）和第三方类库的一些基础类中相当一部分都被声明为final class，目的是为了有效避免API使用者更改基础功能，是保证平台安全的必要手段</p>
<ul>
<li>使用final修饰参数或者变量，也可以清楚地避免意外赋值导致的编程错误</li>
<li>final变量产生了某种程度的不可变（immutable）的效果（但是并不等同，例如声明为final的List仍然可以正常添加元素，对象行为不被final影响，只能约束List这个引用不可以被赋值），所以可以用于保护只读数据，尤其是在并发编程中，因为明确地不能再赋值final变量，有利于减少额外的同步开销，也可以省去一些防御性拷贝的必要</li>
</ul>
<p>要实现immutable的类，我们需要做到：</p>
<ul>
<li>将class自身声明为final，这样别人就不能扩展来绕过限制了</li>
<li>将所有成员变量定义为private和final，并且不要实现setter方法</li>
<li>通常构造对象时，成员变量使用深度拷贝来初始化，而不是直接赋值，这是一种防御措施，因为无法确定输入对象不被其他人修改</li>
<li>如果确实需要实现getter方法，或者其他可能会返回内部状态的方法，使用copy-on-write原则，创建私有的copy</li>
</ul>
<h4 id="强引用、软引用、弱引用、幻象引用的区别"><a href="#强引用、软引用、弱引用、幻象引用的区别" class="headerlink" title="强引用、软引用、弱引用、幻象引用的区别"></a>强引用、软引用、弱引用、幻象引用的区别</h4><p>在Java语言中，除了原始数据类型的变量，其他所有都是所谓的应用类型，指向各种不同的对象。</p>
<p>不同的引用类型，主要体现的是对象不同的可达性（reachable）状态和对垃圾收集的影响</p>
<ul>
<li>所谓强引用（“Strong” Reference），就是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为null，就是可以被垃圾收集的了，当然具体回收时机还是要看垃圾收集策略。</li>
<li>软引用（SoftReference）是一种相对强引用弱化一些的应用，可以让对象豁免一些垃圾收集，只有当JVM认为内存不足时，才会去试图回收软引用指向的对象。JVM会确保在抛出OutOfMemoryError之前，清理软引用指向的对象。软引用通常用来实现内存敏感的缓存，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</li>
<li>弱引用（WeakReference）并不能使对象豁免垃圾收集，仅仅是提供一种访问在弱引用状态下对象的途径。这就可以用来构建一种没有特定约束的关系，比如，维护一种非强制性的映射关系，如果试图获取时对象还在，就使用它，否则重现实例化。它同样是很多缓存实现的选择</li>
<li>对于幻象引用，有时也翻译为虚引用，你不能通过它访问对象。幻象引用仅仅是提供了一种确保对象被finalize以后，做某些事情的机制，比如通常用来做所谓的Post-Mortem清理机制。</li>
</ul>
<h4 id="String、StringBuffer、StringBuilder的区别"><a href="#String、StringBuffer、StringBuilder的区别" class="headerlink" title="String、StringBuffer、StringBuilder的区别"></a>String、StringBuffer、StringBuilder的区别</h4><ul>
<li>String是Java语言非常基础和重要的类，提供了构造和管理字符串的各种基本逻辑。它是典型的Immutable类，被声明称为final class，所有属性也都是final的。也由于它的不可变性，类似拼接、裁剪字符串等动作，都会产生新的String对象。由于字符串操作的普遍性，所以相关操作的效率往往对应用性能有明显影响。</li>
<li>StringBuffer是为解决上面提到拼接产生太多中间对象的问题而提供的一个类，我们可以用append或者add方法，把字符串添加到已有序列的末尾或者指定位置。StringBuffer本质是一个线程安全的可修改字符序列，它保证了线程安全，也随之带来了额外的性能开销，所以除非有线程安全的需要，不然还是推荐使用它的后继者，也就是StringBuilder</li>
<li>StringBuilder是Java1.5中新增的，在能力上和StringBuffer没有本质区别，但是它去掉了线程安全的部分，有效减小了开销，是绝大部分情况下进行字符串拼接的首选</li>
</ul>
<h4 id="反射机制、动态代理基于的原理"><a href="#反射机制、动态代理基于的原理" class="headerlink" title="反射机制、动态代理基于的原理"></a>反射机制、动态代理基于的原理</h4><p>编程语言通常有各种不同的分类角度，动态类型和静态类型是其中一种分类角度，简单区分就是语言类型信息是在运行时检查，还是编译期检查</p>
<p>与其近似的还有一个对比，就是所谓强类型和弱类型，就是不同类型变量赋值时，是否需要显式地（强制）进行类型转换</p>
<p>通常认为Java是静态的强类型语言，但是因为提供了类似反射等机制，也具备了部分动态类型语言的能力</p>
<ul>
<li><p>反射机制是Java语言提供的一种基础功能，赋予程序在运行时自省（introspect）的能力。<u>通过反射我们可以直接操作类或对象，比如获取某个对象的类定义，获取类声明的属性和方法，调用方法或者构造对象，设置可以运行时修改类定义</u></p>
<ul>
<li>Class.forName(“XXX”)会进行类加载，如果类中有static方法，也会在此时执行</li>
<li>Class.forName(“XXX”).newInstance()实例化一个对象，newInstance只能是无参构造</li>
</ul>
</li>
<li><p>动态代理是一种方便运行时动态构建代理、动态处理代理方法调用的机制，很多场景都是利用类似机制做到的，比如用来包装RPC调用、面向切面的编程（AOP）</p>
</li>
<li><p>实现动态代理的方式很多，比如JDK自身提供的动态代理，就是主要利用了上面提到的反射机制。还有其他的实现方式，比如利用传说中更高性能的字节码操作机制，类似ASM、cglib（基于ASM）、Javassist等</p>
</li>
</ul>
<p>动态代理到底解决什么问题？</p>
<ul>
<li>首先它是一个代理机制，如果熟悉设计模式中的代理模式，我们会知道，代理可以看做是对调用目标的一个包装，这样我们对目标代码的调用不是直接发生的，而是通过代理完成。其实很多动态代理场景，也可以看做是装饰器（Decorator）模式的应用。</li>
<li>通过代理可以让调用者和实现者之间解耦，比如进行RPC调用，框架内部的寻址、序列化、反序列化等，对于调用者往往是没有太大意义的，通过代理，可以提供更加友善的界面</li>
</ul>
<h4 id="int和Integer的区别"><a href="#int和Integer的区别" class="headerlink" title="int和Integer的区别"></a>int和Integer的区别</h4><ul>
<li>int是我们常说的整型数字，是Java的8个原始数据类型（Primitive Types, boolean、byte、short、char、int、float、double、long）之一。Java语言虽然号称一切都是对象，但是原始数据类型是例外</li>
<li>Integer是int对应的包装类，它有一个int类型的字段存储数据，并且提供了基本操作，比如数学运算、int和字符串之间转换等。在Java5中，引入了自动装箱和自动拆箱功能（boxing&#x2F;unboxing）功能，Java可以根据上下文，自动进行转换，极大地简化了相关编程</li>
<li>关于Integer的值缓存，这设计Java5中另一个改进。构建Integer对象的传统方式是直接调用构造器，直接new一个对象。但是根据时间，我们发现大部分数据操作都是几种在有限的、较小的数值范围，因而在Java5中新增了静态工厂方法valueOf，在调用它的时候<u>会利用一个缓存机制，带来了明显的性能改进。按照Javadoc，这个值默认缓存是-128到127之间</u>（使用缓存中包含的实例对象，而不是创建一个新的实例（在自动装箱的情况下）可以提高性能）</li>
</ul>
<p><strong>理解自动装箱、拆箱：</strong></p>
<ul>
<li>自动装箱实际上算是一种<strong>语法糖</strong>（可以简单理解为Java平台为我们自动进行了一些转换，保证不同的写法在运行时等价，它们发生在编译阶段，也就是生成的字节码是一致的）</li>
<li>比如前面提到的整数，javac替我们自动把装箱转换为<code>Integer.valueOf()</code>,把拆箱替换为<code>Integer.intValue()</code>，由于调用的是 <code>valueOf()</code>，自然能够得到缓存的好处。其他一些包装类中也存在缓存机制：<ul>
<li>Boolean，缓存了true&#x2F;false对应实例，确切说，只会返回两个常量实例Boolean.TRUE&#x2F;FALSE</li>
<li>Short，同样是缓存了-128到127之间的数值</li>
<li>Byte，数值有限，所以全部被缓存</li>
<li>Character，缓存范围‘u0000’到‘u007F’</li>
</ul>
</li>
<li>实际编程中使用自动装箱&#x2F;自动拆箱的注意事项：<ul>
<li>原则上建议避免无意中的装箱、拆箱行为，尤其是在性能敏感的场合，创建10万个Java对象和10万个整数的开销不是一个数量级的，不管是内存使用还是处理速度，光是对象头的空间占用就已经是数量级的差距了</li>
<li>将这个观点扩展开可以得到：使用原始数据类型、数组甚至本地代码实现等，在性能极度敏感的场景往往具有比较大的优势，用其替换掉包装类、动态数组（如ArrayList）等可以作为性能优化的备选项。（但是开发效率可能会降低）</li>
</ul>
</li>
</ul>
<p><strong>Java原始数据类型和引用类型局限性</strong></p>
<p>对于Java应用开发者，设计复杂而灵活的类型系统似乎已经习以为常了，但是这种设计是源于很多年前的技术决定，现在已经逐渐暴露出了一些副作用，例如：</p>
<ul>
<li><p>原始数据类型和Java泛型并不能配合使用</p>
<p>这是因为Java的泛型某种程度上可以算作伪泛型，它完全是一种编译期的技巧，Java编译期会自动将类型转换为对应的特定类型，这就决定了使用泛型，必须保证相应类型可以转换为Object</p>
</li>
<li><p>无法高效地表达数据，也不便于表达复杂的数据结构，比如vector和tuple</p>
<p>我们知道Java的对象都是引用类型，如果是一个原始数据类型数组，它在内存里是一段连续的内存，而对象数组则不然，数据存储的是引用，对象往往是分散地存储在堆的不同位置。这种设计虽然带来了极大灵活性，但是也导致了数据操作的低效，尤其是无法充分利用现代CPU缓存机制</p>
</li>
</ul>
<h4 id="Vector、ArrayList、LinkedList的区别"><a href="#Vector、ArrayList、LinkedList的区别" class="headerlink" title="Vector、ArrayList、LinkedList的区别"></a>Vector、ArrayList、LinkedList的区别</h4><p>这三者都是实现集合框架中的List，也就是所谓的有序集合，因此具体功能也比较近似，比如都提供按照位置进行定位、添加或者删除的操作，都提供迭代器以遍历其内容等。但因为具体的设计区别，在行为、性能、线程安全等方面，表现又有很大不同</p>
<ul>
<li>Vector是Java早期提供的线程安全的动态数组，如果不需要线程安全，并不建议选择，毕竟同步是有额外开销的。Vector内部是使用对象数组来保存数据，可以根据需要自动的增加容量，当数组已满时，会创建新的数组，并拷贝原有数组数据。</li>
<li>ArrayList是应用更加广泛的动态数组实现，它本身不是线程安全的，所以性能要好很多。与Vector近似，ArrayList也是可以根据需要调整容量，不过两者的调整逻辑有所区别，Vector在扩容时会提高1倍，而ArrayList则是增加50%</li>
<li>LinkedList顾名思义是Java提供的双向链表，所以它不需要像上面两种那样调整容量，它也不是线程安全的</li>
</ul>
<p>补充不同容器类型适合的场景：</p>
<ul>
<li>Vector和ArrayList作为动态数组，其内部元素以数组形式顺序存储的，所以非常适合随机访问的场合。除了尾部插入和删除元素，往往性能会相对较差，比如我们在中间位置插入一个元素，需要移动后续所有元素。</li>
<li>而LinkedList进行节点插入、删除却要高效得多，但是随机访问性能则要比动态数组慢</li>
</ul>
<p>所以在应用开发中，如果实现可以顾及到，应用操作是偏向于插入、删除，还是随机访问较多，就可以针对性的进行选择。</p>
<p>集合框架图：</p>
<img src="https://pic.imgdb.cn/item/629106b909475431297bda7e.jpg" style="zoom:80%;" />

<h4 id="Hashtable、HashMap、TreeMap的区别"><a href="#Hashtable、HashMap、TreeMap的区别" class="headerlink" title="Hashtable、HashMap、TreeMap的区别"></a>Hashtable、HashMap、TreeMap的区别</h4><p>Hashtable、HashMap、TreeMap都是常见的一些Map实现，是以键值对的形式存储和操作数据的容器类型</p>
<ul>
<li>Hashtable是早期Java类库提供的一个哈希表实现，本身是同步的，不支持null键和值，由于同步导致的性能开销，所以已经很少被推荐使用。</li>
<li>HashMap是应用更加广泛的哈希表实现，行为上大致上与HashTable一致，主要区别在与HashMap不是同步的，支持null键和值等。通常情况下，HashMap进行put或者get操作，可以达到常数时间的性能，所以它是绝大部分利用键值对存取场景的首选，比如，实现一个ID和用户信息对应的运行时存储结构，</li>
<li>TreeMap则是基于红黑树的一种提供顺序访问的Map，和HashMap不同，它的get、put、remove之类的操作都是O(log(n))的时间复杂度，具体顺序可以由指定的Comparator来决定，或者根据键的自然顺序来判断</li>
</ul>
<p><strong>HashMap内部结构分析</strong></p>
<p>HashMap可以看做是数组（Node[] table）和链表结合组成的复合结构，数组被分为一个个桶（bucket），通过哈希值决定了键值对在这个数组的寻址；哈希值相同的键值对，则以链表形式存储。参考如下示意图，注意当链表大小超过阈值（TREEIFY_THRESHOLD，8），链表就会被改造为树形结构。</p>
<img src="https://pic.imgdb.cn/item/6291c90e094754312958e9b5.jpg" style="zoom:80%;" />

<p>从非拷贝构造函数的实现来看，这个表格（数组）似乎并没有在最初就初始化好，仅仅设置了一些初始值而已：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> + loadFactor);</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以我们深刻怀疑，HashMap也许是按照lazy-load原则，在首次使用时被初始化（拷贝构造函数除外，这里仅介绍最通用的场景）。既然如此，去看看put方法实现，似乎只有一个putVal的调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>截取putVal中比较关键的部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">            treeifyBin(tab, hash);</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现：</p>
<ul>
<li><p>如果表格是null，resize方法会负责初始化它，这从tab &#x3D; resize()可以看出</p>
</li>
<li><p>resize方法兼顾两个职责，创建初始存储表格，或者在容量不满足需求的时候，进行扩容（resize）</p>
</li>
<li><p>在放置新的键值对的过程中，如果发生下面条件，就会发生扩容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br></pre></td></tr></table></figure>
</li>
<li><p>具体键值对在哈希表中的位置（数组index）取决于下面的位运算：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">i = (n - <span class="number">1</span>) &amp; hash</span><br></pre></td></tr></table></figure>

<p>仔细观察哈希值的源头，我们会发现，它并不是key本身的hashCode，而是来自于HashMap内部的另一个hash方法。注意为什么这里需要将高位数据移位到低位进行异或运算呢？这是因为有些数据计算出的哈希值差异主要在高位，而HashMap里的哈希寻址是忽略容量以上的高位的，那么这种处理就可以有效避免类似情况下的哈希碰撞</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span>&#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>进一步分析一下身兼多职的resize方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">       Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">       <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">       <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">       <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">               threshold = Integer.MAX_VALUE;</span><br><span class="line">               <span class="keyword">return</span> oldTab;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">               newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">           newCap = oldThr;</span><br><span class="line">       <span class="keyword">else</span> &#123;               </span><br><span class="line">           <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">           newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">           newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">           newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                     (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">       &#125;</span><br><span class="line">       threshold = newThr;</span><br><span class="line">       <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">       Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">       table = newTab;</span><br><span class="line">       <span class="comment">//......移动到新的数组结构e数组结构</span></span><br><span class="line">    </span><br><span class="line">       <span class="keyword">return</span> newTab;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>依据resize源码，不考虑极端情况（容量理论最大极限由MAXIMUM_CAPACITY指定，数值为1&lt;&lt;30，也就是2的30次方），我们可以归纳为：</p>
<ul>
<li>门限值等于（负载因子）*（容量），如果苟江HashMap的时候没有指定它们，那么就是依据相应的默认常量值。</li>
<li>门限通常是以倍数进行调整（newThr &#x3D; oldThr &lt;&lt; 1），前面提到，根据putVal中的逻辑，当元素个数超过门限大小时，则调整Map大小</li>
<li>扩容后，需要将老的数组中的元素重新房知道新的数组，这是扩容的一个主要开销来源</li>
</ul>
<p><strong>容量、负载因子和树化</strong></p>
<p>为什么我们需要在乎容量和负载因子呢？</p>
<ul>
<li>这是因为容量和负载系数决定了可用的桶的数量，空桶太多会浪费空间，如果使用的太满则会严重影响操作的性能。极端情况下，假设只有一个桶，那么它就退化成了链表，完全不能提供所谓常数时间存的性能。</li>
</ul>
<p>在实践中应该如何选择呢？</p>
<ul>
<li>如果能够知道HashMap要存取的键值对数量，可以考虑预先设置合适的容量大小，具体数值可以通过 <strong>负载因子 * 容量 &gt; 元素数量</strong> 来预估</li>
</ul>
<p>对于负载因子的建议：</p>
<ul>
<li>如果没有特别需求，不要轻易进行更改，因为JDK自身 的默认负载因子是非常符合通用场景的需求的</li>
<li>如果确实需要调整，建议不要设置超过0.75的数值，因为会显著增加冲突，降低HashMap的性能</li>
<li>如果使用太小的负载因子，按照公式，预设容量值也进行调整，否则可能会导致更加频繁的扩容，增加无谓的开销，本身访问性能也会受影响</li>
</ul>
<p>关于树化改造，对应逻辑主要在putVal和treeifyBin中，那么为什么要进行树化呢？</p>
<ul>
<li>本质上是个安全问题。因为在元素放置过程中，如果一个对象哈希冲突，都被放置到同一个桶里，则会形成一个链表，我们知道连表查询是线性的，会严重影响存取的性能。</li>
<li>而实际上，构造哈希冲突的数据并不是非常复杂的事情，恶意代码就可以利用这些数据大量与服务器端交互，导致服务端CPU大量占用，这就构成了哈希碰撞拒绝服务攻击</li>
</ul>
<h4 id="如何保证集合是线程安全的"><a href="#如何保证集合是线程安全的" class="headerlink" title="如何保证集合是线程安全的"></a>如何保证集合是线程安全的</h4><p>Java提供了不同层面的线程安全支持。在传统集合框架内部，除了HashTable等同步容器，还提供了所谓的同步包装器（Synchronized Wrapper），我们可以调用Collections工具类提供的包装方法，来获取一个同步的包装容器（如Collections.synchronizedMap），但是它们都是利用非常粗粒度的同步方式，在高并发情况下，性能比较低下。</p>
<p>另外，更加普遍的选择是利用并发包提供的线程安全容器类，它提供了：</p>
<ul>
<li>各种并发容器，比如ConcurrentHashMap、CopyOnWriteArrayList</li>
<li>各种线程安全队列（Queue&#x2F;Deque），如ArrayBlockingQueue、SynchronousQueue</li>
<li>各种有序容器的线程安全版本等</li>
</ul>
<p>具体保证线程安全的方式，包括从简单的synchronize方式，到基于更加精细化的，比如基于分离锁实现的ConcurrentHashMap等并发实现等。具体喧闹着要看开发的场景需求，总体来说，并发包内提供的容器通用场景，远优于早期的简单同步实现。</p>
<h4 id="Java提供的IO方式"><a href="#Java提供的IO方式" class="headerlink" title="Java提供的IO方式"></a>Java提供的IO方式</h4><p>Java IO方式有很多种，基于不同的IO抽象模型和交互方式，可以进行简单区分</p>
<ul>
<li><p>首先，传统的java.io包，它基于流模型实现，提供了我们最熟知的一些IO功能，比如File抽象、输入输出流等。交互方式是同步、阻塞的方式，也就是说，在读取输入流或者写入输出流时，在读、写动作完成之前，线程会一直阻塞在哪里，它们之间的调用是可靠的线性顺序。</p>
<p>java.io包的好处是代码比较简单、直观，缺点则是IO效率和扩展性存在局限性，容易称为应用性能的瓶颈。</p>
<p>很多时候，人们也把java.net下面提供的部分网络API，比如Socket、ServerSocket、HttpURLConnection也归类到同步阻塞IO类库，因为网络通信同样是IO行为</p>
</li>
<li><p>第二，在Java 1.4中引入了NIO框架（java.nio包），提供了Channel、Selector、Buffer等新的抽象，可以构建多路复用的、同步非阻塞IO程序，同时提供了更接近操作系统底层的高性能数据操作方式</p>
</li>
<li><p>第三，在Java 7中，NIO有了进一步的改进，也就是NIO 2，引入了异步非阻塞IO方式，也有很多人叫它AIO（Asychronous IO）。异步IO操作基于时间和回调机制，可以简单理解为，应用操作直接返回，而不会阻塞在哪里，当后台处理完成，操作系统会通知相应线程进行后续工作。</p>
</li>
</ul>
<p><strong>基本概念解释：</strong></p>
<ul>
<li>区分同步或异步（synchronous&#x2F;asynchronous）。简单来说，同步是一种可靠的有序运行机制，当我们进行同步操作时，后续的任务是等待当前调用返回，才会进行下一步；而异步则相反，其他任务不需要等待当前调用返回，通常依靠事件、回调等机制来实现任务间次序关系</li>
<li>区分阻塞与非阻塞（blocking&#x2F;non-blocking）。在进行阻塞操作时，当前线程会处于阻塞状态，无法从事其他任务，只有当条件就绪才能继续，比如ServerSocket新连接建立完毕，或数据读取、写入操作完成；而非阻塞则是不管IO操作是否结束，直接返回，相应操作在后台继续处理</li>
</ul>
<p>不能一概而论认为同步或阻塞就是低效，具体还要看应用和系统特征</p>
<p>对于java.io：</p>
<ul>
<li>IO不仅仅是对文件的操作，网络编程中，比如Socket通信，都是典型的IO操作目标</li>
<li>输入流、输出流（InputStream&#x2F;OutputStream）是用于读取或写入字节的，例如操作图片文件</li>
<li>而Reader&#x2F;Writer则是用于操作字符，增加了字符编解码等功能，适用于类似从文件中读取或者写入文本信息。本质上计算机操作的都是字节，不管是网络通信还是文件读取，Reader&#x2F;Writer相当于构建了应用逻辑和原始数据之间的桥梁</li>
<li>BufferedOutputStream等带缓冲区的实现，可以避免频繁的磁盘读写，进而提高IO处理效率。这种设计利用了缓冲区，将批量数据进行一次操作，但在使用中千万别忘了flush</li>
</ul>
<h4 id="Java有几种文件拷贝方式？"><a href="#Java有几种文件拷贝方式？" class="headerlink" title="Java有几种文件拷贝方式？"></a>Java有几种文件拷贝方式？</h4><p>Java有多种比较典型的文件拷贝实现方式：</p>
<ul>
<li><p>利用java.io类库，直接为源文件构建一个FileInputStream读取，然后再为目标文件构建一个FileOutputStream，完成写入工作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyFileByStream</span><span class="params">(File source, File dest)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(source);</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> length;</span><br><span class="line">        <span class="keyword">while</span>((length = is.read(buffer)) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            os.write(buffer, <span class="number">0</span>, length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用java.nio类库提供的transferTo或tansferFrom方法实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyFileByChannel</span><span class="params">(File source, File dest)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">sourceChannel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(source).getChannel();</span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">targetChannel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dest).getChannel();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> sourceChannel.size(); count&gt;<span class="number">0</span>; )&#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">transferred</span> <span class="operator">=</span> sourceChannel.transferTo(sourceChannel.position(),count,targetChannel);</span><br><span class="line">            sourceChannel.position(sourceChannel.position + transferred);</span><br><span class="line">            count -= transferred;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当然，Java标准类库本身已经提供了几种Files.copy的实现</p>
</li>
</ul>
<p>对于Copy的效率，这个其实与操作系统和配置等情况相关，总体上来说，NIO transferTo&#x2F;From的方式可能更快，因为它更能利用现代操作系统底层机制，避免不必要拷贝和上下文切换。</p>
<h4 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h4><p>接口和抽象类是Java面向对象设计的两个基础机制</p>
<ul>
<li><p>接口是对行为的抽象，它是抽象方法的集合，利用接口可以达到API定义和实现分离的目的。接口不能实例化；不能包含任何非常量成员，任何field都是隐含着public static final的意义；同时，没有非静态方法实现，也就是说要么是抽象方法，要么是静态方法。Java标准类库中定义了非常多的接口，比如java.util.List</p>
</li>
<li><p>抽象类识不能实例化的类，用abstract关键字修饰class，其目的主要是代码重用。除了不能实例化，形式上和一般的Java类并没有太大区别，可以有一个或多个抽象方法，也可以没有抽象方法。抽象类大多用于抽取相关Java类的共用方法实现或者是共同成员变量，然后通过继承的方式达到代码复用的目的。Java标准库中，比如collection框架，很多通用部分就抽取称为抽象类，例如java.util.AbstractList。</p>
</li>
<li><p>Java类实现interface使用implements关键词，继承abstract class则是使用extends关键词，可以参考Java标准库中的ArrayList：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span> <span class="keyword">extends</span> <span class="title class_">AbstractList</span> <span class="keyword">implements</span> <span class="title class_">List</span>, RandomAccess, Cloneable, java.io.Serializable&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>知识扩展</strong></p>
<ul>
<li>Java相比于其他面向对象语言，如C++，这几上有一些基本区别，比如Java不支持多继承。这种限制，在规范了代码实现的同时，也产生了一些局限性，影响着程序设计结构。Java类可以实现多个接口，因为接口是抽象方法的集合，所以这是声明性的，但不能通过扩展多个抽象类来重用逻辑</li>
<li>在一些情况下存在特定场景，需要抽象出与具体实现、实例化无关的通用逻辑，或者纯调用关系的逻辑，但是使用传统的抽象类会陷入到单继承的窘境。以往常见的做法是，实现由静态方法组成的工具类（Utils），比如java.util.Collections。</li>
<li>为接口添加任何抽象方法，相应的所有实现了这个接口的类，也必须实现新增方法，否则会出现编译错误。对于抽象类，如果我们添加非抽象方法，其子类只会享受到能力扩展，而不用担心编译出问题。</li>
<li>接口的职责也不仅仅限于抽象方法的集合，其实有各种不同的实践。有一类没有任何方法的接口，通常叫做Marker Interface，顾名思义，它的目的就是为了声明某些东西，比如我们熟知的Cloneable、Serializable等。这种用法，也存在于业界其他的Java产品代码中。</li>
<li>表面上看这似乎与Annotation异曲同工，也确实如此，它的好处是简单直接。对于Annotation，因为可以指定参数和值，在表达能力上要更强大一些，所以更多人选择使用Annotation。</li>
<li>Java 8增加了函数式编程的支持，所以又增加了一类定义，即所谓functional interface，简单说就是只有一个抽象方法的接口，通常建议使用@FunctionalInterface Annotation来标记。Lambda表达式本身可以看作是一类functional interface，某种程度上这和面向对象是两码事。常见的Runnable、Callable之类，都是functional interface</li>
</ul>
<p><strong>面向对象设计</strong></p>
<p>面向对象的基本要素：封装、继承、多态</p>
<ul>
<li>封装的目的是隐藏事务内部的实现细节，以提高安全性和简化编程。封装提供了合理的边界，避免外部调用者接触到内部的细节。我们在日常开发中，因为无意间暴露了细节导致的难缠bug太多了，比如在多线程环境暴露内部状态，导致的并发修改问题。从另外一个角度看，封装这种隐藏，也提供了简化的界面，避免太多无意义的细节浪费调用者的精力。</li>
<li>继承是代码复用的基础机制，类似于我们对于马、白马、黑马的归纳总结。但要注意，继承可以看作是非常紧耦合的一种关系，父类代码修改，子类行为也会变动。在实践中，过度滥用继承，可能会起到反效果。</li>
<li>多态，可能立即会想到重写（override）和重载（overload）、向上转型。简单说，重写是父子类中相同名字和参数的方法，不同的实现；重载则是相同名字的方法，但是不同的参数，本质上这些方法签名是不一样的。（注意只有返回类型不同的重载不是有效的重载，编译会出错）</li>
</ul>
<p>面向对象S.O.L.I.D设计原则：</p>
<ul>
<li><p><strong>单一职责</strong>（Single Responsibility），类或者对象最好只有单一职责，在程序设计中如果发现某个类承担着多种义务，可以考虑进行拆分。</p>
</li>
<li><p><strong>开关原则</strong>（Open-Close，Open for extension，close for modification），设计要对扩展开放，对修改关闭。换句话说，程序设计应保证平滑的扩展性，尽量避免因为新增同类功能而修改已有实现，这样可以少产出些回归（regression）问题。</p>
</li>
<li><p><strong>里氏替换</strong>（Liskov Substitution），这是面向对象的基本要素之一，进行继承关系抽象时，范式可以用父类或者基类的地方，都可以用子类替换。</p>
</li>
<li><p><strong>接口分离</strong>（Interface Segregation），我们在进行类和接口设计时，如果在一个接口里定义了太多方法，其子类很可能面临两难，就是只有部分方法对它是有意义的，这就破坏了程序的内聚性。</p>
<p>对于这种情况，可以通过拆分成功能单一的多个接口，将行为进行解耦。在未来维护中，如果某个接口设计有变，不会对使用其他接口的子类构成影响。</p>
</li>
<li><p><strong>依赖反转</strong>（Dependency Inversion），实体应该依赖于抽象而不是实现（要针对接口编程而不是对实现编程）。也就是说高层次模块，不应该依赖于低层次模块，而是应该基于抽象。实践这一原则是保证产品代码之间适当耦合度的法宝。</p>
</li>
</ul>
<h4 id="设计模式相关"><a href="#设计模式相关" class="headerlink" title="设计模式相关"></a>设计模式相关</h4><p>大致按照模式的应用目标分类，设计模式可以分为创建型模式、结构性模式和行为型模式</p>
<ul>
<li><strong>创建型模式</strong>，是对对象创建过程的各种问题和解决方案的总结，包括各种工厂模式（Factory、Abstract Factory）、单例模式（Singleton）、构建器模式（Builder）、原型模式（ProtoType）</li>
<li><strong>结构型模式</strong>，是针对软件设计结构的总结，关注于类、对象继承、组合方式的实践经验。常见的结构型模式，包括桥接模式（Bridge）、适配器模式（Adaptor）、装饰者模式（Decorator）、代理模式（Proxy）、组合模式（Composite）、外观模式（Facade）、享元模式（Flyweight）等</li>
<li><strong>行为型模式</strong>，是从类或对象之间交互、职责划分等角度总结的模式。比较常见的行为型模式有策略模式（Strategy）、解释器模式（Interpreter）、命令模式（Command）、观察者模式（Observer）、迭代器模式（Iterator）、模板方法模式（Template Method）、访问者模式（Visitor）。</li>
</ul>
<p><strong>实现一个单例模式</strong></p>
<p>最简单的方式就是为单例定义一个private的构造函数。</p>
<p>另外可以通过标准类库中很多地方使用的懒加载（lazy-load）改善初始内存开销：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="comment">// 如果没有使用懒加载，会在第一次加载类的时候会连带着创建 Singleton 实例，但实际上可能暂时用不到，则浪费了资源</span></span><br><span class="line">    <span class="comment">// private static Singleton instance = new Singleton();</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用了懒加载机制，在使用的时候才去创建。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个实现在单线程环境不存在问题，但是如果处于并发场景，就需要考虑线程安全，最熟悉的莫过于“双检锁”，其要点在于：</p>
<ul>
<li>这里的volatile能够提供可见性，以及保证getInstance返回的是初始化完全的对象</li>
<li>在同步之前进行null检查，以尽量避免进入相对昂贵的同步块</li>
<li>直接在class级别进行同步，保证线程安全的类方法调用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getSingleton</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="literal">null</span>)&#123;<span class="comment">//尽量避免重复进入同步块</span></span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class)&#123;<span class="comment">//同步.class，意味着对同步类方法调用</span></span><br><span class="line">                <span class="keyword">if</span>(singleton = <span class="literal">null</span>)&#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外也有人推荐利用内部类持有静态对象的方式实现，其理论依据是对象初始化过程中隐含的初始化锁，不过语法稍显灰色，未必有特别的优势</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getSingleton</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Holder</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Spring在API设计中使用的设计模式：</p>
<ul>
<li>BeanFactory和ApplicationContext应用了工厂模式</li>
<li>在Bean的创建中，Spring也为不同scope定义的对象，提供了单例和原型等模式实现</li>
<li>AOP领域使用了代理模式、装饰器模式、适配器模式等</li>
<li>各种事件监听器，是观察者模式的典型应用</li>
<li>类似JdbcTemplate等则是应用了模板模式</li>
</ul>
<h4 id="synchronized和ReentrantLock的区别"><a href="#synchronized和ReentrantLock的区别" class="headerlink" title="synchronized和ReentrantLock的区别"></a>synchronized和ReentrantLock的区别</h4><p>synchronized是Java内建的同步机制，也有人称其为Intrinsic Locking，它提供了互斥的语义和可见性，当一个线程已经获取当前锁时，其他试图获取的线程只能等待或者在阻塞在那里。</p>
<p>在Java 5以前，synchronized是仅有的同步手段，在代码中，synchronized可以用来修饰方法，也可以使用在特定的代码块上，本质上synchronized方法等同于把方法全部语句用synchronized块包起来。<code>synchronized(ClassName.class) &#123;&#125;</code></p>
<p>ReentrantLock，通常翻译为再入锁，是Java 5提供的锁实现，它的语义和synchronized基本相同。再入锁通过代码直接调用lock()方法获取，代码书写也更加灵活。与此同时，ReentrantLock提供了很多实用的方法，能够实现很多synchronized无法做到的细节控制，比如可以控制fairness，也就是公平性，或者利用定义条件等。但是，编码中也需要注意，必须要明确调用unlock()方法释放，不然就会一直持有该锁。</p>
<p><strong>理解什么是线程安全</strong></p>
<p>线程安全是一个多线程环境下正确性的概念，也就是保证多线程环境下共享的、可修改的状态的正确性，这里的状态反映在程序中其实可以看作是数据。</p>
<p>换个角度看，如果状态不是共享的，或者不是可修改的，也就不存在线程安全问题，进而可以推理出保证线程安全的两个办法：</p>
<ul>
<li>封装：通过封装，我们可以将对象内部状态隐藏、保护起来</li>
<li>不可变：final和immutable。Java语言目前还没有真正意义上的原生不可变。</li>
</ul>
<p>线程安全需要保证几个基本特性：</p>
<ul>
<li><strong>原子性</strong>：简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制实现</li>
<li><strong>可见性</strong>：是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将线程本地状态反映到主内存上，volatile就是负责保证可见性的</li>
<li><strong>有序性</strong>：保证线程内串行语义，避免指令重排</li>
</ul>
<h4 id="一个线程两次调用start-方法会发生什么？"><a href="#一个线程两次调用start-方法会发生什么？" class="headerlink" title="一个线程两次调用start()方法会发生什么？"></a>一个线程两次调用start()方法会发生什么？</h4><p>Java的线程是不允许启动两次的，第二次调用必然会抛出IllegalThreadStateException，这是一种运行时异常，多次调用start被认为是编程错误。</p>
<p>关于线程生命周期的不同状态，在Java5以后，线程状态被明确定义在其公共内部枚举类型java.lang.Thread.State中，分别是：</p>
<ul>
<li><p>新建（NEW），表示线程被创建出来还没真正启动的状态，可以认为它是个Java内部状态</p>
</li>
<li><p>就绪（RUNNABLE），表示该线程已经在JVM中执行，当然由于执行需要计算资源，它可能是正在运行，也可能还在等待系统分配给它CPU片段，在就绪队列里面排队</p>
</li>
<li><p>在其他一些分析中，会额外区分一种状态RUNNING，但是从Java API的角度，并不能表示出来</p>
</li>
<li><p>阻塞（BLOCKED），这个状态和之前介绍的同步非常相关，阻塞表示线程在等待Monitor lock。比如，线程试图通过synchronized去获取某个锁，但是其他线程已经独占了，那么当前线程就会处于阻塞状态。</p>
</li>
<li><p>等待（WAITING），表示正在等待其他线程采取某些操作。一个常见的场景是类似生产者消费者模式，发现任务条件上位满足，就让当前消费者线程等待（wait），另外的生产者线程去准备任务数据，然后通过类似notify等动作，通知消费线程可以继续工作了。Thread.join()也会令线程进入等待状态</p>
</li>
<li><p>计时等待（TIMED_WAIT），其进入条件和等待状态类似，但是调用的是存在超时条件的方法，比如wait或join等方法的指定超时版本，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure>
</li>
<li><p>终止（TERMINATED），不管是意外退出还是正常执行结束，线程已经完成使命，终止运行，也有人把这个状态叫作死亡</p>
</li>
</ul>
<p>在第二次调用start()方法的时候，线程可能处于终止或者其他（非NEW）状态，但是不论如何，都是不可以再次启动的</p>
<p><strong>线程是什么？</strong></p>
<p>从操作系统的角度，可以简单认为，线程是系统调度的最小单元，一个进程可以包含多个线程，作为任务的真正运作者，有自己的栈（Stack）、寄存器（Register）、本地存储（Thread Local）等，但是会和进程内其他线程共享文件描述符、虚拟地址空间等。</p>
<p>在具体实现中，线程还分为内核线程、用户线程，Java的线程实现是和虚拟机相关的。对于Sun&#x2F;Oracle JDK，在Java1.2之后，已经抛弃了所谓的Green Thread，也就是用户调度的线程，现在的模型是一对一映射到操作系统内核线程。</p>
<p><strong>创建线程的基本操作：</strong></p>
<p>我们可以直接扩展Thread类，然后实例化。但是这里选择了另一种方式，就是实现一个Runnable，将代码逻辑放在Runnable中，然后构建Thread并启动（start），等待结束（join）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> ()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        myThread.start();</span><br><span class="line">        myThread.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Runnable的好处是，不会受Java不支持多继承的限制，重用代码实现，当我们需要重复执行相应逻辑时优点明显。而且也能更好的与现代Java并发库中的Executor之类框架结合使用，比如将上面的start和join的逻辑转换成下面这种结构。这样我们就不用操心线程的创建和管理，也能利用Future等机制更好地处理执行结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> ()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Future</span> <span class="variable">future</span> <span class="operator">=</span> (Future) Executors.newFixedThreadPool(<span class="number">1</span>).submit(task).get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>线程API的使用：</strong></p>
<ul>
<li><p>守护线程（Daemon Thread），有的时候应用中需要一个长期驻留的服务程序，但是不希望其影响应用退出，就可以将其设置为守护线程，如果JVM发现只有守护线程 存在时，将结束进程。注意必须在线程启动之前设置！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">daemonThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>();</span><br><span class="line">daemonThread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">daemonThread.start();</span><br></pre></td></tr></table></figure>
</li>
<li><p>Spurious wakeup。尤其是在多核CPU系统中，线程等待存在一种可能，就是在没有任何线程广播或者发出信号的情况下，线程就被唤醒，如果处理不当就可能出现诡异的并发问题，所以我们在等待条件过程中，建议如下书写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//推荐</span></span><br><span class="line"><span class="keyword">while</span>( isCondition())&#123;</span><br><span class="line">    waitForAConfition(...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不推荐，可能引入bug</span></span><br><span class="line"><span class="keyword">if</span>( isCondition())&#123;</span><br><span class="line">    waitForAConfition(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>慎用ThreadLocal</p>
</li>
</ul>
<h4 id="什么情况下Java程序会产生死锁"><a href="#什么情况下Java程序会产生死锁" class="headerlink" title="什么情况下Java程序会产生死锁"></a>什么情况下Java程序会产生死锁</h4><p>死锁是一种特定的程序状态，在实体之间，由于依赖导致彼此一直处于等待之中，没有任何个体可以继续前进。死锁不仅仅是在线程之间会发生，存在资源独占的进程之间同样也可能出现死锁。通常来说，我们大多是聚焦在多线程场景中的死锁，指两个或多个线程之间，由于互相持有对方需要的锁，而永久处于阻塞的状态</p>
<p>以下是一个基本的死锁程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockTest</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String first;</span><br><span class="line">    <span class="keyword">private</span> String second;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DeadLockTest</span><span class="params">(String name, String first,String second)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (first)&#123;</span><br><span class="line">            System.out.println(<span class="built_in">this</span>.getName()+<span class="string">&quot; obtained: &quot;</span>+ first);</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (second)&#123;</span><br><span class="line">                    System.out.println(<span class="built_in">this</span>.getName()+<span class="string">&quot; obtained: &quot;</span>+second);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">lockA</span> <span class="operator">=</span> <span class="string">&quot;lockA&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">lockB</span> <span class="operator">=</span> <span class="string">&quot;lockB&quot;</span>;</span><br><span class="line">        <span class="type">DeadLockTest</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeadLockTest</span>(<span class="string">&quot;Thread1&quot;</span>,lockA,lockB);</span><br><span class="line">        <span class="type">DeadLockTest</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeadLockTest</span>(<span class="string">&quot;Thread2&quot;</span>,lockB,lockA);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个程序编译执行后，几乎每次都可以重现死锁。这里查看输出还有一个有意思的地方：我先调用的是Thread1的start，但是Thread2却先打印出来了，这是因为线程调度依赖于（操作系统）调度器，虽然可以通过优先级之类进行影响，但是具体情况是不确定的。</p>
<img src="https://pic.imgdb.cn/item/629c656e0947543129ba2827.jpg" style="zoom:80%;" />

<p>要定位死锁，可以通过jstack、JConsole等工具进行查找，过程大概可总结为：</p>
<ul>
<li>区分线程状态 &#x3D;》查看等待目标&#x3D;》对比Monitor等持有状态</li>
</ul>
<p><strong>如何在编程中尽量预防死锁？</strong></p>
<p>首先总结死锁发生的原因：</p>
<ul>
<li>互斥条件，类似Java中Monitor都是独占的</li>
<li>互斥条件是长期持有的，在使用结束之前，自己不会释放，也不能被其他线程抢占</li>
<li>循环依赖关系，两个或多个个体之间出现了锁的链条环</li>
</ul>
<p>因此可以总结出避免死锁的思路和方法：</p>
<ul>
<li><p>如果可能的话，尽量避免使用多个锁，并且只有需要时才持有锁（嵌套的synchronized或lock非常容易出问题）</p>
</li>
<li><p>如果必须使用多个锁，尽量设计好锁的获取顺序（参看银行家算法），一般情况可以采取些简单的辅助手段：</p>
<ul>
<li>将对象（方法）和锁之间的关系，用图形化的方式表示分别抽取出来</li>
<li>然后根据对象之间组合、调用的关系对比和组合，考虑可能调用时序</li>
<li>按照可能时序合并，发现可能死锁的场景</li>
</ul>
</li>
<li><p>使用带超时的方法，为程序带来更多可控性：</p>
<ul>
<li><p>类似Object.wait(…)或者CountDownLatch.await(…)，都支持所谓的timed_wait，我们完全可以就不假定该锁一定会获得，指定超时时间，并为无法得到锁时准备退出逻辑</p>
</li>
<li><p>并发Lock实现，如ReentrantLock还支持非阻塞式的获取锁操作tryLock()，这是一个插队行为（barging），并不在乎等待的公平性，如果执行时对象恰好没有被独占，则直接获取锁。有时，我们希望条件条件允许就尝试插队，不然就按照现有公平性规则等待，一般采用下面的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(lock.tryLock() || lock.tryLock(timeout, unit))&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="Java并发包提供的工具类"><a href="#Java并发包提供的工具类" class="headerlink" title="Java并发包提供的工具类"></a>Java并发包提供的工具类</h4><p>通常所说的并发包也就是java.util.concurrent及其子包，集中了Java并发的各种基础工具类，具体主要包括几个方面：</p>
<ul>
<li><p>提供了比synchronized更加高级的各种同步结构，包括CountDownLatch、CyclicBarrier、Semaphore等，可以实现更加丰富的多线程操作，比如利用Semaphore作为资源控制器，限制同时进行工作的线程数量</p>
<ul>
<li>CountDownLatch，允许一个或多个线程等待某些操作完成</li>
<li>CyclicBarrier，一种辅助性的同步结构，允许多个线程等待到达某个屏障</li>
<li>Semaphore，Java版本的信号量实现</li>
</ul>
</li>
<li><p>各种线程安全的容器，比如最常见的ConcurrentHashMap、有序的ConcurrentSkipListMap，或者通过类似快照机制，实现线程安全的动态数组CopyOnWriteArrayList等</p>
</li>
<li><p>各种并发队列实现，如各种BlockingQueue实现，比较典型的ArrayBlockingQueue、SynchronousQueue或针对特定场景的PriorityBlockingQueue等</p>
</li>
<li><p>强大的Executor框架，可以创建各种不同类型的线程池，调度任务运行等，绝大部分情况下，不再需要自己从头实现线程池和任务调度器。通常开发者都是利用Executors提供的通用线程池创建方法，去创建不同配置的线程池，主要区别在于不同的ExecutorService类型或者不同的初始参数。</p>
<p>Executors目前提供了5种不同的线程池创建配置：</p>
<ul>
<li>newCachedThreadPool()，它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过60秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用SynchronousQueue作为工作队列</li>
<li>newFixedThreadPool(int nThreads)，重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有nThreads个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目nThreads。</li>
<li>newSingleThreadExecutor()，它的特点在与工作线程数目被限制为1，操作一个无界的工作队列，所以它保证了所有任务都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目</li>
<li>newSingleThreadScheduledExecutor()和newScheduledThreadPool(int corePoolSize)，创建的是个ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在与单一工作线程还是多个工作线程。</li>
<li>newWorkStealingPool(int parallelism)，这是一个经常被人忽略的线程池，Java 8才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序</li>
</ul>
</li>
</ul>
<h4 id="AtomicInteger底层实现原理和如何自己应用CAS操作"><a href="#AtomicInteger底层实现原理和如何自己应用CAS操作" class="headerlink" title="AtomicInteger底层实现原理和如何自己应用CAS操作"></a>AtomicInteger底层实现原理和如何自己应用CAS操作</h4><p>AtomicIntger是对int类型的一个封装，提供原子性的访问和更新操作，其原子性操作的实现是基于<strong>CAS</strong>（<a href="https://en.wikipedia.org/wiki/Compare-and-swap">compare-and-swap</a>）技术。</p>
<p><strong>所谓CAS，表征的是一些列操作的集合，获取当前数值，进行一些运算，利用CAS指令试图进行更新。如果当前数值未变，代表没有其他线程进行并发修改，则成功更新。否则，可能出现不同的选择，要么进行重试，要么就返回一个成功或者失败的结果。</strong></p>
<p>从AtomicInteger的内部属性可以看出，它<u>依赖于Unsafe提供的一些底层能力，进行底层操作</u>；<u>以volatile的value字段，记录数值，以保证可见性</u>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> jdk.internal.misc.<span class="type">Unsafe</span> <span class="variable">U</span> <span class="operator">=</span> jdk.internal.misc.Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">VALUE</span> <span class="operator">=</span> U.objectFieldOffset(AtomicInteger.class, <span class="string">&quot;value&quot;</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br></pre></td></tr></table></figure>

<p>具体的原子操作细节，可以参考任意一个原子更新方法，比如下面的getAndIncrement。</p>
<p>Unsafe会利用value字段的内存地址偏移，直接完成操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span> &#123;    </span><br><span class="line">    <span class="keyword">return</span> U.getAndAddInt(<span class="built_in">this</span>, VALUE, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为getAndIncrement需要返归数值，所以需要添加失败重试逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">int</span> delta)</span> &#123;    </span><br><span class="line">    <span class="type">int</span> v;    </span><br><span class="line">    <span class="keyword">do</span> &#123;        </span><br><span class="line">        v = getIntVolatile(o, offset);    </span><br><span class="line">    &#125; <span class="keyword">while</span> (!weakCompareAndSetInt(o, offset, v, v + delta));    </span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而类似compareAndSet这种返回boolean类型的函数，因为其返回值表现的就是成功与否，所以不需要重试。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final boolean compareAndSet(int expectedValue, int newValue)</span><br></pre></td></tr></table></figure>

<p>CAS是Java并发中所谓lock-free机制的基础。</p>
<h4 id="Java类加载的过程"><a href="#Java类加载的过程" class="headerlink" title="Java类加载的过程"></a>Java类加载的过程</h4><p>一般来说，把Java的类加载过程分为三个主要步骤：加载、链接、初始化</p>
<ul>
<li><p><strong>加载阶段（Loading）</strong>，它是Java将字节码数据从不同的数据源读取到JVM中，并映射为JVM认可的数据结构（Class对象），这里的数据源可能是各种各样的形态，如jar文件、class文件，甚至是网络数据源等；如果输入数据不是ClassFile结构，则会抛出ClassFormatError。</p>
<p>加载阶段是用户参与的阶段，我们可以自定义类加载器，去实现自己的类加载过程</p>
</li>
<li><p><strong>链接（Linking）</strong>，这是核心的步骤，简单说是把原始的类定义信息平滑地转化如JVM运行的过程中。这里可进一步细分为三个步骤：</p>
<ul>
<li>验证（Verification），这是虚拟机安全的重要保障，JVM需要核验字节信息是符合Java虚拟机规范的，否则就被认为是VerifyError，这样就防止了恶意信息或者不合规信息危害JVM的运行，验证阶段有可能触发更多class的加载</li>
<li>准备（Preparation），创建类或接口中的静态变量，并初始化静态变量的初始值。但这里的“初始化”和下面的显式初始化阶段是有区别的，侧重点在与分配所需要的内存空间，不会去执行更进一步的JVM指令</li>
<li>解析（Resolution），在这一步会将常量池中的符号引用（symbolic reference）替换为直接引用。</li>
</ul>
</li>
<li><p><strong>初始化阶段（Initialization）</strong>，这一步真正去执行类初始化的代码逻辑，包括静态字段赋值的动作，以及执行类定义中的静态初始化块内的逻辑，编译器在编译阶段就会把这部分逻辑整理好，父类型的初始化逻辑优于当前类型的逻辑</p>
</li>
</ul>
<p>双亲委派模型：</p>
<p>简单来说就是当类加载器（Class-Loader）试图加载某个类型的时候，除非父加载器找不到相应类型，否则尽量将这个任务代理给当前加载器的父加载器去做。使用委派模型的目的是避免重复加载Java类型</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>简单的需求开发记录</title>
    <url>/2022/05/12/project-in-meituan-01/</url>
    <content><![CDATA[<p>概述：本文记录了我开发第一个需求【挽留弹窗】的过程</p>
<span id="more"></span>

<h3 id="明确需求"><a href="#明确需求" class="headerlink" title="明确需求"></a>明确需求</h3><h4 id="芥末端"><a href="#芥末端" class="headerlink" title="芥末端"></a>芥末端</h4><img src="https://pic.imgdb.cn/item/627cacf10947543129944b06.jpg" alt="配置界面" style="zoom: 67%;" />

<p>为游戏中心2.0的活动配置界面【新人引导奖励】下方增加一个挽留弹窗的part，拥有两个字段：</p>
<ul>
<li>【开关】，开关开启时展示面向用户选项，关闭时不展示</li>
<li>【面向用户】只提供【全部】和【CRMID】选项</li>
</ul>
<img src="https://pic.imgdb.cn/item/627cac690947543129922080.jpg" style="zoom:80%;" />



<p>打开网页开发者工具，点开编辑，在【Network】中可以找到【detail】开头的name，在【Response】中可以复制Json代码到<code>json.cn</code>中进行解析，其中【bizConfig】字段中包含的也是一个Json实体，去掉转义字符可以同样进行解析发现对应的就是【订单返回奖励】到【新人引导奖励】这部分的内容。</p>
<img src="https://pic.imgdb.cn/item/627cac99094754312992e02b.jpg" style="zoom:80%;" />





<p>在network中【detail】的【Headers】中可以找到【Request URL】从而定位API的名称，方便于在API分组中搜索【path】进行寻找 。</p>
<p>另外点击【保存】后会调用一个save方法，同样也可以在相应的Headers中定位API的位置和名称</p>
<p>在【Shepherd】通过【path】找到API接口后可以在【后端请求定义】中找到接口对应的名称，从而定位到了具体的代码（服务和方法）</p>
<p>例如如这里通过 <code>/activity/generic/detail</code>找到了MAPI下的 <code>queryActivityDetail</code>方法（<code>.client.service.activity.ActivityManagerMTService</code>）</p>
<p>通过 <code>/activity/generic/save</code>找到了MAPI下的 <code>saveActivity</code>方法（<code>.client.service.activity.ActivityManagerMTService</code>）</p>
<h4 id="C端"><a href="#C端" class="headerlink" title="C端"></a>C端</h4><p>需要调整主页加载接口</p>
<p>增加用户类型字段：retainPopDisplay, true表示满足挽留弹窗条件，false表示不满足</p>
<p>responseBody：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span><span class="string">&quot;成功&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;retainPopDisplay&quot;</span><span class="punctuation">:</span><span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">        ......</span><br><span class="line">        ......</span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>如何定位对应的接口：</p>
<ul>
<li>APPMOCK中绑定自己的设备，选择测试环境，扫码美团优选APP测试版，然后在手机中的mis号和泳道中进行相应的设置，完成后点开游戏中心。</li>
<li>在APPMOCK中搜索【game】即可找到一些请求，其中后缀为loadMainView的为我们需要的这条请求，点入之后选择【Response】即可查看response的具体信息</li>
</ul>
<p><strong>写UT</strong></p>
<p>要尽量覆盖到各种可能性，覆盖每一行代码</p>
<h3 id="芥末端开发步骤"><a href="#芥末端开发步骤" class="headerlink" title="芥末端开发步骤"></a>芥末端开发步骤</h3><p>在interact.mapi包下</p>
<h4 id="DTO到VO"><a href="#DTO到VO" class="headerlink" title="DTO到VO"></a>DTO到VO</h4><p>找到要修改的位置：</p>
<ul>
<li><p>从 <code>ActivityManagerMTService</code>类中的 <code>queryActivityDetail</code>方法出发，从接口找到实现类，</p>
<ul>
<li>进入 <code>ActivityDetailResponse</code>查看返回类型的具体信息，</li>
<li>进入 <code>ActivityDetailConfigVO</code>，可以看到这里的对象与网络上detail的response中收到的Json格式的对象是对应起来的，包含baseInfo 基本信息， dispatchStrategy 分流信息， <strong>bizConfig 业务模型</strong>， ext 扩展信息，其中bizConfig是我们需要关注的东西，可以看到他是一个String。</li>
</ul>
</li>
<li><p>重新回到实现类 <code>ActivityManagerMTServiceImpl</code>，进入 <code>ActivityManagerLocalService</code>接口，可以看到 <code>supportActivityType()</code> <code>save()</code> <code>detail()</code>三个方法，进入<code>detail()</code>的实现，进入<code>convertDTO2VO</code>方法的实现，注意其中<code>setBizConfig</code>方法是我们需要设置bizConfig的关键代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ActivityDetailConfigVO</span> <span class="variable">vo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActivityDetailConfigVO</span>();</span><br><span class="line">vo.setBizConfig(resolveExtraConfigWhenQuery(vo.getBaseInfo(),activityDTO.getExtraConfig()));</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入 <code>resolveExtraConfigWhenQuery</code>接口再进入实现（GameCenter前缀的那一个）</p>
</li>
<li><p>这里可以进入 <code>GameCenterExtraConfigDTO</code><strong>加入DTO字段和对应方法</strong>（注意DTO的修改需要在另一个包下）和 <code>GameCenterInfoConfigVO</code>（需要在里面加入VO字段和对应方法）</p>
</li>
<li><p>在同样的位置进入 <code>buildExtraConfigVO</code>方法，在其中new一个retainWindowVO对象，并将从DTO的对应数据set进去，<strong>完成DTO到VO对象的转换</strong></p>
</li>
</ul>
<h4 id="VO到DTO"><a href="#VO到DTO" class="headerlink" title="VO到DTO"></a>VO到DTO</h4><ul>
<li><p>从 <code>ActivityManagerMTService</code>类中的 <code>saveActivity</code>方法出发，从接口找到实现类，</p>
<ul>
<li>入参是<code>ActivityDetailConfigVO</code></li>
<li>进入 <code>PrimaryIdResponse</code>查看返回类型的具体信息，可以看见其中是一个Long类型的data</li>
<li>找到 <code>saveActivity</code>的实现，同样可以通过<code>ActivityManagerLocalService</code>找到其中的 <code>save()</code>方法，进入 <code>AbstractActivityManagerService</code>的实现</li>
</ul>
</li>
<li><p>可以看到save中需要更改的几处地方</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> PrimaryIdResponse <span class="title function_">save</span><span class="params">(ActivityDetailConfigVO vo)</span>&#123;</span><br><span class="line">	<span class="comment">//......</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//校验配置</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">bizCheckMsg</span> <span class="operator">=</span> checkBizConfig(vo.getBaseInfo(), vo.getBizConfig());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//0.init activity base info</span></span><br><span class="line">    <span class="type">ActivityDTO</span> <span class="variable">activityDTO</span> <span class="operator">=</span> init(vo);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//convert and check</span></span><br><span class="line">    activityDTO.setExtraConfig(resolveExtraConfigWhenSave(vo.getBaseInfo(), vo.getBizConfig()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在【校验配置】部分，进入 <code>checkBizConfig</code>方法位于 <code>GameCenterActivityManagerLocalServiceImpl</code>实现中使用的 <code>checkBaseAndBizParam</code>方法（返回String），注意需要在这里<strong>设置校验</strong></p>
</li>
<li><p>【convert and check】部分，进入<code>resolveExtraConfigWhenSave</code>方法位于 <code>GameCenterActivityManagerLocalServiceImpl</code>实现中使用的 <code>resolveExtraConfigWhenSave</code>（返回String），可以进入 <code>GameCenterConvert</code>类中的 <code>buildExtraDTO</code>方法，在这里进行对应的<strong>VO对象到DTO对象的转换</strong></p>
</li>
</ul>
<h4 id="设计RetainWindowDTO类"><a href="#设计RetainWindowDTO类" class="headerlink" title="设计RetainWindowDTO类"></a>设计RetainWindowDTO类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RetainWindowDTO</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span>      ;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//弹窗开关</span></span><br><span class="line">    privateBoolean popSwitch;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//任务人群配置</span></span><br><span class="line">    <span class="keyword">private</span> CrowdConfigDTO crowd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意还需要在GameCenterExtraConfigDTO中加入一条对应的配置</p>
<h4 id="设计RetainWindowVO类"><a href="#设计RetainWindowVO类" class="headerlink" title="设计RetainWindowVO类"></a>设计RetainWindowVO类</h4><p>注意VO（ View Object）：显示层对象，通常是 Web 向模板渲染引擎层传输的对象。</p>
<p>注解使用：</p>
<p><code>@ToString</code>：Lombok下自动生成toString()方法的注解</p>
<p><code>@ThriftStruct</code>：Thrift组件用于定义结构体</p>
<p>生成serialVersionUID：注意要安装<code>GenerateSerialVersionUID</code>插件 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@ThriftStruct</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RetainWindowVO</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span>       ;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//弹窗开关</span></span><br><span class="line">    <span class="keyword">private</span> Boolean popSwitch;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//人群类型</span></span><br><span class="line">    <span class="keyword">private</span> CrowdConfigVO crowdConfig;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ThriftField(1)</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">getPopSwitch</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> popSwitch;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ThriftField</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPopSwitch</span><span class="params">(Boolean popSwitch)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.popSwitch = popSwitch;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ThriftField(2)</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">getCrowdConfig</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> crowdConfig;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ThriftField</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCrowdConfig</span><span class="params">(CrowdConfigVO crowdConfigVO)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.crowdConfig = crowdConfig;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="注意本地代码和远程代码的合并"><a href="#注意本地代码和远程代码的合并" class="headerlink" title="注意本地代码和远程代码的合并"></a>注意本地代码和远程代码的合并</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//切换分支命令</span><br><span class="line">git checkout 分支名</span><br></pre></td></tr></table></figure>



<h4 id="调试和测试"><a href="#调试和测试" class="headerlink" title="调试和测试"></a>调试和测试</h4><p>千万注意要在测试时要设置泳道 <code>Tracer.setSwimlane(&quot;泳道名称&quot;)</code>，否则默认是在默认渠道上进行的。并且要保证服务已经在泳道进行了部署，否则是在做无用功</p>
<p>userId &#x3D; 5054538345L</p>
<p>poi&#x3D;143339791618804</p>
<h3 id="C端开发"><a href="#C端开发" class="headerlink" title="C端开发"></a>C端开发</h3><p>在 <code>game-center</code> 包的core模块下的local包下找到 <code>GameCenterLocalService</code>类中的 <code>loadMainSceneInfo</code>方法：</p>
<ul>
<li><p>首先看返回类型 <code>MainSceneResp</code>，这里的字段其实是和网页上的Response中的内容对应的，我们要做的就是增加一个挽留窗口<code>retainPopDisplay</code>的字段，类型为Boolean</p>
</li>
<li><p>查看 <code>ActivityDTO</code>可以发现其中有<code>bizConfig</code>字段</p>
</li>
<li><p>在合并奖励结果部分写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">resp.setRetainPopDisplay(mainSceneService.getRetainPopDisplay(req, activityDto));</span><br></pre></td></tr></table></figure></li>
</ul>
<p>在 <code>MainSceneService</code>类下新增一个 <code>getRetainPopDisplay(activityDto)</code>的方法，用于通过DTO的状态获取得到RetainPopDisplay的结果。这里要<strong>写清楚业务需求的逻辑关系（最关键的部分！）</strong>，目前的需求就是按照传入的dto和req中的id进行分析，看是否符合弹出挽留窗口的需求。</p>
<p><strong>注意完成这部分的开发后要修改版本号，如从1.0.29到1.0.30-SNAPSHOT</strong>，然后在devtools网站上进行jar包的更新。</p>
<h3 id="修改http服务"><a href="#修改http服务" class="headerlink" title="修改http服务"></a>修改http服务</h3><p>首先需要全局搜索<code>grocerymkthd-game-center-client</code>jar包所在的pom.xml的位置并进行相应版本号的修改，才能导入我们开发完成后的字段和功能。</p>
<p>在web模块下，在controller包下找到 <code>GameCenterController</code>类中的 <code>loadMainView</code>方法，找到loadMainView的实现，在其中进入 <code>convertToResp</code>方法：</p>
<ul>
<li><p>查看返回类型 <code>GameCenterMainSceneResp</code>，在其中加入一个挽留弹窗状态 <code>retailPopDisplay</code> 的字段，返回类型为Boolean</p>
</li>
<li><p>加入以下一行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">resp.setRetainPopDisplay(mainSceneResp.getRetainPopDisplay());</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="在泳道上部署服务"><a href="#在泳道上部署服务" class="headerlink" title="在泳道上部署服务"></a>在泳道上部署服务</h3><h3 id="整体测试"><a href="#整体测试" class="headerlink" title="整体测试"></a>整体测试</h3><p>在ones中完成一些case的测试</p>
<h3 id="线上监控"><a href="#线上监控" class="headerlink" title="线上监控"></a>线上监控</h3><p>线上ERROR：</p>
<ul>
<li>线上ERROR率走势：errorRate &#x3D; failCount&#x2F;totalCount*100%</li>
<li>接口错误率：errorRate &#x3D; failCount&#x2F;totalCount*100%</li>
</ul>
<p>线上性能：</p>
<ul>
<li><p>TP响应趋势：在开始时间和结束时间内，组织内所有服务（appkey）的平均响应时间走势</p>
<p>TPavg &#x3D; （TPavgA * totalCountA + TPavgB * totalCountB）&#x2F;（totalCountA + totalCountB）</p>
</li>
<li><p>慢响应（long-url）：在开始时间和结束时间内，组织内所有服务（appkey）的long-url走势</p>
</li>
<li><p>慢缓存（long-cache）</p>
</li>
<li><p>慢消息（long-mq）</p>
</li>
<li><p>慢RPC调用量（long-call）</p>
</li>
<li><p>慢服务数（long-service）</p>
</li>
</ul>
<p>线上故障：</p>
<ul>
<li>故障数（COE）</li>
<li>热修复统计</li>
</ul>
]]></content>
      <categories>
        <category>Projects</category>
        <category>MeiTuan</category>
      </categories>
      <tags>
        <tag>MeiTuan</tag>
        <tag>Projects</tag>
      </tags>
  </entry>
  <entry>
    <title>GET/POST</title>
    <url>/2022/05/10/GET-POST/</url>
    <content><![CDATA[<p>简介HTTP，并总结GET和POST的区别</p>
<span id="more"></span>

<h4 id="什么是-HTTP-？"><a href="#什么是-HTTP-？" class="headerlink" title="什么是 HTTP ？"></a>什么是 HTTP ？</h4><p>超文本传输协议（HTTP）的设计目的是保证客户端与服务器之间的通信。</p>
<p>HTTP 的工作方式是客户端与服务器之间的请求-应答协议。</p>
<p>web 浏览器可能是客户端，而计算机上的网络应用程序也可能作为服务器端。</p>
<p>举例：客户端（浏览器）向服务器提交 HTTP 请求；服务器向客户端返回响应。响应包含关于请求的状态信息以及可能被请求的内容。</p>
<p><strong>特点总结</strong>：</p>
<ul>
<li>基于tcp&#x2F;ip、一种网络应用层协议、超文本传输协议HyperText Transfer Protocol</li>
<li>工作方式：客户端请求服务端应答的模式</li>
<li>快速：无状态连接</li>
<li>灵活：可以传输任意对象，对象类型由Content-Type标记</li>
</ul>
<p>客户端请求request消息包括以下格式：请求行（request line）、请求头部（header）、空行、请求数据</p>
<img src="https://pic.imgdb.cn/item/627b775809475431298c5e7d.jpg" style="zoom:80%;" />

<p>服务端响应response也由四个部分组成，分别是：状态行、消息报头、空行、响应正文</p>
<p>or</p>
<p>＜request-line＞</p>
<p>＜headers＞</p>
<p>＜blank line＞</p>
<p>[＜request-body＞]</p>
<h5 id="request"><a href="#request" class="headerlink" title="request"></a>request</h5><p><strong>1.请求头</strong></p>
<p>请求行由请求方法字段、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔。例如，GET &#x2F;index.html HTTP&#x2F;1.1。</p>
<p>HTTP协议的请求方法有GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT。</p>
<p> <strong>2.请求头部</strong></p>
<p>请求头部由关键字&#x2F;值对组成，每行一对，关键字和值用英文冒号“:”分隔。请求头部通知服务器有关于客户端请求的信息，典型的请求头有：</p>
<p>User-Agent：产生请求的浏览器类型。</p>
<p>Accept：客户端可识别的内容类型列表。</p>
<p>Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。</p>
<p><strong>3.空行</strong></p>
<p>最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。</p>
<p><strong>4.请求数据</strong></p>
<p>请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。</p>
<h5 id="response"><a href="#response" class="headerlink" title="response"></a>response</h5><p><strong>HTTP报文</strong></p>
<p>HTTP响应也由三个部分组成，分别是：状态行、消息报头、响应正文。</p>
<p>如下所示，HTTP响应的格式与请求的格式十分类似：</p>
<p>＜status-line＞</p>
<p>＜headers＞</p>
<p>＜blank line＞</p>
<p>[＜response-body＞]</p>
<p> 正如你所见，<strong>在响应中唯一真正的区别在于第一行中用状态信息代替了请求信息</strong>。状态行（status line）通过提供一个状态码来说明所请求的资源情况。</p>
<p>状态行格式如下：</p>
<p>HTTP-Version Status-Code Reason-Phrase CRLF</p>
<p>其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述。状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。</p>
<ul>
<li>1xx：指示信息–表示请求已接收，继续处理。</li>
<li>2xx：成功–表示请求已被成功接收、理解、接受。</li>
<li>3xx：重定向–要完成请求必须进行更进一步的操作。</li>
<li>4xx：客户端错误–请求有语法错误或请求无法实现。</li>
<li>5xx：服务器端错误–服务器未能实现合法的请求。</li>
</ul>
<p>常见状态代码、状态描述的说明如下。</p>
<ul>
<li>200 OK：客户端请求成功。</li>
<li>400 Bad Request：客户端请求有语法错误，不能被服务器所理解。</li>
<li>401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。</li>
<li>403 Forbidden：服务器收到请求，但是拒绝提供服务。</li>
<li>404 Not Found：请求资源不存在，举个例子：输入了错误的URL。</li>
<li>500 Internal Server Error：服务器发生不可预期的错误。</li>
<li>503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常，举个例子：HTTP&#x2F;1.1 200 OK（CRLF）。</li>
</ul>
<h4 id="两种-HTTP-请求方法：GET-和-POST"><a href="#两种-HTTP-请求方法：GET-和-POST" class="headerlink" title="两种 HTTP 请求方法：GET 和 POST"></a>两种 HTTP 请求方法：GET 和 POST</h4><p>在客户机和服务器之间进行请求-响应时，两种最常被用到的方法是：GET 和 POST。</p>
<ul>
<li><strong>GET</strong> - 从指定的资源请求数据。</li>
<li><strong>POST</strong> - 向指定的资源提交要被处理的数据。</li>
</ul>
<h5 id="GET-方法"><a href="#GET-方法" class="headerlink" title="GET 方法"></a>GET 方法</h5><p><strong>请注意，查询字符串（名称&#x2F;值对）是在 GET 请求的 URL 中发送的：</strong></p>
<p>&#x2F;test&#x2F;demo_form.php**?name1&#x3D;value1&amp;name2&#x3D;value2**</p>
<p><strong>有关 GET 请求的其他一些注释：</strong></p>
<ul>
<li>GET 请求可被缓存</li>
<li>GET 请求保留在浏览器历史记录中</li>
<li>GET 请求可被收藏为书签</li>
<li>GET 请求不应在处理敏感数据时使用</li>
<li>GET 请求有长度限制</li>
<li>GET 请求只应当用于取回数据</li>
</ul>
<h5 id="POST-方法"><a href="#POST-方法" class="headerlink" title="POST 方法"></a>POST 方法</h5><p><strong>请注意，查询字符串（名称&#x2F;值对）是在 POST 请求的 HTTP 消息主体中发送的：</strong></p>
<p>POST &#x2F;test&#x2F;demo_form.php HTTP&#x2F;1.1<br>Host: runoob.com<br><strong>name1&#x3D;value1&amp;name2&#x3D;value2</strong></p>
<p><strong>有关 POST 请求的其他一些注释：</strong></p>
<ul>
<li>POST 请求不会被缓存</li>
<li>POST 请求不会保留在浏览器历史记录中</li>
<li>POST 不能被收藏为书签</li>
<li>POST 请求对数据长度没有要求</li>
</ul>
<h5 id="比较-GET-与-POST"><a href="#比较-GET-与-POST" class="headerlink" title="比较 GET 与 POST"></a>比较 GET 与 POST</h5><p>下面的表格比较了两种 HTTP 方法：GET 和 POST。</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">GET</th>
<th align="left">POST</th>
</tr>
</thead>
<tbody><tr>
<td align="left">后退按钮&#x2F;刷新</td>
<td align="left">无害</td>
<td align="left">数据会被重新提交（浏览器应该告知用户数据会被重新提交）。</td>
</tr>
<tr>
<td align="left">书签</td>
<td align="left">可收藏为书签</td>
<td align="left">不可收藏为书签</td>
</tr>
<tr>
<td align="left">缓存</td>
<td align="left">能被缓存</td>
<td align="left">不能缓存</td>
</tr>
<tr>
<td align="left">编码类型</td>
<td align="left">application&#x2F;x-www-form-urlencoded</td>
<td align="left">application&#x2F;x-www-form-urlencoded or multipart&#x2F;form-data。为二进制数据使用多重编码。</td>
</tr>
<tr>
<td align="left">历史</td>
<td align="left">参数保留在浏览器历史中。</td>
<td align="left">参数不会保存在浏览器历史中。</td>
</tr>
<tr>
<td align="left">对数据长度的限制</td>
<td align="left">是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。（只能发送2M大小的数据）</td>
<td align="left">无限制。</td>
</tr>
<tr>
<td align="left">对数据类型的限制</td>
<td align="left">只允许 ASCII 字符。</td>
<td align="left">没有限制。也允许二进制数据。</td>
</tr>
<tr>
<td align="left">安全性</td>
<td align="left">与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。  在发送密码或其他敏感信息时绝不要使用 GET ！</td>
<td align="left">POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。</td>
</tr>
<tr>
<td align="left">可见性</td>
<td align="left">数据在 URL 中对所有人都是可见的。</td>
<td align="left">数据不会显示在 URL 中。</td>
</tr>
</tbody></table>
<ul>
<li>GET用于获取信息，是无副作用的，是幂等的，且可缓存</li>
<li>POST用于修改服务器上的数据，有副作用，非幂等（不能随意多次执行），不可缓存</li>
</ul>
<h4 id="其他-HTTP-请求方法"><a href="#其他-HTTP-请求方法" class="headerlink" title="其他 HTTP 请求方法"></a>其他 HTTP 请求方法</h4><p>下面的表格列出了其他一些 HTTP 请求方法：</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">HEAD</td>
<td align="left">与 GET 相同，但只返回 HTTP 报头，不返回文档主体。</td>
</tr>
<tr>
<td align="left">PUT</td>
<td align="left">上传指定的 URI 表示。</td>
</tr>
<tr>
<td align="left">DELETE</td>
<td align="left">删除指定资源。</td>
</tr>
<tr>
<td align="left">OPTIONS</td>
<td align="left">返回服务器支持的 HTTP 方法。</td>
</tr>
<tr>
<td align="left">CONNECT</td>
<td align="left">把请求连接转换到透明的 TCP&#x2F;IP 通道。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP/IP知识整理</title>
    <url>/2022/05/10/TCP-IP/</url>
    <content><![CDATA[<p>本文记录了TCP&#x2F;IP协议的一些基本知识，包括概念、功能和数据包格式</p>
<span id="more"></span>

<h3 id="1-TCP-x2F-IP-协议体系"><a href="#1-TCP-x2F-IP-协议体系" class="headerlink" title="1. TCP&#x2F;IP 协议体系"></a>1. TCP&#x2F;IP 协议体系</h3><p>为了减少网络设计的复杂性，大多数网络都采用了分层结构。不同的网络，层的数量、名字、内容和功能都不尽相同。相同网络中，一台机器上的第N层与另一台机器上的第N层利用第N层协议进行通信，协议基本上是双方关于如何进行通信所达成的一致。<br> TCP&#x2F;IP参考模型就是一个符合上面描述的网络体系结构。他是依据他的两个主要协议-TCP和IP而命名的。这一网络细分一般是七层：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。</p>
<h3 id="2-IP协议"><a href="#2-IP协议" class="headerlink" title="2. IP协议"></a>2. IP协议</h3><h4 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1  概念"></a>2.1  概念</h4><p>IP协议用于连接多个分组交换网，他提供在具有固定地址长度的主机之间传送数据报，以及根据各个数据包大小的不同，在需要时进行分段和重组大数据报的功能。IP协议仅限于将数据从源端传送到目的端，而不提供可靠的传输服务。在传送出错时，IP协议通过互联网控制消息协议（<a href="https://link.jianshu.com/?t=https://baike.baidu.com/item/ICMP">ICMP, Internet Control Message Protocol</a>）报告。</p>
<h4 id="2-2-功能"><a href="#2-2-功能" class="headerlink" title="2.2  功能"></a>2.2  功能</h4><p><strong>IP协议最基本的两个功能：寻址和分段</strong></p>
<p><strong>寻址：</strong>IP协议根据数据报头中所包含的目的地址将数据报传输到目的端，传送过程中对道路的选择称为<strong>路由</strong><br><strong>分段：</strong>当一些网络只能传送小数据报时，IP协议将数据报分段并在报头里面注明。数据包也可以被标记为“不可分段”，如果一个数据报被如此标记，那么在任何情况下都不准对他进行分段，如果因此到不了目的地，那么数据包就会在中途被丢弃。</p>
<h4 id="2-3-IP协议数据报的头："><a href="#2-3-IP协议数据报的头：" class="headerlink" title="2.3  IP协议数据报的头："></a>2.3  IP协议数据报的头：</h4><h5 id="2-3-1-IP协议头部格式"><a href="#2-3-1-IP协议头部格式" class="headerlink" title="2.3.1  IP协议头部格式"></a>2.3.1  IP协议头部格式</h5><img src="https://pic.imgdb.cn/item/627a268a09475431293fb0bb.jpg" style="zoom:80%;" />

<ul>
<li><strong>版本</strong>：记录数据报属于哪个版本的协议，例如可以用此区分出IPv4和IPv6，这个字段可以使得在不同版本间传递数据变得可行。</li>
<li><strong>头部长</strong>：标明IP协议报头有多长，<strong>其单位是32bit即4个字节</strong>，其最小值为5（<code>5 x 4 = 20 byte</code>，这个长度是除去可选项的长度），从上图中看出，其规定头部长为 4 bit，所以最大值为 15， <code>15 x 4 = 60 byte</code> 可以算出可选项长度最大为40个字节(即 <code>60 byte - 20 byte = 40 byte</code>)</li>
<li><strong>服务类型</strong>：用来指示当数据报在一个特定网络中传输时对实际服务质量的要求是什么，服务类型字段从左到右由一个3位的优先顺序字段、三个标志位(D、T、R)和两个保留位组成。优先顺序字段用于标志该数据报的优先级，D、T、R三个标志位分别代表是否对低延迟(Delay)、高吞吐量(Throughput)、高可靠性(Reliability)有要求，不过实际上，现在的路由器都忽略服务类型这个字段。</li>
<li><strong>总长</strong>：是指整个数据报的长度，包括头部和数据部分，<strong>单位是 1 个字节</strong>，从图上可以看出，规定总长位数为16bit，能存储最大数据为65535个字节的数据报。如长的数据报对大部分主机和网络来说是不现实的。所有主机必须能够接收长达576个字节的数据报(不管他们是以整个数据报到达还是以分片到达)，源端主机在确认目的地址能够接收大数据报的情况下才发送大于576字节的数据报。</li>
<li><strong>标识</strong>：该标识由发送者设定值，主要为了目的主机组装分段时判断新到的报文分段属于哪个分组，所有属于同一分组的报文分段都包含相同的标识。</li>
<li><strong>标记</strong>：长度为3bit，从前到后分别是<strong>保留位</strong>、<strong>不可分段位</strong>(DF, Don’t Fragment)和<strong>分段位</strong>(MF,More Fragment)。<br> 保留为始终为 0<br> DF位为 1 时表示该分组不能被分段<br> MF位为 1 时表示后面还有该分组的分段，在有分段的情况下，除了最后一个分段该位为 0 外，其他分段该位都为 1</li>
<li><strong>分段偏移</strong>：标记该分段在数据报的位置，<strong>单位是8个字节</strong>，第一个分段的偏移是 0</li>
<li><strong>生命期</strong>：用来限制分组生命周期的计数器，<strong>单位是秒</strong>，该字段长度为 8bit ，说明存储的最大数值是 255 ，在实际的应用过程中是以经过的节点计数的，每经过一个节点计数减 1 ，计数减到 0 时，分组要被丢弃。</li>
<li><strong>协议</strong>：指明IP层所封装的上层协议类型，如ICMP -&gt; 1、IGMP -&gt; 2 、TCP -&gt; 6、UDP -&gt; 17、EIGRP -&gt; 88 、OSPF -&gt; 89等</li>
<li><strong>头部效验和</strong>：只对头部进行效验，由于头部的一些字段始终在变化(例如：生命期字段)，头部效验和在每个节点都得重新进行计算。</li>
<li><strong>源地址</strong>：发送报文段的IP地址</li>
<li><strong>目的地址</strong>：接收报文段的IP地址</li>
<li><strong>可选项</strong>：可选项对于主机和网关的IP模块来说都是必须实现的，可选是指它们在特定数据报中是否出现是可选的，而不是指他们的实现，每个可选项都以 1 个字节表明它的类型。其长度从1~40个字节之间不固定，主要取决于设置的可选项数目，最终数据长度不够32位的倍数要填充 0 补齐，主要是为了让报头长度是32位的整数倍，一般正常的IP报文头部都是没有可选项的。<br> 目前已定义的可选项有 5 个，分别是安全性(指明数据报的机密程度)、严格路由选择(后面给出所规定的完全路由)、宽松路由选择(后面给出必须要经过的路由)、记录路由(记录下所经路由器附上其IP地址)、时间戳(要求所经路由器都附上其IP地址和时间标记)。</li>
</ul>
<h5 id="2-3-2-IP协议头部数据"><a href="#2-3-2-IP协议头部数据" class="headerlink" title="2.3.2  IP协议头部数据"></a>2.3.2  IP协议头部数据</h5><p>下面是我用抓包工具抓到的一个TCP断开的四次握手，其他的咱不管，先看第一次发送FIN类型数据包的IP报头部分</p>
<img src="https://pic.imgdb.cn/item/627a2795094754312944b85c.jpg" style="zoom:80%;" />

<p>最下面的是数据，去掉以前面<strong>太网首部</strong>的14个字节开始是IP数据报头部分，下面我们对着上面的格式来解析下</p>
<p>先单独把IP报头数据粘贴下来</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字节为单位 Hex+ASCII方式显示</span></span><br><span class="line"><span class="number">45</span> <span class="number">00</span> <span class="number">00</span> <span class="number">28</span> a2 ad <span class="number">40</span> <span class="number">00</span> <span class="number">39</span> <span class="number">06</span> <span class="number">0f</span> <span class="number">71</span> b7 <span class="number">83</span> <span class="number">87</span> <span class="number">91</span> <span class="number">0</span>a <span class="number">16</span> <span class="number">46</span> <span class="number">87</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二进制 bit流显示为</span></span><br><span class="line"><span class="number">01000101</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00101000</span> </span><br><span class="line"><span class="number">10100010</span> <span class="number">10101101</span> <span class="number">01000000</span> <span class="number">00000000</span> </span><br><span class="line"><span class="number">00111001</span> <span class="number">00000110</span> <span class="number">00001111</span> <span class="number">01110001</span> </span><br><span class="line"><span class="number">10110111</span> <span class="number">10000011</span> <span class="number">10000111</span> <span class="number">10010001</span> </span><br><span class="line"><span class="number">00001010</span> <span class="number">00010110</span> <span class="number">01000110</span> <span class="number">10000111</span></span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>字段</th>
<th align="center">位置</th>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>版本</td>
<td align="center">0-3</td>
<td>0100</td>
<td>属于IPv4版本</td>
</tr>
<tr>
<td>头部长</td>
<td align="center">4-7</td>
<td>0101</td>
<td>表示头部长度为20个字节(<code>5 x 4 byte = 20 byte</code>)</td>
</tr>
<tr>
<td>服务类型</td>
<td align="center">8-31</td>
<td>00000000</td>
<td>….</td>
</tr>
<tr>
<td>总长</td>
<td align="center">32-47</td>
<td>00000000 00101000</td>
<td>IP数据报总长(不包括以太网首部) 为 40 个字节(<code>40 x 1 byte = 40 byte</code>)</td>
</tr>
<tr>
<td>标识</td>
<td align="center">48 - 50</td>
<td>010</td>
<td>保留位为 0 ， 不可分段数据报</td>
</tr>
<tr>
<td>分段偏移</td>
<td align="center">51 - 63</td>
<td>00000 00000000</td>
<td>数据偏移为0，数据报属于分组的第一个分段(其实这个数据包是不允许分段的，这里只是一个理论解释)</td>
</tr>
<tr>
<td>生命期</td>
<td align="center">64 - 71</td>
<td>00111001</td>
<td>生命期值是57，理论解释是还可以经过57个节点</td>
</tr>
<tr>
<td>协议</td>
<td align="center">72 - 79</td>
<td>00000110</td>
<td>值为6，表示上层为TCP协议</td>
</tr>
<tr>
<td>头部效验和</td>
<td align="center">80 - 95</td>
<td>00001111 01110001</td>
<td>….</td>
</tr>
<tr>
<td>源地址</td>
<td align="center">96 - 127</td>
<td>10110111 10000011 10000111 10010001</td>
<td>因为IP地址在网络中传播是用网络排序(大端)表示，所以直接按顺序解析，16进制表示：b7.83.87.91，转换成十进制表示为：183.131.135.145</td>
</tr>
<tr>
<td>目的地址</td>
<td align="center">128 - 159</td>
<td>00001010 00010110 01000110 10000111</td>
<td>十进制点形式表示为：10.22.70.135</td>
</tr>
<tr>
<td>可选项</td>
<td align="center">~</td>
<td>~</td>
<td>没有可选项</td>
</tr>
</tbody></table>
<h4 id="2-4-IP地址分类"><a href="#2-4-IP地址分类" class="headerlink" title="2.4  IP地址分类"></a>2.4  IP地址分类</h4><h5 id="2-4-1-IP地址分类"><a href="#2-4-1-IP地址分类" class="headerlink" title="2.4.1  IP地址分类"></a>2.4.1  IP地址分类</h5><p>IP地址包含网络号和主机号两部分，网络号代表一个子网络，主机号则表示该子网络下某一台具体的主机标号，IP地址根据功能和用途的不同可以划分为五类。<br> <strong>A 类地址</strong>：1 . 0 . 0 . 0 ~ 126 . 255 . 255 . 255，前 8 位为网络号，后 24 位为主机号<br> <strong>B 类地址</strong>：128 . 0 . 0 .0 ~ 191 . 255 . 255 . 255，前16位为主机号，后16位为主机号<br> <strong>C 类地址</strong>：192 . 0 . 0 . 0 ~ 223 . 255 . 255 . 255，前24位为网络号，后8位为主机号<br> <strong>D 类地址</strong>：224 . 0 . 0 .0 ~ 239 . 255 . 255 . 255<br> <strong>E 类地址</strong>：240 . 0 . 0 . 0 ~ 254 . 255 . 255 . 255</p>
<p>A、B、C三类地址是根据网络规模大小来分配给用户的，例如A类地址有24位的主机号，同一个网络下，一个 A 类地址可以容纳 2^24 - 2 &#x3D; 16777213 台主机，但是A类地址一共只能分配 126 个网络(这里只是做一个理论上的运算，并不代表实际分配情况)，所以这类地址一般分配给那些为数不多的大网络。D类地址用来多播，E类地址做保留地址。<br> <strong>另外还有一些特殊地址：</strong><br> ①. 例如主机号全为 1 是该网络的广播地址(例如在一个C类地址的网络中，192. 192 . 192 . 255 , 网络号是前面三个字节， 主机号是后面的一个字节，8位全为1，那么这个地址则是 网络号位 192.192.192.0这个网络的广播地址)。其中 255 . 255 . 255 . 255也是主机所在网络的广播地址；<br> ②. 主机号全为 0 则是该网络的网络地址；<br> ③. 127 . 0 . 0 . 0 ~ 127 . 255 . 255 . 255是主机会送地址，通常用来做网络测试，调试主机与路由是否连接畅通;<br> ④. <strong>其中 10 . 0 . 0 . 0 ~ 10 . 255 . 255 . 255、172 . 16 . 0 . 0 ~ 172 . 31 . 255 . 255、192 . 168 . 0 . 0 ~ 192 . 168 . 255 . 255保留给内部网络使用。</strong></p>
<h5 id="2-4-2-子网掩码、超网"><a href="#2-4-2-子网掩码、超网" class="headerlink" title="2.4.2  子网掩码、超网"></a>2.4.2  子网掩码、超网</h5><p>传统的IP地址分类确定是不能在网络内部使用路由，这样对于较大的网络，例如一个A类网络，由于主机数太多而变得难以管理，为此引入了子网掩码以从一个大网络上划分成一些小网络。子网掩码由一系列 0 和 1 构成，通过与IP地址做与运算来得到一个IP地址的网络号，例如A类地址的子网掩码是  255 . 0 . 0 . 0，B类地址的子网掩码是 255 . 255 . 0 . 0，C类地址的子网掩码是 255 . 255 . 255 . 0。要是想将一个B类地址(例：129 . 145 . 0 . 0)划分为多个小的C类网络，只需要将其子网掩码设为 255 . 255 . 255 . 0就可以了，这样 129 . 145 . 1 . 0和 129 . 145 . 2 . 0就属于不同网络了，因为虽然是B类地址，但是与给定的子网掩码做与运算出来的网络号不一样了，就属于不同网络。像这样通过子网掩码将一个大网络划分成若干个小网络叫做划分子网。<br> 超网：与子网功能相反，将若干个小网络划分成一个大网络。例如一个单位分配到了8个C类(前三个字节为网络号)地址：202 . 120 . 224 . 0 ~ 202 . 120 . 231 . 0，只要将其子网掩码设置为 255 . 255 . 248 . 0 就能使这些C类网络相通。(PS：这个结果是怎么得来的我现在还不明白，等日后明白了再补上)</p>
<h3 id="3、TCP协议"><a href="#3、TCP协议" class="headerlink" title="3、TCP协议"></a>3、TCP协议</h3><h4 id="3-1-概念"><a href="#3-1-概念" class="headerlink" title="3.1  概念"></a>3.1  概念</h4><p>TCP协议是用于主机到主机的通信协议。他是面向连接的端到端的可靠协议，提供可靠字节流传输和对上层应用提供连接服务。TCP协议建立在IP协议的基础之上，可以根据IP协议提供的服务传输大小不定的数据段。IP协议负责数据的分段、重组及在多种网络和互联的网关间传输数据报。<br> 为了在不可靠的IP数据传输服务上实现面向连接的可靠数据传输，<strong>TCP协议使用序列号和应答号来保证其传输的可靠性，TCP协议是面向字节流的，每个字节都有一个序列号，一个数据段的第一个字节的序列号将随同数据段被发送，并且作为这个数据段的序列号。数据段同时还带有一个应答序号，表明它期望对方下次发送的字节的顺序号。</strong>当TCP协议传输一个数据段的时候，会同时将其放入重传队列，并启动一个定时器。如果这个数据段的应答能在定时器超时前收到，那么就将它从重传队列中移除，否则重发此数据段。应答未能收到，既可能是接收方未收到所发数据段，也可能是应答本身丢失。<br> TCP协议提供了端口来区分他所处理的不同数据流。由于端口号是由操作系统、TCP协议进程或用户自行确定，所以有可能不唯一。为此将网络地址同端口号组合起来形成套接字保证其在整个互联网络上的唯一性。</p>
<h4 id="3-2-TCP协议数据报的头"><a href="#3-2-TCP协议数据报的头" class="headerlink" title="3.2  TCP协议数据报的头"></a>3.2  TCP协议数据报的头</h4><h5 id="3-2-1-TCP协议头部格式"><a href="#3-2-1-TCP协议头部格式" class="headerlink" title="3.2.1  TCP协议头部格式"></a>3.2.1  TCP协议头部格式</h5><img src="https://pic.imgdb.cn/item/627a2b47094754312952acfa.jpg" style="zoom:80%;" />

<ul>
<li><strong>源端口</strong>：发送数据端套接字的端口号</li>
<li><strong>目的端口</strong>：目的套接字端口号</li>
<li><strong>顺序号</strong>：该数据报第一个数据字节的序列号，用作标识该报文段序列号</li>
<li><strong>应答号</strong>：存放的是发送方期望收到的数据段序号，算作是对收到报文的一个确认。ACK标志为 0 时，应答号部分无效(例如首个连接的[SYN]数据包)，ACK标志为1时应答号才有效</li>
<li><strong>TCP首部长度</strong>：标明TCP协议报头长度，<strong>单位是32bit即4个字节</strong>，其最小值为5（<code>5 x 4 = 20 byte</code>，这个长度是除去可选项的长度），从上图中看出，其规定头部长为 4 bit，所以最大值为 15， <code>15 x 4 = 60 byte</code>可以算出可选项长度大为40个字节(<code>60 byte - 20 byte = 40 byte</code>)</li>
<li><strong>保留位</strong>：保留字段长度为3位，必须全置为0</li>
<li><strong>标记</strong>：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">标志位简写</th>
<th>全写</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">NS</td>
<td>Nonce</td>
<td>有效排除潜在的ECN滥用</td>
</tr>
<tr>
<td align="center">CWR</td>
<td>Congestion Window Reduced</td>
<td>拥塞窗口减少标志</td>
</tr>
<tr>
<td align="center">ECE</td>
<td>ECN-Echo</td>
<td>ECN标志</td>
</tr>
<tr>
<td align="center">URG</td>
<td>Urgent</td>
<td>紧急指针有效性标志</td>
</tr>
<tr>
<td align="center">ACK</td>
<td>Acknowledgment</td>
<td>确认序号有效性标志，一旦一个连接建立起来，该标志总被置为1</td>
</tr>
<tr>
<td align="center">PSH</td>
<td>Push</td>
<td>Push标志（接收方应尽快将报文段提交至应用层）</td>
</tr>
<tr>
<td align="center">RST</td>
<td>Reset</td>
<td>重置连接标志</td>
</tr>
<tr>
<td align="center">SYN</td>
<td>Synchronization</td>
<td>同步序号标志(建立连接时候使用)</td>
</tr>
<tr>
<td align="center">FIN</td>
<td>Fin</td>
<td>传输数据结束标志(断开连接时使用)</td>
</tr>
</tbody></table>
<ul>
<li><strong>窗口</strong>：表示发送方还可以接受数据大小，防止对方发送数据大于自己的缓冲数据区，从应答字段的顺序号开始计。</li>
<li><strong>效验和</strong>：效验和覆盖整个TCP报文段，强制字段，由发送端计算存储，接收端进行验证</li>
<li><strong>紧急指针</strong>：当Urgent标志置1时，紧急指针才有效</li>
<li><strong>可选项</strong>：可选项可以有 0 到多个，可选项字段以第一个字节表明其类型，第二个字节表示该可选项的总长度，后面紧跟可选项的值(长度为可选项的总长度-2)。可选项字段可以从任何字节边界开始，但若最后选项长度不足的话，要填充以补足定义的数据段长度。具体解释请看下面 <strong>3.2.2</strong></li>
</ul>
<h5 id="3-2-2-TCP报头可选项字段"><a href="#3-2-2-TCP报头可选项字段" class="headerlink" title="3.2.2  TCP报头可选项字段"></a>3.2.2  TCP报头可选项字段</h5><p><strong>TCP报头可选项字段的数据一般拼接格式(不是全部可选项都是这个格式)</strong><br> 类型<code>kind</code>(1byte) + 长度<code>length</code>(1byte) + 值<code>value</code>(length-2byte)</p>
<p><strong>TCP报头可选项和含义：</strong></p>
<table>
<thead>
<tr>
<th>kind</th>
<th>字段</th>
<th>长度(单位byte)</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>End of Option List (EOL)</td>
<td>0 (没有长度，只有类型)</td>
</tr>
<tr>
<td>1</td>
<td>No-Operation (NOP)</td>
<td>0 (没有长度，只有类型)</td>
</tr>
<tr>
<td>2</td>
<td>Maximum segment size (MSS)</td>
<td>1 (用一个字节来表示该可选项的总长)</td>
</tr>
<tr>
<td>3</td>
<td>Window scale</td>
<td>1 (用一个字节来表示该可选项的总长)</td>
</tr>
<tr>
<td>4</td>
<td>SACK Permitted</td>
<td>1 (用一个字节来表示该可选项的总长)</td>
</tr>
<tr>
<td>5</td>
<td>SACK</td>
<td>1 (用一个字节来表示该可选项的总长)</td>
</tr>
<tr>
<td>8</td>
<td>Timestamps</td>
<td>1 (用一个字节来表示该可选项的总长)</td>
</tr>
</tbody></table>
<ul>
<li><strong>①. End of Option List (EOL)：</strong><code>kind = 0</code>，当可选项总长度不够32位的倍数，用该可选项来填补，实际就是用 0 填补</li>
<li><strong>②. No-Operation (NOP)：</strong><code>kind = 1</code>，<strong>no operation</strong>，设计该字段主要是用来明确不同可选项之间的分割点，假设有多个可选项的情况下，一般用该可选项来分割下，因此在一个数据包中出现多个nop 也不奇怪的。<strong>注意 No-Operation 可选项没有长度和值，只有一个类型占一个字节，也就是有涉及到该可选项解析只需解析一个字节，后面可能是另一个可选项的类型</strong></li>
<li><strong>③. Maximum segment size (MSS)：</strong><code>kind = 2</code>，<strong>最大报文传输段</strong>，每一个TCP报文段中数据字段的最大长度，<strong>注意：只是数据部分的字段，不包括TCP的头部</strong>。TCP在三次握手中，每一方都会通告其期望收到的MSS（MSS只出现在SYN数据包中）如果一方不接受另一方的MSS值则定位默认值536byte。<br> MSS值太小或太大都是不合适，太小，例如MSS值只有1byte，那么为了传输这1byte数据，至少要消耗20字节IP头部+20字节TCP头部&#x3D;40byte，这还不包括其二层头部所需要的开销，显然这种数据传输效率是很低的。MSS过大，导致数据包可以封装很大，那么在IP传输中分片的可能性就会增大，接收方在处理分片包所消耗的资源和处理时间都会增大，如果分片在传输中还发生了重传，那么其网络开销也会增大。因此合理的MSS是至关重要的。MSS的合理值应为保证数据包不分片的最大值。对于以太网MSS可以达到1460byte (<code>MTU(1500byte) - IP首部(20byte) - TCP首部(20byte) = 1460byte</code>)。</li>
<li><strong>④. Window scale：</strong><code>kind = 3</code>，<strong>窗口扩大选项</strong>，我们知道TCP最大的窗口大小为65535byte，在早期网络这是够用的，但随着各种复杂网络的产生，特别是类似卫星通信这种时延和带宽都比较大的通信产生，需要更大窗口来满足性能和高吞吐率，于是窗口扩大选项便产生了。<br> 我们假设 主机A — 主机B 是一条高速的WAN链路，A向B发送大量数据，由于有足够带宽，那么A在很短时间内就可以发送完 65535byte 的数据，而由于窗口过小，A只能停止发送，直到B对A发送的数据进行ACK确认。假设通信距离较远，延时也由于距离的原因变大，这么一发一确认可能需要等上很长时间，在这个等待的时间里面 A-B 是没有实际数据发送的，因此大量的时间被浪费在了等待对方回应上。<br> 这个时候我们可以通过增大窗口的大小来使一次可以传输更多的数据，从而减少等待确认的时间。<br> 窗口扩大选项占值占一个字节，表示移位值S。新的窗口值等于TCP首部的窗口位数从16增大到（16+S）。这相当于把窗口值向左移动S位后获得实际的窗口大小。移位值准许使用的最大值是14，相当于窗口最大值增大到 <code>2^(16+14) = 1073741824 byte = 1048576 kb = 1024 M = 1GB</code>，方便理解和记忆一般用<code>TCP头中的窗口值 x 2^S</code>来表示实际窗口的大小。窗口扩大选项在TCP建立之初进行协商，如果已经实现了窗口扩大，当不再需要其扩大窗口时，发送S&#x3D;0选项就可以恢复到窗口大小为16位。</li>
<li><strong>⑤. SACK Permitted：</strong> <code>kind = 4</code>，<strong>选择确认选项可以使用</strong>，SACK Permitted 选项在TCP建立连接时由SYN数据包中加上(只有类型和长度，没有值)，表示该链接允许接下来SACK的实现。</li>
<li><strong>⑥. SACK：</strong> <code>kind = 5</code>，**选择确认选项(Selective Acknowledgements )**，我们假设TCP传输中有这种情况出现，收到的报文无差错，只是未按序列号，中间还缺少一些序列号，那么能否只传输缺少的数据，而不重传已经正确到达的数据？这就是选择确认的技术。<br> 举例：主机A向主机B传输3个数据包，五个包的序号分别是1 2 3，主机B只收到了序号为 1 和 3 的数据包，而中间的2没有收到，那么如果设置可选项SACK的值，这样就可以让A主机知道只传输丢失的序列号为2的块号。<br> 原理：拿上面的例子来说，丢了2号块，收到1和3块号的数据包，那么回给主机A的确认包对于设置SACK值来说就要有一个上下的边界(表明从序列号为多少的字节传输到序列号为多少的字节中间这段数据)，序列号在TCP报头中占4个字节，表示上下边界就需要消耗8个字节(4byte x 2)，由上面讲的可知IP可选项的最大长度为 40 个字节，加上表示SACK字段需要占用1个字节，表示长度也需要占一个字节，因此最多可以指明4个字块的边界信息( <code>(40 - 2) / 8 ≈ 4</code>)。</li>
<li><strong>⑦. Timestamps：</strong><code>kind = 8</code>，<strong>时间戳选项</strong>，时间戳选项占10个字节，其中最主要的字段时间戳字段（4字节）和时间戳回送回答字段（4字节）。<br> 时间戳选项主要的功能有两个：<ul>
<li>用来计算往返时间RTT，发送方在发送报文段时把当前时钟的时间值放入时间戳字段，接收方在确认该报文段时把当前时间赋值到时间戳回送回答字段。因此，发送方在收到确认报文后，可以准确计算出RTT。</li>
<li>PAWS:防止回绕的序号，我们知道序列号只有32位，而每增加2^32 &#x3D; 4294967295 个序列号后就会重复使用原来用过的序列号。假设我们有一条高速网络，通信的主机双方有足够大的带宽用来快速的传输数据。例如1Gb&#x2F;s的速率发送报文段，则不到35秒钟数据字节的序列号就会重复。这样对TCP传输带来混乱的情况。而采用时间戳选项，可以很容易的分辨出相同序列号的数据报，哪个是最近发送，哪个是以前发送的。</li>
</ul>
</li>
</ul>
<h5 id="3-2-3-TCP协议头部数据"><a href="#3-2-3-TCP协议头部数据" class="headerlink" title="3.2.3  TCP协议头部数据"></a>3.2.3  TCP协议头部数据</h5><p>下面是我用抓包工具抓到的一个TCP断开的四次握手，其他的咱不管，先看第一次发送FIN类型数据包的TCP数据的头部</p>
<img src="https://pic.imgdb.cn/item/627a2c49094754312955a407.jpg" style="zoom:80%;" />

<p>最下面的是数据，去掉以前面<strong>太网首部</strong> 14 个字节和<strong>IP报头</strong> 20 个字节开始是TCP数据报头部分，下面我们对着上面的格式来解析下</p>
<p>先单独把TCP头部数据粘贴下来</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字节为单位 Hex+ASCII方式显示</span></span><br><span class="line"><span class="number">00</span> <span class="number">50</span> d2 <span class="number">21</span> de ce <span class="number">92</span> <span class="number">2b</span> ba da c8 db <span class="number">50</span> <span class="number">11</span> <span class="number">01</span> <span class="number">9b</span> <span class="number">57</span> <span class="number">64</span> <span class="number">00</span> <span class="number">00</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">//二进制 bit流显示</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">01010000</span> <span class="number">11010010</span> <span class="number">00100001</span> </span><br><span class="line"><span class="number">11011110</span> <span class="number">11001110</span> <span class="number">10010010</span> <span class="number">00101011</span> </span><br><span class="line"><span class="number">10111010</span> <span class="number">11011010</span> <span class="number">11001000</span> <span class="number">11011011</span> </span><br><span class="line"><span class="number">01010000</span> <span class="number">00010001</span> <span class="number">00000001</span> <span class="number">10011011</span> </span><br><span class="line"><span class="number">01010111</span> <span class="number">01100100</span> <span class="number">00000000</span> <span class="number">00000000</span>   </span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>字段</th>
<th align="center">位置</th>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>源端口</td>
<td align="center">0 - 15</td>
<td>00000000 01010000</td>
<td>网络字节排序解析，源端口为 80</td>
</tr>
<tr>
<td>目的端口</td>
<td align="center">16 - 31</td>
<td>11010010 00100001</td>
<td>目的端口 53793</td>
</tr>
<tr>
<td>顺序号</td>
<td align="center">32 - 63</td>
<td>11011110 11001110 10010010 00101011</td>
<td>顺序号为~</td>
</tr>
<tr>
<td>应答号</td>
<td align="center">64 - 95</td>
<td>10111010 11011010 11001000 11011011</td>
<td>确认号为~</td>
</tr>
<tr>
<td>TCP首部长度</td>
<td align="center">96 - 99</td>
<td>0101</td>
<td>长度为20字节 <code>5 x 4 byte = 29 byte</code></td>
</tr>
<tr>
<td>保留位</td>
<td align="center">100 - 102</td>
<td>000</td>
<td>~</td>
</tr>
<tr>
<td>标记</td>
<td align="center">103 - 111</td>
<td>0 00010001</td>
<td>ACK位为 1 标记应答号有效，FIN位为 1 表示该数据包为结束标识数据包</td>
</tr>
<tr>
<td>窗口</td>
<td align="center">112 - 127</td>
<td>00000001 10011011</td>
<td>窗口值为411，标识发送套接字缓存区最大容纳411字节数据</td>
</tr>
<tr>
<td>效验和</td>
<td align="center">128 - 143</td>
<td>01010111 01100100</td>
<td>~</td>
</tr>
<tr>
<td>紧急指针</td>
<td align="center">144 - 159</td>
<td>00000000 00000000</td>
<td>紧急指针标记位(URG)为1时这里的数据才有效</td>
</tr>
<tr>
<td>可选项</td>
<td align="center">~</td>
<td>~</td>
<td>~</td>
</tr>
</tbody></table>
<h4 id="3-3-TCP通信数据交互细节和实践"><a href="#3-3-TCP通信数据交互细节和实践" class="headerlink" title="3.3  TCP通信数据交互细节和实践"></a>3.3  TCP通信数据交互细节和实践</h4><p>关于TCP连接的三次握手、中间数据交互以及断开连接的四次握手理论部分请参考我前面的一片文章<a href="https://www.jianshu.com/p/1b71b6ff4334">套接字(Socket)编程(二) 内部通信原理</a>，这里就不做重复的解释了</p>
<h5 id="3-3-1-TCP建立连接的三次握手抓包数据部分"><a href="#3-3-1-TCP建立连接的三次握手抓包数据部分" class="headerlink" title="3.3.1  TCP建立连接的三次握手抓包数据部分"></a>3.3.1  TCP建立连接的三次握手抓包数据部分</h5><p>首先来看下抓包过程截图</p>
<img src="https://pic.imgdb.cn/item/627a2fdf0947543129600c42.jpg" style="zoom:80%;" />

<p>① 客户端发送[SYN]同步消息</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以太网头部+IP报头+TCP报头+TCP数据(字节为单位位 Hex+ASCII方式显示)</span></span><br><span class="line"><span class="number">88</span> <span class="number">25</span> <span class="number">93</span> <span class="number">02</span> b7 <span class="number">8</span>c <span class="number">78</span> <span class="number">4f</span> <span class="number">43</span> <span class="number">5b</span> <span class="number">56</span> <span class="number">75</span> <span class="number">08</span> <span class="number">00</span> <span class="number">45</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">40</span> <span class="number">00</span> <span class="number">40</span> <span class="number">06</span> f6 <span class="number">72</span> <span class="number">0</span>a <span class="number">16</span> <span class="number">46</span> <span class="number">87</span> cb d0</span><br><span class="line"><span class="number">27</span> d8 d2 <span class="number">23</span> <span class="number">01</span> bb <span class="number">2</span>e f0 <span class="number">89</span> c5 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> b0 <span class="number">02</span></span><br><span class="line">ff ff b3 <span class="number">39</span> <span class="number">00</span> <span class="number">00</span> <span class="number">02</span> <span class="number">04</span> <span class="number">05</span> b4 <span class="number">01</span> <span class="number">03</span> <span class="number">03</span> <span class="number">05</span> <span class="number">01</span> <span class="number">01</span></span><br><span class="line"><span class="number">08</span> <span class="number">0</span>a <span class="number">32</span> a6 <span class="number">80</span> <span class="number">43</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">04</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//提取TCP报头+TCP数据(去掉以太网头部14byte和IP报头20byte)</span></span><br><span class="line">d2 <span class="number">23</span> <span class="number">01</span> bb </span><br><span class="line"><span class="number">2</span>e f0 <span class="number">89</span> c5 </span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line">b0 <span class="number">02</span> ff ff </span><br><span class="line">b3 <span class="number">39</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">02</span> <span class="number">04</span> <span class="number">05</span> b4 <span class="number">01</span> <span class="number">03</span> <span class="number">03</span> <span class="number">05</span> <span class="number">01</span> <span class="number">01</span> <span class="number">08</span> <span class="number">0</span>a <span class="number">32</span> a6 <span class="number">80</span> <span class="number">43</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">04</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span></span><br></pre></td></tr></table></figure>

<p>解析：从上面可以解析出源端口号为：0xd23 &#x3D; 353795；目的端口号：0x01bb &#x3D; 443；序列号：SEQ &#x3D; 0x2ef089c5；ACK &#x3D; 0x00000000；TCP报头长为：<code>0xb = 11(32 bit)，11 x 4 byte = 44 byte</code>，即TCP报头长为 44 个字节；窗口大小为 0xffff &#x3D; 65535 byte；<br> 保留位和标志位：0x002 &#x3D; 0b000000000010；<strong>按位解析标志位为 0b000000010</strong>，NS: 0，CWR: 0，ECE: 0，URG: 0，ACK: 0，PSH: 0，RST: 0，SYN: 1，FIN: 0，<strong>从解析里面可以看出该报文ACK字段无效，只有SYN字段有效，是第一个请求连接[SYN]同步数据报</strong>；<br> 可选项部分：可以看出该TCP报头最后的24个字节表示可选项，解析如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">02</span> <span class="number">04</span> <span class="number">05</span> b4            kind = <span class="number">2</span>, <span class="built_in">len</span> = <span class="number">4</span>，MMS Value = <span class="number">0x05b4</span> 表示MSS = <span class="number">1460</span><span class="type">byte</span></span><br><span class="line"><span class="number">01</span>                     kind = <span class="number">1</span>  No-Operation</span><br><span class="line"><span class="number">03</span> <span class="number">03</span> <span class="number">05</span>               kind = <span class="number">3</span>，<span class="built_in">len</span> = <span class="number">3</span>，value = <span class="number">0x05</span>  窗口选项偏移<span class="number">5</span>位，即实际窗口大小为 <span class="number">0xffff</span> x <span class="number">2</span>^<span class="number">5</span></span><br><span class="line"><span class="number">01</span>                     kind = <span class="number">1</span>  No-Operation</span><br><span class="line"><span class="number">01</span>                     kind = <span class="number">1</span>  No-Operation</span><br><span class="line"><span class="number">08</span> <span class="number">0</span>a <span class="number">32</span> a6 <span class="number">80</span> <span class="number">43</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>   kind = <span class="number">8</span>，<span class="built_in">len</span> = <span class="number">10</span>  时间戳选项，Timestamp Value(TSval): <span class="number">0x32a68043</span> = <span class="number">849772611</span>，Timestamp echo reply(TSecr): <span class="number">0</span></span><br><span class="line"><span class="number">04</span> <span class="number">02</span>                  kind = <span class="number">4</span>，<span class="built_in">len</span>  =<span class="number">2</span>  SACK Permitted，选择确认选项有效</span><br><span class="line"><span class="number">00</span> <span class="number">00</span>                  kind = <span class="number">0</span>  补充够<span class="number">32</span>bit，即<span class="number">4</span><span class="type">byte</span>的倍数</span><br></pre></td></tr></table></figure>

<p>② 服务器回复[SYN+ACK]消息</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以太网头部+IP报头+TCP报头+TCP数据(字节为单位位 Hex+ASCII方式显示)</span></span><br><span class="line"><span class="number">78</span> <span class="number">4f</span> <span class="number">43</span> <span class="number">5b</span> <span class="number">56</span> <span class="number">75</span> <span class="number">88</span> <span class="number">25</span> <span class="number">93</span> <span class="number">02</span> b7 <span class="number">8</span>c <span class="number">08</span> <span class="number">00</span> <span class="number">45</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">3</span>c <span class="number">66</span> f2 <span class="number">00</span> <span class="number">00</span> <span class="number">38</span> <span class="number">06</span> d7 <span class="number">84</span> cb d0 <span class="number">27</span> d8 <span class="number">0</span>a <span class="number">16</span></span><br><span class="line"><span class="number">46</span> <span class="number">87</span> <span class="number">01</span> bb d2 <span class="number">23</span> f4 <span class="number">36</span> <span class="number">9f</span> <span class="number">4</span>a <span class="number">2</span>e f0 <span class="number">89</span> c6 a0 <span class="number">12</span></span><br><span class="line"><span class="number">71</span> <span class="number">20</span> a5 e3 <span class="number">00</span> <span class="number">00</span> <span class="number">02</span> <span class="number">04</span> <span class="number">05</span> a0 <span class="number">04</span> <span class="number">02</span> <span class="number">08</span> <span class="number">0</span>a d6 c8</span><br><span class="line"><span class="number">42</span> f0 <span class="number">32</span> a6 <span class="number">80</span> <span class="number">43</span> <span class="number">01</span> <span class="number">03</span> <span class="number">03</span> <span class="number">08</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//提取TCP报头+TCP数据(去掉以太网头部14byte和IP报头20byte)</span></span><br><span class="line"><span class="number">01</span> bb d2 <span class="number">23</span> </span><br><span class="line">f4 <span class="number">36</span> <span class="number">9f</span> <span class="number">4</span>a </span><br><span class="line"><span class="number">2</span>e f0 <span class="number">89</span> c6 </span><br><span class="line">a0 <span class="number">12</span> <span class="number">71</span> <span class="number">20</span> </span><br><span class="line">a5 e3 <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">02</span> <span class="number">04</span> <span class="number">05</span> a0 <span class="number">04</span> <span class="number">02</span> <span class="number">08</span> <span class="number">0</span>a d6 c8 <span class="number">42</span> f0 <span class="number">32</span> a6 <span class="number">80</span> <span class="number">43</span> <span class="number">01</span> <span class="number">03</span> <span class="number">03</span> <span class="number">08</span></span><br></pre></td></tr></table></figure>

<p>解析：从上面可以解析出源端口号为：0x01bb &#x3D; 443；目的端口号：0xd23 &#x3D; 353795；序列号：SEQ &#x3D; 0xf4369f4a；ACK &#x3D; 0x2ef089c6**(即第一个包的SEQ+1，对第一个同步包的确认)<strong>；TCP报头长为：0xa &#x3D; 10(32 bit)，10 x 4 byte &#x3D; 40 byte，即TCP报头长为 40 个字节；窗口大小为 0x7120 &#x3D;28960 byte；<br> 保留位和标志位：0x012 &#x3D; 0b000000010010；按位解析标志位为 0b000010010，NS: 0，CWR: 0，ECE: 0，URG: 0，ACK: 1，PSH: 0，RST: 0，SYN: 1，FIN: 0，</strong>从解析里面可以看出该报文ACK字段和SYN字段有效，是对第一个连接请求包的确认[SYN+ACK]数据报**；<br> 可选项部分：可以看出该TCP报头最后的20个字节表示可选项，解析如下</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="number">02</span> <span class="number">04</span> <span class="number">05</span> a0       kind = <span class="number">2</span>, len = <span class="number">4</span>，<span class="keyword">value</span> = <span class="number">0x05a0</span> 表示MSS = <span class="number">1440</span> <span class="built_in">byte</span></span><br><span class="line"><span class="number">04</span> <span class="number">02</span>             kind = <span class="number">4</span>  SACK Permitted，选择确认选项有效</span><br><span class="line"><span class="number">08</span> <span class="number">0</span>a d6 c8 <span class="number">42</span> f0 <span class="number">32</span> a6 <span class="number">80</span> <span class="number">43</span>  kind = <span class="number">8</span>, len = <span class="number">10</span> 时间戳选项，<span class="function">Timestamp <span class="title">Value</span>(<span class="params">TSval</span>): 0xd6c842f0</span> = <span class="number">36033448560</span>，<span class="function">Timestamp echo <span class="title">reply</span>(<span class="params">TSecr</span>): 0x32a68043</span> = <span class="number">849772611</span></span><br><span class="line"><span class="number">01</span>   kind = <span class="number">1</span>     NOP</span><br><span class="line"><span class="number">03</span> <span class="number">03</span> <span class="number">08</span>  kind = <span class="number">3</span>, len = <span class="number">3</span>，<span class="keyword">value</span> = <span class="number">8</span> 窗口选项偏移<span class="number">8</span>位，即实际窗口大小为 <span class="number">0x7120</span> x <span class="number">2</span>^<span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>③ 客户端回复[ACK]消息，表示连接成功</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以太网头部+IP报头+TCP报头+TCP数据(字节为单位位 Hex+ASCII方式显示)</span></span><br><span class="line"><span class="number">88</span> <span class="number">25</span> <span class="number">93</span> <span class="number">02</span> b7 <span class="number">8</span>c <span class="number">78</span> <span class="number">4f</span> <span class="number">43</span> <span class="number">5b</span> <span class="number">56</span> <span class="number">75</span> <span class="number">08</span> <span class="number">00</span> <span class="number">45</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">34</span> <span class="number">00</span> <span class="number">00</span> <span class="number">40</span> <span class="number">00</span> <span class="number">40</span> <span class="number">06</span> f6 <span class="number">7</span>e <span class="number">0</span>a <span class="number">16</span> <span class="number">46</span> <span class="number">87</span> cb d0</span><br><span class="line"><span class="number">27</span> d8 d2 <span class="number">23</span> <span class="number">01</span> bb <span class="number">2</span>e f0 <span class="number">89</span> c6 f4 <span class="number">36</span> <span class="number">9f</span> <span class="number">4b</span> <span class="number">80</span> <span class="number">10</span></span><br><span class="line"><span class="number">10</span> <span class="number">09</span> <span class="number">35</span> <span class="number">75</span> <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">01</span> <span class="number">08</span> <span class="number">0</span>a <span class="number">32</span> a6 <span class="number">80</span> <span class="number">82</span> d6 c8</span><br><span class="line"><span class="number">42</span> f0</span><br><span class="line"></span><br><span class="line"><span class="comment">//提取TCP报头+TCP数据(去掉以太网头部14byte和IP报头20byte)</span></span><br><span class="line">d2 <span class="number">23</span> <span class="number">01</span> bb </span><br><span class="line"><span class="number">2</span>e f0 <span class="number">89</span> c6 </span><br><span class="line">f4 <span class="number">36</span> <span class="number">9f</span> <span class="number">4b</span> </span><br><span class="line"><span class="number">80</span> <span class="number">10</span> <span class="number">10</span> <span class="number">09</span> </span><br><span class="line"><span class="number">35</span> <span class="number">75</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">01</span> <span class="number">01</span> <span class="number">08</span> <span class="number">0</span>a <span class="number">32</span> a6 <span class="number">80</span> <span class="number">82</span> d6 c8 <span class="number">42</span> f0</span><br></pre></td></tr></table></figure>

<p>解析：从上面可以解析出源端口号为：0xd23 &#x3D; 353795；目的端口号：0x01bb &#x3D; 443；序列号：SEQ &#x3D; 0x2ef089c6；ACK &#x3D; 0xf4369f4b (即上一个包的SEQ +1，对上一个同步包的确认)；TCP报头长为：0x8 &#x3D; 8(32 bit)，8 x 4 byte &#x3D; 32 byte，即TCP报头长为 32 个字节；窗口大小为 0x1009  &#x3D;4105 byte；<br> 保留位和标志位：0x010 &#x3D; 0b000000010000；按位解析标志位为 0b000010000，NS: 0，CWR: 0，ECE: 0，URG: 0，ACK: 1，PSH: 0，RST: 0，SYN: 0，FIN: 0，<strong>从解析里面可以看出该报文ACK字段有效，是对上一个服务器确认请求连接包的确认[ACK]数据报</strong>；<br> 可选项部分：可以看出该TCP报头最后的12个字节表示可选项，解析如下</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="number">01</span>     kind = <span class="number">1</span>     NOP</span><br><span class="line"><span class="number">01</span>     kind = <span class="number">1</span>     NOP</span><br><span class="line"><span class="number">08</span> <span class="number">0</span>a <span class="number">32</span> a6 <span class="number">80</span> <span class="number">82</span> d6 c8 <span class="number">42</span> f0  时间戳选项，<span class="function">Timestamp <span class="title">Value</span>(<span class="params">TSval</span>): 0x32a68082</span> = <span class="number">849772674</span>，<span class="function">Timestamp echo <span class="title">reply</span>(<span class="params">TSecr</span>): 0xd6c842f0</span> = <span class="number">36033448560</span></span><br></pre></td></tr></table></figure>

<h5 id="3-3-2-TCP数据交互抓包数据部分"><a href="#3-3-2-TCP数据交互抓包数据部分" class="headerlink" title="3.3.2  TCP数据交互抓包数据部分"></a>3.3.2  TCP数据交互抓包数据部分</h5><p>下面来一组TCP连接中间交换数据部分</p>
<p>① 客户端发送数据</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以太网头部+IP报头+TCP报头+TCP数据(字节为单位位 Hex+ASCII方式显示)</span></span><br><span class="line"><span class="number">88</span> <span class="number">25</span> <span class="number">93</span> <span class="number">02</span> b7 <span class="number">8</span>c <span class="number">78</span> <span class="number">4</span>f <span class="number">43</span> <span class="number">5</span>b <span class="number">56</span> <span class="number">75</span> <span class="number">08</span> <span class="number">00</span> <span class="number">45</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> f5 <span class="number">00</span> <span class="number">00</span> <span class="number">40</span> <span class="number">00</span> <span class="number">40</span> <span class="number">06</span> f5 bd <span class="number">0</span>a <span class="number">16</span> <span class="number">46</span> <span class="number">87</span> cb d0</span><br><span class="line"><span class="number">27</span> d8 d2 <span class="number">23</span> <span class="number">01</span> bb <span class="number">2</span>e f0 <span class="number">89</span> c6 f4 <span class="number">36</span> <span class="number">9</span>f <span class="number">4</span>b <span class="number">80</span> <span class="number">18</span></span><br><span class="line"><span class="number">10</span> <span class="number">09</span> <span class="number">43</span> d2 <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">01</span> <span class="number">08</span> <span class="number">0</span>a <span class="number">32</span> a6 <span class="number">80</span> <span class="number">82</span> d6 c8</span><br><span class="line"><span class="number">42</span> f0  + <span class="number">193</span><span class="type">byte</span> TCP数据</span><br><span class="line"></span><br><span class="line"><span class="comment">//提取TCP报头+TCP数据(去掉以太网头部14byte和IP报头20byte)</span></span><br><span class="line">d2 <span class="number">23</span> <span class="number">01</span> bb </span><br><span class="line"><span class="number">2</span>e f0 <span class="number">89</span> c6 </span><br><span class="line">f4 <span class="number">36</span> <span class="number">9</span>f <span class="number">4</span>b </span><br><span class="line"><span class="number">80</span> <span class="number">18</span> <span class="number">10</span> <span class="number">09</span> </span><br><span class="line"><span class="number">43</span> d2 <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">01</span> <span class="number">01</span> <span class="number">08</span> <span class="number">0</span>a <span class="number">32</span> a6 <span class="number">80</span> <span class="number">82</span> d6 c8 <span class="number">42</span> f0  </span><br><span class="line">+ <span class="number">193</span><span class="type">byte</span> TCP数据</span><br></pre></td></tr></table></figure>

<p>解析：从上面可以解析出源端口号为：0xd23 &#x3D; 353795；目的端口号：0x01bb &#x3D; 443；序列号：SEQ &#x3D; 0x2ef089c6；ACK &#x3D; 0xf4369f4b；TCP报头长为：0x8 &#x3D; 8(32 bit)，8 x 4 byte &#x3D; 32 byte，即TCP报头长为 32 个字节；窗口大小为 0x1009 &#x3D;4105 byte；<br> 保留位和标志位：0x018 &#x3D; 0b000000011000；按位解析标志位为 0b000011000，NS: 0，CWR: 0，ECE: 0，URG: 0，ACK: 1，PSH: 1，RST: 0，SYN: 0，FIN: 0，<strong>从解析里面可以看出该报文ACK字段和PUSH有效，希望传输层尽快将数据交到应用层</strong>；<br> 可选项部分：可以看出该TCP报头最后的12个字节表示可选项</p>
<p>②  服务器端回复ACK确认</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以太网头部+IP报头+TCP报头+TCP数据(字节为单位位 Hex+ASCII方式显示)</span></span><br><span class="line"><span class="number">78</span> <span class="number">4f</span> <span class="number">43</span> <span class="number">5b</span> <span class="number">56</span> <span class="number">75</span> <span class="number">88</span> <span class="number">25</span> <span class="number">93</span> <span class="number">02</span> b7 <span class="number">8</span>c <span class="number">08</span> <span class="number">00</span> <span class="number">45</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">34</span> <span class="number">66</span> fa <span class="number">00</span> <span class="number">00</span> <span class="number">38</span> <span class="number">06</span> d7 <span class="number">84</span> cb d0 <span class="number">27</span> d8 <span class="number">0</span>a <span class="number">16</span></span><br><span class="line"><span class="number">46</span> <span class="number">87</span> <span class="number">01</span> bb d2 <span class="number">23</span> f4 <span class="number">36</span> <span class="number">9f</span> <span class="number">4b</span> <span class="number">2</span>e f0 <span class="number">8</span>a <span class="number">87</span> <span class="number">80</span> <span class="number">10</span></span><br><span class="line"><span class="number">00</span> <span class="number">76</span> <span class="number">44</span> <span class="number">09</span> <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">01</span> <span class="number">08</span> <span class="number">0</span>a d6 c8 <span class="number">43</span> <span class="number">2</span>e <span class="number">32</span> a6</span><br><span class="line"><span class="number">80</span> <span class="number">82</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//提取TCP报头+TCP数据(去掉以太网头部14byte和IP报头20byte)</span></span><br><span class="line"><span class="number">01</span> bb d2 <span class="number">23</span> </span><br><span class="line">f4 <span class="number">36</span> <span class="number">9f</span> <span class="number">4b</span> </span><br><span class="line"><span class="number">2</span>e f0 <span class="number">8</span>a <span class="number">87</span> </span><br><span class="line"><span class="number">80</span> <span class="number">10</span> <span class="number">00</span> <span class="number">76</span> </span><br><span class="line"><span class="number">44</span> <span class="number">09</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">01</span> <span class="number">01</span> <span class="number">08</span> <span class="number">0</span>a d6 c8 <span class="number">43</span> <span class="number">2</span>e <span class="number">32</span> a6 <span class="number">80</span> <span class="number">82</span></span><br></pre></td></tr></table></figure>

<p>解析：从上面可以解析出源端口号为：0x01bb &#x3D; 443；目的端口号：0xd23 &#x3D; 353795；序列号：SEQ &#x3D; 0xf4369f4b；<br> ACK &#x3D; 0x2ef08a87**(前面数据包的SEQ(0x2ef089c6) + 193 &#x3D; 0x2ef08a87  PS:这里需要注意下，很多网络和书上都说这个ACK的值应该是上个包的SEQ + TCP数据大小 + 1，这种说法是不准确的，拿上个数据来讲，数据的第一个字节序号也就是上个数据包的序号是0x2ef089c6，那么第二个字节序号就是0x2ef089c7，现在TCP数据一共是193个字节，那么接下来的第194个字节序号应该是0x2ef089c6 + 193 &#x3D; 0x2ef08a87，所以服务器期望收到下个包的序号应该是0x2ef08a87)<strong>；<br> TCP报头长为：0x8 &#x3D; 8(32 bit)，8 x 4 byte &#x3D; 32 byte，即TCP报头长为 32 个字节；窗口大小为 0x0076 &#x3D; 118 byte；<br> 保留位和标志位：0x010 &#x3D; 0b000000010000；按位解析标志位为 0b000010000，NS: 0，CWR: 0，ECE: 0，URG: 0，ACK: 1，PSH: 0，RST: 0，SYN: 0，FIN: 0，</strong>从解析里面可以看出该报文ACK字段有效，对上个数据包的一个确认，表示可以接着传送后面的数据了(从字节编号为0x2ef08a87开始)，是一个[ACK]确认数据报**；<br> 可选项部分：可以看出该TCP报头最后的12个字节表示可选项</p>
<h5 id="3-3-3-TCP断开连接的四次握手抓包数据部分"><a href="#3-3-3-TCP断开连接的四次握手抓包数据部分" class="headerlink" title="3.3.3  TCP断开连接的四次握手抓包数据部分"></a>3.3.3  TCP断开连接的四次握手抓包数据部分</h5><p>首先来看下抓包过程截图</p>
<img src="https://pic.imgdb.cn/item/627a333f09475431296b1c7c.jpg" style="zoom:80%;" />

<p>① 主动断开方发送[FIN]数据报</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以太网头部+IP报头+TCP报头+TCP数据(字节为单位位 Hex+ASCII方式显示)</span></span><br><span class="line"><span class="number">78</span> <span class="number">4f</span> <span class="number">43</span> <span class="number">5b</span> <span class="number">56</span> <span class="number">75</span> <span class="number">88</span> <span class="number">25</span> <span class="number">93</span> <span class="number">02</span> b7 <span class="number">8</span>c <span class="number">08</span> <span class="number">00</span> <span class="number">45</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">34</span> <span class="number">89</span> <span class="number">5</span>e <span class="number">40</span> <span class="number">00</span> <span class="number">39</span> <span class="number">06</span> a4 <span class="number">3f</span> <span class="number">7</span>a e4 <span class="number">48</span> a5 <span class="number">0</span>a <span class="number">16</span></span><br><span class="line"><span class="number">46</span> <span class="number">87</span> <span class="number">00</span> <span class="number">50</span> d2 <span class="number">1</span>e a9 ba <span class="number">9</span>e eb <span class="number">65</span> ee <span class="number">19</span> b0 <span class="number">80</span> <span class="number">11</span></span><br><span class="line"><span class="number">03</span> cc <span class="number">9</span>e <span class="number">50</span> <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">01</span> <span class="number">08</span> <span class="number">0</span>a <span class="number">41</span> fa <span class="number">79</span> <span class="number">05</span> <span class="number">32</span> a6</span><br><span class="line"><span class="number">38</span> <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//提取TCP报头+TCP数据(去掉以太网头部14byte和IP报头20byte)</span></span><br><span class="line"><span class="number">00</span> <span class="number">50</span> d2 <span class="number">1</span>e </span><br><span class="line">a9 ba <span class="number">9</span>e eb </span><br><span class="line"><span class="number">65</span> ee <span class="number">19</span> b0 </span><br><span class="line"><span class="number">80</span> <span class="number">11</span> <span class="number">03</span> cc </span><br><span class="line"><span class="number">9</span>e <span class="number">50</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">01</span> <span class="number">01</span> <span class="number">08</span> <span class="number">0</span>a <span class="number">41</span> fa <span class="number">79</span> <span class="number">05</span> <span class="number">32</span> a6 <span class="number">38</span> <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>解析：从上面可以解析出源端口号为：0x0050 &#x3D;80；目的端口号：0xd21e &#x3D;53790；序列号：SEQ &#x3D; 0xa9ba9eeb；ACK &#x3D; 0x65ee19b0；TCP报头长为：0x8 &#x3D; 8(32 bit)，8 x 4 byte &#x3D; 32 byte，即TCP报头长为 32 个字节；窗口大小为 0x03cc &#x3D;972 byte；<br> 保留位和标志位：0x011 &#x3D; 0b000000010001；按位解析标志位为 0b000010001，NS: 0，CWR: 0，ECE: 0，URG: 0，ACK: 1，PSH: 0，RST: 0，SYN: 0，FIN: 1，<strong>从解析里面可以看出该报文ACK字段和FIN字段有效，是请求断开连接的[FIN+ACK]数据报</strong>；<br> 可选项部分：可以看出该TCP报头最后的12个字节表示可选项，解析如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">01     kind = 1     NOP</span><br><span class="line">01     kind = 1     NOP</span><br><span class="line">08 0a 41 fa 79 05 32 a6 38 20 时间戳选项，Timestamp Value(TSval): 1106934021，Timestamp <span class="built_in">echo</span> reply(TSecr): 849754144</span><br></pre></td></tr></table></figure>

<p>② 被断开方发送[ACK]数据包，对主动对方数据报进行确认</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以太网头部+IP报头+TCP报头+TCP数据(字节为单位位 Hex+ASCII方式显示)</span></span><br><span class="line"><span class="number">88</span> <span class="number">25</span> <span class="number">93</span> <span class="number">02</span> b7 <span class="number">8</span>c <span class="number">78</span> <span class="number">4f</span> <span class="number">43</span> <span class="number">5b</span> <span class="number">56</span> <span class="number">75</span> <span class="number">08</span> <span class="number">00</span> <span class="number">45</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">34</span> <span class="number">00</span> <span class="number">00</span> <span class="number">40</span> <span class="number">00</span> <span class="number">40</span> <span class="number">06</span> <span class="number">26</span> <span class="number">9</span>e <span class="number">0</span>a <span class="number">16</span> <span class="number">46</span> <span class="number">87</span> <span class="number">7</span>a e4</span><br><span class="line"><span class="number">48</span> a5 d2 <span class="number">1</span>e <span class="number">00</span> <span class="number">50</span> <span class="number">65</span> ee <span class="number">19</span> b0 a9 ba <span class="number">9</span>e ec <span class="number">80</span> <span class="number">10</span></span><br><span class="line"><span class="number">10</span> <span class="number">00</span> <span class="number">1</span>d d9 <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">01</span> <span class="number">08</span> <span class="number">0</span>a <span class="number">32</span> a6 ac <span class="number">63</span> <span class="number">41</span> fa</span><br><span class="line"><span class="number">79</span> <span class="number">05</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//提取TCP报头+TCP数据(去掉以太网头部14byte和IP报头20byte)</span></span><br><span class="line">d2 <span class="number">1</span>e <span class="number">00</span> <span class="number">50</span> </span><br><span class="line"><span class="number">65</span> ee <span class="number">19</span> b0 </span><br><span class="line">a9 ba <span class="number">9</span>e ec </span><br><span class="line"><span class="number">80</span> <span class="number">10</span> <span class="number">10</span> <span class="number">00</span> </span><br><span class="line"><span class="number">1</span>d d9 <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">01</span> <span class="number">01</span> <span class="number">08</span> <span class="number">0</span>a <span class="number">32</span> a6 ac <span class="number">63</span> <span class="number">41</span> fa <span class="number">79</span> <span class="number">05</span></span><br></pre></td></tr></table></figure>

<p>解析：从上面可以解析出源端口号为：0xd21e &#x3D;53790；目的端口号：0x0050 &#x3D;80；序列号：SEQ &#x3D; 0x65ee19b0；ACK &#x3D; 0xa9ba9eec ；TCP报头长为：0x8 &#x3D; 8(32 bit)，8 x 4 byte &#x3D; 32 byte，即TCP报头长为 32 个字节；窗口大小为 0x1000 &#x3D; 4096 byte；<br> 保留位和标志位：0x010 &#x3D; 0b000000010000；按位解析标志位为 0b000010000，NS: 0，CWR: 0，ECE: 0，URG: 0，ACK: 1，PSH: 0，RST: 0，SYN: 0，FIN: 0，<strong>从解析里面可以看出该报文ACK字段有效，是对断开连接请求的确认[ACK]数据报</strong>；<br> 可选项部分：可以看出该TCP报头最后的12个字节表示可选项，解析如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">01     kind = 1     NOP</span><br><span class="line">01     kind = 1     NOP</span><br><span class="line">08 0a 32 a6 ac 63 41 fa 79 05 时间戳选项，Timestamp Value(TSval): 849783907 ，Timestamp <span class="built_in">echo</span> reply(TSecr): 1106934021</span><br></pre></td></tr></table></figure>

<p>③ 被断开方处理完自己的逻辑，发送[FIN]数据报到断开方</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以太网头部+IP报头+TCP报头+TCP数据(字节为单位位 Hex+ASCII方式显示)</span></span><br><span class="line"><span class="number">88</span> <span class="number">25</span> <span class="number">93</span> <span class="number">02</span> b7 <span class="number">8</span>c <span class="number">78</span> <span class="number">4f</span> <span class="number">43</span> <span class="number">5b</span> <span class="number">56</span> <span class="number">75</span> <span class="number">08</span> <span class="number">00</span> <span class="number">45</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">34</span> <span class="number">00</span> <span class="number">00</span> <span class="number">40</span> <span class="number">00</span> <span class="number">40</span> <span class="number">06</span> <span class="number">26</span> <span class="number">9</span>e <span class="number">0</span>a <span class="number">16</span> <span class="number">46</span> <span class="number">87</span> <span class="number">7</span>a e4</span><br><span class="line"><span class="number">48</span> a5 d2 <span class="number">1</span>e <span class="number">00</span> <span class="number">50</span> <span class="number">65</span> ee <span class="number">19</span> b0 a9 ba <span class="number">9</span>e ec <span class="number">80</span> <span class="number">11</span></span><br><span class="line"><span class="number">10</span> <span class="number">00</span> <span class="number">1</span>d d8 <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">01</span> <span class="number">08</span> <span class="number">0</span>a <span class="number">32</span> a6 ac <span class="number">63</span> <span class="number">41</span> fa</span><br><span class="line"><span class="number">79</span> <span class="number">05</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//提取TCP报头+TCP数据(去掉以太网头部14byte和IP报头20byte)</span></span><br><span class="line">d2 <span class="number">1</span>e <span class="number">00</span> <span class="number">50</span></span><br><span class="line"><span class="number">65</span> ee <span class="number">19</span> b0 </span><br><span class="line">a9 ba <span class="number">9</span>e ec </span><br><span class="line"><span class="number">80</span> <span class="number">11</span> <span class="number">10</span> <span class="number">00</span> </span><br><span class="line"><span class="number">1</span>d d8 <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">01</span> <span class="number">01</span> <span class="number">08</span> <span class="number">0</span>a <span class="number">32</span> a6 ac <span class="number">63</span> <span class="number">41</span> fa <span class="number">79</span> <span class="number">05</span></span><br></pre></td></tr></table></figure>

<p>解析：从上面可以解析出源端口号为：0xd21e &#x3D;53790；目的端口号：0x0050 &#x3D;80；序列号：SEQ &#x3D; 0x65ee19b0 ；ACK &#x3D; 0xa9ba9eec ；TCP报头长为：0x8 &#x3D; 8(32 bit)，8 x 4 byte &#x3D; 32 byte，即TCP报头长为 32 个字节；窗口大小为 0x1000 &#x3D; 4096 byte；<br> 保留位和标志位：0x011 &#x3D; 0b000000010001；按位解析标志位为 0b000010000，NS: 0，CWR: 0，ECE: 0，URG: 0，ACK: 1，PSH: 0，RST: 0，SYN: 0，FIN: 1，<strong>从解析里面可以看出该报文ACK字段和FIN字段有效，是被断开方发送的断开连接[FIN+ACK]数据报</strong>；<br> 可选项部分：可以看出该TCP报头最后的12个字节表示可选项，解析如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">01     kind = 1     NOP</span><br><span class="line">01     kind = 1     NOP</span><br><span class="line">08 0a 32 a6 ac 63 41 fa 79 05 时间戳选项，Timestamp Value(TSval): 849783907 ，Timestamp <span class="built_in">echo</span> reply(TSecr): 1106934021</span><br></pre></td></tr></table></figure>

<p>④ 断开方对被对开放发送的断开数据报发送[ACK]数据报进行确认</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以太网头部+IP报头+TCP报头+TCP数据(字节为单位位 Hex+ASCII方式显示)</span></span><br><span class="line"><span class="number">78</span> <span class="number">4f</span> <span class="number">43</span> <span class="number">5b</span> <span class="number">56</span> <span class="number">75</span> <span class="number">88</span> <span class="number">25</span> <span class="number">93</span> <span class="number">02</span> b7 <span class="number">8</span>c <span class="number">08</span> <span class="number">00</span> <span class="number">45</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">34</span> <span class="number">42</span> <span class="number">6b</span> <span class="number">40</span> <span class="number">00</span> <span class="number">39</span> <span class="number">06</span> eb <span class="number">32</span> <span class="number">7</span>a e4 <span class="number">48</span> a5 <span class="number">0</span>a <span class="number">16</span></span><br><span class="line"><span class="number">46</span> <span class="number">87</span> <span class="number">00</span> <span class="number">50</span> d2 <span class="number">1</span>e a9 ba <span class="number">9</span>e ec <span class="number">65</span> ee <span class="number">19</span> b1 <span class="number">80</span> <span class="number">10</span></span><br><span class="line"><span class="number">03</span> cc <span class="number">29</span> f7 <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">01</span> <span class="number">08</span> <span class="number">0</span>a <span class="number">41</span> fa <span class="number">79</span> <span class="number">1</span>a <span class="number">32</span> a6</span><br><span class="line">ac <span class="number">63</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//提取TCP报头+TCP数据(去掉以太网头部14byte和IP报头20byte)</span></span><br><span class="line"><span class="number">00</span> <span class="number">50</span> d2 <span class="number">1</span>e </span><br><span class="line">a9 ba <span class="number">9</span>e ec </span><br><span class="line"><span class="number">65</span> ee <span class="number">19</span> b1 </span><br><span class="line"><span class="number">80</span> <span class="number">10</span> <span class="number">03</span> cc </span><br><span class="line"><span class="number">29</span> f7 <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">01</span> <span class="number">01</span> <span class="number">08</span> <span class="number">0</span>a <span class="number">41</span> fa <span class="number">79</span> <span class="number">1</span>a <span class="number">32</span> a6 ac <span class="number">63</span></span><br></pre></td></tr></table></figure>

<p>解析：从上面可以解析出源端口号为：0x0050 &#x3D;80；目的端口号：0xd21e &#x3D;53790；序列号：SEQ &#x3D; 0xa9ba9eec；ACK &#x3D; 0x65ee19b1；TCP报头长为：0x8 &#x3D; 8(32 bit)，8 x 4 byte &#x3D; 32 byte，即TCP报头长为 32 个字节；窗口大小为 0x03cc &#x3D;972 byte；<br> 保留位和标志位：0x010 &#x3D; 0b000000010000；按位解析标志位为 0b000010000，NS: 0，CWR: 0，ECE: 0，URG: 0，ACK: 1，PSH: 0，RST: 0，SYN: 0，FIN: 0，<strong>从解析里面可以看出该报文ACK字段有效，是对断开连接请求的确认[ACK]数据报</strong>；<br> 可选项部分：可以看出该TCP报头最后的12个字节表示可选项，解析如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">01     kind = 1     NOP</span><br><span class="line">01     kind = 1     NOP</span><br><span class="line">08 0a 41 fa 79 1a 32 a6 ac 63 时间戳选项，Timestamp Value(TSval): 1106934042，Timestamp <span class="built_in">echo</span> repl</span><br></pre></td></tr></table></figure>



<h3 id="4-UDP协议"><a href="#4-UDP协议" class="headerlink" title="4. UDP协议"></a>4. UDP协议</h3><p>UDP协议是IP协议上层的另一个重要协议，他是面向无连接的、不可靠的数据报传输协议，他仅仅将要发送的数据报传送至网络，并接受从网络上传来的数据报，而不与远端的UDP协议模块建立连接。UDP协议为用户的网络应用程序提供服务。</p>
<h4 id="4-1-UDP协议数据报头"><a href="#4-1-UDP协议数据报头" class="headerlink" title="4.1 UDP协议数据报头"></a>4.1 UDP协议数据报头</h4><h5 id="4-1-1-UDP协议头部格式"><a href="#4-1-1-UDP协议头部格式" class="headerlink" title="4.1.1 UDP协议头部格式"></a>4.1.1 UDP协议头部格式</h5><img src="https://pic.imgdb.cn/item/627a33cc09475431296d4a17.jpg" style="zoom:80%;" />

<ul>
<li><strong>源端口</strong>：套接字发送端端口号</li>
<li><strong>目的端口</strong>：目的套接字端口号</li>
<li><strong>数据包长</strong>：UDP报头+UDP数据报的长度，单位1byte</li>
</ul>
<h5 id="4-1-2-UDP协议头部数据"><a href="#4-1-2-UDP协议头部数据" class="headerlink" title="4.1.2 UDP协议头部数据"></a>4.1.2 UDP协议头部数据</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以太网头部+IP报头+UDP报头+UDP数据(字节为单位位 Hex+ASCII方式显示)</span></span><br><span class="line"><span class="number">01</span> <span class="number">00</span> <span class="number">5</span>e <span class="number">4b</span> <span class="number">00</span> fe f8 <span class="number">32</span> e4 <span class="number">8</span>a ef e5 <span class="number">08</span> <span class="number">00</span> <span class="number">45</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">74</span> <span class="number">49</span> b6 <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">11</span> <span class="number">2f</span> <span class="number">50</span> <span class="number">0</span>a <span class="number">16</span> <span class="number">46</span> <span class="number">14</span> ef <span class="number">4b</span></span><br><span class="line"><span class="number">00</span> fe c1 <span class="number">5f</span> <span class="number">26</span> e5 <span class="number">00</span> <span class="number">60</span> <span class="number">19</span> b1 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">58</span> <span class="number">4f</span> <span class="number">47</span></span><br><span class="line"><span class="number">45</span> <span class="number">4</span>d <span class="number">52</span> <span class="number">41</span> <span class="number">59</span> <span class="number">2</span>d <span class="number">4</span>e <span class="number">42</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">41</span> <span class="number">4</span>a</span><br><span class="line"><span class="number">52</span> <span class="number">40</span> <span class="number">31</span> <span class="number">32</span> <span class="number">33</span> <span class="number">34</span> <span class="number">35</span> <span class="number">36</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//UDP报头+UDP数据(去掉以太网头部14byte和IP报头20byte)</span></span><br><span class="line">c1 <span class="number">5f</span> <span class="number">26</span> e5 <span class="number">00</span> <span class="number">60</span> <span class="number">19</span> b1 </span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">58</span> <span class="number">4f</span> <span class="number">47</span> <span class="number">45</span> <span class="number">4</span>d <span class="number">52</span> <span class="number">41</span> <span class="number">59</span> <span class="number">2</span>d <span class="number">4</span>e <span class="number">42</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">41</span> <span class="number">4</span>a <span class="number">52</span> <span class="number">40</span> <span class="number">31</span> <span class="number">32</span> <span class="number">33</span> <span class="number">34</span> <span class="number">35</span> <span class="number">36</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br></pre></td></tr></table></figure>

<p>从上面数据抓包可以看出：<br> 源端口：0xc15f &#x3D; 49503<br> 目的端口：0x26e5 &#x3D; 9957<br> 数据包长(UDP报头加+UDP数据)：0x0060 &#x3D; 96 byte<br> 效验值：0x18b1</p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA常用快捷键总结</title>
    <url>/2022/05/06/IDEAtechniques/</url>
    <content><![CDATA[<p>概述：本文记录了IDEA常用的一些快捷键，提高开发效率！</p>
<span id="more"></span>



<h4 id="Ctrl类"><a href="#Ctrl类" class="headerlink" title="Ctrl类"></a>Ctrl类</h4><table>
<thead>
<tr>
<th><strong>快捷键</strong></th>
<th><strong>介绍</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Ctrl + F</strong></td>
<td><strong>在当前文件进行文本查找 <code>（必备）</code></strong></td>
</tr>
<tr>
<td><strong>Ctrl + R</strong></td>
<td><strong>在当前文件进行文本替换 <code>（必备）</code></strong></td>
</tr>
<tr>
<td><strong>Ctrl + Z</strong></td>
<td><strong>撤销 （必备）</strong></td>
</tr>
<tr>
<td><strong>Ctrl + Y</strong></td>
<td><strong>删除光标所在行 或 删除选中的行 （必备）</strong></td>
</tr>
<tr>
<td><strong>Ctrl + X</strong></td>
<td><strong>剪切光标所在行 或 剪切选择内容</strong></td>
</tr>
<tr>
<td><strong>Ctrl + C</strong></td>
<td><strong>复制光标所在行 或 复制选择内容</strong></td>
</tr>
<tr>
<td><strong>Ctrl + D</strong></td>
<td><strong>复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面 <code>（必备）</code></strong></td>
</tr>
<tr>
<td><strong>Ctrl + E</strong></td>
<td><strong>显示最近打开的文件记录列表</strong></td>
</tr>
<tr>
<td><strong>Ctrl + N</strong></td>
<td><strong>根据输入的 类名 查找类文件</strong></td>
</tr>
<tr>
<td><strong>Ctrl + F12</strong></td>
<td><strong>弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选</strong></td>
</tr>
<tr>
<td><strong>Ctrl + Enter</strong></td>
<td><strong>智能分隔行</strong></td>
</tr>
<tr>
<td><strong>Ctrl + End</strong></td>
<td><strong>跳到文件尾</strong></td>
</tr>
<tr>
<td><strong>Ctrl + Home</strong></td>
<td><strong>跳到文件头</strong></td>
</tr>
<tr>
<td><strong>Ctrl + 左键单击</strong></td>
<td><strong>在打开的文件标题上，弹出该文件路径</strong></td>
</tr>
<tr>
<td><strong>Ctrl + 光标定位</strong></td>
<td><strong>按 Ctrl 不要松开，会显示光标所在的类信息摘要</strong></td>
</tr>
</tbody></table>
<h4 id="Alt类"><a href="#Alt类" class="headerlink" title="Alt类"></a>Alt类</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Alt + Enter</strong></td>
<td><strong>IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同 <code>（必备）</code></strong></td>
</tr>
<tr>
<td><strong>Alt + Insert</strong></td>
<td><strong>代码自动生成，如生成对象的 set &#x2F; get 方法，构造函数，toString() 等</strong></td>
</tr>
<tr>
<td><strong>Alt + 左方向键</strong></td>
<td><strong>按左方向切换当前已打开的文件视图</strong></td>
</tr>
<tr>
<td><strong>Alt + 右方向键</strong></td>
<td><strong>按右方向切换当前已打开的文件视图</strong></td>
</tr>
</tbody></table>
<h4 id="Shift类"><a href="#Shift类" class="headerlink" title="Shift类"></a>Shift类</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Shift + F1</td>
<td>如果有外部文档可以连接外部文档</td>
</tr>
<tr>
<td>Shift + F2</td>
<td>跳转到上一个高亮错误 或 警告位置</td>
</tr>
<tr>
<td>Shift + F3</td>
<td>在查找模式下，查找匹配上一个</td>
</tr>
<tr>
<td>Shift + F7</td>
<td>在 Debug 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法</td>
</tr>
<tr>
<td>Shift + F8</td>
<td>在 Debug 模式下，跳出，表现出来的效果跟 <code>F9</code> 一样</td>
</tr>
<tr>
<td>Shift + F9</td>
<td>等效于点击工具栏的 <code>Debug</code> 按钮</td>
</tr>
<tr>
<td>Shift + F10</td>
<td>等效于点击工具栏的 <code>Run</code> 按钮</td>
</tr>
<tr>
<td>Shift + Tab</td>
<td>取消缩进</td>
</tr>
<tr>
<td>Shift + ESC</td>
<td>隐藏当前 或 最后一个激活的工具窗口</td>
</tr>
<tr>
<td><strong>Shift + End</strong></td>
<td><strong>选中光标到当前行尾位置</strong></td>
</tr>
<tr>
<td><strong>Shift + Home</strong></td>
<td><strong>选中光标到当前行头位置</strong></td>
</tr>
<tr>
<td><strong>Shift + Enter</strong></td>
<td><strong>开始新一行。光标所在行下空出一行，光标定位到新行位置</strong></td>
</tr>
<tr>
<td><strong>Shift + 左键单击</strong></td>
<td><strong>在打开的文件名上按此快捷键，可以关闭当前打开文件</strong></td>
</tr>
<tr>
<td><strong>Shift + 滚轮前后滚动</strong></td>
<td><strong>当前文件的横向滚动轴滚动</strong></td>
</tr>
</tbody></table>
<h4 id="Ctrl-Alt"><a href="#Ctrl-Alt" class="headerlink" title="Ctrl + Alt"></a>Ctrl + Alt</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Ctrl + Alt + L</strong></td>
<td><strong>格式化代码，可以对当前文件和整个包目录使用 <code>（必备）</code></strong></td>
</tr>
<tr>
<td><strong>Ctrl + Alt + O</strong></td>
<td><strong>优化导入的类，可以对当前文件和整个包目录使用 <code>（必备）</code></strong></td>
</tr>
</tbody></table>
<h4 id="Ctrl-Shift"><a href="#Ctrl-Shift" class="headerlink" title="Ctrl + Shift"></a>Ctrl + Shift</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Ctrl + Shift + F</strong></td>
<td><strong>根据输入内容查找整个项目 或 指定目录内文件 <code>（必备）</code></strong></td>
</tr>
<tr>
<td><strong>Ctrl + Shift + R</strong></td>
<td><strong>根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件 <code>（必备）</code></strong></td>
</tr>
<tr>
<td><strong>Ctrl + Shift + J</strong></td>
<td><strong>自动将下一行合并到当前行末尾 <code>（必备）</code></strong></td>
</tr>
<tr>
<td><strong>Ctrl + Shift + Z</strong></td>
<td><strong>取消撤销 <code>（必备）</code></strong></td>
</tr>
<tr>
<td>Ctrl + Shift + W</td>
<td>递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围 <code>（必备）</code></td>
</tr>
<tr>
<td><strong>Ctrl + Shift + N</strong></td>
<td><strong>通过文件名定位 &#x2F; 打开文件 &#x2F; 目录，打开目录需要在输入的内容后面多加一个正斜杠 <code>（必备）</code></strong></td>
</tr>
<tr>
<td><strong>Ctrl + Shift + U</strong></td>
<td><strong>对选中的代码进行大 &#x2F; 小写轮流转换 <code>（必备）</code></strong></td>
</tr>
<tr>
<td>Ctrl + Shift + T</td>
<td>对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择</td>
</tr>
<tr>
<td><strong>Ctrl + Shift + C</strong></td>
<td><strong>复制当前文件磁盘路径到剪贴板</strong></td>
</tr>
<tr>
<td><strong>Ctrl + Shift + V</strong></td>
<td><strong>弹出缓存的最近拷贝的内容管理器弹出层</strong></td>
</tr>
<tr>
<td>Ctrl + Shift + E</td>
<td>显示最近修改的文件列表的弹出层</td>
</tr>
<tr>
<td>Ctrl + Shift + H</td>
<td>显示方法层次结构</td>
</tr>
<tr>
<td><strong>Ctrl + Shift + B</strong></td>
<td><strong>跳转到类型声明处</strong></td>
</tr>
<tr>
<td>Ctrl + Shift + I</td>
<td>快速查看光标所在的方法 或 类的定义</td>
</tr>
<tr>
<td>Ctrl + Shift + A</td>
<td>查找动作 &#x2F; 设置</td>
</tr>
<tr>
<td><strong>Ctrl + Shift + &#x2F;</strong></td>
<td><strong>代码块注释 <code>（必备）</code></strong></td>
</tr>
<tr>
<td>Ctrl + Shift + [</td>
<td>选中从光标所在位置到它的顶部中括号位置</td>
</tr>
<tr>
<td>Ctrl + Shift + ]</td>
<td>选中从光标所在位置到它的底部中括号位置</td>
</tr>
<tr>
<td>Ctrl + Shift + +</td>
<td>展开所有代码</td>
</tr>
<tr>
<td>Ctrl + Shift + -</td>
<td>折叠所有代码</td>
</tr>
<tr>
<td>Ctrl + Shift + F7</td>
<td>高亮显示所有该选中文本，按Esc高亮消失</td>
</tr>
<tr>
<td>Ctrl + Shift + F8</td>
<td>在 Debug 模式下，指定断点进入条件</td>
</tr>
<tr>
<td>Ctrl + Shift + F9</td>
<td>编译选中的文件 &#x2F; 包 &#x2F; Module</td>
</tr>
<tr>
<td>Ctrl + Shift + F12</td>
<td>编辑器最大化</td>
</tr>
<tr>
<td><strong>Ctrl + Shift + Space</strong></td>
<td><strong>智能代码提示</strong></td>
</tr>
<tr>
<td>Ctrl + Shift + Enter</td>
<td>自动结束代码，行末自动添加分号 <code>（必备）</code></td>
</tr>
<tr>
<td>Ctrl + Shift + Backspace</td>
<td>退回到上次修改的地方</td>
</tr>
<tr>
<td>Ctrl + Shift + 1,2,3…9</td>
<td>快速添加指定数值的书签</td>
</tr>
<tr>
<td><strong>Ctrl + Shift + 左方向键</strong></td>
<td><strong>在代码文件上，光标跳转到当前单词 &#x2F; 中文句的左侧开头位置，同时选中该单词 &#x2F; 中文句</strong></td>
</tr>
<tr>
<td><strong>Ctrl + Shift + 右方向键</strong></td>
<td><strong>在代码文件上，光标跳转到当前单词 &#x2F; 中文句的右侧开头位置，同时选中该单词 &#x2F; 中文句</strong></td>
</tr>
<tr>
<td>Ctrl + Shift + 左方向键</td>
<td>在光标焦点是在工具选项卡上，缩小选项卡区域</td>
</tr>
<tr>
<td>Ctrl + Shift + 右方向键</td>
<td>在光标焦点是在工具选项卡上，扩大选项卡区域</td>
</tr>
<tr>
<td>Ctrl + Shift + 前方向键</td>
<td>光标放在方法名上，将方法移动到上一个方法前面，调整方法排序</td>
</tr>
<tr>
<td>Ctrl + Shift + 后方向键</td>
<td>光标放在方法名上，将方法移动到下一个方法前面，调整方法排序</td>
</tr>
</tbody></table>
<h4 id="Alt-Shift"><a href="#Alt-Shift" class="headerlink" title="Alt + Shift"></a>Alt + Shift</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Alt + Shift + I</td>
<td>查看项目当前文件</td>
</tr>
<tr>
<td>Alt + Shift + F7</td>
<td>在 Debug 模式下，下一步，进入当前方法体内，如果方法体还有方法，则会进入该内嵌的方法中，依此循环进入</td>
</tr>
<tr>
<td>Alt + Shift + F9</td>
<td>弹出 <code>Debug</code> 的可选择菜单</td>
</tr>
<tr>
<td>Alt + Shift + F10</td>
<td>弹出 <code>Run</code> 的可选择菜单</td>
</tr>
</tbody></table>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>F2</td>
<td>跳转到下一个高亮错误 或 警告位置 <code>（必备）</code></td>
</tr>
<tr>
<td>F3</td>
<td>在查找模式下，定位到下一个匹配处</td>
</tr>
<tr>
<td>F4</td>
<td>编辑源</td>
</tr>
<tr>
<td>F7</td>
<td>在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中</td>
</tr>
<tr>
<td>F8</td>
<td>在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内</td>
</tr>
<tr>
<td>F9</td>
<td>在 Debug 模式下，恢复程序运行，但是如果该断点下面代码还有断点则停在下一个断点上</td>
</tr>
<tr>
<td>F11</td>
<td>添加书签</td>
</tr>
<tr>
<td>F12</td>
<td>回到前一个工具窗口</td>
</tr>
<tr>
<td>Tab</td>
<td>缩进</td>
</tr>
<tr>
<td>ESC</td>
<td>从工具窗口进入代码文件窗口</td>
</tr>
<tr>
<td><strong>连按两次Shift</strong></td>
<td><strong>弹出 <code>Search Everywhere</code> 弹出层</strong></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>RPC</title>
    <url>/2022/05/05/RPC/</url>
    <content><![CDATA[<p>本文简单介绍了RPC框架</p>
<span id="more"></span>

<h4 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="什么是RPC"></a>什么是RPC</h4><p>RPC（Remote Procedure Call）— 远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。</p>
<p>比如两个不同的服务 A、B 部署在两台不同的机器上，那么服务 A 如果想要调用服务 B 中的某个方法该怎么办呢？使用 HTTP请求 当然可以，但是可能会比较慢而且一些优化做的并不好。 RPC 的出现就是为了解决这个问题。</p>
<p>概括来讲RPC 主要解决了：<strong>让分布式或者微服务系统中不同服务之间的调用像本地调用一样简单。</strong></p>
<h4 id="RPC的原理"><a href="#RPC的原理" class="headerlink" title="RPC的原理"></a>RPC的原理</h4><img src="https://pic.imgdb.cn/item/6273ed640947543129a39226.jpg" style="zoom:80%;" />

<ol>
<li>服务消费端（client）以本地调用的方式调用远程服务；</li>
<li>客户端 Stub（client stub） 接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体（序列化）：<code>RpcRequest</code>；</li>
<li>客户端 Stub（client stub） 找到远程服务的地址，并将消息发送到服务提供端；</li>
<li>服务端 Stub（桩）收到消息将消息反序列化为Java对象: <code>RpcRequest</code>；</li>
<li>服务端 Stub（桩）根据<code>RpcRequest</code>中的类、方法、方法参数等信息调用本地的方法；</li>
<li>服务端 Stub（桩）得到方法执行结果并将组装成能够进行网络传输的消息体：<code>RpcResponse</code>（序列化）发送至消费方；</li>
<li>客户端 Stub（client stub）接收到消息并将消息反序列化为Java对象:<code>RpcResponse</code> ，这样也就得到了最终结果。</li>
</ol>
<p>时序图：</p>
<img src="https://pic.imgdb.cn/item/6273edad0947543129a46883.jpg" style="zoom:80%;" />

<h4 id="常见的RPC框架"><a href="#常见的RPC框架" class="headerlink" title="常见的RPC框架"></a>常见的RPC框架</h4><ul>
<li><strong>RMI（JDK自带）：</strong> JDK自带的RPC，有很多局限性，不推荐使用。</li>
<li><strong>Dubbo:</strong> Dubbo是 阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring框架无缝集成。目前 Dubbo 已经成为 Spring Cloud Alibaba 中的官方组件。</li>
<li><strong>gRPC</strong> ：gRPC是可以在任何环境中运行的现代开源高性能RPC框架。它可以通过可插拔的支持来有效地连接数据中心内和跨数据中心的服务，以实现负载平衡，跟踪，运行状况检查和身份验证。它也适用于分布式计算的最后一英里，以将设备，移动应用程序和浏览器连接到后端服务。</li>
<li><strong>Hessian：</strong> Hessian是一个轻量级的remoting on http工具，使用简单的方法提供了RMI的功能。 相比WebService，Hessian更简单、快捷。采用的是二进制RPC协议，因为采用的是二进制协议，所以它很适合于发送二进制数据。</li>
<li><strong>Thrift：</strong> Apache Thrift是Facebook开源的跨语言的RPC通信框架，目前已经捐献给Apache基金会管理，由于其跨语言特性和出色的性能，在很多互联网公司得到应用，有能力的公司甚至会基于thrift研发一套分布式服务框架，增加诸如服务注册、服务发现等功能。</li>
</ul>
]]></content>
      <categories>
        <category>RPC</category>
      </categories>
      <tags>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>Startup in MeiTuan</title>
    <url>/2022/05/05/project-in-meituan-00/</url>
    <content><![CDATA[<p>本文记录了一个简易Java开发流程和服务部署和调用的学习过程</p>
<span id="more"></span>

<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><strong>流程</strong>：</p>
<ul>
<li>在A服务写一套CRUD，对外提供RPC接口</li>
<li>在B服务中调用A服务提供的接口，完成数据CRUD</li>
<li>利用这个项目对接http网关</li>
</ul>
<p><strong>涉及的技术</strong>：</p>
<ul>
<li>MDP（spring boot）</li>
<li>RPC接口用到thrift，公司内部为MTthrift</li>
<li>服务注册</li>
<li>kafka</li>
<li>redis</li>
</ul>
<h3 id="CRUD实现"><a href="#CRUD实现" class="headerlink" title="CRUD实现"></a>CRUD实现</h3><h4 id="DO-Example-mapper生成"><a href="#DO-Example-mapper生成" class="headerlink" title="DO, Example, mapper生成"></a>DO, Example, mapper生成</h4><p>使用MyBatis-generator自动生成，注意在generatorConfig.xml中配置文件路径，表名和实体类名。</p>
<p>另外注意插件的使用必须在对应的模块（dao模块）下（我一开始直接使用主目录下的generator导致出现了找不到路径的错误）</p>
<p>一共会生成四个文件：XX.java（实体DO），XXExample.java， XXMapper.java， XXMapper.xml</p>
<h4 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h4><p>测试CRUD的API和example相关API，注意测试类要继承BaseTest类</p>
<h3 id="提供RPC接口"><a href="#提供RPC接口" class="headerlink" title="提供RPC接口"></a>提供RPC接口</h3><p>(注意这里的代码都不符合工程的规范，仅仅只是简单的尝试使用)</p>
<p><strong>在client模块下：</strong></p>
<ul>
<li><p>写一个CRUDService接口，提供所需要的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ThriftService</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CRUDService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ThriftMethod</span></span><br><span class="line">    <span class="keyword">public</span> CRUDResponse <span class="title function_">method1</span><span class="params">(CRUDRequest testRequest)</span> <span class="keyword">throws</span> TException;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ThriftMethod</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">method2</span><span class="params">(<span class="type">int</span> i)</span> <span class="keyword">throws</span> TException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>写一个CRUDResponse和CRUDRequest</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ThriftStruct</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CRUDRequest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ThriftField(value = 1, requiredness = ThriftField.Requiredness.REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ThriftField</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ThriftField(2)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ThriftField</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;CRUDRequest&#123;&quot;</span> +</span><br><span class="line">            <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">            <span class="string">&quot;, name=&quot;</span> + name +</span><br><span class="line">            <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>在service模块下：</strong></p>
<ul>
<li><p>对CRUDService进行实现，写一个CRUDServiceImpl类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@MdpThriftServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CRUDServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">CRUDService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    TempDataDOMapper tempDataDOMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    FunctionConfigDOMapper functionConfigDOMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> CRUDResponse <span class="title function_">method1</span><span class="params">(CRUDRequest testRequest)</span> <span class="keyword">throws</span> TException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">method2</span><span class="params">(<span class="type">int</span> i)</span> <span class="keyword">throws</span> TException &#123;</span><br><span class="line">        System.out.println(tempDataDOMapper.selectByPrimaryKey(i));</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">long</span>)i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@Slf4j</code>：slf4j是一个日志标准，使用它可以完美的桥接到具体的日志框架，必要时可以简便的更换底层的日志框架，而不需要关心具体的日志框架的实现（slf4j-simple、logback等）。</p>
<p><code>@Override</code> 在java中如果方法上加@Override的注解的话，表示子类重写了父类的方法。当然也可以不写，写的好处是：</p>
<ul>
<li>可读性提高</li>
<li>编译器会校验写的方法在父类中是否存在</li>
</ul>
</li>
</ul>
<p><strong>测试</strong></p>
<p>在测试类中可以直接调用CRUDService接口进行方法的调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line">CRUDService crudService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testImpl</span><span class="params">()</span> <span class="keyword">throws</span> TException &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> crudService.method2(<span class="number">1</span>);</span><br><span class="line">    System.out.println(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="服务的部署"><a href="#服务的部署" class="headerlink" title="服务的部署"></a>服务的部署</h4><p><strong>注意点</strong>：</p>
<ul>
<li><p>注意修改版本号，如从0.0.5到0.0.6-SNAPSHOT</p>
</li>
<li><p>注意一定不要合并到master分支上去，要使用自己的分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看分支</span></span><br><span class="line">git branch</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">切换到自己的分支</span></span><br><span class="line">git checkout -b zhangqi-local</span><br><span class="line"></span><br><span class="line">git push --set-upstream origin zhangqi-local</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用git进行提交和push</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -a -m &quot;描述文字&quot;</span><br></pre></td></tr></table></figure>

<p>注意也可以通过非命令的方式提交和push，可以查看修改的地方 【根目录】&#x3D;&#x3D;》【Git】 &#x3D;&#x3D;》【提交目录】</p>
</li>
</ul>
<p><strong>服务的发布流程</strong></p>
<ul>
<li><p>Devtools中的Services中找到对应的服务</p>
<p>【To Maven】&#x3D;&#x3D;》【To Maven】&#x3D;&#x3D;》【代码配置】（填写自己的分支）&#x3D;&#x3D;》【To Maven】</p>
</li>
<li><p>Devtools中的Cargo中，进入自己的机器。构建服务，选择自己的分支，进行构建，直到状态为success，在【机器列表】中可以看到主机名</p>
</li>
<li><p>进入OCTO，调整为线下模式。【用户自检】&#x3D;&#x3D;》【MTthrift自检】&#x3D;&#x3D;》【切换到test】&#x3D;&#x3D;》【接口调用】&#x3D;&#x3D;》选择对应泳道和主机&#x3D;&#x3D;》选择要进行测试的服务接口和调用方法&#x3D;&#x3D;》选择【不配置】压测标识&#x3D;&#x3D;》设置方法的参数，点击【执行】即可查看调用结果</p>
</li>
</ul>
<h3 id="服务的调用"><a href="#服务的调用" class="headerlink" title="服务的调用"></a>服务的调用</h3><ul>
<li><p>在新的服务下，首先在service模块下的pom.xml和主目录下的pom.xml中要引入相应的dependency</p>
</li>
<li><p>写一个service，注意@Service注解需要使用spring包下的，否则会扫描不到。在类内使用@MdpThriftClient调用远程的服务，注意要写上remoteAppKey，其可以在上传的服务的resource目录下找到，也可以在devtools网站下找到，注意不需要设置端口号，让服务自己去配置。另外可能会报无法自动装配的问题（红线），可以不用理会。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.meituan.mdp.boot.starter.thrift.annotation.MdpThriftClient;</span><br><span class="line"><span class="keyword">import</span> com.sankuai.grocerymkthd.interact.tools.client.request.test.CRUDRequest;</span><br><span class="line"><span class="keyword">import</span> com.sankuai.grocerymkthd.interact.tools.client.response.test.CRUDResponse;</span><br><span class="line"><span class="keyword">import</span> com.sankuai.grocerymkthd.interact.tools.client.service.CRUDService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.thrift.TException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CRUDMTService</span> &#123;</span><br><span class="line">    <span class="meta">@MdpThriftClient(</span></span><br><span class="line"><span class="meta">        remoteAppKey = &quot;com.sankuai.grocerymkthd.interact.tools&quot;,</span></span><br><span class="line"><span class="meta">        timeout = 10000</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">private</span> CRUDService crudService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> CRUDResponse <span class="title function_">getResponse</span><span class="params">(CRUDRequest request)</span> <span class="keyword">throws</span> TException &#123;</span><br><span class="line">        <span class="keyword">return</span> crudService.method1(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSelection</span><span class="params">(<span class="type">int</span> id)</span> <span class="keyword">throws</span> TException&#123;</span><br><span class="line">        <span class="keyword">return</span> crudService.selectById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在单元测试UT中，<strong>要指定访问的泳道，因为我们只在自己的泳道上部署了服务</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.meituan.mtrace.Tracer;</span><br><span class="line"><span class="keyword">import</span> com.sankuai.grocerymkthd.interact.mapi.BaseTest;</span><br><span class="line"><span class="keyword">import</span> com.sankuai.grocerymkthd.interact.mapi.simple.CRUDMTService;</span><br><span class="line"><span class="keyword">import</span> com.sankuai.grocerymkthd.interact.tools.client.request.test.CRUDRequest;</span><br><span class="line"><span class="keyword">import</span> org.apache.thrift.TException;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CRUDServiceTest</span> <span class="keyword">extends</span> <span class="title class_">BaseTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> CRUDMTService crudmtService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> <span class="keyword">throws</span> TException &#123;</span><br><span class="line">        <span class="comment">// 要指定访问的泳道，因为只在自己的泳道上部署了服务</span></span><br><span class="line">        Tracer.setSwimlane(<span class="string">&quot;zhuzhangqi-yzwgj&quot;</span>);</span><br><span class="line">        System.out.println(crudmtService.getResponse(<span class="keyword">new</span> <span class="title class_">CRUDRequest</span>()));</span><br><span class="line">        System.out.println(crudmtService.getSelection(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="与HTTP网关的对接"><a href="#与HTTP网关的对接" class="headerlink" title="与HTTP网关的对接"></a>与HTTP网关的对接</h3><p>公司内部使用Shepherd</p>
<ul>
<li><p>创建分组</p>
</li>
<li><p>创建API，两种方式</p>
<ul>
<li>【API分组管理】&#x3D;&#x3D;》【API管理】&#x3D;&#x3D;》【新建API】（传统方式）</li>
<li>【API分组管理】&#x3D;&#x3D;》【API管理】&#x3D;&#x3D;》【快速创建API】（推荐），输入API名称、后端服务Appkey、服务名、方法名即可完成创建</li>
</ul>
</li>
<li><p>创建完API后，可根据需要将路径、服务参数、返回值进行个性化修改</p>
<ul>
<li><p>注意要使用自己的服务要配置泳道：</p>
<ul>
<li>方法1：在【http header】或【url query】信息里加swimlane字段，字段值为需要路由的泳道服务</li>
<li>方法2：如果不希望前端传递泳道信息，可以配置Tracer组件泳道参数，Tracer-Key固定为INF_SWIMLANE，Tracer_Value为泳道名称</li>
</ul>
</li>
<li><p>注意要在【后端请求定义】配置相应的入参，注意DSL表达式的写法</p>
</li>
</ul>
</li>
<li><p>发布API</p>
</li>
<li><p>用POSTMAN测试API，通过查看API文档，可以看到请求路径和path信息</p>
<ul>
<li>通过POSTMAN请求url（其中{id}为路径参数，类型为整数型，要用实际参数替换）</li>
<li>可以在【Params】中给相应的参数赋值</li>
<li>DSL指南见appendix</li>
</ul>
</li>
</ul>
<h3 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h3><h4 id="Mybatis中的example类简介"><a href="#Mybatis中的example类简介" class="headerlink" title="Mybatis中的example类简介"></a>Mybatis中的example类简介</h4><p><strong>什么是example类</strong></p>
<p>mybatis-generator会为每个字段产生Criterion，为底层的mapper.xml创建动态sql。如果表的字段比较多,产生的example类会十分庞大。理论上通过example类可以构造你想到的任何筛选条件。在mybatis-generator中加以配置，配置数据表的生成操作就可以自动生成example了。</p>
<p><strong>了解example成员变量</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//作用：升序还是降序</span></span><br><span class="line"><span class="comment">//参数格式：字段+空格+asc(desc)</span></span><br><span class="line"><span class="keyword">protected</span> String orderByClause;  </span><br><span class="line"><span class="comment">//作用：去除重复</span></span><br><span class="line"><span class="comment">//true是选择不重复记录，false，反之</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> distinct;</span><br><span class="line"><span class="comment">//自定义查询条件</span></span><br><span class="line"><span class="comment">//Criteria的集合，集合中对象是由or连接</span></span><br><span class="line"><span class="keyword">protected</span> List&lt;Criteria&gt; oredCriteria;</span><br><span class="line"><span class="comment">//内部类Criteria包含一个Cretiron的集合，</span></span><br><span class="line"><span class="comment">//每一个Criteria对象内包含的Cretiron之间是由  AND连接的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Criteria</span> <span class="keyword">extends</span> <span class="title class_">GeneratedCriteria</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Criteria</span><span class="params">()</span> &#123;<span class="built_in">super</span>();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//是mybatis中逆向工程中的代码模型</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">GeneratedCriteria</span> &#123;......&#125;</span><br><span class="line"><span class="comment">//是最基本,最底层的Where条件，用于字段级的筛选</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Criterion</span> &#123;......&#125;</span><br></pre></td></tr></table></figure>

<p><strong>example使用前的准备</strong></p>
<p>比如我的TempDataDOExample是根据TempData表生成的，TempDataDOMapper属于dao层，TempDataDOMapper.xml是对应的映射文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TempDataDOMapper</span> <span class="variable">tempDataDOMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TempDataDOMapper</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//UserMapper接口：</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">countByExample</span><span class="params">(CompetingStoreExample example)</span>;</span><br><span class="line">List&lt;CompetingStore&gt; <span class="title function_">selectByExample</span><span class="params">(CompetingStoreExample example)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在我们的测试类里：</span></span><br><span class="line"><span class="type">TempDataDOExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TempDataDOExample</span>();</span><br><span class="line">TempDataDOExample.<span class="type">Criteria</span> <span class="variable">criteria</span> <span class="operator">=</span> example.createCriteria();</span><br></pre></td></tr></table></figure>

<p><strong>查询用户数量</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// select count(*) from temp_data</span></span><br><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> tempDataDOMapper.countByExample(example);</span><br></pre></td></tr></table></figure>

<p><strong>where条件查询或多条件查询</strong></p>
<p>(注意以下不是对应TempData的代码)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// select * from user where name=&#123;#user.name&#125; and sex=&#123;#user.sex&#125; order by age asc;</span></span><br><span class="line">example.setOrderByClause(“age asc<span class="string">&quot;); //升序</span></span><br><span class="line"><span class="string">example.setDistinct(false); //不去重</span></span><br><span class="line"><span class="string">if(!StringUtils.isNotBlank(user.getName()))&#123;</span></span><br><span class="line"><span class="string">    Criteria.andNameEqualTo(user.getName());</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">if(!StringUtils.isNotBlank(user.getSex()))&#123;</span></span><br><span class="line"><span class="string">    Criteria.andSexEqualTo(user.getSex());</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">List&lt;User&gt; userList=userMapper.selectByExample(example);</span></span><br></pre></td></tr></table></figure>

<p><strong>模糊查询</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// select * from user where name like %&#123;#user.name&#125;%</span></span><br><span class="line"><span class="keyword">if</span>(!StringUtils.isNotBlank(user.getName()))&#123;</span><br><span class="line">    criteria.andNameLIke(‘%’+name+’%’);</span><br><span class="line">&#125;</span><br><span class="line">List&lt;User&gt; userList=userMapper.selectByExample(example);</span><br></pre></td></tr></table></figure>

<p><strong>分页查询</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// select * from user limit start to rows</span></span><br><span class="line"><span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> (currentPage - <span class="number">1</span>) * rows;</span><br><span class="line"><span class="comment">//分页查询中的一页数量</span></span><br><span class="line">example.setPageSize(rows); </span><br><span class="line"><span class="comment">//开始查询的位置</span></span><br><span class="line">example.setStartRow(start);  </span><br><span class="line">List&lt;User&gt; userList=userMapper.selectByExample(example);</span><br></pre></td></tr></table></figure>



<h4 id="POSTMAN的简单使用"><a href="#POSTMAN的简单使用" class="headerlink" title="POSTMAN的简单使用"></a>POSTMAN的简单使用</h4><p><strong>使用POSTMAN进行接口测试</strong></p>
<ul>
<li>新建Collections，相当于在POSTMAN中的一个文件夹</li>
<li>添加request</li>
<li>点击发送</li>
</ul>
<p><strong>显示的内容</strong></p>
<ul>
<li>Params：显示get请求参数</li>
<li>Authorization：身份认证</li>
<li>Headers：请求头信息</li>
</ul>
<h4 id="DSL的使用"><a href="#DSL的使用" class="headerlink" title="DSL的使用"></a>DSL的使用</h4><p><strong>参数类型</strong> </p>
<p>参数类型主要分为三种类型：请求参数、上下⽂参数、服务返回结果参数</p>
<p>\1. 请求参数：请求参数⽀持path路径取值、query取值、header取值、cookie取值、body取值（⽀持 json、表单等）。 </p>
<p>\2. 上下⽂参数：上下⽂参数主要⽀持⽤户⾃定义插件中可编程的取值⽅式。Shepherd Context取值汇总 </p>
<p>\3. 服务返回结果参数：请求后端服务后返回的结果可作为参数以待取值。</p>
<p><strong>表达式类型</strong> </p>
<p>\1. JsonPath（默认）：</p>
<p>表达式类型⽀持JsonPath标准：JSONPath-简单⼊⻔ </p>
<p>Jayway JsonPath - A Java DSL for reading JSON documents. </p>
<p>\2. Freemarker： </p>
<p>对于表达式有特殊要求，⽐如说在返回的Bean列表中，希望屏蔽Bean的某⼀个field时，可以使⽤ </p>
<p>Freemarker模板语⾔实现。 </p>
<p>具体请参⻅：Freemarker 表达式使⽤指南</p>
<p><strong>JsonPath表达式取值示例</strong> </p>
<img src="https://pic.imgdb.cn/item/627b89d70947543129b99894.jpg" style="zoom:80%;" />

<img src="https://pic.imgdb.cn/item/627b89e90947543129b9ccec.jpg" style="zoom:80%;" />

<p>服务调⽤参数和返回值Schema填写举例： </p>
<p>后端服务输⼊参数部分采⽤RPC框架泛化json-simple调⽤格式。 </p>
<p>先⽤com.dianping.pigeon.remoting.common.codec.json.SimpleJacksonUtils#serialize⽣成Json格式。 </p>
<p>然后对需要从请求参数或上下⽂取值的部分⽤DSL表达式替换。</p>
]]></content>
      <categories>
        <category>Projects</category>
        <category>MeiTuan</category>
      </categories>
      <tags>
        <tag>MeiTuan</tag>
        <tag>Projects</tag>
      </tags>
  </entry>
  <entry>
    <title>ObjectName</title>
    <url>/2022/05/03/objectName/</url>
    <content><![CDATA[<p>解释了Java中的各种O(Object)</p>
<span id="more"></span>

<h4 id="为什么会出现这些O？"><a href="#为什么会出现这些O？" class="headerlink" title="为什么会出现这些O？"></a>为什么会出现这些O？</h4><p>第一，随着编程工业化的发展，需要有一套合理的体系出现。随着MVC、MVP、MVVM 等编程模型就出现了，为了搭配这些编程模型的使用，需要对 Object 的功能进行划分，于是我们便看到了这些层出不穷的 Object。 </p>
<p>其二，在团队协作编码中，一个好的命名方式是可以节约很多时间成本的。就比如<code>getItemById</code>一眼看去就知道是通过 id 获取一个 item 对象，<code>ItemVO</code>一眼看去就知道是前端透出的 json 对应的对象。 </p>
<p>其三，如此划分，可以让项目结构更加清楚，不至于出现东一块西一块，对象乱扔的局面。尽可能避免了在多人协作时对象混乱的情况。 总的来说，这一切都是为了让软件编程更加合理、更加规范、更加高效。</p>
<h4 id="名称的含义"><a href="#名称的含义" class="headerlink" title="名称的含义"></a>名称的含义</h4><ul>
<li>DO（ Data Object）：与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。</li>
<li>PO（Persistant Object）：持久对象，一个 PO 的数据结构对应着库中表的结构，表中的一条记录就是一个 PO 对象</li>
<li>DTO（ Data Transfer Object）：数据传输对象，Service 或 Manager 向外传输的对象。</li>
<li>BO（ Business Object）：业务对象。 由 Service 层输出的封装业务逻辑的对象。</li>
<li>AO（ Application Object）：应用对象。 在 Web 层与 Service 层之间抽象的复用对象模型，极为贴近展示层，复用度不高。</li>
<li>VO（ View Object）：显示层对象，通常是 Web 向模板渲染引擎层传输的对象。</li>
<li>POJO（ Plain Ordinary Java Object）：POJO 专指只有 setter&#x2F;getter&#x2F;toString 的简单类，包括 DO&#x2F;DTO&#x2F;BO&#x2F;VO 等。</li>
<li>DAO（Data Access Objects）：数据访问对象，和上面那些 O 不同的是，其功能是用于进行数据操作的。通常不会用于描述数据实体。</li>
</ul>
<h4 id="数据的流向"><a href="#数据的流向" class="headerlink" title="数据的流向"></a>数据的流向</h4><img src="https://pic.imgdb.cn/item/62711f100947543129befd3b.jpg" style="zoom:80%;" />

<p>一般情况下，前端是不会凭空造出数据的，因此最后前端展示的数据一定是从数据库中来的，数据的流向通常也是从数据库流向页面。可将其分成三个部分：数据访问、业务处理和业务解释。</p>
<ol>
<li>数据访问：这一部分是用于从数据库中读取数据，将数据记录转换成数据实体也就是 Java 对象，便于操作。</li>
<li>业务处理：这一部分是数据流的核心，几乎所有数据的操作都是在这一部分完成的。</li>
<li>业务解释：这一部分是用于展示给前端的数据，解释业务体现在某些字段&#x2F;值是需要经过处理的才会呈现的。</li>
</ol>
<h4 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h4><ul>
<li>DAO，是用于<strong>操作数据</strong>而不是描述数据的。</li>
<li>PO&#x2F;DO&#x2F;Entity，其数据结构对应数据表中的一条记录，因此是同一类别的。</li>
<li>BO，可以理解为 PO 的组合，举个简单的例子，假设 PO 是一条交易记录，BO 就可以是一个人全部的交易记录集合对象。</li>
<li>DTO，用于传输数据，可能传递给前端，也有可能传递给其他系统。用于<strong>承载数据</strong>。</li>
<li>VO，这个最好理解，前端最后需要的数据长什么样，对应的对象就是 VO。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>High Performance Computer Architecture</title>
    <url>/2022/05/01/ELEC6036/</url>
    <content><![CDATA[<p>Hong Kong University 2022 summer semester class review —— ELEC6036 High Performance Computer Architecture.</p>
<span id="more"></span>

<h3 id="Pipelining"><a href="#Pipelining" class="headerlink" title="Pipelining"></a>Pipelining</h3><h4 id="Pipelining-Lessons"><a href="#Pipelining-Lessons" class="headerlink" title="Pipelining Lessons"></a>Pipelining Lessons</h4><ul>
<li><p>Pipelining is an implementation technique whereby <strong>multiple instructions are</strong> <strong>overlapped in execution</strong>.</p>
</li>
<li><p>Pipelining is the key implementation technique that is currently used to make high</p>
<p>performance CPUs.</p>
</li>
<li><p>Pipelining <u>doesn’t help to lower the <strong>latency</strong> of single task,</u> it helps to increase the <strong>throughput</strong>(overall system performance) of entire workload.</p>
</li>
<li><p>Pipeline rate limited by <strong>slowest</strong> (longest) pipeline stage.</p>
</li>
<li><p>The principle: <strong>Multiple</strong> tasks operating simultaneously using different resources.</p>
</li>
<li><p>Potential speedup &#x3D; <strong>Number pipe stages</strong></p>
</li>
<li><p><strong>Unbalanced</strong> lengths of pipe stages reduces speedup: that is, the key is every stage should have <strong>the same duration</strong>.</p>
</li>
<li><p>Time to “<strong>fill</strong>“ pipeline and time to “<strong>drain</strong>“ it reduces speedup.</p>
</li>
<li><p>Stall for Dependences. (stall &#x3D; delay, i.e we will have delay in the pipelined computer whenever there is contro&#x2F;data dependences between the instructions)</p>
</li>
</ul>
<h4 id="The-Five-Stages-of-Load"><a href="#The-Five-Stages-of-Load" class="headerlink" title="The Five Stages of Load"></a>The Five Stages of Load</h4><img src="https://pic.imgdb.cn/item/626e714f239250f7c5ad139b.jpg" style="zoom:80%;" />

<ul>
<li><strong>Ifetch</strong>: Instruction Fetch, fetch the instruction <u>from the instruction memory</u>.</li>
<li><strong>Reg&#x2F;Dec</strong>: Registers Fetch and Instruction Decode <u>from register file’s Read ports</u></li>
<li><strong>Exec</strong>: Calculate the memory address <u>from ALU</u></li>
<li><strong>Mem</strong>: Read the data <u>from the Data Memory</u></li>
<li><strong>Wr</strong>: Write the data back to the register file <u>from register file’s Write port</u></li>
</ul>
<img src="https://pic.imgdb.cn/item/626e756b239250f7c5b713f8.jpg" style="zoom:80%;" />

<p>As the instruction execution cycle uses different hardware components for different steps, it is possible to set up a <strong>pipeline</strong>.</p>
<p><img src="https://pic.imgdb.cn/item/626e77d2239250f7c5bce44c.jpg"></p>
<p>Suppose each stage takes 1 nsec(nano-second). Then each instruction still takes 5 nsec. But once the pipeline has been filled, a complete instruction rolls out every 1 nsec. Thus, the <strong>speedup</strong> is 5.</p>
<h4 id="Pipelining-in-the-CPU"><a href="#Pipelining-in-the-CPU" class="headerlink" title="Pipelining in the CPU"></a>Pipelining in the CPU</h4><p>(instruction-level parallelism)</p>
<ul>
<li>Pipelining is an implementation technique that exploits <strong>parallelism</strong> among instructions in a sequential instruction stream.</li>
<li>A major advantage of pipelining over “<strong>parallel processing</strong>” is that <strong>it is not visible to the programmer</strong> (whereas in parallel processing, the program usually needs to specify what kinds of tasks to be executed in parallel).</li>
<li>In a computer system, each pipeline stage completes a part of the instruction being executed. </li>
<li>The time required between <u>moving an instruction one step down the pipeline is a machine cycle</u> (<strong>the clock cycle</strong>). The length of a machine cycle is determined by the time required for <u>the slowest stage to proceed</u>.</li>
<li>The computer engineer should try to balance the length of each pipeline stage so as to achieve the ideal speedup. In practice, however, the pipeline stages will not be perfectly the same, and there are additional <strong>overheads</strong>. But we can get close to the <strong>ideal case</strong> (i.e. CPI &#x3D; 1, Cycle Per Instruction).</li>
</ul>
<p><strong>Design Issues</strong></p>
<ul>
<li>We have to make sure that <u>the same resource (e.g., ALU) is not used in more than one pipeline stage</u>.</li>
<li>If the resources used in the same pipelining stage are different, then <strong>overlapping</strong> is possible.</li>
<li>However, we must note that to retain the <strong>intermediate values</strong> produced by an individual instruction for all its pipeline stages, we must include <strong>temporary registers</strong> between the pipeline stages.</li>
</ul>
<img src="https://pic.imgdb.cn/item/626e8d05239250f7c5f37bbf.jpg" style="zoom: 67%;" />

<p>($1, $2 or $3 - represent Register #1, #2 and #3)</p>
<ul>
<li>Pipelining increases the processor <strong>instruction throughput</strong> — the <u>number of instructions completed per unit time</u>.</li>
<li>Remember: pipelining does not reduce the execution time of a single instruction.</li>
<li>The increase in instruction throughput means that <u>the program runs faster</u>, even though no single instruction runs faster.</li>
<li>Imbalance among the pipeline stages reduces performance since the <strong>clock</strong> cannot run faster than the time needed for the slowest pipeline stage.</li>
<li>Pipelining overhead can arise from the combination of <strong>pipeline register delay</strong> (propagation delay of the register to transfer the values between the pipeline stages) and other factors.</li>
</ul>
<h4 id="Graphically-Representing-Pipelines"><a href="#Graphically-Representing-Pipelines" class="headerlink" title="Graphically Representing Pipelines"></a>Graphically Representing Pipelines</h4><p><strong>Conventional Pipelined Execution Representation</strong></p>
<img src="https://pic.imgdb.cn/item/626e8f04239250f7c5fa5f47.jpg" style="zoom:80%;" />

<p><strong>Single Cycle, Multiple Cycle, vs. Pipeline</strong></p>
<img src="https://pic.imgdb.cn/item/626e8f3a239250f7c5fb2a2c.jpg" style="zoom:80%;" />

<p>Suppose we execute 100 instructions:</p>
<ul>
<li><p><strong>Single Cycle Machine</strong></p>
<p>- 45 ns&#x2F;cycle x 1 CPI x 100 instructions &#x3D; 4500ns</p>
</li>
<li><p><strong>Multi-Cycle Machine</strong></p>
<p>- 10 ns&#x2F;cycle x 4.6 CPI (due to instruction mix) x 100 instructions &#x3D; 4600ns</p>
</li>
<li><p><strong>Ideal pipelined machine</strong></p>
</li>
</ul>
<p>  - 10 ns&#x2F;cycle x (1 CPI x 100 instructions + 4 cycles drain) &#x3D; 1040ns!!</p>
<p>Ans: pipelining is much faster, i.e. in the above example, the total duration is around 1&#x2F;4 of the total time required for single-sysle machine!</p>
<p><strong>Why Pipeline? Because We Can!</strong></p>
<img src="https://pic.imgdb.cn/item/626e9041239250f7c5fecac6.jpg" style="zoom:80%;" />

<h4 id="Pipeline-Hazards"><a href="#Pipeline-Hazards" class="headerlink" title="Pipeline Hazards"></a>Pipeline Hazards</h4><h5 id="Structural-Hazards"><a href="#Structural-Hazards" class="headerlink" title="Structural Hazards:"></a><strong>Structural Hazards</strong>:</h5><p>attempt to use the same resource in two different ways (e.g., by two different instructions) at the same time.</p>
<p>- e.g., combined washer&#x2F;dryer would be a structural hazard or “folder” busy doing something else (e.g., watching TV ;-)</p>
<img src="https://pic.imgdb.cn/item/626e9224239250f7c5055a4b.jpg" style="zoom:80%;" />



<h5 id="Control-Hazards"><a href="#Control-Hazards" class="headerlink" title="Control Hazards:"></a><strong>Control Hazards</strong>:</h5><p><u>attempt to make a decision <strong>before</strong> condition is evaluated</u></p>
<p>- e.g., washing football uniforms and need to get proper detergent level; need to see after dryer before next load in</p>
<p>- <u>branch instructions</u></p>
<ul>
<li><p><strong>Control Hazard Solution #1: Stall</strong></p>
<img src="https://pic.imgdb.cn/item/626e952d239250f7c50f6c42.jpg" style="zoom:80%;" />

<p><u>Stall</u>: wait until decision is clear</p>
<p><u>Impact</u>: 2 lost cycles (i.e. 3 clock cycles per branch instruction) &#x3D;&gt; slow</p>
<p><u>Move decision to the end of decode</u>. (earlier to the decoder stage) —— save 1 cycle per branch.</p>
</li>
<li><p><strong>Control Hazard Solution #2: Predict</strong></p>
<img src="https://pic.imgdb.cn/item/626e95fa239250f7c5128041.jpg" style="zoom:80%;" />

<p><u>Predict</u>: guess one direction then back up if wrong</p>
<p><u>Impact</u>: 0 lost cycles per branch instruction if right, 1 if wrong (right - 50% of time)</p>
<ul>
<li>Need to “Squash” and restart following instruction if wrong</li>
<li>Produce CPI on branch of (1 * 0.5 + 2 * 0.5 &#x3D; 1.5) （the CPI of the branch instructions）</li>
<li>Total CPI might then be: 1.5 * 0.2 + 1 * 0.8 &#x3D; 1.1 (20% branch)</li>
</ul>
<p><u>More dynamic scheme</u>: history of 1 branch ( - 90%) , e.g. if there is 30% branch, then the total CPI &#x3D; 1.5 * 0.3 + 1 * 0.7</p>
<img src="https://pic.imgdb.cn/item/626e9b00239250f7c52578d9.jpg" style="zoom:80%;" />

<p>Delayed Branch: Redefine branch behavior (takes place after next instruction)</p>
<p>Impact: 0 clock cycles per branch instruction if can find instruction to put in “slot” ( - 50% of time)</p>
<p>As launch more instruction per clock syscle, less useful</p>
</li>
</ul>
<h5 id="Data-Hazards"><a href="#Data-Hazards" class="headerlink" title="Data Hazards:"></a><strong>Data Hazards</strong>:</h5><p>attempt to use item before it is ready ( an instruction depends on the result of a previous instruction still in the pipeline.)</p>
<p>- e.g., one sock of pair in dryer and one in washer; can’t fold until get sock from washer through dryer</p>
<p>- <u>instruction depends on result of prior instruction still in the pipeline</u></p>
<p><strong>Data Hazard on r1: Read After Write (RAW)</strong></p>
<img src="https://pic.imgdb.cn/item/626e9c70239250f7c52ae07d.jpg" style="zoom:80%;" />

<img src="https://pic.imgdb.cn/item/626ea026239250f7c539334f.jpg" style="zoom:80%;" />

<p><strong>Data Hazard Solution: Forwarding</strong></p>
<img src="https://pic.imgdb.cn/item/626e9d7c239250f7c52ea8e7.jpg" style="zoom:80%;" />

<p><strong>Forwarding (or Bypassing): What About Loads?</strong></p>
<img src="https://pic.imgdb.cn/item/626f6cdc239250f7c5971695.jpg" style="zoom:80%;" />

<img src="C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20220502133433952.png" alt="image-20220502133433952" style="zoom:80%;" />

<p><strong>Can always resolve these hazards by waiting(pipeline stall)</strong></p>
<p>- pipeline control must detect the hazard</p>
<p>- take action (or delay action) to resolve hazards</p>
<img src="https://pic.imgdb.cn/item/62790e490947543129ab86b8.jpg" style="zoom:80%;" />



<h4 id="Summary-of-Concepts"><a href="#Summary-of-Concepts" class="headerlink" title="Summary of Concepts"></a>Summary of Concepts</h4><ul>
<li>Reduce CPI by overlapping many instructions<ul>
<li>average throughput of approximately 1 CPI with fast clock</li>
</ul>
</li>
<li>Utilize capabilities of the datapath<ul>
<li>start next instruction while working on the current one</li>
<li>limited by length of longest stage (plus fill&#x2F;flush)</li>
<li>detect and resolve hazards</li>
</ul>
</li>
<li>What makes it easy</li>
<li><u>all instructions are of the same length</u> (very import for the pipeline design)</li>
<li>just a few instruction formats</li>
<li>memory operands appear only in loads(LW) and store(SW)</li>
<li>What makes it hard?<ul>
<li>structural hazards: suppose we had only one memory</li>
<li>control hazards: need to worry about branch instructions</li>
<li>data hazards: an instruction depends on a previous instruction (whenever two instructions have data dependence, there will be data hazards)</li>
</ul>
</li>
</ul>
<h4 id="Issues-in-Pipelined-Design"><a href="#Issues-in-Pipelined-Design" class="headerlink" title="Issues in Pipelined Design"></a>Issues in Pipelined Design</h4><img src="https://pic.imgdb.cn/item/626f7439239250f7c5a839d6.jpg" style="zoom:80%;" />

<h3 id="High-Performance-Techniques"><a href="#High-Performance-Techniques" class="headerlink" title="High Performance Techniques"></a>High Performance Techniques</h3><ul>
<li>How to Optimize the Pipeline? Extract More Parallelism! (<strong>multiple execution-stage PL</strong> computers e.g. ADD - EX1 and EX2, etc)</li>
<li><strong>Compiler-Directed (Static)</strong> Approaches<ul>
<li>VLIW (Very Long Instruction Word)</li>
<li>EPIC (Explicit Parallel Instruction Computer)</li>
<li>Superscalar</li>
<li>Software Pipelining</li>
</ul>
</li>
<li>A Dynamic Approach—Scoreboard</li>
</ul>
<p><strong>Pipelining: Can we somehow make CPI closer to 1?</strong></p>
<ul>
<li><p>Let’s assume FP ( full pipelining):</p>
</li>
<li><p>If we have a 4-cycle instruction (an instruction requiring 4 execution cycles), then we need 3 instructions between a producing instruction and its use:</p>
<img src="https://pic.imgdb.cn/item/626fb289239250f7c53ab10f.jpg" style="zoom:80%;" />
</li>
<li><p>Getting CPI &lt;1 : Processing Multiple Instructions&#x2F;Cycles</p>
<ul>
<li>Use parallel processing!!</li>
<li>Two main variations: superscalar and VLIW</li>
<li>Superscalar: varying number of instructions&#x2F;cycle (1 to 6)<ul>
<li>parallelism and dependencies determined&#x2F;resolved by HW(hardware)</li>
<li>IBM PowerPC 604, Sun UltraSPARC, DEC Alpha 21164, HP 7100</li>
</ul>
</li>
<li>Very Long Instruction Words (VLIW): fixed number of instructions (16) determined by compiler<ul>
<li>pipeline is exposed; compiler must schedule delays to get right results</li>
</ul>
</li>
<li>Explicit Parallel Instruction Computer (EPIC)&#x2F;Intel<ul>
<li>128 bit packets containing 3 instructions (can execute sequentially)</li>
<li>can link 128 bit packets together to allow more parallelism</li>
<li><strong>compiler determines parallelism</strong>, HW checks dependencies and <strong>forwards&#x2F;stalls</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>Parallelism: Overt vs. Covert</p>
<img src="https://pic.imgdb.cn/item/626fc41e239250f7c56323bd.jpg" style="zoom:80%;" />

<img src="https://pic.imgdb.cn/item/626fc453239250f7c563973e.jpg" style="zoom:80%;" /></li>
</ul>
<h4 id="Compliation-and-ISA-Instruction-Set-Architecture"><a href="#Compliation-and-ISA-Instruction-Set-Architecture" class="headerlink" title="Compliation and ISA (Instruction Set Architecture)"></a>Compliation and ISA (Instruction Set Architecture)</h4><ul>
<li><p>Efficient compilation requires knowledge of the pipeline structure</p>
<ul>
<li><strong>latency</strong> and <strong>bandwidth</strong> of each operation type</li>
</ul>
</li>
<li><p>But a good ISA transcends several implementations with different pipelines</p>
<ul>
<li>should things like a delayed branch be in an ISA?</li>
<li>should a compiler use the properties of one implementation when compiling for an ISA?</li>
<li>do we need a new interface?</li>
</ul>
<img src="https://pic.imgdb.cn/item/626fca4d239250f7c571fcca.jpg" style="zoom:80%;" /></li>
</ul>
<h4 id="Very-Long-Instruction-Word-VLIW-Computers"><a href="#Very-Long-Instruction-Word-VLIW-Computers" class="headerlink" title="Very Long Instruction Word (VLIW) Computers"></a>Very Long Instruction Word (VLIW) Computers</h4><img src="https://pic.imgdb.cn/item/626fcd40239250f7c5794c31.jpg" style="zoom:80%;" />

<p><strong>Pros</strong>(Strength)</p>
<ul>
<li>Very simple hardware<ul>
<li>no dependency detection</li>
<li>simple issue logic</li>
<li>just ALUs and register files</li>
</ul>
</li>
<li>Potentially exploits large amounts of ILP</li>
</ul>
<p><strong>Cons</strong>(Weakness)</p>
<ul>
<li>Lockstep execution (static schedule)<ul>
<li>very sensitive to long latency operations(cache misses)</li>
</ul>
</li>
<li>Global register file hard to build</li>
<li>Lots of NO-OPs<ul>
<li>poor “code density”</li>
<li>I-cache capacity and bandwidth compromised</li>
</ul>
</li>
<li>Must recompile sources to deliver potential</li>
<li>Implementation visible through ISA</li>
</ul>
<h4 id="EPIC-Explicit-Parallel-Instruction-Computer"><a href="#EPIC-Explicit-Parallel-Instruction-Computer" class="headerlink" title="EPIC: Explicit Parallel Instruction Computer"></a>EPIC: Explicit Parallel Instruction Computer</h4><p><strong>128-bit instructions</strong>:</p>
<ul>
<li><p>three 3-address operations</p>
</li>
<li><p>a template that encodes dependencies</p>
</li>
<li><p>128 general registers</p>
</li>
<li><p>predication (branch prediction)</p>
</li>
<li><p>speculative load (load prediction)</p>
</li>
<li><p>Example: IA-64 of Intel&#x2F;HP</p>
<img src="C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20220502204711061.png" alt="image-20220502204711061" style="zoom:80%;" /></li>
</ul>
<h4 id="Superscalar"><a href="#Superscalar" class="headerlink" title="Superscalar"></a>Superscalar</h4><p>Superscalar DLX: 2 instructions, 1 FP &amp; 1 anything else (int &#x2F; LW &#x2F; SW)</p>
<ul>
<li><p>fetch 64 bits&#x2F;clock cycle; integer on left, FP on right</p>
</li>
<li><p>can only issue 2nd instruction if 1st instruction issues</p>
</li>
<li><p>more ports for FP registers to do FP load &amp; FP op in a pair</p>
<img src="https://pic.imgdb.cn/item/626fd33f239250f7c588b92f.jpg" style="zoom: 67%;" />
</li>
<li><p>1 cycle load delay expands to 3 instructions in SS (super-scalar)</p>
<ul>
<li>instruction in right half can’t use it, nor instructions in next slot</li>
</ul>
</li>
</ul>
<p>Limits of Superscalar:</p>
<ul>
<li><p>While integer&#x2F;FP split is simple for the HW, get CPI of 0.5 only for programs with:</p>
<ul>
<li>exactly 50% FP operations</li>
<li>no hazards</li>
</ul>
</li>
<li><p>If more instructions issue at same time, greater difficulty of decode and issue</p>
<ul>
<li><p>even 2-scalar &#x3D;&gt; examine 2 opcodes, 6 register specifiers, &amp; decide if 1 or 2 instructions</p>
<p>can issue</p>
</li>
</ul>
</li>
<li><p>VLIW: tradeoff instruction space for simple decoding</p>
<ul>
<li>the long instruction word has room for many operations</li>
<li>by definition, all the operations the compiler puts in the long instruction word can execut in parallel</li>
<li>e.g., 2 integer operations, 2 FP ops, 2 memory references, 1 branch; 16 to 24 bits for each of these fields &#x3D;&#x3D;&gt; 7 x 16 or 112 bits to 7 x 24 or 168 bits wide</li>
<li>need compiling technique that schedules across several branches</li>
</ul>
</li>
</ul>
<h4 id="Software-Pipelining"><a href="#Software-Pipelining" class="headerlink" title="Software Pipelining"></a>Software Pipelining</h4><ul>
<li><p>Observation: if iterations from loops are independent, then can get more ILP (instruction level parallelism) by taking instructions from different iterations</p>
</li>
<li><p>Software pipelining: reorganizes loops so that each iteration is made from instructions chosen from different iterations of the original loop (i.e., Tomasulo algorithms in SW)</p>
<img src="https://pic.imgdb.cn/item/626fd999239250f7c599aa88.jpg" style="zoom: 67%;" /></li>
</ul>
<p><strong>Example:</strong></p>
<img src="https://pic.imgdb.cn/item/626fd9f5239250f7c59aa218.jpg" style="zoom:80%;" />

<h4 id="Multiple-Issue-as-compared-with-VLIW"><a href="#Multiple-Issue-as-compared-with-VLIW" class="headerlink" title="Multiple Issue as compared with VLIW"></a>Multiple Issue as compared with VLIW</h4><p><strong>Multiple Issue:</strong></p>
<ul>
<li>more complex issue logic<ul>
<li>check dependencies</li>
<li>check structural hazards</li>
<li>issue variable number of instructions (0-N)</li>
<li>shift unissued instructions over</li>
</ul>
</li>
<li>Able to run existing binaries<ul>
<li>recompile for performance, not correctness</li>
</ul>
</li>
<li>Data paths identical<ul>
<li>but bypass requires detection</li>
</ul>
</li>
<li>Neither VLIW or multiple-issue can schedule around run-time variation in instruction latency<ul>
<li>cache misses</li>
</ul>
</li>
<li>Dealing with run-time variation requires run-time or dynamic scheduling</li>
</ul>
<h4 id="The-problem-with-Static-Scheduling-Compile-Time"><a href="#The-problem-with-Static-Scheduling-Compile-Time" class="headerlink" title="The problem with Static Scheduling (Compile-Time)"></a>The problem with Static Scheduling (Compile-Time)</h4><p><strong>In-Order Execution</strong>:</p>
<ul>
<li>an unexpected long latency blocks <u>ready instructions</u> from executing (scheduled code cannot be changed at run-time)</li>
<li>binaries need to be <u>rescheduled (recompiled)</u> for each new processor implementation</li>
<li>small number of named registers becomes a bottleneck.</li>
</ul>
<p><strong>动态调度：</strong></p>
<ul>
<li><p>通过硬件在程序执行时重新安排代码的执行序列来减少竞争引起的流水线停顿时间</p>
</li>
<li><p>动态调度流水线具备以下功能：</p>
<ul>
<li>允许按序取多条指令和发射多条指令—-取指(IF)流水级允许按顺序取多条指令进入单口暂存器(single-entry latch)或队列(queue), 指令然后从latch或queue取出，进入ID节拍。</li>
<li>能检查并消除hazards—-将ID流水级分为独立的两级：Issue（ID1）级和Read operand（ID2）级：<ul>
<li>Issue级功能 —-指令译码，检查是否存在结构竞争(即在这一流水级解决结构竞争问题）；</li>
<li>Read operands级功能 —-等到无数据竞争(RAW)后，读出操作数，即在这一流水级解决数据竞争问题</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Scoreboard-a-bookkeeping-technique"><a href="#Scoreboard-a-bookkeeping-technique" class="headerlink" title="Scoreboard: a bookkeeping technique"></a>Scoreboard: a bookkeeping technique</h3><ul>
<li>Out-of-order execution divides <strong>ID stage</strong>:<ul>
<li><strong>Issue</strong>——decode instructions, check for <strong>structural hazards</strong></li>
<li><strong>Read operands</strong>——<strong>wait until no data hazards</strong>, then read operands</li>
</ul>
</li>
<li>Scoreboards date to CDC6600 designed in 1963</li>
<li>Instructions execute whenever not dependent on previous instructions and no hazards</li>
<li>CDC6600: <strong>in-order issue, out-of-order execution, out-of-order commit</strong> (or completion) (out-of-order or dynamic order&#x2F;scheduling, means that it DOES NOT have to follow the original order of the program code)<ul>
<li>no forwarding</li>
<li>imprecise interrupt&#x2F;exception model for now</li>
</ul>
</li>
</ul>
<h4 id="Scoreboard-Implications"><a href="#Scoreboard-Implications" class="headerlink" title="Scoreboard Implications"></a>Scoreboard Implications</h4><p><strong>算法设计</strong></p>
<ul>
<li>动态调度技术需要将ID译码段分成两个阶段：1是发射，2是读取操作数。<ul>
<li>发射阶段对指令进行译码，检查<strong>结构冒险</strong>（例如有四个运算器：整数运算、加法器、乘法器、除法器，检查该指令需要使用的运算器是否正在被占用）读取操作数阶段检查数据冒险（读之前检查寄存器的值是否已经写回，或者是否会覆盖了之前的值）。</li>
<li><strong>数据冒险</strong>的解决方法：<ul>
<li>读写冒险(RAW)：将指令和操作数保存起来，然后只能在读操作数阶段进行读取；</li>
<li>写写冒险(WAW)：检测是否有其它指令会写回到相同的寄存器（检测到冒险），有则等待，直到其它的完成</li>
</ul>
</li>
<li>发射阶段：假如检测到没有结构冒险和数据冒险，那么记分板将会将指令发射到相关的运算器，假如结构冒险或者写写冒险发生了，那么该指令将会等待，直到冒险消失为止。</li>
<li>读取操作数：没有数据相关了以后（之前的指令不会写回源寄存器或者正在写寄存器的情况时，读写冒险），读取操作数。读取操作数后将交给运算器，之后开始运算。发送到运算器的顺序可能是乱序的。</li>
</ul>
</li>
<li>之后就是执行段以及写回段了。执行段在完成计算以后会通知记分板。记分板直到计算已经完成了，那么它进行读写冒险检验（即写之前是否已经读取了寄存器的值，例如 ADD F10,F0,F8 SUB F8,F8,F14，这里SUB指令写回时要检查ADD指令的F8是否已经读取了，仅此而已）假如检测到冒险，则等待，不然就可以写寄存器了。</li>
</ul>
<p>Out-of-order completion &#x3D;&#x3D;&gt; WAR, WAW hazards?</p>
<ul>
<li>Solutions for WAR:<ul>
<li><u>stall writeback until registers have been read</u></li>
<li>read registers only during Read Operands stage</li>
</ul>
</li>
<li>No register renaming!  (This is different from the Tomasulo’s computers to be discussed)</li>
<li>Need to have multiple instructions in execution phase &#x3D;&#x3D;&gt;multiple execution units or pipelined execution units</li>
<li>Scoreboard keeps track of dependencies between instructions that have already issued</li>
<li>Scoreboard replaces ID, EX, WB with 4 stages (ID1(Issue), ID2(Read Operand), EX, WB(or completion))</li>
</ul>
<h4 id="Four-Stages-of-Scoreboard-Control"><a href="#Four-Stages-of-Scoreboard-Control" class="headerlink" title="Four Stages of Scoreboard Control"></a>Four Stages of Scoreboard Control</h4><ul>
<li><p>Issue—decode instructions &amp; check for structural hazards (ID1)</p>
<ul>
<li>instructions issued in program order (for hazard checking)</li>
<li>don’t issue if structural hazard</li>
<li>don’t issue if instruction is output dependent on any previously issued but uncompleted instruction (no WAW hazards)</li>
</ul>
</li>
<li><p>Read operands—wait until no data hazards, then read operands (ID2)</p>
<ul>
<li>all real dependencies (RAW hazards) resolved in this stage, since we wait for instructions to write back data</li>
<li>no forwarding of data in this model</li>
</ul>
</li>
<li><p>Execution—operate on operands (EX)</p>
<ul>
<li>the functional unit begins execution upon receiving operands; when the result is ready, it notifies the scoreboard that it has completed execution</li>
<li>note that different instructions will require different number of clock cycles for the execution stage!</li>
</ul>
</li>
<li><p>Write result—finish execution (WB)</p>
<ul>
<li><strong>stall until no WAR hazards</strong> with previous instructions:</li>
</ul>
<img src="https://pic.imgdb.cn/item/626fe9da239250f7c5db2acb.jpg" style="zoom:80%;" /></li>
</ul>
<h4 id="Three-Parts-of-the-Scoreboard"><a href="#Three-Parts-of-the-Scoreboard" class="headerlink" title="Three Parts of the Scoreboard"></a>Three Parts of the Scoreboard</h4><ul>
<li><p><strong>Instruction status</strong>:</p>
<p>Which of 4 steps the instruction is in</p>
</li>
<li><p><strong>Functional unit status</strong>:</p>
<p>Indicates the state of the functional unit (FU). 9 fields <u>for each functional unit</u>:</p>
<img src="https://pic.imgdb.cn/item/626fea7f239250f7c5dcf4fc.jpg" style="zoom:80%;" />
</li>
<li><p><strong>Register result status</strong>:</p>
<p>Indicates which <u>functional unit will write each register</u>, if one exists; <u>blank</u> when no pending instructions will write that register</p>
</li>
</ul>
<p><strong>Scoreboard Example:</strong></p>
<img src="https://pic.imgdb.cn/item/626feb92239250f7c5e041c4.jpg" style="zoom:80%;" />

<h4 id="Summary-of-Concepts-1"><a href="#Summary-of-Concepts-1" class="headerlink" title="Summary of Concepts"></a>Summary of Concepts</h4><ul>
<li>Compiler scheduling</li>
<li>HW exploiting ILP<ul>
<li>works when we can’t possibly know dependencies at compile time</li>
<li>code for one machine runs well on another</li>
</ul>
</li>
<li>Key idea of scoreboard: allow instructions behind stall to proceed (decode &#x3D;&gt; issue instructions and read operands)<ul>
<li>enables out-of-order execution &#x3D;&#x3D;&gt; out-of-order completion</li>
<li>ID stage checked both for structural and data dependencies</li>
<li>original version didn’t handle forwarding</li>
<li>no automatic register renaming (Tomasulo’s computer)</li>
</ul>
</li>
</ul>
<h4 id="要点总结和补充（重点）"><a href="#要点总结和补充（重点）" class="headerlink" title="要点总结和补充（重点）"></a>要点总结和补充（重点）</h4><p>总结和补充一下记分牌工作流程中的要点：</p>
<ul>
<li>一条指令能否发射，一看是否有功能部件空闲可用，这个信息包含在功能状态中；二看指令要写的寄存器是否正要被别的指令写，这个信息包含在寄存器状态中，观察这个信息是为了解决WAW冒险。</li>
<li>一条指令能否读数，要看记分牌是否提示源寄存器不可读，如果不可读，就说明该寄存器将要被别的前序指令改写，现在的指令要等待前序指令写回，观察这个信息是为了解决RAW冒险。</li>
<li>一条指令一旦读数完成，就必然可以进行运算，运算可以是多周期的，在第一个周期结束时应该改写功能状态，表明自己不再需要读寄存器。</li>
<li>一条指令能否写回，要看是否有指令需要读即将被改写的这个寄存器，具体一点来说，就是要观察标记Yes的Rj、Rk对应的寄存器里是否有当前指令的目的寄存器，如果有，就说明有指令需要读取寄存器的旧值，这样一来我们就要等指令读完旧值之后再写回，观察这个信息是为了解决WAR冒险。</li>
</ul>
<h3 id="Tomasulo-Algorithm"><a href="#Tomasulo-Algorithm" class="headerlink" title="Tomasulo Algorithm"></a>Tomasulo Algorithm</h3><p>Improved Dynamic Instruction Scheduling: Tomasulo Algorithm</p>
<p>由于<strong>记分牌算法只能检测竞争(WAR,WAW)并不能消除这两种竞争</strong>，所以将记分牌算法改进为Tomasulo算法。</p>
<p>Tomasulo算法的基本思想：</p>
<ul>
<li>Tomasulo算法采用寄存器重命名（Renaming）方法，将记分牌中的寄存器用一大组虚拟寄存器名来代替，即用虚拟寄存器集来代替真实的FP寄存器组，由于虚拟寄存器集合所含有的寄存器数目远大于真是的寄存器组，所以可以用虚拟寄存器集来实现寄存器重命名。</li>
<li>虚拟寄存器组由三部分组成：<ul>
<li>每个功能单元（FU）都带有的保留站（Reservation station）</li>
<li>取数缓冲区（Load buffers）—-保存被访问的存储单元的数据和地址</li>
<li>存数缓冲区（Store buffers）</li>
</ul>
</li>
</ul>
<h4 id="Recall-Compiler-Techniques-for-Parallelism"><a href="#Recall-Compiler-Techniques-for-Parallelism" class="headerlink" title="Recall: Compiler Techniques for Parallelism"></a>Recall: Compiler Techniques for Parallelism</h4><ul>
<li><strong>Loop unrolling</strong> &#x3D;&gt; multiple iterations of loop in software:<ul>
<li>amortizes loop overhead over several iterations</li>
<li>gives more opportunity for scheduling around stalls</li>
</ul>
</li>
<li><strong>Software Pipelining</strong> &#x3D;&gt; take one instruction from each of several iterations of the loop<ul>
<li>software overlapping of loop iterations</li>
</ul>
</li>
<li><strong>Very Long Instruction Word machines</strong> (VLIW) &#x3D;&gt;multiple operations coded in single, long instruction<ul>
<li>requires sophisticated compiler to decide which operations can be done in parallel</li>
<li>trace scheduling &#x3D;&gt; find common path and schedule code as if branches didn’t exist (add “fixup code”)</li>
</ul>
</li>
<li><u>ALL OF THE ABOVE require additional registers</u>!</li>
</ul>
<h4 id="Recall-How-are-WAR-and-WAW-hazard-handled-in-scoreboard"><a href="#Recall-How-are-WAR-and-WAW-hazard-handled-in-scoreboard" class="headerlink" title="Recall: How are WAR and WAW hazard handled in scoreboard?"></a>Recall: How are WAR and WAW hazard handled in scoreboard?</h4><ul>
<li><p><strong>WAR</strong> hazards handled by <u>stalling in WriteBack stage</u></p>
</li>
<li><p><strong>WAW</strong> hazards handled by <u>stalling in Issue stage</u></p>
</li>
<li><p>Are either of these <em>real</em> hazards???</p>
<img src="https://pic.imgdb.cn/item/627011fc239250f7c546a61c.jpg" style="zoom:80%;" /></li>
</ul>
<h4 id="Tomasulo-Algorithm-vs-Scoreboard"><a href="#Tomasulo-Algorithm-vs-Scoreboard" class="headerlink" title="Tomasulo Algorithm vs. Scoreboard"></a>Tomasulo Algorithm vs. Scoreboard</h4><ul>
<li>Control and buffers <u>distributed</u> with Function Units (FU) vs. <u>centralized</u> in scoreboard:<ul>
<li>FU buffers called “<u>reservation stations</u>“(A Buffer to a specific FU), have pending operands</li>
</ul>
</li>
<li>Registers in instructions replaced by values or pointers to reservation stations(RS); called <strong>Register Renaming</strong>. (i.e. pointing to a specific RS to wait for its register result)<ul>
<li><u>avoids WAR, WAW hazards</u></li>
<li><u>more reservation stations than registers</u>, so can do optimizations that compilers can’t do</li>
</ul>
</li>
<li>Results to FU <u>from RS</u>, not through registers, over <strong>Common Data Bus</strong> that broadcasts results to all FUs.</li>
<li>Load and Store treated as FUs with RSs as well</li>
<li>Integer instructions can go past branches, allowing FP ops beyond basic block in FP queue.</li>
</ul>
<img src="https://pic.imgdb.cn/item/6270bfa2239250f7c55636f2.jpg" style="zoom:80%;" />

<h4 id="Organization"><a href="#Organization" class="headerlink" title="Organization"></a>Organization</h4><img src="https://pic.imgdb.cn/item/6270b8af239250f7c5461af3.jpg" style="zoom:80%;" />

<ul>
<li>浮点寄存器（FP）通过一对总线与每一个功能单元（FU）相连接，这一对总线分别对应两个操作数，并通过一条总线与存数缓冲区（Load buffer）相连接。这里是浮点指令队列，指令在这里等待发射；</li>
<li>功能单元（FU）的输出和存数缓冲区（Load Buffer）的输出汇总在CDB与浮点寄存器（FP）的输入相连接。在这个算法中存储指令在执行前会先计算好存储地址；</li>
<li>公共数据总线（Common data bus）CDB：CDB与FP，Reservation station，store buffer等输入相连接，唯一无连接关系的是Load Buffer的输入。它可以直达寄存器堆（用来更新通用寄存器）、加法乘法存储单元的保留站（输送保留站中指令需要的数据）</li>
<li>由于保留站和Buffer都有对应的标识符，所以这里实现了重命名。保留站保留已经发射的指令的信息和缓冲下来的数据，指令一旦离开保留站就意味着指令开始执行</li>
</ul>
<h4 id="RS-Components"><a href="#RS-Components" class="headerlink" title="RS Components"></a>RS Components</h4><ul>
<li>Op: operation to perform in the unit(e.g., add or sub)</li>
<li>Vj, Vk, Value of source operands<ul>
<li>store buffers has V field, result to be stored</li>
</ul>
</li>
<li>Qj, Qk: reservation stations producing source registers (value to be written)<ul>
<li>note: no ready flags as in scoreboard; Qj, Qk &#x3D; 0 &#x3D;&#x3D;&gt; ready</li>
<li>store buffers only have Qi for RS producing result</li>
</ul>
</li>
<li>Busy: indicates reservation station or FU is busy</li>
<li>Register result status — indicates which functional unit will write each register, if one exists; blank when no pending instructions that will write that register.</li>
</ul>
<img src="https://pic.imgdb.cn/item/6277e6510947543129bf7d99.jpg" style="zoom:80%;" />

<ul>
<li><p>保留站的结构有点像cache，可能有多行数据，每一行都对应一条被发射到保留站的指令。</p>
<ul>
<li>保留站每一行都有Busy位，指示这一行是否现存有指令；</li>
<li>Vj和Vk与记分牌不同，记分牌的Vj和Vk会记录源寄存器的编号，<strong>而保留站则直接把能读取的数据直接拷贝到保留站中</strong>，可想而知，一旦数据进入保留站，那对应的寄存器就和这条指令没瓜葛了；</li>
<li>Qj和Qk的信息和记分牌一样，记录尚不能读取的数据将由哪条指令算出；</li>
<li>A是存储指令的地址，用于存放立即数和计算得到的地址数据。</li>
</ul>
</li>
<li><p>看上去保留站和记分牌非常相似，但是两者其实有很大的不同。</p>
<ul>
<li>以Add为例，保留站中有三行Add信息，这三行数据对应的是同一个加法单元，而在记分牌中这代表着三个加法单元。</li>
<li>记分牌那样的一条通路只对应一条信息的做法容易造成指令堵塞、无法发射，<strong>而保留站则为每条通路预留了缓冲区，指令可以在加法单元忙碌的时候发射到保留站的缓冲区待命</strong>。</li>
</ul>
</li>
<li><p>其次，保留站会直接把读取的数据缓冲下来，而不像记分牌一样只记录一个寄存器编号，只记录编号的话会造成读后写阻塞，因为一条指令在正式执行前一直在监控着它的源寄存器，源寄存器的值是不能改变的，因此后续指令无法写回，只能阻塞流水，<strong>而保留站则贯彻了“数据一旦准备完毕，就立马执行指令”的思想</strong>，指令一旦发现有数据可读，就立马读下来，读下来之后，那个源寄存器的写与不写就不关己事了。</p>
</li>
<li><p>记分牌和保留站相同的地方是都记录了Qj和Qk，即一旦需要的数据被算出来，就通过Qj和Qk捕捉广播数据，<strong>这样的做法其实就是重命名，即用保留站的编号而不是寄存器编号来标记数据源</strong>。</p>
</li>
</ul>
<img src="https://pic.imgdb.cn/item/6277e7030947543129c268cd.jpg" style="zoom:80%;" />

<ul>
<li>除了保留站数据结构之外，Tomasulo同样要记录寄存器结果状态，记录信息和记分牌一样，Tomasulo也会记录寄存器将被哪条指令更新，这个信息在指令寻找源数据时被使用。</li>
</ul>
<h4 id="Three-Stages"><a href="#Three-Stages" class="headerlink" title="Three Stages"></a>Three Stages</h4><ul>
<li>发射级（Issue）<ul>
<li>若是一条FP操作指令，如果<strong>保留站有空</strong>（判断能否发射的唯一标准），则将其送至保留站，如果该指令的操作数已在FP寄存器，将操作数的值送往保留站。</li>
<li>若是一条Load或者Store指令，如果Buffer有空，将其送往相应的Buffer</li>
<li>如果保留站或者Buffer没有空，则存在结构竞争，停顿该指令，直到对应的保留站或者Buffer有空为止。</li>
<li>这一级完成了重命名，因为在保留站中的操作数不再使用寄存器号。</li>
</ul>
</li>
<li>执行级（Execute）<ul>
<li>若有一个或几个操作数未就绪，等待该操作数，并同时监控CDB。一旦操作数就绪，立即存入相应的保留站，若两个操作数均已就绪，则执行该操作，此级检查了是否存在RAW竞争。</li>
</ul>
</li>
<li>写回级（Write Back）<ul>
<li>当结果计算出来之后，将其写入CDB，并从CDB写入目的寄存器以及等待此结果的保留站，当连续写同一寄存器时，只有最后一次才能写入，消除了WAW竞争。</li>
</ul>
</li>
</ul>
<p><strong>1. Issue</strong>:</p>
<ul>
<li>Get instruction from FP Op Queue<ul>
<li>if reservation station free (no structural hazard), control issues instructions and sends operands (renames registers);</li>
</ul>
</li>
</ul>
<p><strong>2. Execution</strong>:</p>
<ul>
<li>Operate on operands (EX)<ul>
<li>when both operands ready then execute; if not ready, watch Common Data Bus for result</li>
</ul>
</li>
</ul>
<p><strong>3. Write Result</strong>:</p>
<ul>
<li>Finish execution (WB)<ul>
<li>write on Common Data Bus to all awaiting units(all the FU that are waiting for its broadcasted result); mark reservation station available</li>
</ul>
</li>
</ul>
<p><strong>Remarks</strong>:</p>
<ul>
<li>Normal data bus: data + destination (“go to” bus) (i.e. destination-oriented data bus in the conventional computers)</li>
<li>Common Data Bus: data + source (“come from” bus) (i.e. a NEW source-oriented data bus trying to broadcast result FROM a specific FU as the data source)<ul>
<li>64 bits of data + 4 bits of Functional Unit source address</li>
<li>write if matches expected Functional Unit (produces result); does the broadcast</li>
</ul>
</li>
</ul>
<h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><p><strong>Tomasulo Example Cycle 57</strong></p>
<img src="https://pic.imgdb.cn/item/6270bf24239250f7c5551ddc.jpg" style="zoom:80%;" />

<p><strong>Compare to Scoreboard Cycle 62</strong></p>
<img src="https://pic.imgdb.cn/item/6270bffa239250f7c55700ed.jpg" style="zoom:80%;" />



<p><strong>Tomuasulo调度流程中的要点</strong>：</p>
<ul>
<li>一条指令能否发射，要看对应配置通路的保留站是否有空余，<strong>只要有空余，就可以发射到保留站中等待执行；发射的同时会被能读取的数据直接拷贝到保留站</strong>，这样做就不用考虑读后写冒险，后续的指令只要完成就可以写回，不用顾虑是否会有前序指令需要读取寄存器，换句话说，每一条被发射到保留站中的指令都不再需要读取寄存器堆。</li>
<li>指令在发射的时候会更新寄存器状态表，如果后序指令和前序指令的目的寄存器重合了，就用后序指令的写信息标志寄存器，<strong>表示只会把后序指令的计算结果写进寄存器</strong>，这样可以解决写后写冒险；</li>
<li>如果执行单元中有指令正在执行，其他指令就在保留站中等待；<strong>如果指令缺少源数据，就留在保留站中，时刻监听CDB总线</strong>，如果CDB总线广播了需要的数据，就立马拷贝下来，然后准备执行。</li>
<li>一条指令在源数据全部准备好之后就可以执行，执行可能是多周期的。</li>
<li>一条指令只要完成计算，就可以写回，<strong>写回的数据通过CDB总线直通寄存器堆和各个保留站</strong>。<strong>但是要注意的一点是指令的结果未必会写进寄存器堆</strong>，因为寄存器结果状态表中总是存有最新的状态，即如果发生写后写冒险，Tomasulo算法会记录下最新的写指令，而抛弃前序的写指令结果，前序写指令的结果不会写回到寄存器堆，这样的做法很符合数据流思维。</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>Tomasulo成功地解决了三种冒险，实现了指令的乱序执行，<strong>且性能比记分牌更好，具体优化的地方有三</strong>：</p>
<ul>
<li>记分牌每条通路只能存一条指令，导致经常有指令因为结构冒险而不能发射，<strong>而Tomasulo引入保留站之后每条通路可以缓冲下多条指令，这样的做法平缓了指令发射的速度</strong>；</li>
<li>写后写冒险时，记分牌过度纠结寄存器名字，会把所有指令的结果都写进寄存器堆，会因为写后写冒险阻塞指令发射，而Tomasulo只保存最新的写入值，这样即保证了正确的结果，又减少了无谓的工作；</li>
<li>读后写冒险时，记分牌过度纠结寄存器名字，指令在执行之前一直检测的是寄存器堆，一旦数据准备好，就会从寄存器堆中取数，这样的后果就是后序指令即使计算完结果也可能不能立刻写回寄存器堆，而Tomasulo则在发射时就拷贝数据，贯彻数据流的思想——“<strong>寄存器名字不重要，寄存器里的数据才重要</strong>”。</li>
</ul>
<p>在写后读冒险中两者都用CDB总线实现了逻辑上的正确，都解决了写后读冒险。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>但是Tomasulo也不是完美的，它也存在一些问题，图7的PPT显示了Tomasulo算法的一系列问题。</p>
<p>Tomasulo算法中每一个执行单元对应一个保留站，保留站中缓冲多条指令，所以有可能在同一周期有多条指令准备好数据，但是执行单元同时只能执行一条指令，所以就需要从中选择一条指令，简单的解决办法是为保留站的每一行增加一个年龄位，每次出现冲突，就选择最老的指令送到执行单元。</p>
<p>在前文的举例中，电路里的CDB总线只有一组，<strong>这意味着每一个周期只能写回一条指令</strong>，如果同时有多条指令完成，那就只能选择一条指令进行广播，别的指令等待；第二种办法是增加CDB总线，支持多指令广播，但是这会让电路面积大增，包括增加寄存器堆写口、增加保留站tag和CDB总线的比较电路、增加保留站写口。</p>
<h4 id="Drawbacks"><a href="#Drawbacks" class="headerlink" title="Drawbacks"></a>Drawbacks</h4><ul>
<li>Complexity<ul>
<li>delays of 360&#x2F;91, MIPS 10000, IBM 620?</li>
</ul>
</li>
<li>Many associative stores(CDB) at high speed</li>
<li>Performance limited by Common Data Bus<ul>
<li>multiple CDBs &#x3D;&#x3D;&gt; more FU logic for parallel associative stores</li>
</ul>
</li>
</ul>
<h4 id="Why-issue-in-order"><a href="#Why-issue-in-order" class="headerlink" title="Why issue in-order?"></a>Why issue in-order?</h4><ul>
<li>In-order issue permits us to analyze dataflow of program</li>
<li>This way , we know exactly which results should flow to which subsequent instructions<ul>
<li>if we issued out-of-order, we <strong>would confuse RAW and WAR hazards</strong></li>
<li>the most advanced machines ALL issue in-order ;-)</li>
</ul>
</li>
<li>This idea works perfectly well “in principle” with multiple instructions issued per clock:<ul>
<li>need to multi-port “rename table” and be able to re name a sequence of instructions together</li>
<li>need to be able to issue to multiple reservation stations in a single cycle</li>
<li>need to have 2x number of read ports and 1x number of write ports in register file</li>
</ul>
</li>
<li>In-order issue can be serious bottleneck when issuing multiple instructions per clock-cycle</li>
</ul>
<h3 id="The-5-tips-to-develop-an-effective-cloud-architecture-application"><a href="#The-5-tips-to-develop-an-effective-cloud-architecture-application" class="headerlink" title="The 5 tips to develop an effective cloud architecture application"></a>The 5 tips to develop an effective cloud architecture application</h3><ul>
<li>Ensure that your application is scalable by designing each component to be scalable on its own. If every component implements a service interface, responsible for its own scalability in all appropriate dimensions, the overall system will have a scalable base. </li>
<li>For better manageability and high-availability, make sure that your components are loosely coupled. The key is to build components without having tight dependencies between each other, so that if one component were to die (fail), sleep (not respond) or remain busy (slow to respond) for some reason, the other components in the system are built so as to continue to work as if no failure is happening.</li>
<li>Implement parallelization for better use of the infrastructure and for performance. Distributing the tasks on multiple machines, multithreading your requests and effective aggregation of results obtained in parallel are some of the techniques that help exploit the infrastructure. </li>
<li>After designing the basic functionality, use techniques and approaches that will ensure resilience. If any component fails (and failures happen all the time), the system should automatically alert, failover, and re-sync back to the ―last known state as if nothing had failed. </li>
<li>Don’t forget the cost factor. The key to building a cost-effective application is using on demand resources in your design. It’s wasteful to pay for infrastructure that is sitting idle.</li>
</ul>
<p><strong>There are numerous examples of cloud architectures including:</strong> </p>
<ul>
<li><strong>Processing pipelines</strong><ul>
<li>Document processing pipelines to convert hundreds of thousands of documents from one format to another, e.g. from MS Word to PDF; </li>
<li>Image processing piplelines – say resizing millions of images; </li>
<li>Video transcoding piplelines – transcoding AVI to MPEG movies; </li>
<li>Indexing – creating an index of web crawled documents; </li>
<li>Data mining – performing search over millions of records.</li>
</ul>
</li>
<li><strong>Batch processing systems</strong>: back-office applications in finance, insurance or retail sectors, log analysis, nightly builds or automated unit testing and deployment, etc</li>
</ul>
<h3 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h3><h4 id="MIPS-instructions"><a href="#MIPS-instructions" class="headerlink" title="MIPS instructions"></a>MIPS instructions</h4><ul>
<li><strong>Arithmetic Instructions</strong></li>
</ul>
<img src="https://pic.imgdb.cn/item/626fb4a1239250f7c53f9ffc.jpg" style="zoom:80%;" />

<ul>
<li><strong>Logical</strong></li>
</ul>
<img src="https://pic.imgdb.cn/item/626fb4d6239250f7c5400ed9.jpg" style="zoom:80%;" />

<ul>
<li><strong>Data Transfer</strong></li>
</ul>
<img src="https://pic.imgdb.cn/item/626fb4fa239250f7c5405a43.jpg" style="zoom:80%;" />

<img src="https://pic.imgdb.cn/item/626fb51a239250f7c5409d42.jpg" style="zoom:80%;" />

<ul>
<li><strong>Conditional Branch</strong></li>
</ul>
<img src="https://pic.imgdb.cn/item/626fb542239250f7c540f7f1.jpg" style="zoom:80%;" />

<ul>
<li><strong>Comparison</strong></li>
</ul>
<img src="https://pic.imgdb.cn/item/626fb566239250f7c54148d6.jpg" style="zoom:80%;" />

<ul>
<li><strong>Unconditional Jump</strong></li>
</ul>
<img src="https://pic.imgdb.cn/item/626fb586239250f7c54184f4.jpg" style="zoom:80%;" />

<ul>
<li><strong>Registers</strong></li>
</ul>
<img src="https://pic.imgdb.cn/item/626fb5c7239250f7c5420cd1.jpg" style="zoom:80%;" />
]]></content>
      <categories>
        <category>HKU</category>
      </categories>
      <tags>
        <tag>HKU</tag>
      </tags>
  </entry>
  <entry>
    <title>applicationLayers</title>
    <url>/2022/04/29/applicationLayers/</url>
    <content><![CDATA[<p>—— ELEC6036 High Performance Computer Architecture.</p>
<span id="more"></span>



<h3 id="应用分层"><a href="#应用分层" class="headerlink" title="应用分层"></a>应用分层</h3><img src="https://pic.imgdb.cn/item/626b6309239250f7c5458cdb.jpg" style="zoom:67%;" />

<ul>
<li>开放接口层：可直接封装 Service 方法暴露成 RPC 接口;通过 Web 封装成 http 接口;进行网关安全控制、流量控制等。</li>
<li>终端显示层：各个端的模板渲染并执行显示的层。当前主要是 velocity 渲染，JS 渲染，JSP 渲染，移动端展示等。</li>
<li>Web 层：主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。</li>
<li>Service 层：相对具体的业务逻辑服务层。</li>
<li>Manager 层：通用业务处理层。它有如下特征:<ul>
<li>对第三方平台封装的层，预处理返回结果及转化异常信息。</li>
<li>对 Service 层通用能力的下沉，如缓存方案、中间件通用处理。</li>
<li>与 DAO 层交互，对多个 DAO 的组合复用。</li>
</ul>
</li>
<li>DAO 层：数据访问层，与底层 MySQL、Oracle、Hbase 进行数据交互。</li>
</ul>
<h3 id="分层领域模型"><a href="#分层领域模型" class="headerlink" title="分层领域模型"></a>分层领域模型</h3><p>在阿里巴巴编码规约中列举了下面几个领域模型规约：</p>
<ul>
<li>DO(Data Object)：与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。</li>
<li>DTO(Data Transfer Object)：数据传输对象，Service 或 Manager 向外传输的对象。</li>
<li>BO(Business Object)：业务对象。由 Service 层输出的封装业务逻辑的对象。</li>
<li>AO(Application Object)：应用对象。在 Web 层与 Service 层之间抽象的复用对象模型，极为贴近展示层，复用度不高。</li>
<li>VO(View Object)：显示层对象，通常是 Web 向模板渲染引擎层传输的对象。</li>
<li>Query：数据查询对象，各层接收上层的查询请求。注意超过2个参数的查询封装，禁止使用 Map 类来传输。</li>
</ul>
]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>Sort Algorithms</title>
    <url>/2022/04/27/SortAlgorithms/</url>
    <content><![CDATA[<p>概述：本文主要记录了八大排序算法的Java实现</p>
<span id="more"></span>

<h3 id="部分性能总结"><a href="#部分性能总结" class="headerlink" title="部分性能总结"></a>部分性能总结</h3><img src="https://pic.imgdb.cn/item/626907de239250f7c5bfe4f8.jpg" style="zoom:80%;" />

<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zzzzzq.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 步骤：</span></span><br><span class="line"><span class="comment"> * 1. 比较相邻的元素，如果第一个比第二个大，就交换他们两个</span></span><br><span class="line"><span class="comment"> * 2. 对每一对相邻元素作同样的工作，每经过一次循环，会有一个最大的元素移到数组后段</span></span><br><span class="line"><span class="comment"> * 3. 重复上述循环直到没有任何一对数字需要比较</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 时间复杂度O(n^2), 空间复杂度O(1)</span></span><br><span class="line"><span class="comment"> * 稳定</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bubble</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n - <span class="number">1</span> - i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">                    arr[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;arr = &quot;</span> + Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zzzzzq.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. 从第一个元素开始</span></span><br><span class="line"><span class="comment"> * 2. 取出下一个元素，在已经排序号的元素序列中从后向前扫描</span></span><br><span class="line"><span class="comment"> * 3. 如果已排序的元素大于新元素，则两两交换</span></span><br><span class="line"><span class="comment"> * 4. 如果扫描到的已排序的元素小于新元素，则视为找到了&quot;插入位置&quot;，这个元素已经完成排序</span></span><br><span class="line"><span class="comment"> * 5. 重复步骤2，3，4</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 时间复杂度O(n^2),空间复杂度O(1)</span></span><br><span class="line"><span class="comment"> * 稳定</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Insertion</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i-<span class="number">1</span> ; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j]&gt;arr[i])&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">                    arr[i] = arr[j];</span><br><span class="line">                    arr[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;arr = &quot;</span> + Arrays.toString(arr));;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zzzzzq.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.xml.internal.ws.api.model.wsdl.WSDLOutput;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 希尔排序(又称递减增量排序算法)</span></span><br><span class="line"><span class="comment"> * 是简单插入排序的改进版，会有限比较距离较远的元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 步骤：</span></span><br><span class="line"><span class="comment"> * 1. 设置一个增量序列t1, t2, ... tk,我的设置一般为t1 = n/3 +1 , tn = tn-1/3 +1</span></span><br><span class="line"><span class="comment"> * 2. 按增量序列个数k面对序列进行k趟排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Shell</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(h&lt;n/<span class="number">3</span>) h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(h&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//h-sort the array</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> h; i &lt; n;i ++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=i;j&gt;=h &amp;&amp; arr[j]&lt;arr[j-h]; j-=h)&#123;</span><br><span class="line">                    exch(arr[j],arr[j-h]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            h/=<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;arr = &quot;</span> + Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a;</span><br><span class="line">        a=b;</span><br><span class="line">        b=temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zzzzzq.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选择排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. 从待排序序列中找到最小的元素</span></span><br><span class="line"><span class="comment"> * 2. 将该元素与待排序序列的第一个元素进行交换</span></span><br><span class="line"><span class="comment"> * 3. 从余下的N-1个元素中找出关键字最小的元素，重复1.2两步，直到排序结束</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 时间复杂度O(n^2),空间复杂度O(n)</span></span><br><span class="line"><span class="comment"> * 不稳定</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Selection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectionSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i!= n; ++i)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">minindex</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i; j != n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j]&lt;arr[minindex])&#123;</span><br><span class="line">                    minindex=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(minindex!=i)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">                arr[i] = arr[minindex];</span><br><span class="line">                arr[minindex] = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;arr = &quot;</span> + Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zzzzzq.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆排序</span></span><br><span class="line"><span class="comment"> * 基本思想：堆排序的过程就是将待排序的序列构造成一个堆，选出堆中最大的移走</span></span><br><span class="line"><span class="comment"> * 再把剩余的元素调整成堆，找出最大的再移走，重复直至有序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 步骤:</span></span><br><span class="line"><span class="comment"> * 1. 先将初始序列构造成一个大根堆，此时第一个元素最大，此堆为初始的无序区</span></span><br><span class="line"><span class="comment"> * 2. 将堆顶元素(最大元素)和无序区的最后一个元素交换，并进行调整</span></span><br><span class="line"><span class="comment"> * 3. 重复步骤2直到无序区只有一个元素时停止</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 需要定义如下几种操作:</span></span><br><span class="line"><span class="comment"> * 1. 最大堆调整(Max_Heapify): 将堆的末端子节点作调整，使得子节点永远小于父节点</span></span><br><span class="line"><span class="comment"> * 2. 创建最大堆(Build_Max_Heap): 将堆所有数据重新排序</span></span><br><span class="line"><span class="comment"> * 3. 堆排序(HeapSort): 移除位在第一个数据的根节点，并做最大堆调整的递归运算</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 用数组表示堆，对于节点的访问:</span></span><br><span class="line"><span class="comment"> * 1. 父节点 i 的左子节点在位置 (2*i+1)</span></span><br><span class="line"><span class="comment"> * 2. 父节点 i 的左子节点在位置 (2*i+2)</span></span><br><span class="line"><span class="comment"> * 3. 子节点 j 的父节点在位置 floor((i-1)/2)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 时间复杂度O(nlogn),空间复杂度O(n)</span></span><br><span class="line"><span class="comment"> * 稳定</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Heap</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=arr.length;i&gt;<span class="number">0</span>;--i)&#123;</span><br><span class="line">            max_heapify(arr,i);</span><br><span class="line">            <span class="comment">//将堆中最大的元素放到末尾</span></span><br><span class="line">            exch(arr[<span class="number">0</span>],arr[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;arr = &quot;</span> + Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">max_heapify</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> limit)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr.length &lt;= <span class="number">0</span> || arr.length &lt; limit) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">parentIdx</span> <span class="operator">=</span> limit / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(; parentIdx&gt;=<span class="number">0</span>;parentIdx--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(parentIdx*<span class="number">2</span>&gt;=limit) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> parentIdx*<span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> (left+<span class="number">1</span>) &gt;= limit ? left : left+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">maxChildId</span> <span class="operator">=</span> arr[left] &gt;= arr[right] ? left : right;</span><br><span class="line">            <span class="keyword">if</span>(arr[maxChildId] &gt; arr[parentIdx])&#123;</span><br><span class="line">                exch(arr[maxChildId],arr[parentIdx]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a;</span><br><span class="line">        a=b;</span><br><span class="line">        b=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zzzzzq.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 步骤：</span></span><br><span class="line"><span class="comment"> * 1. 从数列中挑出一个元素，称为pivot</span></span><br><span class="line"><span class="comment"> * 2. 重新排列数组，所有比pivot小的元素摆放在基准前面，所有比pivot大的元素摆在基准的后面</span></span><br><span class="line"><span class="comment"> * 3. &quot;递归地&quot;把小于pivot的子数列和大于pivot的子数列排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Quick</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        quickSort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;arr = &quot;</span> + Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> low, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low &gt; high) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> partition(arr,low,high);</span><br><span class="line">        quickSort(arr,low,index-<span class="number">1</span>);</span><br><span class="line">        quickSort(arr,index+<span class="number">1</span>,high);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[low];</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">while</span>(low &lt; high &amp;&amp; arr[high] &gt;= pivot)&#123;</span><br><span class="line">                --high;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[low] = arr[high];</span><br><span class="line">            <span class="keyword">while</span>(low &lt; high &amp;&amp; arr[low] &lt;= pivot)&#123;</span><br><span class="line">                ++low;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[high] = arr[low];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> high;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zzzzzq.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 步骤:</span></span><br><span class="line"><span class="comment"> * 1. 将序列每相邻两个数字进行归并操作，形成floor(n/2)个序列，排序后每个序列包含两个元素；</span></span><br><span class="line"><span class="comment"> * 2. 将上述序列再次合并，形成floor(n/4)个序列，每个序列包含四个元素</span></span><br><span class="line"><span class="comment"> * 3. 重复步骤2，直到所有元素排序完毕</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Merge</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] aux = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">        mergeSort(arr,aux,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;arr = &quot;</span> + Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span>[] aux, <span class="type">int</span> low, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(high &lt;= low) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> low + ( high - low ) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//优化方案，将mergeSort中aux,arr互换可以节省拷贝到辅助数组的时间，但不能节省空间</span></span><br><span class="line">        mergeSort(arr, aux, low, mid);</span><br><span class="line">        mergeSort(arr, aux, mid+<span class="number">1</span>, high);</span><br><span class="line">        <span class="comment">//优化方案，若a[mid]&lt;a[mid+1]，则表示两边已经有序，不需要merge，直接return</span></span><br><span class="line">        <span class="keyword">if</span>(arr[mid]&lt;arr[mid+<span class="number">1</span>])&#123;</span><br><span class="line">            merge(arr, aux, low, mid, high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span>[] aux, <span class="type">int</span> low, <span class="type">int</span> mid, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">        <span class="comment">//copy</span></span><br><span class="line">        <span class="keyword">if</span> (high + <span class="number">1</span> - low &gt;= <span class="number">0</span>) System.arraycopy(arr, low, aux, low, high + <span class="number">1</span> - low);</span><br><span class="line">        <span class="comment">//merge</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low, j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> low; k &lt;= high ;++k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; mid)             arr[k] = aux[j++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; high)       arr[k] = aux[i++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(aux[j]&lt;aux[i])  arr[k] = aux[j++];</span><br><span class="line">            <span class="keyword">else</span>                    arr[k] = aux[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zzzzzq.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 桶排序</span></span><br><span class="line"><span class="comment"> * 基本思想：把数组arr划分为n个大小相同子区间(桶)，每个子区间各自排序，最后合并</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. 找出待排序数组中的最大值max，最小值min</span></span><br><span class="line"><span class="comment"> * 2. 使用动态数组ArrayList作为桶，桶里放的元素也用ArrayList存储。桶的数量为(max-min)/arr.length+1</span></span><br><span class="line"><span class="comment"> * 3. 遍历数组arr，计算每个元素arr[i]放的痛</span></span><br><span class="line"><span class="comment"> * 4. 每个桶各自排序</span></span><br><span class="line"><span class="comment"> * 5. 遍历桶数组，把排序号的元素放进输出数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bucket</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bucketSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i != arr.length; ++i)&#123;</span><br><span class="line">            max = Math.max(max, arr[i]);</span><br><span class="line">            min = Math.min(min, arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//桶数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">bucketNum</span> <span class="operator">=</span> (max - min) / arr.length + <span class="number">1</span>;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(bucketNum);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != bucketNum; ++i)&#123;</span><br><span class="line">            bucketArr.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将每个元素放入桶中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != arr.length; ++i)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (arr[i] - min) / (arr.length);</span><br><span class="line">            bucketArr.get(num).add(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//堆每个桶进行排序并修改原数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != bucketNum; ++i)&#123;</span><br><span class="line">            Collections.sort(bucketArr.get(i));</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j != bucketArr.get(i).size(); ++j)&#123;</span><br><span class="line">                arr[index] = bucketArr.get(i).get(j);</span><br><span class="line">                ++index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;arr = &quot;</span> + Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="测试模块"><a href="#测试模块" class="headerlink" title="测试模块"></a>测试模块</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zzzzzq.sort.Bubble;</span><br><span class="line"><span class="keyword">import</span> com.zzzzzq.sort.Bucket;</span><br><span class="line"><span class="keyword">import</span> com.zzzzzq.sort.Heap;</span><br><span class="line"><span class="keyword">import</span> com.zzzzzq.sort.Insertion;</span><br><span class="line"><span class="keyword">import</span> com.zzzzzq.sort.Merge;</span><br><span class="line"><span class="keyword">import</span> com.zzzzzq.sort.Quick;</span><br><span class="line"><span class="keyword">import</span> com.zzzzzq.sort.Selection;</span><br><span class="line"><span class="keyword">import</span> com.zzzzzq.sort.Shell;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">6</span>,<span class="number">34</span>,<span class="number">32</span>,<span class="number">44</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">23</span>&#125;;</span><br><span class="line">        Bubble.bubbleSort(arr);</span><br><span class="line">        Selection.selectionSort(arr);</span><br><span class="line">        Insertion.insertionSort(arr);</span><br><span class="line">        Shell.shellSort(arr);</span><br><span class="line">        Heap.heapSort(arr);</span><br><span class="line">        Quick.quickSort(arr);</span><br><span class="line">        Merge.mergeSort(arr);</span><br><span class="line">        Bucket.bucketSort(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Buildup the Java environment on MacOS</title>
    <url>/2022/04/26/buildup/</url>
    <content><![CDATA[<p>本文主要介绍了在Mac上进行开发环境搭建的主要步骤</p>
<span id="more"></span>



<h3 id="效率工具"><a href="#效率工具" class="headerlink" title="效率工具"></a>效率工具</h3><h4 id="Homebrew软件管理工具"><a href="#Homebrew软件管理工具" class="headerlink" title="Homebrew软件管理工具"></a>Homebrew软件管理工具</h4><p><a href="https://blog.51cto.com/u_15346415/3691436">教程</a></p>
<h4 id="Iterm2替换默认终端"><a href="#Iterm2替换默认终端" class="headerlink" title="Iterm2替换默认终端"></a>Iterm2替换默认终端</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install --cask iterm2</span><br></pre></td></tr></table></figure>



<h4 id="oh-my-zsh"><a href="#oh-my-zsh" class="headerlink" title="oh-my-zsh"></a>oh-my-zsh</h4><p><a href="https://zhuanlan.zhihu.com/p/35283688">安装和配置</a></p>
<h4 id="AIfred-4替代spotlight"><a href="#AIfred-4替代spotlight" class="headerlink" title="AIfred 4替代spotlight"></a>AIfred 4替代spotlight</h4><h3 id="Java开发环境"><a href="#Java开发环境" class="headerlink" title="Java开发环境"></a>Java开发环境</h3><h4 id="sdkman管理各种开发sdk"><a href="#sdkman管理各种开发sdk" class="headerlink" title="sdkman管理各种开发sdk"></a>sdkman管理各种开发sdk</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -s &quot;https://get.sdkman.io&quot; | zsh</span><br><span class="line">source &quot;$HOME/.sdkman/bin/sdkman-init.sh&quot;</span><br><span class="line">sdk version</span><br></pre></td></tr></table></figure>

<p>sdkman版本：5.15.0</p>
<p><strong>jdk使用sdkman来安装管理</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sdk install java 8.0.292.hs-adpt</span><br><span class="line">sdk current java</span><br></pre></td></tr></table></figure>



<p><strong>maven使用sdkman来安装管理</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sdk install maven</span><br></pre></td></tr></table></figure>

<p>maven版本：3.8.5</p>
<p>下载 setting.xml ⽂件并放置在 ~&#x2F;.m2 ⽬录下，其中配置了公司内部 maven 仓库</p>
<p>注：找不到.m2文件夹要注意开启显示隐藏文件夹，并且任意执行一条maven命令，如 <code>mvn -version</code>,即会自动创建文件夹</p>
<h4 id="git-版本控制管理⼯具"><a href="#git-版本控制管理⼯具" class="headerlink" title="git 版本控制管理⼯具"></a>git 版本控制管理⼯具</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install git</span><br><span class="line">git config</span><br><span class="line">git config --global user.name &quot;username&quot;</span><br><span class="line">git config --global user.email username@meituan.com</span><br></pre></td></tr></table></figure>

<p>git版本：2.30.1</p>
<p>安装失败：提示No available formula or cask with the name “git”</p>
<p><a href="https://www.jianshu.com/p/28c99973cb5f">解决方案</a></p>
<p><strong>add ssh key</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>



<h3 id="Idea配置"><a href="#Idea配置" class="headerlink" title="Idea配置"></a>Idea配置</h3><p>直接官⽹下载社区版，或者公司内部申请Ultimate版。 </p>
<ul>
<li>Settings <ul>
<li>Code Style -&gt; Wrap on typing at 120 </li>
<li>Code Style -&gt; Java -&gt; Tab size, Indent, Continuation indent: 4 </li>
<li>Code Style -&gt; Java -&gt; Imports <ul>
<li>Class count to use import with “*”: 20 *</li>
<li><em>Names count to use static import with “</em>“: 8</li>
</ul>
</li>
<li>Editor Tabs -&gt; Tab placement: None(Use <code>cmd + E</code> instead)</li>
</ul>
</li>
<li>plugins <ul>
<li>Lombok</li>
<li>Meituan IDEKit </li>
<li>Maven Helper </li>
<li>SequenceDiagram </li>
<li>IdeaVim </li>
<li>GitToolBox </li>
<li>Presentation Assistant </li>
<li>…</li>
</ul>
</li>
</ul>
<p>[使用小技巧](<a href="https://blog.jetbrains.com/idea/2015/10/intellij-idea-tips-and-tricks/">IntelliJ IDEA Tips and Tricks | The IntelliJ IDEA Blog (jetbrains.com)</a>)</p>
<h3 id="本地环境"><a href="#本地环境" class="headerlink" title="本地环境"></a>本地环境</h3><p>每台机器有唯⼀的环境归属、泳道归属。泳道配置在机器的<code>/data/webapps/appenv</code>⽂件⾥</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">env=test</span><br><span class="line">deployenv=test</span><br><span class="line">zkserver=lion.dev.sankuai.com:2181</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果没有配置swimlane参数，则认为机器归属于⻣⼲链路</span></span><br><span class="line">swimlane=misid</span><br></pre></td></tr></table></figure>

<p>ps1: 如果没有配置swimlane参数，则认为机器归属于⻣⼲链路。 </p>
<p>如果是新电脑，修改环境⽬录⽆权限请参考如下解决⽅案： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.禁⽤SIP（重启，按住Command+R进⼊恢复模式，在⼯具⻚⾯打开终端，运⾏如下命令：）</span></span><br><span class="line">csrutil disable</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. 开启写权限</span></span><br><span class="line">sudo mount -uw /</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 3. 创建⽂件</span></span></span><br><span class="line">cd /</span><br><span class="line">sudo mkdir data</span><br><span class="line">sudo chmod -R 777 /data</span><br><span class="line">mkdir /data/webapps</span><br><span class="line">cd /data/webapps</span><br><span class="line">touch appenv</span><br></pre></td></tr></table></figure>

<p>这里有个坑，如果macOS是Big Sur则版本过高，关闭SIP后仍无法修改文件夹下的文件，解决方案较为复杂，我在尝试的过程中系统崩溃导致只能重装系统，耗费了非常大量的时间。</p>
<p><a href="https://www.zhihu.com/question/403361335">解决方案</a></p>
]]></content>
      <categories>
        <category>Mac</category>
        <category>EnvBuildUp</category>
        <category>MeiTuan</category>
      </categories>
      <tags>
        <tag>MeiTuan</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot05 —— 程序运行相关</title>
    <url>/2022/04/23/SpringBoot05/</url>
    <content><![CDATA[<p>概述：SpringBoot框架中程序的打包与运行，高级配置相关，多环境开发，日志</p>
<span id="more"></span>

<h3 id="程序的打包与运行"><a href="#程序的打包与运行" class="headerlink" title="程序的打包与运行"></a>程序的打包与运行</h3><p><strong>为什么要打包？</strong></p>
<p>实际开发完成后，我们的项目是不可能运行在自己的电脑上的。</p>
<p>我们以后制作的程序是运行在专用的服务器上的，这就要将我们的程序先组织成一个文件，然后将这个文件传输到这台服务器上。这里面就存在两个过程，一个是打包的过程，另一个是运行的过程。</p>
<p><strong>程序打包</strong></p>
<p>SpringBoot程序是基于Maven创建的，在Maven中提供有打包的指令，叫做package。本操作可以在Idea环境下执行。（注意打包应该把test部分排除）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mvn <span class="keyword">package</span></span><br></pre></td></tr></table></figure>

<p>打包后会产生一个与工程名类似的jar文件，其名称是由模块名+版本号+.jar组成的。</p>
<p><strong>程序运行</strong></p>
<p>程序包打好以后，就可以直接执行了。在程序包所在路径下，执行指令。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -jar 工程包名.jar</span><br></pre></td></tr></table></figure>

<p>执行程序打包指令后，程序正常运行，与在Idea下执行程序没有区别。</p>
<p><strong>特别关注</strong>：</p>
<ul>
<li>如果你的计算机中没有安装java的jdk环境，是无法正确执行上述操作的，因为程序执行使用的是java指令。</li>
<li>在使用向导创建SpringBoot工程时，pom.xml文件中会有如下配置，这一段配置千万不能删除，否则打包后无法正常执行程序。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ul>
<li>SpringBoot工程可以基于java环境下独立运行jar文件启动服务</li>
<li>SpringBoot工程执行mvn命令package进行打包</li>
<li>执行jar命令：java –jar 工程名.jar</li>
</ul>
<p><strong>程序的打包与运行（Linux版本）</strong></p>
<ul>
<li>基于Linux（CenterOS7） </li>
<li>安装JDK，且版本不低于打包时使用的JDK版本</li>
<li>安装包保存在&#x2F;usr&#x2F;local&#x2F;自定义目录中或$HOME下 </li>
<li>其他操作参照Windows版进行</li>
</ul>
<h3 id="配置高级"><a href="#配置高级" class="headerlink" title="配置高级"></a>配置高级</h3><h4 id="临时属性设置"><a href="#临时属性设置" class="headerlink" title="临时属性设置"></a>临时属性设置</h4><p>我们的程序包打好了，可以发布了。但是程序包打好以后，里面的配置都已经是固定的了，比如配置了服务器的端口是8080。如果我要启动项目，发现当前我的服务器上已经有应用启动起来并且占用了8080端口，此时就需要临时设置端口数形。</p>
<p>SpringBoot提供了灵活的配置方式，如果你发现你的项目中有个别属性需要重新配置，可以使用临时属性的方式快速修改某些配置。方法也特别简单，在启动的时候添加上对应参数就可以了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java –jar springboot.jar --server.port=<span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>上面的命令是启动SpringBoot程序包的命令，在命令输入完毕后，空一格，然后输入两个<code>-</code>号。下面按照属性名<code>=</code>属性值的形式添加对应参数就可以了。</p>
<p>注意这里的格式不是yaml中的书写格式，当属性存在多级名称时，中间使用点分隔，和properties文件中的属性格式完全相同。</p>
<p>如果你发现要修改的属性不止一个，可以按照上述格式继续写，属性与属性之间使用空格分隔。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java –jar springboot.jar –-server.port=<span class="number">80</span> --logging.level.root=debug</span><br></pre></td></tr></table></figure>

<p>现在我们的程序配置受配置文件和临时属性共同控制。并且我们发现临时属性的加载优先级要高于配置文件的。</p>
<p>那是否还有其他的配置方式呢？其实是有的，打开官方文档中对应的内容，就可以查看配置读取的优先顺序。<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html">地址</a></p>
<p><strong>总结</strong></p>
<ul>
<li>使用jar命令启动SpringBoot工程时可以使用临时属性替换配置文件中的属性</li>
<li>临时属性添加方式：java –jar 工程名.jar –-属性名&#x3D;值</li>
<li>多个临时属性之间使用空格分隔</li>
<li>临时属性必须是当前boot工程支持的属性，否则设置无效</li>
</ul>
<h4 id="配置文件分配"><a href="#配置文件分配" class="headerlink" title="配置文件分配"></a>配置文件分配</h4><h4 id="自定义配置文件"><a href="#自定义配置文件" class="headerlink" title="自定义配置文件"></a>自定义配置文件</h4>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot04 —— SSMP整合案例</title>
    <url>/2022/04/21/SpringBoot04/</url>
    <content><![CDATA[<p>概述：SpringBoot整合JUnit，MyBatis，MyBatis-Plus，Druid的简单案例</p>
<span id="more"></span>

<h3 id="功能及技术概述"><a href="#功能及技术概述" class="headerlink" title="功能及技术概述"></a>功能及技术概述</h3><p>实现一个图书管理系统，完成增删改查的功能</p>
<p>整体案例中需要采用的技术如下，先了解一下，做到哪一个说哪一个</p>
<ul>
<li><p>实体类开发————使用Lombok快速制作实体类</p>
</li>
<li><p>Dao开发————整合MyBatisPlus，制作数据层测试</p>
</li>
<li><p>Service开发————基于MyBatisPlus进行增量开发，制作业务层测试类</p>
</li>
<li><p>Controller开发————基于Restful开发，使用PostMan测试接口功能</p>
</li>
<li><p>Controller开发————前后端开发协议制作</p>
</li>
<li><p>页面开发————基于VUE+ElementUI制作，前后端联调，页面数据处理，页面消息处理</p>
<ul>
<li>列表</li>
<li>新增</li>
<li>修改</li>
<li>删除</li>
<li>分页</li>
<li>查询</li>
</ul>
</li>
<li><p>项目异常处理</p>
</li>
<li><p>按条件查询————页面功能调整、Controller修正功能、Service修正功能</p>
</li>
</ul>
<p>SSMP案例制作流程解析</p>
<ul>
<li>先开发基础CRUD功能，做一层测一层</li>
<li>调通页面，确认异步提交成功后，制作所有功能</li>
<li>添加分页功能与查询功能</li>
</ul>
<h3 id="模块创建"><a href="#模块创建" class="headerlink" title="模块创建"></a>模块创建</h3><p>如果按照企业开发的形式进行应该制作后台微服务，前后端分离的开发。</p>
<img src="https://pic.imgdb.cn/item/6261534f239250f7c59fa635.jpg" style="zoom: 67%;" />

<p>这里进行了简化，后台做单体服务器，前端不使用前后端分离的制作。一个服务器即充当后台服务调用，又负责前端页面展示。</p>
<img src="https://pic.imgdb.cn/item/62615380239250f7c5a01911.jpg" style="zoom:67%;" />

<p>下面我们创建一个新的模块，加载要使用的技术对应的starter，修改配置文件格式为yml格式，并把web访问端口先设置成80。</p>
<p><strong>pom.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<h3 id="实体类开发"><a href="#实体类开发" class="headerlink" title="实体类开发"></a>实体类开发</h3><p>本案例对应的模块表结构如下：（mysql创建tbl_book表并插入数据）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- ----------------------------</span><br><span class="line">-- Table structure for tbl_book</span><br><span class="line">-- ----------------------------</span><br><span class="line">DROP TABLE IF EXISTS `tbl_book`;</span><br><span class="line">CREATE TABLE `tbl_book`  (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `type` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  `name` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  `description` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`) USING BTREE</span><br><span class="line">) ENGINE = InnoDB AUTO_INCREMENT = 51 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line">-- Records of tbl_book</span><br><span class="line">-- ----------------------------</span><br><span class="line">INSERT INTO `tbl_book` VALUES (1, &#x27;计算机理论&#x27;, &#x27;Spring实战 第5版&#x27;, &#x27;Spring入门经典教程，深入理解Spring原理技术内幕&#x27;);</span><br><span class="line">INSERT INTO `tbl_book` VALUES (2, &#x27;计算机理论&#x27;, &#x27;Spring 5核心原理与30个类手写实战&#x27;, &#x27;十年沉淀之作，手写Spring精华思想&#x27;);</span><br><span class="line">INSERT INTO `tbl_book` VALUES (3, &#x27;计算机理论&#x27;, &#x27;Spring 5 设计模式&#x27;, &#x27;深入Spring源码剖析Spring源码中蕴含的10大设计模式&#x27;);</span><br><span class="line">INSERT INTO `tbl_book` VALUES (4, &#x27;计算机理论&#x27;, &#x27;Spring MVC+MyBatis开发从入门到项目实战&#x27;, &#x27;全方位解析面向Web应用的轻量级框架，带你成为Spring MVC开发高手&#x27;);</span><br><span class="line">INSERT INTO `tbl_book` VALUES (5, &#x27;计算机理论&#x27;, &#x27;轻量级Java Web企业应用实战&#x27;, &#x27;源码级剖析Spring框架，适合已掌握Java基础的读者&#x27;);</span><br><span class="line">INSERT INTO `tbl_book` VALUES (6, &#x27;计算机理论&#x27;, &#x27;Java核心技术 卷I 基础知识（原书第11版）&#x27;, &#x27;Core Java 第11版，Jolt大奖获奖作品，针对Java SE9、10、11全面更新&#x27;);</span><br><span class="line">INSERT INTO `tbl_book` VALUES (7, &#x27;计算机理论&#x27;, &#x27;深入理解Java虚拟机&#x27;, &#x27;5个维度全面剖析JVM，大厂面试知识点全覆盖&#x27;);</span><br><span class="line">INSERT INTO `tbl_book` VALUES (8, &#x27;计算机理论&#x27;, &#x27;Java编程思想（第4版）&#x27;, &#x27;Java学习必读经典,殿堂级著作！赢得了全球程序员的广泛赞誉&#x27;);</span><br><span class="line">INSERT INTO `tbl_book` VALUES (9, &#x27;计算机理论&#x27;, &#x27;零基础学Java（全彩版）&#x27;, &#x27;零基础自学编程的入门图书，由浅入深，详解Java语言的编程思想和核心技术&#x27;);</span><br><span class="line">INSERT INTO `tbl_book` VALUES (10, &#x27;市场营销&#x27;, &#x27;直播就该这么做：主播高效沟通实战指南&#x27;, &#x27;李子柒、李佳琦、薇娅成长为网红的秘密都在书中&#x27;);</span><br><span class="line">INSERT INTO `tbl_book` VALUES (11, &#x27;市场营销&#x27;, &#x27;直播销讲实战一本通&#x27;, &#x27;和秋叶一起学系列网络营销书籍&#x27;);</span><br><span class="line">INSERT INTO `tbl_book` VALUES (12, &#x27;市场营销&#x27;, &#x27;直播带货：淘宝、天猫直播从新手到高手&#x27;, &#x27;一本教你如何玩转直播的书，10堂课轻松实现带货月入3W+&#x27;);</span><br></pre></td></tr></table></figure>

<p>根据上述表结构，制作对应的实体类</p>
<p><strong>实体类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实体类的开发可以自动通过工具手工生成get&#x2F;set方法，然后覆盖toString()方法，方便调试，等等。不过这一套操作书写很繁琐，有对应的工具可以帮助我们简化开发，介绍一个小工具，lombok。</p>
<p>Lombok，一个Java类库，提供了一组注解，简化POJO实体类开发，SpringBoot目前默认集成了lombok技术，并提供了对应的版本控制，所以只需要提供对应的坐标即可，在pom.xml中添加lombok的坐标。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--lombok--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用lombok可以通过一个注解<code>@Data</code>完成一个实体类对应的getter，setter，toString，equals，hashCode等操作的快速添加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="数据层开发——基础CRUD"><a href="#数据层开发——基础CRUD" class="headerlink" title="数据层开发——基础CRUD"></a>数据层开发——基础CRUD</h3><p>数据层开发本次使用MyBatisPlus技术，数据源使用Druid。</p>
<p><strong>步骤①</strong>：导入MyBatisPlus与Druid对应的starter，注意mysql的驱动不能少</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤②</strong>：配置数据库连接相关的数据源配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/test?serverTimezone=UTC</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤③</strong>：使用MyBatisPlus的标准通用接口BaseMapper加速开发，别忘了<code>@Mapper</code>和泛型的指定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Book&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤④</strong>：制作测试类测试结果（企业开发中往往都为加速开发跳过此步）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.metadata.IPage;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.pagination.Page;</span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.Book;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoTestCase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testGetById</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(bookDao.selectById(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSave</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">        book.setType(<span class="string">&quot;测试数据123&quot;</span>);</span><br><span class="line">        book.setName(<span class="string">&quot;测试数据123&quot;</span>);</span><br><span class="line">        book.setDescription(<span class="string">&quot;测试数据123&quot;</span>);</span><br><span class="line">        bookDao.insert(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testUpdate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">        book.setId(<span class="number">17</span>);</span><br><span class="line">        book.setType(<span class="string">&quot;测试数据abcdefg&quot;</span>);</span><br><span class="line">        book.setName(<span class="string">&quot;测试数据123&quot;</span>);</span><br><span class="line">        book.setDescription(<span class="string">&quot;测试数据123&quot;</span>);</span><br><span class="line">        bookDao.updateById(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testDelete</span><span class="params">()</span>&#123;</span><br><span class="line">        bookDao.deleteById(<span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testGetAll</span><span class="params">()</span>&#123;</span><br><span class="line">        bookDao.selectList(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<p>MyBatisPlus技术默认的主键生成策略为雪花算法，生成的主键ID长度较大，和目前的数据库设定规则不相符，需要配置一下使MyBatisPlus使用数据库的主键生成策略，方式还是做配置。在application.yml中添加对应配置即可，具体如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">table-prefix:</span> <span class="string">tbl_</span>		<span class="comment">#设置表名通用前缀</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span>				<span class="comment">#设置主键id字段的生成策略为参照数据库设定的策略，当前数据库设置id生成策略为自增</span></span><br></pre></td></tr></table></figure>

<p><strong>查看MyBatisPlus运行日志</strong></p>
<p>在进行数据层测试的时候，因为基础的CRUD操作均由MyBatisPlus给我们提供了，所以就出现了一个局面，开发者不需要书写SQL语句了，这样程序运行的时候总有一种感觉，一切的一切都是黑盒的，作为开发者我们啥也不知道就完了。如果程序正常运行还好，这个时候就不知道从何下手，因为传递参数、封装SQL语句这些操作完全不是你开发出来的，所以查看执行期运行的SQL语句就成为当务之急。</p>
<p>SpringBoot整合MyBatisPlus的时候充分考虑到了这点，通过配置的形式就可以查阅执行期SQL语句，配置如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">table-prefix:</span> <span class="string">tbl_</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure>

<p>再来看运行结果，此时能显示了运行期执行SQL的情况。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Creating a new SqlSession</span><br><span class="line">SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@2c9a6717] was not registered for synchronization because synchronization is not active</span><br><span class="line">JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@6ca30b8a] will not be managed by Spring</span><br><span class="line">==&gt;  Preparing: SELECT id,type,name,description FROM tbl<span class="built_in">_</span>book</span><br><span class="line">==&gt; Parameters: </span><br><span class="line">&lt;==    Columns: id, type, name, description</span><br><span class="line">&lt;==        Row: 1, 计算机理论, Spring实战 第5版, Spring入门经典教程，深入理解Spring原理技术内幕</span><br><span class="line">&lt;==        Row: 2, 计算机理论, Spring 5核心原理与30个类手写实战, 十年沉淀之作，手写Spring精华思想</span><br><span class="line">&lt;==        Row: 3, 计算机理论, Spring 5 设计模式, 深入Spring源码剖析Spring源码中蕴含的10大设计模式</span><br><span class="line">&lt;==        Row: 4, 计算机理论, Spring MVC+MyBatis开发从入门到项目实战, 全方位解析面向Web应用的轻量级框架，带你成为Spring MVC开发高手</span><br><span class="line">&lt;==        Row: 5, 计算机理论, 轻量级Java Web企业应用实战, 源码级剖析Spring框架，适合已掌握Java基础的读者</span><br><span class="line">&lt;==        Row: 6, 计算机理论, Java核心技术 卷I 基础知识（原书第11版）, Core Java 第11版，Jolt大奖获奖作品，针对Java SE9、10、11全面更新</span><br><span class="line">&lt;==        Row: 7, 计算机理论, 深入理解Java虚拟机, 5个维度全面剖析JVM，大厂面试知识点全覆盖</span><br><span class="line">&lt;==        Row: 8, 计算机理论, Java编程思想（第4版）, Java学习必读经典,殿堂级著作！赢得了全球程序员的广泛赞誉</span><br><span class="line">&lt;==        Row: 9, 计算机理论, 零基础学Java（全彩版）, 零基础自学编程的入门图书，由浅入深，详解Java语言的编程思想和核心技术</span><br><span class="line">&lt;==        Row: 10, 市场营销, 直播就该这么做：主播高效沟通实战指南, 李子柒、李佳琦、薇娅成长为网红的秘密都在书中</span><br><span class="line">&lt;==        Row: 11, 市场营销, 直播销讲实战一本通, 和秋叶一起学系列网络营销书籍</span><br><span class="line">&lt;==        Row: 12, 市场营销, 直播带货：淘宝、天猫直播从新手到高手, 一本教你如何玩转直播的书，10堂课轻松实现带货月入3W+</span><br><span class="line">&lt;==        Row: 13, 测试类型, 测试数据, 测试描述数据</span><br><span class="line">&lt;==        Row: 14, 测试数据update, 测试数据update, 测试数据update</span><br><span class="line">&lt;==        Row: 15, -----------------, 测试数据123, 测试数据123</span><br><span class="line">&lt;==      Total: 15</span><br></pre></td></tr></table></figure>

<p>其中清晰的标注了当前执行的SQL语句是什么，携带了什么参数，对应的执行结果是什么，所有信息应有尽有。</p>
<p>此处设置的是日志的显示形式，当前配置的是控制台输出，当然还可以由更多的选择，根据需求切换即可</p>
<img src="https://pic.imgdb.cn/item/62619cac239250f7c54d1d93.jpg" style="zoom:80%;" />



<p><strong>总结</strong></p>
<ol>
<li><p>手工导入starter坐标（2个），mysql驱动（1个）</p>
</li>
<li><p>配置数据源与MyBatisPlus对应的配置</p>
</li>
<li><p>开发Dao接口（继承BaseMapper）</p>
</li>
<li><p>制作测试类测试Dao功能是否有效</p>
</li>
<li><p>使用配置方式开启日志，设置日志输出方式为标准输出即可查阅SQL执行日志</p>
</li>
</ol>
<h4 id="数据层开发——分页功能制作"><a href="#数据层开发——分页功能制作" class="headerlink" title="数据层开发——分页功能制作"></a>数据层开发——分页功能制作</h4><p>MyBatisPlus提供的分页操作API如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testGetPage</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">IPage</span> <span class="variable">page</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Page</span>(<span class="number">2</span>,<span class="number">5</span>);</span><br><span class="line">    bookDao.selectPage(page, <span class="literal">null</span>);</span><br><span class="line">    System.out.println(page.getCurrent());</span><br><span class="line">    System.out.println(page.getSize());</span><br><span class="line">    System.out.println(page.getTotal());</span><br><span class="line">    System.out.println(page.getPages());</span><br><span class="line">    System.out.println(page.getRecords());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中selectPage方法需要传入一个封装分页数据的对象，可以通过new的形式创建这个对象，当然这个对象也是MyBatisPlus提供的，别选错包了。创建此对象时需要指定两个分页的基本数据</p>
<ul>
<li>当前显示第几页</li>
<li>每页显示几条数据</li>
</ul>
<p>可以通过创建Page对象时利用构造方法初始化这两个数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">IPage</span> <span class="variable">page</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Page</span>(<span class="number">2</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>将该对象传入到查询方法selectPage后，可以得到查询结果，但是我们会发现当前操作查询结果返回值仍然是一个IPage对象，这又是怎么回事？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">IPage</span> <span class="variable">page</span> <span class="operator">=</span> bookDao.selectPage(page, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>原来这个IPage对象中封装了若干个数据，而查询的结果作为IPage对象封装的一个数据存在的，可以理解为查询结果得到后，又塞到了这个IPage对象中，其实还是为了高度的封装，一个IPage描述了分页所有的信息。下面5个操作就是IPage对象中封装的所有信息了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testGetPage</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">IPage</span> <span class="variable">page</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Page</span>(<span class="number">2</span>,<span class="number">5</span>);</span><br><span class="line">    bookDao.selectPage(page, <span class="literal">null</span>);</span><br><span class="line">    System.out.println(page.getCurrent());		<span class="comment">//当前页码值</span></span><br><span class="line">    System.out.println(page.getSize());			<span class="comment">//每页显示数</span></span><br><span class="line">    System.out.println(page.getTotal());		<span class="comment">//数据总量</span></span><br><span class="line">    System.out.println(page.getPages());		<span class="comment">//总页数</span></span><br><span class="line">    System.out.println(page.getRecords());		<span class="comment">//详细数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里就知道这些数据如何获取了，但是当你去执行这个操作时，你会发现并不像我们分析的这样，实际上这个分页功能当前是无效的。为什么这样呢？这个要源于MyBatisPlus的内部机制。</p>
<p>对于MySQL的分页操作使用limit关键字进行，而并不是所有的数据库都使用limit关键字实现的，这个时候MyBatisPlus为了制作的兼容性强，将分页操作设置为基础查询操作的升级版，你可以理解为IPhone6与IPhone6S-PLUS的关系。</p>
<p>基础操作中有查询全部的功能，而在这个基础上只需要升级一下（PLUS）就可以得到分页操作。所以MyBatisPlus将分页操作做成了一个开关，你用分页功能就把开关开启，不用就不需要开启这个开关。而我们现在没有开启这个开关，所以分页操作是没有的。这个开关是通过MyBatisPlus的拦截器的形式存在的，具体设置方式如下：</p>
<p><strong>定义MyBatisPlus拦截器并将其设置为Spring管控的bean</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MPConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>());</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码第一行是创建MyBatisPlus的拦截器栈，这个时候拦截器栈中没有具体的拦截器，第二行是初始化了分页拦截器，并添加到拦截器栈中。如果后期开发其他功能，需要添加全新的拦截器，按照第二行的格式继续add进去新的拦截器就可以了。</p>
<p><strong>总结</strong></p>
<ul>
<li>使用IPage封装分页数据</li>
<li>分页操作依赖MyBatisPlus分页拦截器实现功能</li>
<li>借助MyBatisPlus日志查阅执行SQL语句</li>
</ul>
<h3 id="数据层开发——条件查询功能制作"><a href="#数据层开发——条件查询功能制作" class="headerlink" title="数据层开发——条件查询功能制作"></a>数据层开发——条件查询功能制作</h3><p>除了分页功能，MyBatisPlus还提供有强大的条件查询功能。以往我们写条件查询要自己动态拼写复杂的SQL语句，现在简单了，MyBatisPlus将这些操作都制作成API接口，调用一个又一个的方法就可以实现各种条件的拼装。</p>
<p>下面的操作就是执行一个模糊匹配对应的操作，由like条件书写变为了like方法的调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testGetBy</span><span class="params">()</span>&#123;</span><br><span class="line">    QueryWrapper&lt;Book&gt; qw = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    qw.like(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;Spring&quot;</span>);</span><br><span class="line">    bookDao.selectList(qw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中第一句QueryWrapper对象是一个用于封装查询条件的对象，该对象可以动态使用API调用的方法添加条件，最终转化成对应的SQL语句。第二句就是一个条件了，需要什么条件，使用QueryWapper对象直接调用对应操作即可。比如做大于小于关系，就可以使用lt或gt方法，等于使用eq方法，等等。</p>
<p>这组API使用还是比较简单的，但是关于属性字段名的书写存在着安全隐患，比如查询字段name，当前是以字符串的形态书写的，万一写错，编译器还没有办法发现，只能将问题抛到运行器通过异常堆栈告诉开发者，不太友好。</p>
<p>MyBatisPlus针对字段检查进行了功能升级，全面支持Lambda表达式，就有了下面这组API。由QueryWrapper对象升级为LambdaQueryWrapper对象，这下就避免了上述问题的出现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testGetBy2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    LambdaQueryWrapper&lt;Book&gt; lqw = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;Book&gt;();</span><br><span class="line">    lqw.like(Book::getName,name);</span><br><span class="line">    bookDao.selectList(lqw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了便于开发者动态拼写SQL，防止将null数据作为条件使用，MyBatisPlus还提供了动态拼装SQL的快捷书写方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testGetBy2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    LambdaQueryWrapper&lt;Book&gt; lqw = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;Book&gt;();</span><br><span class="line">    <span class="comment">//if(name != null) lqw.like(Book::getName,name);		//方式一：JAVA代码控制</span></span><br><span class="line">    lqw.like(name != <span class="literal">null</span>,Book::getName,name);				<span class="comment">//方式二：API接口提供控制开关</span></span><br><span class="line">    bookDao.selectList(lqw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>总结</strong></p>
<ul>
<li>使用QueryWrapper对象封装查询条件</li>
<li>推荐使用LambdaQueryWrapper对象</li>
<li>所有查询操作封装成方法调用</li>
<li>查询条件支持动态条件拼装</li>
</ul>
<h3 id="业务层开发"><a href="#业务层开发" class="headerlink" title="业务层开发"></a>业务层开发</h3><p>下面进行业务层开发，其实标准业务层开发很多初学者认为就是调用数据层，更精准的说法应该是<font color="#ff0000"><b>组织业务逻辑功能，并根据业务需求，对数据持久层发起调用</b></font>。有什么差别呢？目标是为了组织出符合需求的业务逻辑功能，至于调不调用数据层还真不好说，有需求就调用，没有需求就不调用。</p>
<p>业务层的方法名定义一定要与业务有关，例如登录操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">login(String username,String password);</span><br></pre></td></tr></table></figure>

<p>而数据层的方法名定义一定与业务无关，例如根据用户名密码查询</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">selectByUserNameAndPassword(String username,String password);</span><br></pre></td></tr></table></figure>

<p>我们在开发的时候是可以根据完成的工作不同划分成不同职能的开发团队的。比如一个哥们制作数据层，他就可以不知道业务是什么样子，拿到的需求文档要求可能是这样的</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">接口：传入用户名与密码字段，查询出对应结果，结果是单条数据</span><br><span class="line">接口：传入ID字段，查询出对应结果，结果是单条数据</span><br><span class="line">接口：传入离职字段，查询出对应结果，结果是多条数据</span><br></pre></td></tr></table></figure>

<p>但是进行业务功能开发的哥们，拿到的需求文档要求差别就很大</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">接口：传入用户名与密码字段，对用户名字段做长度校验，4-15位，对密码字段做长度校验，8到24位，对密码字段做特殊字符校验，不允许存在空格，查询结果为对象。如果为null，返回BusinessException，封装消息码INFO<span class="built_in">_</span>LOGON<span class="built_in">_</span>USERNAME<span class="built_in">_</span>PASSWORD<span class="built_in">_</span>ERROR</span><br></pre></td></tr></table></figure>

<p>所以说业务层方法定义与数据层方法定义差异化很大，只不过有些入门级的开发者手懒或者没有使用过公司相关的ISO标准化文档而已。</p>
<p>我们的案例就简单制作了，业务层接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    Boolean <span class="title function_">save</span><span class="params">(Book book)</span>;</span><br><span class="line">    Boolean <span class="title function_">update</span><span class="params">(Book book)</span>;</span><br><span class="line">    Boolean <span class="title function_">delete</span><span class="params">(Integer id)</span>;</span><br><span class="line">    Book <span class="title function_">getById</span><span class="params">(Integer id)</span>;</span><br><span class="line">    List&lt;Book&gt; <span class="title function_">getAll</span><span class="params">()</span>;</span><br><span class="line">    IPage&lt;Book&gt; <span class="title function_">getPage</span><span class="params">(<span class="type">int</span> currentPage,<span class="type">int</span> pageSize)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>业务层实现类如下，转调数据层即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">save</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bookDao.insert(book) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">update</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bookDao.updateById(book) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">delete</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bookDao.deleteById(id) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Book <span class="title function_">getById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bookDao.selectById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Book&gt; <span class="title function_">getAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bookDao.selectList(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IPage&lt;Book&gt; <span class="title function_">getPage</span><span class="params">(<span class="type">int</span> currentPage, <span class="type">int</span> pageSize)</span> &#123;</span><br><span class="line">        <span class="type">IPage</span> <span class="variable">page</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Page</span>(currentPage,pageSize);</span><br><span class="line">        bookDao.selectPage(page,<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> page;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>别忘了对业务层接口进行测试，测试类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IBookService bookService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testGetById</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(bookService.getById(<span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSave</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">        book.setType(<span class="string">&quot;测试数据123&quot;</span>);</span><br><span class="line">        book.setName(<span class="string">&quot;测试数据123&quot;</span>);</span><br><span class="line">        book.setDescription(<span class="string">&quot;测试数据123&quot;</span>);</span><br><span class="line">        bookService.save(book);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testUpdate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">        book.setId(<span class="number">17</span>);</span><br><span class="line">        book.setType(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line">        book.setName(<span class="string">&quot;测试数据123&quot;</span>);</span><br><span class="line">        book.setDescription(<span class="string">&quot;测试数据123&quot;</span>);</span><br><span class="line">        bookService.updateById(book);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testDelete</span><span class="params">()</span>&#123;</span><br><span class="line">        bookService.removeById(<span class="number">18</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testGetAll</span><span class="params">()</span>&#123;</span><br><span class="line">        bookService.list();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testGetPage</span><span class="params">()</span>&#123;</span><br><span class="line">        IPage&lt;Book&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;Book&gt;(<span class="number">2</span>,<span class="number">5</span>);</span><br><span class="line">        bookService.page(page);</span><br><span class="line">        System.out.println(page.getCurrent());</span><br><span class="line">        System.out.println(page.getSize());</span><br><span class="line">        System.out.println(page.getTotal());</span><br><span class="line">        System.out.println(page.getPages());</span><br><span class="line">        System.out.println(page.getRecords());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ol>
<li>Service接口名称定义成业务名称，并与Dao接口名称进行区分</li>
<li>制作测试类测试Service功能是否有效</li>
</ol>
<p><strong>业务层快速开发</strong></p>
<p>其实MyBatisPlus技术不仅提供了数据层快速开发方案，业务层MyBatisPlus也给了一个通用接口，个人观点不推荐使用，凑合能用吧，其实就是一个封装+继承的思想，代码给出，实际开发慎用。</p>
<p>业务层接口快速开发</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IBookService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;Book&gt; &#123;</span><br><span class="line">    <span class="comment">//添加非通用操作API接口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>业务层接口实现类快速开发，关注继承的类需要传入两个泛型，一个是数据层接口，另一个是实体类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;BookDao, Book&gt; <span class="keyword">implements</span> <span class="title class_">IBookService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">	<span class="comment">//添加非通用操作API</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果感觉MyBatisPlus提供的功能不足以支撑你的使用需要（其实是一定不能支撑的，因为需求不可能是通用的），在原始接口基础上接着定义新的API接口就行了，此处不再说太多了，就是自定义自己的操作了，但是不要和已有的API接口名冲突即可。</p>
<p><strong>总结</strong></p>
<ul>
<li>使用通用接口（<code>ISerivce&lt;T&gt;</code>）快速开发Service</li>
<li>使用通用实现类（<code>ServiceImpl&lt;M,T&gt;</code>）快速开发ServiceImpl</li>
<li>可以在通用接口基础上做功能重载或功能追加</li>
<li>注意重载时不要覆盖原始操作，避免原始提供的功能丢失</li>
</ul>
<h3 id="表现层开发"><a href="#表现层开发" class="headerlink" title="表现层开发"></a>表现层开发</h3><p>表现层的开发使用基于Restful的表现层接口开发，功能测试通过Postman工具进行。</p>
<p>表现层接口如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/books&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IBookService bookService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Book&gt; <span class="title function_">getAll</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookService.list();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span><span class="comment">//添加操作</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> Book book)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookService.save(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping</span><span class="comment">//修改操作</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">update</span><span class="params">(<span class="meta">@RequestBody</span> Book book)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookService.modify(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;&#123;id&#125;&quot;)</span><span class="comment">//删除操作</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookService.delete(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Book <span class="title function_">getById</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookService.getById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;&#123;currentPage&#125;/&#123;pageSize&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> IPage&lt;Book&gt; <span class="title function_">getPage</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> currentPage,<span class="meta">@PathVariable</span> <span class="type">int</span> pageSize)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookService.getPage(currentPage,pageSize, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用Postman测试时关注提交类型，对应上即可，不然就会报405的错误码了。</p>
<p><strong>总结</strong></p>
<p>基于Restful制作表现层接口</p>
<ul>
<li>新增：POST</li>
<li>删除：DELETE</li>
<li>修改：PUT</li>
<li>查询：GET</li>
</ul>
<p>接收参数</p>
<ul>
<li>实体数据：<code>@RequestBody</code></li>
<li>路径变量：<code>@PathVariable</code></li>
</ul>
<h3 id="表现层消息一致性处理"><a href="#表现层消息一致性处理" class="headerlink" title="表现层消息一致性处理"></a>表现层消息一致性处理</h3><p>目前我们通过Postman测试后业务层接口功能是通的，但是这样的结果给到前端开发者会出现一个小问题。不同的操作结果所展示的数据格式差异化严重。</p>
<p><strong>增删改操作结果</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure>

<p><strong>查询单个数据操作结果</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;计算机理论&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Spring实战 第5版&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Spring入门经典教程&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>查询全部数据操作结果</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;计算机理论&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Spring实战 第5版&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Spring入门经典教程&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;计算机理论&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Spring 5核心原理与30个类手写实战&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;十年沉淀之作&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p>每种不同操作返回的数据格式都不一样，而且还不知道以后还会有什么格式，这样的结果让前端人员看了是很容易让人崩溃的，必须将所有操作的操作结果数据格式统一起来，需要设计表现层返回结果的模型类，用于后端与前端进行数据格式统一，也称为<strong>前后端数据协议</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">R</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Boolean flag;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中flag用于标识操作是否成功，data用于封装操作数据，现在的数据格式就变了</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;flag&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;计算机理论&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Spring实战 第5版&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Spring入门经典教程&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>表现层开发格式也需要转换一下</p>
<img src="https://pic.imgdb.cn/item/62619fb2239250f7c551227a.jpg" style="zoom:80%;" />

<img src="https://pic.imgdb.cn/item/62619fd9239250f7c551600d.jpg" style="zoom:80%;" />

<p>现在后端发送给前端的数据格式就统一了，免去了不少前端解析数据的烦恼。</p>
<p><strong>总结</strong></p>
<ul>
<li>设计统一的返回值结果类型便于前端开发读取数据</li>
<li>返回值结果类型可以根据需求自行设定，没有固定格式</li>
<li>返回值结果模型类用于后端与前端进行数据格式统一，也称为前后端数据协议</li>
</ul>
<h3 id="前后端联通性测试"><a href="#前后端联通性测试" class="headerlink" title="前后端联通性测试"></a>前后端联通性测试</h3><p>后端的表现层接口开发完毕，就可以进行前端的开发了。</p>
<p>将前端人员开发的页面保存到lresources目录下的static目录中，建议执行maven的clean生命周期，避免缓存的问题出现。</p>
<p>​    <img src="https://pic.imgdb.cn/item/6261a160239250f7c553cb73.jpg" style="zoom:67%;" /></p>
<p>在进行具体的功能开发之前，先做联通性的测试，通过页面发送异步提交（axios），这一步调试通过后再进行进一步的功能开发。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//列表</span></span><br><span class="line"><span class="title function_">getAll</span>(<span class="params"></span>) &#123;</span><br><span class="line">	axios.<span class="title function_">get</span>(<span class="string">&quot;/books&quot;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">data</span>);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>只要后台代码能够正常工作，前端能够在日志中接收到数据，就证明前后端是通的，也就可以进行下一步的功能开发了。</p>
<p><strong>总结</strong></p>
<ol>
<li>单体项目中页面放置在resources&#x2F;static目录下</li>
<li>created钩子函数用于初始化页面时发起调用</li>
<li>页面使用axios发送异步请求获取数据后确认前后端是否联通</li>
</ol>
<h3 id="页面基础功能开发"><a href="#页面基础功能开发" class="headerlink" title="页面基础功能开发"></a>页面基础功能开发</h3><h5 id="F-1-列表功能（非分页版）"><a href="#F-1-列表功能（非分页版）" class="headerlink" title="F-1.列表功能（非分页版）"></a>F-1.列表功能（非分页版）</h5><p>列表功能主要操作就是加载完数据，将数据展示到页面上，此处要利用VUE的数据模型绑定，发送请求得到数据，然后页面上读取指定数据即可。</p>
<p>​        <strong>页面数据模型定义</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">data</span>:&#123;</span><br><span class="line">	<span class="attr">dataList</span>: [],		<span class="comment">//当前页要展示的列表数据</span></span><br><span class="line">	...</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>​        异步请求获取数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//列表</span></span><br><span class="line"><span class="title function_">getAll</span>(<span class="params"></span>) &#123;</span><br><span class="line">    axios.<span class="title function_">get</span>(<span class="string">&quot;/books&quot;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">dataList</span> = res.<span class="property">data</span>.<span class="property">data</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>​        这样在页面加载时就可以获取到数据，并且由VUE将数据展示到页面上了。</p>
<p>总结：</p>
<ol>
<li>将查询数据返回到页面，利用前端数据绑定进行数据展示</li>
</ol>
<h5 id="F-2-添加功能"><a href="#F-2-添加功能" class="headerlink" title="F-2.添加功能"></a>F-2.添加功能</h5><p>​        添加功能用于收集数据的表单是通过一个弹窗展示的，因此在添加操作前首先要进行弹窗的展示，添加后隐藏弹窗即可。因为这个弹窗一直存在，因此当页面加载时首先设置这个弹窗为不可显示状态，需要展示，切换状态即可。</p>
<p>​        <strong>默认状态</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">data</span>:&#123;</span><br><span class="line">	<span class="attr">dialogFormVisible</span>: <span class="literal">false</span>,	<span class="comment">//添加表单是否可见</span></span><br><span class="line">	...</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>​        <strong>切换为显示状态</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//弹出添加窗口</span></span><br><span class="line"><span class="title function_">handleCreate</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">dialogFormVisible</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>​        由于每次添加数据都是使用同一个弹窗录入数据，所以每次操作的痕迹将在下一次操作时展示出来，需要在每次操作之前清理掉上次操作的痕迹。</p>
<p>​        <strong>定义清理数据操作</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//重置表单</span></span><br><span class="line"><span class="title function_">resetForm</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">formData</span> = &#123;&#125;;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>​        <strong>切换弹窗状态时清理数据</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//弹出添加窗口</span></span><br><span class="line"><span class="title function_">handleCreate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">dialogFormVisible</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">resetForm</span>();</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>​        至此准备工作完成，下面就要调用后台完成添加操作了。</p>
<p>​        <strong>添加操作</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加</span></span><br><span class="line">handleAdd () &#123;</span><br><span class="line">    <span class="comment">//发送异步请求</span></span><br><span class="line">    axios.<span class="title function_">post</span>(<span class="string">&quot;/books&quot;</span>,<span class="variable language_">this</span>.<span class="property">formData</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//如果操作成功，关闭弹层，显示数据</span></span><br><span class="line">        <span class="keyword">if</span>(res.<span class="property">data</span>.<span class="property">flag</span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">dialogFormVisible</span> = <span class="literal">false</span>;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">success</span>(<span class="string">&quot;添加成功&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(<span class="string">&quot;添加失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).<span class="title function_">finally</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">getAll</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ol>
<li>将要保存的数据传递到后台，通过post请求的第二个参数传递json数据到后台</li>
<li>根据返回的操作结果决定下一步操作<ul>
<li>如何是true就关闭添加窗口，显示添加成功的消息</li>
<li>如果是false保留添加窗口，显示添加失败的消息</li>
</ul>
</li>
<li>无论添加是否成功，页面均进行刷新，动态加载数据（对getAll操作发起调用）</li>
</ol>
<p>​        <strong>取消添加操作</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取消</span></span><br><span class="line"><span class="title function_">cancel</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">dialogFormVisible</span> = <span class="literal">false</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">info</span>(<span class="string">&quot;操作取消&quot;</span>);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ol>
<li>请求方式使用POST调用后台对应操作</li>
<li>添加操作结束后动态刷新页面加载数据</li>
<li>根据操作结果不同，显示对应的提示信息</li>
<li>弹出添加Div时清除表单数据</li>
</ol>
<h5 id="F-3-删除功能"><a href="#F-3-删除功能" class="headerlink" title="F-3.删除功能"></a>F-3.删除功能</h5><p>​        模仿添加操作制作删除功能，差别之处在于删除操作仅传递一个待删除的数据id到后台即可。</p>
<p>​        <strong>删除操作</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="title function_">handleDelete</span>(<span class="params">row</span>) &#123;</span><br><span class="line">    axios.<span class="title function_">delete</span>(<span class="string">&quot;/books/&quot;</span>+row.<span class="property">id</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(res.<span class="property">data</span>.<span class="property">flag</span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">success</span>(<span class="string">&quot;删除成功&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(<span class="string">&quot;删除失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).<span class="title function_">finally</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">getAll</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>​        <strong>删除操作提示信息</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="title function_">handleDelete</span>(<span class="params">row</span>) &#123;</span><br><span class="line">    <span class="comment">//1.弹出提示框</span></span><br><span class="line">    <span class="variable language_">this</span>.$confirm(<span class="string">&quot;此操作永久删除当前数据，是否继续？&quot;</span>,<span class="string">&quot;提示&quot;</span>,&#123;</span><br><span class="line">        <span class="attr">type</span>:<span class="string">&#x27;info&#x27;</span></span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//2.做删除业务</span></span><br><span class="line">        axios.<span class="title function_">delete</span>(<span class="string">&quot;/books/&quot;</span>+row.<span class="property">id</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">       		<span class="keyword">if</span>(res.<span class="property">data</span>.<span class="property">flag</span>)&#123;</span><br><span class="line">            	<span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">success</span>(<span class="string">&quot;删除成功&quot;</span>);</span><br><span class="line">        	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            	<span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(<span class="string">&quot;删除失败&quot;</span>);</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;).<span class="title function_">finally</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">getAll</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//3.取消删除</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">info</span>(<span class="string">&quot;取消删除操作&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;，	</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ol>
<li>请求方式使用Delete调用后台对应操作</li>
<li>删除操作需要传递当前行数据对应的id值到后台</li>
<li>删除操作结束后动态刷新页面加载数据</li>
<li>根据操作结果不同，显示对应的提示信息</li>
<li>删除操作前弹出提示框避免误操作</li>
</ol>
<h5 id="F-4-修改功能"><a href="#F-4-修改功能" class="headerlink" title="F-4.修改功能"></a>F-4.修改功能</h5><p>​        修改功能可以说是列表功能、删除功能与添加功能的合体。几个相似点如下：</p>
<ol>
<li><p>页面也需要有一个弹窗用来加载修改的数据，这一点与添加相同，都是要弹窗</p>
</li>
<li><p>弹出窗口中要加载待修改的数据，而数据需要通过查询得到，这一点与查询全部相同，都是要查数据</p>
</li>
<li><p>查询操作需要将要修改的数据id发送到后台，这一点与删除相同，都是传递id到后台</p>
</li>
<li><p>查询得到数据后需要展示到弹窗中，这一点与查询全部相同，都是要通过数据模型绑定展示数据</p>
</li>
<li><p>修改数据时需要将被修改的数据传递到后台，这一点与添加相同，都是要传递数据</p>
<p>所以整体上来看，修改功能就是前面几个功能的大合体</p>
<p><strong>查询并展示数据</strong></p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//弹出编辑窗口</span></span><br><span class="line"><span class="title function_">handleUpdate</span>(<span class="params">row</span>) &#123;</span><br><span class="line">    axios.<span class="title function_">get</span>(<span class="string">&quot;/books/&quot;</span>+row.<span class="property">id</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(res.<span class="property">data</span>.<span class="property">flag</span>)&#123;</span><br><span class="line">            <span class="comment">//展示弹层，加载数据</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">formData</span> = res.<span class="property">data</span>.<span class="property">data</span>;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">dialogFormVisible4Edit</span> = <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(<span class="string">&quot;数据同步失败，自动刷新&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>​        <strong>修改操作</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改</span></span><br><span class="line"><span class="title function_">handleEdit</span>(<span class="params"></span>) &#123;</span><br><span class="line">    axios.<span class="title function_">put</span>(<span class="string">&quot;/books&quot;</span>,<span class="variable language_">this</span>.<span class="property">formData</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//如果操作成功，关闭弹层并刷新页面</span></span><br><span class="line">        <span class="keyword">if</span>(res.<span class="property">data</span>.<span class="property">flag</span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">dialogFormVisible4Edit</span> = <span class="literal">false</span>;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">success</span>(<span class="string">&quot;修改成功&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(<span class="string">&quot;修改失败，请重试&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).<span class="title function_">finally</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">getAll</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ol>
<li>加载要修改数据通过传递当前行数据对应的id值到后台查询数据（同删除与查询全部）</li>
<li>利用前端双向数据绑定将查询到的数据进行回显（同查询全部）</li>
<li>请求方式使用PUT调用后台对应操作（同新增传递数据）</li>
<li>修改操作结束后动态刷新页面加载数据（同新增）</li>
<li>根据操作结果不同，显示对应的提示信息（同新增）</li>
</ol>
<p>​    </p>
<h3 id="业务消息一致性处理"><a href="#业务消息一致性处理" class="headerlink" title="业务消息一致性处理"></a>业务消息一致性处理</h3><p>​        目前的功能制作基本上达成了正常使用的情况，什么叫正常使用呢？也就是这个程序不出BUG，如果我们搞一个BUG出来，你会发现程序马上崩溃掉。比如后台手工抛出一个异常，看看前端接收到的数据什么样子。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2021-09-15T03:27:31.038+00:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">500</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Internal Server Error&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/books&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>​        面对这种情况，前端的同学又不会了，这又是什么格式？怎么和之前的格式不一样？</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;flag&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;计算机理论&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Spring实战 第5版&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Spring入门经典教程&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>​        看来不仅要对正确的操作数据格式做处理，还要对错误的操作数据格式做同样的格式处理。</p>
<p>​        首先在当前的数据结果中添加消息字段，用来兼容后台出现的操作消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">R</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Boolean flag;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">    <span class="keyword">private</span> String msg;		<span class="comment">//用于封装消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        后台代码也要根据情况做处理，当前是模拟的错误。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="keyword">public</span> R <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> Book book)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> bookService.insert(book);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">R</span>(flag , flag ? <span class="string">&quot;添加成功^_^&quot;</span> : <span class="string">&quot;添加失败-_-!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        然后在表现层做统一的异常处理，使用SpringMVC提供的异常处理器做统一的异常处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectExceptionAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">doOtherException</span><span class="params">(Exception ex)</span>&#123;</span><br><span class="line">        <span class="comment">//记录日志</span></span><br><span class="line">        <span class="comment">//发送消息给运维</span></span><br><span class="line">        <span class="comment">//发送邮件给开发人员,ex对象发送给开发人员</span></span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">R</span>(<span class="literal">false</span>,<span class="literal">null</span>,<span class="string">&quot;系统错误，请稍后再试！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        页面上得到数据后，先判定是否有后台传递过来的消息，标志就是当前操作是否成功，如果返回操作结果false，就读取后台传递的消息。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加</span></span><br><span class="line">handleAdd () &#123;</span><br><span class="line">	<span class="comment">//发送ajax请求</span></span><br><span class="line">    axios.<span class="title function_">post</span>(<span class="string">&quot;/books&quot;</span>,<span class="variable language_">this</span>.<span class="property">formData</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//如果操作成功，关闭弹层，显示数据</span></span><br><span class="line">        <span class="keyword">if</span>(res.<span class="property">data</span>.<span class="property">flag</span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">dialogFormVisible</span> = <span class="literal">false</span>;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">success</span>(<span class="string">&quot;添加成功&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(res.<span class="property">data</span>.<span class="property">msg</span>);			<span class="comment">//消息来自于后台传递过来，而非固定内容</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).<span class="title function_">finally</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">getAll</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ol>
<li>使用注解@RestControllerAdvice定义SpringMVC异常处理器用来处理异常的</li>
<li>异常处理器必须被扫描加载，否则无法生效</li>
<li>表现层返回结果的模型类中添加消息属性用来传递消息到页面</li>
</ol>
<p>​    </p>
<h3 id="页面功能开发"><a href="#页面功能开发" class="headerlink" title="页面功能开发"></a>页面功能开发</h3><h5 id="F-5-分页功能"><a href="#F-5-分页功能" class="headerlink" title="F-5.分页功能"></a>F-5.分页功能</h5><p>​        分页功能的制作用于替换前面的查询全部，其中要使用到elementUI提供的分页组件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!--分页组件--&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;pagination-container&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">el-pagination</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">		<span class="attr">class</span>=<span class="string">&quot;pagiantion&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">		@<span class="attr">current-change</span>=<span class="string">&quot;handleCurrentChange&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">		<span class="attr">:current-page</span>=<span class="string">&quot;pagination.currentPage&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">		<span class="attr">:page-size</span>=<span class="string">&quot;pagination.pageSize&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">		<span class="attr">layout</span>=<span class="string">&quot;total, prev, pager, next, jumper&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">		<span class="attr">:total</span>=<span class="string">&quot;pagination.total&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">el-pagination</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>​        为了配合分页组件，封装分页对应的数据模型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">data</span>:&#123;</span><br><span class="line">	<span class="attr">pagination</span>: &#123;	</span><br><span class="line">		<span class="comment">//分页相关模型数据</span></span><br><span class="line">		<span class="attr">currentPage</span>: <span class="number">1</span>,	<span class="comment">//当前页码</span></span><br><span class="line">		<span class="attr">pageSize</span>:<span class="number">10</span>,	<span class="comment">//每页显示的记录数</span></span><br><span class="line">		<span class="attr">total</span>:<span class="number">0</span>,		<span class="comment">//总记录数</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>​        修改查询全部功能为分页查询，通过路径变量传递页码信息参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getAll</span>(<span class="params"></span>) &#123;</span><br><span class="line">    axios.<span class="title function_">get</span>(<span class="string">&quot;/books/&quot;</span>+<span class="variable language_">this</span>.<span class="property">pagination</span>.<span class="property">currentPage</span>+<span class="string">&quot;/&quot;</span>+<span class="variable language_">this</span>.<span class="property">pagination</span>.<span class="property">pageSize</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>​        后台提供对应的分页功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/&#123;currentPage&#125;/&#123;pageSize&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R <span class="title function_">getAll</span><span class="params">(<span class="meta">@PathVariable</span> Integer currentPage,<span class="meta">@PathVariable</span> Integer pageSize)</span>&#123;</span><br><span class="line">    IPage&lt;Book&gt; pageBook = bookService.getPage(currentPage, pageSize);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">R</span>(<span class="literal">null</span> != pageBook ,pageBook);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        页面根据分页操作结果读取对应数据，并进行数据模型绑定。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getAll</span>(<span class="params"></span>) &#123;</span><br><span class="line">    axios.<span class="title function_">get</span>(<span class="string">&quot;/books/&quot;</span>+<span class="variable language_">this</span>.<span class="property">pagination</span>.<span class="property">currentPage</span>+<span class="string">&quot;/&quot;</span>+<span class="variable language_">this</span>.<span class="property">pagination</span>.<span class="property">pageSize</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">pagination</span>.<span class="property">total</span> = res.<span class="property">data</span>.<span class="property">data</span>.<span class="property">total</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">pagination</span>.<span class="property">currentPage</span> = res.<span class="property">data</span>.<span class="property">data</span>.<span class="property">current</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">pagination</span>.<span class="property">pagesize</span> = res.<span class="property">data</span>.<span class="property">data</span>.<span class="property">size</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">dataList</span> = res.<span class="property">data</span>.<span class="property">data</span>.<span class="property">records</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>​        对切换页码操作设置调用当前分页操作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//切换页码</span></span><br><span class="line"><span class="title function_">handleCurrentChange</span>(<span class="params">currentPage</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">pagination</span>.<span class="property">currentPage</span> = currentPage;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">getAll</span>();</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ol>
<li>使用el分页组件</li>
<li>定义分页组件绑定的数据模型</li>
<li>异步调用获取分页数据</li>
<li>分页数据页面回显</li>
</ol>
<h5 id="F-6-删除功能维护"><a href="#F-6-删除功能维护" class="headerlink" title="F-6.删除功能维护"></a>F-6.删除功能维护</h5><p>​        由于使用了分页功能，当最后一页只有一条数据时，删除操作就会出现BUG，最后一页无数据但是独立展示，对分页查询功能进行后台功能维护，如果当前页码值大于最大页码值，重新执行查询。其实这个问题解决方案很多，这里给出比较简单的一种处理方案。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;&#123;currentPage&#125;/&#123;pageSize&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R <span class="title function_">getPage</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> currentPage,<span class="meta">@PathVariable</span> <span class="type">int</span> pageSize)</span>&#123;</span><br><span class="line">    IPage&lt;Book&gt; page = bookService.getPage(currentPage, pageSize);</span><br><span class="line">    <span class="comment">//如果当前页码值大于了总页码值，那么重新执行查询操作，使用最大页码值作为当前页码值</span></span><br><span class="line">    <span class="keyword">if</span>( currentPage &gt; page.getPages())&#123;</span><br><span class="line">        page = bookService.getPage((<span class="type">int</span>)page.getPages(), pageSize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">R</span>(<span class="literal">true</span>, page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="F-7-条件查询功能"><a href="#F-7-条件查询功能" class="headerlink" title="F-7.条件查询功能"></a>F-7.条件查询功能</h5><p>​        最后一个功能来做条件查询，其实条件查询可以理解为分页查询的时候除了携带分页数据再多带几个数据的查询。这些多带的数据就是查询条件。比较一下不带条件的分页查询与带条件的分页查询差别之处，这个功能就好做了</p>
<ul>
<li><p>页面封装的数据：带不带条件影响的仅仅是一次性传递到后台的数据总量，由传递2个分页相关数据转换成2个分页数据加若干个条件</p>
</li>
<li><p>后台查询功能：查询时由不带条件，转换成带条件，反正不带条件的时候查询条件对象使用的是null，现在换成具体条件，差别不大</p>
</li>
<li><p>查询结果：不管带不带条件，出来的数据只是有数量上的差别，其他都差别，这个可以忽略</p>
<p>经过上述分析，看来需要在页面发送请求的格式方面做一定的修改，后台的调用数据层操作时发送修改，其他没有区别。</p>
<p>页面发送请求时，两个分页数据仍然使用路径变量，其他条件采用动态拼装url参数的形式传递。</p>
<p><strong>页面封装查询条件字段</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pagination: &#123;		</span><br><span class="line">//分页相关模型数据</span><br><span class="line">	currentPage: 1,		//当前页码</span><br><span class="line">	pageSize:10,		//每页显示的记录数</span><br><span class="line">	total:0,			//总记录数</span><br><span class="line">	name: &quot;&quot;,</span><br><span class="line">	type: &quot;&quot;,</span><br><span class="line">	description: &quot;&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>页面添加查询条件字段对应的数据模型绑定名称</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;filter-container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">placeholder</span>=<span class="string">&quot;图书类别&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;pagination.type&quot;</span> <span class="attr">class</span>=<span class="string">&quot;filter-item&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">placeholder</span>=<span class="string">&quot;图书名称&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;pagination.name&quot;</span> <span class="attr">class</span>=<span class="string">&quot;filter-item&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">placeholder</span>=<span class="string">&quot;图书描述&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;pagination.description&quot;</span> <span class="attr">class</span>=<span class="string">&quot;filter-item&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">&quot;getAll()&quot;</span> <span class="attr">class</span>=<span class="string">&quot;dalfBut&quot;</span>&gt;</span>查询<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> <span class="attr">class</span>=<span class="string">&quot;butT&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;handleCreate()&quot;</span>&gt;</span>新建<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>将查询条件组织成url参数，添加到请求url地址中，这里可以借助其他类库快速开发，当前使用手工形式拼接，降低学习要求</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getAll</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//1.获取查询条件,拼接查询条件</span></span><br><span class="line">    param = <span class="string">&quot;?name=&quot;</span>+<span class="variable language_">this</span>.<span class="property">pagination</span>.<span class="property">name</span>;</span><br><span class="line">    param += <span class="string">&quot;&amp;type=&quot;</span>+<span class="variable language_">this</span>.<span class="property">pagination</span>.<span class="property">type</span>;</span><br><span class="line">    param += <span class="string">&quot;&amp;description=&quot;</span>+<span class="variable language_">this</span>.<span class="property">pagination</span>.<span class="property">description</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;-----------------&quot;</span>+ param);</span><br><span class="line">    axios.<span class="title function_">get</span>(<span class="string">&quot;/books/&quot;</span>+<span class="variable language_">this</span>.<span class="property">pagination</span>.<span class="property">currentPage</span>+<span class="string">&quot;/&quot;</span>+<span class="variable language_">this</span>.<span class="property">pagination</span>.<span class="property">pageSize</span>+param).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">dataList</span> = res.<span class="property">data</span>.<span class="property">data</span>.<span class="property">records</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>后台代码中定义实体类封查询条件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;&#123;currentPage&#125;/&#123;pageSize&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R <span class="title function_">getAll</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> currentPage,<span class="meta">@PathVariable</span> <span class="type">int</span> pageSize,Book book)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;参数=====&gt;&quot;</span>+book);</span><br><span class="line">    IPage&lt;Book&gt; pageBook = bookService.getPage(currentPage,pageSize);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">R</span>(<span class="literal">null</span> != pageBook ,pageBook);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应业务层接口与实现类进行修正</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IBookService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;Book&gt; &#123;</span><br><span class="line">    IPage&lt;Book&gt; <span class="title function_">getPage</span><span class="params">(Integer currentPage,Integer pageSize,Book queryBook)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl2</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;BookDao,Book&gt; <span class="keyword">implements</span> <span class="title class_">IBookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> IPage&lt;Book&gt; <span class="title function_">getPage</span><span class="params">(Integer currentPage,Integer pageSize,Book queryBook)</span>&#123;</span><br><span class="line">        <span class="type">IPage</span> <span class="variable">page</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Page</span>(currentPage,pageSize);</span><br><span class="line">        LambdaQueryWrapper&lt;Book&gt; lqw = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;Book&gt;();</span><br><span class="line">        lqw.like(Strings.isNotEmpty(queryBook.getName()),Book::getName,queryBook.getName());</span><br><span class="line">        lqw.like(Strings.isNotEmpty(queryBook.getType()),Book::getType,queryBook.getType());</span><br><span class="line">        lqw.like(Strings.isNotEmpty(queryBook.getDescription()),Book::getDescription,queryBook.getDescription());</span><br><span class="line">        <span class="keyword">return</span> bookDao.selectPage(page,lqw);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>页面回显数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getAll</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//1.获取查询条件,拼接查询条件</span></span><br><span class="line">    param = <span class="string">&quot;?name=&quot;</span>+<span class="variable language_">this</span>.<span class="property">pagination</span>.<span class="property">name</span>;</span><br><span class="line">    param += <span class="string">&quot;&amp;type=&quot;</span>+<span class="variable language_">this</span>.<span class="property">pagination</span>.<span class="property">type</span>;</span><br><span class="line">    param += <span class="string">&quot;&amp;description=&quot;</span>+<span class="variable language_">this</span>.<span class="property">pagination</span>.<span class="property">description</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;-----------------&quot;</span>+ param);</span><br><span class="line">    axios.<span class="title function_">get</span>(<span class="string">&quot;/books/&quot;</span>+<span class="variable language_">this</span>.<span class="property">pagination</span>.<span class="property">currentPage</span>+<span class="string">&quot;/&quot;</span>+<span class="variable language_">this</span>.<span class="property">pagination</span>.<span class="property">pageSize</span>+param).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">pagination</span>.<span class="property">total</span> = res.<span class="property">data</span>.<span class="property">data</span>.<span class="property">total</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">pagination</span>.<span class="property">currentPage</span> = res.<span class="property">data</span>.<span class="property">data</span>.<span class="property">current</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">pagination</span>.<span class="property">pagesize</span> = res.<span class="property">data</span>.<span class="property">data</span>.<span class="property">size</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">dataList</span> = res.<span class="property">data</span>.<span class="property">data</span>.<span class="property">records</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>总结</strong></p>
<ol>
<li>定义查询条件数据模型（当前封装到分页数据模型中）</li>
<li>异步调用分页功能并通过请求参数传递数据到后台</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot03 —— 第三方技术整合</title>
    <url>/2022/04/21/SpringBoot03/</url>
    <content><![CDATA[<p>概述：SpringBoot整合JUnit，MyBatis，MyBatis-Plus，Druid</p>
<p>SpringBoot之所以好用，就是它能方便快捷的整合其他技术</p>
<span id="more"></span>

<h3 id="整合JUnit"><a href="#整合JUnit" class="headerlink" title="整合JUnit"></a>整合JUnit</h3><p>SpringBoot技术的定位用于简化开发，再具体点是简化Spring程序的开发。</p>
<p>使用SpringBoot整合JUnit需要保障导入test对应的starter，初始化项目时此项是默认导入的，导入了<code>spring-boot-starter-test</code>。</p>
<p>先看一下不使用SpringBoot技术时，Spring整合JUnit的制作方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加载spring整合junit专用的类运行器</span></span><br><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="comment">//指定对应的配置信息</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = SpringConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceTestCase</span> &#123;</span><br><span class="line">    <span class="comment">//注入你要测试的对象</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountService accountService;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetById</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//执行要测试的对象对应的方法</span></span><br><span class="line">        System.out.println(accountService.findById(<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中核心代码是前两个注解：</p>
<p>第一个注解<code>@RunWith</code>是设置Spring专用的测试类运行器，简单说就是Spring程序执行程序有自己的一套独立的运行程序的方式，不能使用JUnit提供的类运行方式了，必须指定一下，但是格式是固定的</p>
<p>第二个注解<code>@ContextConfiguration</code>是用来设置Spring核心配置文件或配置类的，简单说就是加载Spring的环境你要告诉Spring具体的环境配置是在哪里写的，虽然每次加载的文件都有可能不同，但是如果文件名是固定的，这个也是一个固定格式。</p>
<p>SpringBoot就抓住上述两条内容书写进行开发简化，能走默认值的走默认值，能不写的就不写，具体格式如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Springboot04JunitApplicationTests</span> &#123;</span><br><span class="line">    <span class="comment">//注入你要测试的对象</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//执行要测试的对象对应的方法</span></span><br><span class="line">        bookDao.save();</span><br><span class="line">        System.out.println(<span class="string">&quot;two...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用一个注解<code>@SpringBootTest</code>替换了前面两个注解。</p>
<p>那么加载的配置类或者配置文件是哪一个？其实就是我们前面启动程序使用的引导类。</p>
<p>如果想手工指定引导类有两种方式，第一种方式使用属性的形式进行，在注解<code>@SpringBootTest</code>中添加classes属性指定配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest(classes = Springboot04JunitApplication.class)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Springboot04JunitApplicationTests</span> &#123;</span><br><span class="line">    <span class="comment">//注入你要测试的对象</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//执行要测试的对象对应的方法</span></span><br><span class="line">        bookDao.save();</span><br><span class="line">        System.out.println(<span class="string">&quot;two...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种方式回归原始配置方式，仍然使用<code>@ContextConfiguration</code>注解进行，效果是一样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = Springboot04JunitApplication.class)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Springboot04JunitApplicationTests</span> &#123;</span><br><span class="line">    <span class="comment">//注入你要测试的对象</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//执行要测试的对象对应的方法</span></span><br><span class="line">        bookDao.save();</span><br><span class="line">        System.out.println(<span class="string">&quot;two...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用SpringBoot整合JUnit需要保障导入test对应的starter，由于初始化项目时此项是默认导入的，所以此处没有提及，其实和之前学习的内容一样，用什么技术导入对应的starter即可。</p>
<p><strong>总结</strong></p>
<ol>
<li>导入测试对应的starter</li>
<li>测试类使用@SpringBootTest修饰</li>
<li>使用自动装配的形式添加要测试的对象</li>
<li>测试类如果存在于引导类所在包或子包中无需指定引导类</li>
<li>测试类如果不存在于引导类所在的包或子包中需要通过classes属性指定引导类</li>
</ol>
<h3 id="整合MyBatis"><a href="#整合MyBatis" class="headerlink" title="整合MyBatis"></a>整合MyBatis</h3><h4 id="原始整合方式"><a href="#原始整合方式" class="headerlink" title="原始整合方式"></a>原始整合方式</h4><p>以配置类的形式为例</p>
<ul>
<li><p>导入坐标，MyBatis坐标不能少，Spring整合MyBatis还有自己专用的坐标，此外Spring进行数据库操作的jdbc坐标是必须的，剩下还有mysql驱动坐标，本例中使用了Druid数据源，这个倒是可以不要</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--1.导入mybatis与spring整合的jar包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--导入spring操作数据库必选的包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Spring核心配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>MyBatis要交给Spring接管的bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义mybatis专用的配置类</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisConfig</span> &#123;</span><br><span class="line"><span class="comment">//    定义创建SqlSessionFactory对应的bean</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactoryBean <span class="title function_">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="comment">//SqlSessionFactoryBean是由mybatis-spring包提供的，专用于整合用的对象</span></span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">sfb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        <span class="comment">//设置数据源替代原始配置中的environments的配置</span></span><br><span class="line">        sfb.setDataSource(dataSource);</span><br><span class="line">        <span class="comment">//设置类型别名替代原始配置中的typeAliases的配置</span></span><br><span class="line">        sfb.setTypeAliasesPackage(<span class="string">&quot;com.itheima.domain&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sfb;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    定义加载所有的映射配置</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MapperScannerConfigurer <span class="title function_">mapperScannerConfigurer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MapperScannerConfigurer</span> <span class="variable">msc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapperScannerConfigurer</span>();</span><br><span class="line">        msc.setBasePackage(<span class="string">&quot;com.itheima.dao&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> msc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据源对应的bean，此处使用Druid数据源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;dataSource&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(driver);</span><br><span class="line">        ds.setUrl(url);</span><br><span class="line">        ds.setUsername(userName);</span><br><span class="line">        ds.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据库连接信息（properties格式）</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/spring_db?useSSL=false</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure>

<p>上述格式基本上是最简格式了</p>
</li>
</ul>
<h4 id="SpringBoot整合MyBaits格式"><a href="#SpringBoot整合MyBaits格式" class="headerlink" title="SpringBoot整合MyBaits格式"></a>SpringBoot整合MyBaits格式</h4><ul>
<li><p>创建模块</p>
</li>
<li><p>勾选要使用的技术，MyBatis，由于要操作数据库，还要勾选对应数据库</p>
</li>
<li><p>或者手工导入对应技术的starter，和对应数据库的坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--1.导入对应的starter--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置数据源相关信息，没有这个信息你连接哪个数据库都不知道</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#2.配置相关信息</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/test?serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>到这为止所有配置部分就结束了，写一个MyBatis程序运行需要的Dao（或者Mapper）就可以运行了</p>
</li>
</ul>
<p><strong>实体类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>映射接口（Dao）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from tbl_book where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Book <span class="title function_">getById</span><span class="params">(Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Springboot05MybatisApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(bookDao.getById(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color="#ff0000"><b>注意</b></font>：当前使用的SpringBoot版本是2.5.4，对应的坐标设置中Mysql驱动使用的是8x版本。<strong>使用SpringBoot2.4.3（不含）之前版本会出现一个BUG</strong>，就是MySQL驱动升级到8以后要求强制配置时区，如果不设置会出问题。解决方案很简单，驱动url上面添加上对应设置就行了</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#2.配置相关信息</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/test?serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p>这里设置的UTC是全球标准时间，也可以理解为是英国时间，中国处在东八区，需要在这个基础上加上8小时，这样才能和中国地区的时间对应的，也可以修改配置为Asia&#x2F;Shanghai，同样可以解决这个问题。</p>
<p>此外在运行程序时还会给出一个提示，说数据库驱动过时的警告，根据提示修改配置即可，弃用<strong>com.mysql.jdbc.Driver</strong>，换用<font color="#ff0000"><b>com.mysql.cj.jdbc.Driver</b></font>。前面的例子中已经更换了驱动了，在此说明一下。</p>
<h3 id="整合MyBatis-Plus"><a href="#整合MyBatis-Plus" class="headerlink" title="整合MyBatis-Plus"></a>整合MyBatis-Plus</h3><p>MyBaitsPlus（简称MP），国人开发的技术，符合中国人开发习惯。不能在创建项目时通过勾选的形式找到这个名字，因为SpringBoot官网还未收录此坐标。</p>
<p><strong>导入对应的starter</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>关于这个坐标，此处要说明一点，之前使用的starter都是下面的格式</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Spring-boot-start-***</span><br></pre></td></tr></table></figure>

<p>而MyBatis与MyBatisPlus这两个坐标的名字书写比较特殊，是第三方技术名称在前，boot和starter在后</p>
<p><strong>配置数据源相关信息</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#2.配置相关信息</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/test?serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 一系列配置：如关闭驼峰式命名转换，防止将列名自动从roleName转换为role_name</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>剩下的就是写MyBaitsPlus的程序：</p>
<p><strong>映射接口（Dao）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Book&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>核心在于Dao接口继承了一个BaseMapper的接口，这个接口中帮助开发者预定了若干个常用的API接口，简化了通用API接口的开发工作</strong>。</p>
<img src="https://pic.imgdb.cn/item/62610ce2239250f7c5f88efa.jpg" style="zoom:80%;" />

<p>下面就可以写一个测试类进行测试了，此处省略</p>
<h3 id="整合Druid"><a href="#整合Druid" class="headerlink" title="整合Druid"></a>整合Druid</h3><p>前面整合MyBatis和MyBatisPlus的时候，使用的数据源对象都是SpringBoot默认的数据源对象。通过启动日志我们可以知道是HiKari：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">2022-04-21 16:46:36.790  INFO 23160 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...</span><br><span class="line">2022-04-21 16:46:37.408  INFO 23160 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.</span><br></pre></td></tr></table></figure>

<p>如果需要更换数据源为Druid：</p>
<ul>
<li><p>导入Druid对应的starter</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/test?serverTimezone=UTC</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p>注意，配置项中，在datasource下面并不是直接配置url这些属性的，而是先配置了一个druid节点，然后再配置的url这些东西。</p>
<p>言外之意，url这个属性是druid下面的属性。其实除了这4个常规配置外，还有druid专用的其他配置。通过提示功能可以打开druid相关的配置查阅</p>
<img src="https://pic.imgdb.cn/item/62611b7f239250f7c51ba0a3.jpg" style="zoom:80%;" /></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot02 —— 基础配置</title>
    <url>/2022/04/20/SpringBoot02/</url>
    <content><![CDATA[<p>概述：SpringBoot的基础配置，包括属性配置，配置文件分类，yaml文件，yaml数据读取</p>
<span id="more"></span>

<h3 id="复制工程"><a href="#复制工程" class="headerlink" title="复制工程"></a>复制工程</h3><p><strong>原则</strong></p>
<ul>
<li><p>保留工程基础结构</p>
</li>
<li><p>抹掉原始工程痕迹</p>
</li>
</ul>
<p><strong>步骤</strong></p>
<ul>
<li><p>在工作空间中复制对应工程，并修改工程名称</p>
</li>
<li><p>删除与Idea相关配置文件，<strong>仅保留src目录与pom.xml文件</strong></p>
</li>
<li><p>修改pom.xml文件中的artifactId与新工程&#x2F;模块名相同（务必注意！）</p>
</li>
<li><p>删除name标签（可选）</p>
</li>
<li><p>保留备份工程供后期使用</p>
</li>
</ul>
<h3 id="属性配置"><a href="#属性配置" class="headerlink" title="属性配置"></a>属性配置</h3><p><strong>SpringBoot通过配置文件application.properties就可以修改默认的配置</strong></p>
<p><strong>服务器端口配置</strong></p>
<p>当前访问tomcat的默认端口是8080，尝试改成80：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 服务器端口配置</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">80</span></span><br></pre></td></tr></table></figure>

<p>注意要实现查看端口是否占用</p>
<p><strong>关闭运行日志图标（banner）</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改banner</span></span><br><span class="line"><span class="attr">spring.main.banner-mode</span>=<span class="string">off</span></span><br><span class="line"><span class="comment"># spring.banner.image.location=logo.png</span></span><br></pre></td></tr></table></figure>

<p><strong>设置日志相关</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 日志debug info error</span></span><br><span class="line"><span class="attr">logging.level.root</span>=<span class="string">info</span></span><br><span class="line"><span class="comment"># logging.level.com.itheima=warn</span></span><br></pre></td></tr></table></figure>



<p><strong>SpringBoot内置属性查询</strong></p>
<p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#application-properties">官方文档</a></p>
<p>官方文档中参考文档第一项：Application Properties</p>
<p><strong>总结</strong></p>
<ul>
<li><p>SpringBoot中导入对应starter后，提供对应配置属性</p>
</li>
<li><p>书写SpringBoot配置采用关键字+提示形式书写</p>
</li>
</ul>
<h3 id="配置文件分类"><a href="#配置文件分类" class="headerlink" title="配置文件分类"></a>配置文件分类</h3><p>SpringBoot除了支持properties格式的配置文件，还支持另外两种格式的配置文件。三种配置文件格式分别如下:</p>
<ul>
<li>properties格式（传统格式&#x2F;默认格式）</li>
<li>yml格式（主流格式）</li>
<li>yaml格式</li>
</ul>
<p>下面列举三种不同文件格式配置相同的属性范例：</p>
<ul>
<li>application.properties（properties格式）</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">80</span></span><br></pre></td></tr></table></figure>

<ul>
<li>application.yml（yml格式）</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">81</span></span><br></pre></td></tr></table></figure>

<ul>
<li>application.yaml（yaml格式）</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">82</span></span><br></pre></td></tr></table></figure>

<p>yml格式和yaml格式除了文件名后缀不一样，格式完全一样，所以可以合并成一种格式来看。</p>
<p>对于这三种格式来说，yml格式在实际中用得比较多</p>
<p><strong>配置文件优先级</strong></p>
<p>3种类型的文件如果同时存在，那么加载优先顺序是：</p>
<p><code>.properties</code>  &gt;  <code>.yml</code>  &gt;  <code>.yaml</code></p>
<p>不同配置文件中相同配置按照加载优先级相互覆盖，不同配置文件中不同配置全部保留 </p>
<h3 id="yaml文件"><a href="#yaml文件" class="headerlink" title="yaml文件"></a>yaml文件</h3><p>YAML（YAML Ain’t Markup Language），一种数据序列化格式</p>
<p>优点：</p>
<ul>
<li>容易阅读</li>
<li>容易与脚本语言交互</li>
<li>以数据为核心，重数据轻格式</li>
</ul>
<p>YAML文件扩展名</p>
<ul>
<li><p><strong>.yml</strong>（主流）</p>
</li>
<li><p>.yaml</p>
</li>
</ul>
<p><strong>yaml语法规则</strong></p>
<ul>
<li>大小写敏感</li>
<li>属性不允许同名</li>
<li>属性层级关系使用多行描述，每行结尾使用冒号结束</li>
<li>使用缩进表示层级关系，同层级左侧对齐，<strong>只允许使用空格</strong>（不允许使用Tab键）</li>
<li>属性值前面添加空格（属性名与属性值之间使用冒号+空格作为分隔）</li>
<li># 表示注释</li>
<li>核心规则：<strong>数据前面要加空格与冒号隔开</strong></li>
</ul>
<p>示例：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">boolean:</span> <span class="literal">TRUE</span>  						<span class="comment">#TRUE,true,True,FALSE,false，False均可</span></span><br><span class="line"><span class="attr">float:</span> <span class="number">3.14</span>    						<span class="comment">#6.8523015e+5  #支持科学计数法</span></span><br><span class="line"><span class="attr">int:</span> <span class="number">123</span>       						<span class="comment">#0b1010_0111_0100_1010_1110    #支持二进制、八进制、十六进制</span></span><br><span class="line"><span class="attr">null:</span> <span class="string">~</span>        						<span class="comment">#使用~表示null</span></span><br><span class="line"><span class="attr">string:</span> <span class="string">HelloWorld</span>      			<span class="comment">#字符串可以直接书写</span></span><br><span class="line"><span class="attr">string2:</span> <span class="string">&quot;Hello World&quot;</span>  			<span class="comment">#可以使用双引号包裹特殊字符</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018-02-17</span>        			<span class="comment">#日期必须使用yyyy-MM-dd格式</span></span><br><span class="line"><span class="attr">datetime:</span> <span class="number">2018-02-17T15:02:31+08:00</span>  <span class="comment">#时间和日期之间使用T连接，最后使用+代表时区</span></span><br></pre></td></tr></table></figure>

<p>yaml格式中也可以表示数组，<strong>在属性名书写位置的下方使用减号作为数据开始符号</strong>，<strong>每行书写一个数据，减号与数据间空格分隔</strong>。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">subject:</span></span><br><span class="line">	<span class="bullet">-</span> <span class="string">Java</span></span><br><span class="line">	<span class="bullet">-</span> <span class="string">前端</span></span><br><span class="line">	<span class="bullet">-</span> <span class="string">大数据</span></span><br><span class="line"><span class="attr">enterprise:</span></span><br><span class="line">	<span class="attr">name:</span> <span class="string">itcast</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">16</span></span><br><span class="line">    <span class="attr">subject:</span></span><br><span class="line">    	<span class="bullet">-</span> <span class="string">Java</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">前端</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">大数据</span></span><br><span class="line"><span class="attr">likes:</span> [<span class="string">game</span>,<span class="string">study</span>]				  <span class="comment">#数组书写缩略格式</span></span><br><span class="line"><span class="attr">users:</span>							 <span class="comment">#对象数组格式一</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Tom</span></span><br><span class="line">   	<span class="attr">age:</span> <span class="number">4</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Jerry</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">users:</span>							 <span class="comment">#对象数组格式二</span></span><br><span class="line">  <span class="bullet">-</span>  </span><br><span class="line">    <span class="attr">name:</span> <span class="string">Tom</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">4</span></span><br><span class="line">  <span class="bullet">-</span>   </span><br><span class="line">    <span class="attr">name:</span> <span class="string">Jerry</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">5</span>			    </span><br><span class="line"><span class="attr">users2:</span> [ &#123; <span class="string">name:Tom</span> , <span class="string">age:4</span> &#125; , &#123; <span class="string">name:Jerry</span> , <span class="string">age:5</span> &#125; ]	<span class="comment">#对象数组缩略格式</span></span><br></pre></td></tr></table></figure>



<h3 id="yaml数据读取"><a href="#yaml数据读取" class="headerlink" title="yaml数据读取"></a>yaml数据读取</h3><p>对于yaml文件中的数据，其实可以想象成这就是一个小型的数据库，里面保存有若干数据，每个数据都有一个独立的名字</p>
<h4 id="读取单一数据"><a href="#读取单一数据" class="headerlink" title="读取单一数据"></a>读取单一数据</h4><p>yaml中保存的单个数据，可以使用Spring中的注解<code>@Value</code>读取单个数据，属性名引用方式：<code>$&#123;一级属性名.二级属性名……&#125;</code></p>
<img src="https://pic.imgdb.cn/item/62603d05239250f7c5d952c8.jpg" style="zoom:80%;" />

<h4 id="读取全部数据"><a href="#读取全部数据" class="headerlink" title="读取全部数据"></a>读取全部数据</h4><p>SpringBoot提供了一个对象，能够把所有的数据都封装到这一个对象中，这个对象叫Environment，使用自动装配注解可以将所有的yaml数据封装到这个对象中</p>
<img src="https://pic.imgdb.cn/item/62603df5239250f7c5dabfe4.jpg" style="zoom:80%;" />

<h4 id="读取对象数据"><a href="#读取对象数据" class="headerlink" title="读取对象数据"></a>读取对象数据</h4><p>由于Java是一个面向对象的语言，很多情况下，我们会将<strong>一组数据封装成一个对象</strong>。SpringBoot也提供了可以将一组yaml对象数据封装一个Java对象的操作</p>
<p>首先定义一个对象，并将该对象纳入Spring管控的范围，也就是定义成一个bean，然后使用注解<code>@ConfigurationProperties</code>指定该对象加载哪一组yaml中配置的信息。</p>
<img src="https://pic.imgdb.cn/item/62603ed0239250f7c5dc1248.jpg" style="zoom:80%;" />

<p>这个<code>@ConfigurationProperties</code>必须告诉他加载的数据前缀是什么，这样指定前缀下的所有属性就封装到这个对象中。注意数据属性名要与对象的变量名一一对应.</p>
<img src="https://pic.imgdb.cn/item/62604187239250f7c5dfc918.jpg" style="zoom:80%;" />

<ul>
<li>使用@ConfigurationProperties注解绑定配置信息到封装类中</li>
<li>封装类需要定义为Spring管理的bean（使用<code>@Component</code>），否则无法进行属性注入</li>
</ul>
<h4 id="yaml文件中的数据引用"><a href="#yaml文件中的数据引用" class="headerlink" title="yaml文件中的数据引用"></a>yaml文件中的数据引用</h4><p>如果在书写yaml数据时，经常出现如下现象，比如很多个文件都具有相同的目录前缀</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">center:</span></span><br><span class="line">	<span class="attr">dataDir:</span> <span class="string">D:/usr/local/fire/data</span></span><br><span class="line">    <span class="attr">tmpDir:</span> <span class="string">D:/usr/local/fire/tmp</span></span><br><span class="line">    <span class="attr">logDir:</span> <span class="string">D:/usr/local/fire/log</span></span><br><span class="line">    <span class="attr">msgDir:</span> <span class="string">D:/usr/local/fire/msgDir</span></span><br></pre></td></tr></table></figure>

<p>这个时候可以使用引用格式来定义数据，其实就是定义了一个变量名，然后引用变量，格式如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">baseDir:</span> <span class="string">/usr/local/fire</span></span><br><span class="line"><span class="attr">center:</span></span><br><span class="line">    <span class="attr">dataDir:</span> <span class="string">$&#123;baseDir&#125;/data</span></span><br><span class="line">    <span class="attr">tmpDir:</span> <span class="string">$&#123;baseDir&#125;/tmp</span></span><br><span class="line">    <span class="attr">logDir:</span> <span class="string">$&#123;baseDir&#125;/log</span></span><br><span class="line">    <span class="attr">msgDir:</span> <span class="string">$&#123;baseDir&#125;/msgDir</span></span><br></pre></td></tr></table></figure>

<p>还有一个注意事项，在书写字符串时，如果需要使用转义字符，需要<strong>将数据字符串使用双引号包裹起来</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">lesson:</span> <span class="string">&quot;Spring\tboot\nlesson&quot;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot01 —— 概览及Demo运行</title>
    <url>/2022/04/20/SpringBoot01/</url>
    <content><![CDATA[<p>概述：SpringBoot入门程序搭建和运行</p>
<span id="more"></span>

<h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>SpringBoot是由Pivotal团队提供的全新框架，其设计目的是用来简化Spring应用的初始搭建以及开发过程</p>
<p><strong>Spring程序缺点</strong></p>
<ul>
<li>依赖设置繁琐</li>
<li>配置繁琐</li>
</ul>
<p><strong>SpringBoot程序优点</strong></p>
<ul>
<li>起步依赖（简化依赖配置）</li>
<li>自动配置（简化常用工程相关配置）</li>
<li>辅助功能（内置服务器，……）</li>
</ul>
<h3 id="快速构建一个SpringMVC控制器程序"><a href="#快速构建一个SpringMVC控制器程序" class="headerlink" title="快速构建一个SpringMVC控制器程序"></a>快速构建一个SpringMVC控制器程序</h3><p><strong>IDEA新建项目</strong></p>
<p>查看版本：File -&gt; Settings -&gt; Maven 可以查看版本（我的版本为3.8.1）</p>
<p>File -&gt; Project Structure -&gt; Modules -&gt; ‘+’  -&gt;New Module -&gt; Spring Initializr (注意如果没有的话要去settings -&gt;plugins -&gt; marketplace 下搜索并下载)</p>
<p>进行如下配置</p>
<p><img src="https://pic.imgdb.cn/item/6245ff0427f86abb2a70bbd8.jpg" alt="image01"></p>
<p>SpringBoot程序中需要使用何种功能即勾选选择技术，目前选择spring web</p>
<p>基础的环境配置即完成了</p>
<p><strong>开发控制器类</strong></p>
<p>入门案例制作的SpringMVC的控制器基于Rest风格开发.</p>
<p>以下程序中的<code>@RestController</code>与<code>@GetMapping</code>注解是基于Restful开发的典型注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Rest模式</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/books&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getById</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;springboot is running...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;springboot is running...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用带main方法的java程序的运行形式来运行程序（运行SpringBoot程序通过运行Application程序入口进行）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Springboot0101QuickstartApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> SpringApplication.run(Springboot0101QuickstartApplication.class, args);</span><br><span class="line">        <span class="type">BookController</span> <span class="variable">bean</span> <span class="operator">=</span> ctx.getBean(BookController.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;bean======&gt;&quot;</span> + bean);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> ctx.getBean(User.class);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img src="https://pic.imgdb.cn/item/625ef571239250f7c5a4e46e.jpg"></p>
<p>Spring程序与SpringBoot程序对比：</p>
<img src="https://pic.imgdb.cn/item/625ef5ac239250f7c5a52ceb.jpg" style="zoom: 80%;" />

<p>注意基于IDEA开发SpringBoot程序需要确保联网并且能够加载到程序框架结构</p>
<p><strong>如果无法联网（外网连接慢）：</strong></p>
<ul>
<li><p>进入<a href="spring.io">Spring的官网</a>  </p>
</li>
<li><p>通过项目一级一级的找到SpringBoot技术的介绍页，然后在页面中间部位找到如下内容</p>
</li>
</ul>
<img src="https://pic.imgdb.cn/item/625ef76f239250f7c5a7ab22.jpg" style="zoom:67%;" />

<ul>
<li>点击<strong>Spring Initializr</strong>后进入到创建SpringBoot程序界面，接下来就是输入信息的过程，和在Idea中制作是一样的，只是界面发生了变化，根据自己的要求，在左侧选择对应信息和输入对应的信息。</li>
<li>右侧的<strong>ADD DEPENDENCIES</strong>用于选择使用何种技术，和之前勾选的Spring WEB是在做同一件事，仅仅是界面不同而已，点击后打开网页版的技术选择界面。</li>
<li>所有信息设置完毕后，点击下面左侧<strong>GENERATE</strong>按钮，生成一个文件包。</li>
<li>保存后得到一个压缩文件，这个文件就是创建的SpringBoot工程    </li>
<li>解压缩此文件得到工程目录，在Idea中导入即可直接使用，和之前在Idea环境下根据向导创建的工程完全一样</li>
</ul>
<p>实际上，Idea工具中创建SpringBoot工程其实连接的就是SpringBoot的官网，还句话说这种方式和第一种方式是一模一样的，只不过Idea把界面给整合了一下，读取Spring官网信息，然后展示到Idea界面中而已</p>
<p><strong>在Idea中隐藏指定文件&#x2F;文件夹</strong></p>
<p>Idea中隐藏指定文件或指定类型文件</p>
<ul>
<li>【Files】→【Settings】</li>
<li>【Editor】→【File Types】→【Ignored Files and Folders】</li>
<li>输入要隐藏的名称，支持*号通配符</li>
<li>回车确认添加</li>
</ul>
<h3 id="入门案例详解"><a href="#入门案例详解" class="headerlink" title="入门案例详解"></a>入门案例详解</h3><h4 id="parent"><a href="#parent" class="headerlink" title="parent"></a>parent</h4><img src="https://pic.imgdb.cn/item/625efd37239250f7c5af0b73.jpg" style="zoom:80%;" />

<ul>
<li>开发SpringBoot程序要继承spring-boot-starter-parent</li>
<li>spring-boot-starter-parent中定义了若干个依赖管理（继承于spring-boot-starter-parent）</li>
<li><strong>继承parent模块可以避免多个依赖使用相同技术时出现依赖版本冲突</strong></li>
<li>继承parent的形式也可以采用引入依赖的形式实现效果（aliyun版本的实现方式）</li>
</ul>
<h4 id="starter"><a href="#starter" class="headerlink" title="starter"></a>starter</h4><p>SpringBoot关注到实际开发时，开发者对于依赖坐标的使用往往都有一些固定的组合方式，比如使用spring-webmvc就一定要使用spring-web。每次都要固定搭配着写，非常繁琐，而且格式固定，没有任何技术含量。</p>
<p>SpringBoot把所有的技术使用的固定搭配格式都给开发出来，以后使用某个技术，就不用每次写一堆依赖了，我给你做一个东西，代表一堆东西，开发者使用的时候，直接用做好的这个东西就好了，对于这样的固定技术搭配，SpringBoot给它起了个名字叫做<font color="#ff0000"><b>starter</b></font>。</p>
<p>starter定义了使用某种技术时对于依赖的固定搭配格式，也是一种最佳解决方案，<font color="#ff0000"><b>使用starter可以帮助开发者减少依赖配置</b></font>。</p>
<p><strong>实际开发</strong></p>
<ul>
<li><p>使用任意坐标时，仅书写GAV中的G和A，V由SpringBoot提供，除非SpringBoot未提供对应版本V </p>
</li>
<li><p>如发生坐标错误，再指定Version（要小心版本冲突）</p>
</li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li><p>开发SpringBoot程序需要导入坐标时通常导入对应的starter</p>
</li>
<li><p>每个不同的starter根据功能不同，通常包含多个依赖坐标</p>
</li>
<li><p>使用starter可以实现快速配置的效果，达到简化配置的目的</p>
</li>
</ul>
<h4 id="引导类"><a href="#引导类" class="headerlink" title="引导类"></a>引导类</h4><p>其实SpringBoot程序启动还是创建了一个Spring容器对象。当前运行的这个类在SpringBoot程序中是所有功能的入口，称为<font color="#ff0000"><b>引导类</b></font>。</p>
<p>作为一个引导类最典型的特征就是当前类上方声明了一个注解<font color="#ff0000"><b>@SpringBootApplication</b></font>。</p>
<p>启动方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Springboot0101QuickstartApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> SpringApplication.run(Springboot0101QuickstartApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>ingBoot的引导类是Boot工程的执行入口，运行main方法就可以启动项目</p>
</li>
<li><p>SpringBoot工程运行后初始化Spring容器，扫描引导类所在包加载bean</p>
</li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li>SpringBoot工程提供引导类用来启动程序</li>
<li>SpringBoot工程启动后创建并初始化Spring容器</li>
</ul>
<h4 id="内嵌tomcat"><a href="#内嵌tomcat" class="headerlink" title="内嵌tomcat"></a>内嵌tomcat</h4><p>当前我们做的SpringBoot入门案例勾选了Spring-web的功能，并且导入了对应的starter。</p>
<p><strong>更换内嵌Tomcat</strong></p>
<p>SpringBoot提供了3款内置的服务器：</p>
<ul>
<li><p>tomcat(默认) ：apache出品，粉丝多，应用面广，负载了若干较重的组件</p>
</li>
<li><p>jetty：更轻量级，负载性能远不及tomcat</p>
</li>
<li><p>undertow：undertow，负载性能勉强跑赢tomcat</p>
</li>
</ul>
<p>想用哪个，加个坐标就行。前提是把tomcat排除掉，因为tomcat是默认加载的</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>现在就已经成功替换了web服务器，核心思想就是用什么加入对应坐标就可以了。如果有starter，优先使用starter。</p>
<p><strong>总结</strong></p>
<ul>
<li><p>内嵌Tomcat服务器是SpringBoot辅助功能之一</p>
</li>
<li><p>内嵌Tomcat工作原理是将Tomcat服务器作为对象运行，并将该对象交给Spring容器管理</p>
</li>
<li><p>变更内嵌服务器思想是去除现有服务器，添加全新的服务器</p>
</li>
</ul>
<h3 id="学习链接"><a href="#学习链接" class="headerlink" title="学习链接"></a>学习链接</h3><ol>
<li><a href="https://docs.spring.io/spring-boot/docs/3.0.0-M1/reference/htmlsingle/"><em>SpringBoot reference documentation</em></a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM08 —— SSM整合</title>
    <url>/2022/04/19/SSM08/</url>
    <content><![CDATA[<p>本文记录了SSM框架的原始整合方式，mybatis整合spring，声明式事务控制实现</p>
<span id="more"></span>

<h3 id="原始方式整合"><a href="#原始方式整合" class="headerlink" title="原始方式整合"></a>原始方式整合</h3><p>示例account表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create database ssm;</span><br><span class="line">create table account(</span><br><span class="line">	id int primary key auto_increment,</span><br><span class="line">	name varchar(100),</span><br><span class="line">	money double(7,2)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>创建Maven工程</p>
</li>
<li><p>导入Maven坐标</p>
</li>
<li><p>编写实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Double money;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写Mapper接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountMapper</span> &#123;</span><br><span class="line">	<span class="comment">//保存账户数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Account account)</span>;</span><br><span class="line">	<span class="comment">//查询账户数据</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Account&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写Service接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">	<span class="comment">//保存账户数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Account account)</span>;</span><br><span class="line">	<span class="comment">//查询账户数据</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Account&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写Service接口实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;accountService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Account account)</span> &#123;</span><br><span class="line">	<span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> MyBatisUtils.openSession();</span><br><span class="line">	<span class="type">AccountMapper</span> <span class="variable">accountMapper</span> <span class="operator">=</span> sqlSession.getMapper(AccountMapper.class);</span><br><span class="line">	accountMapper.save(account);</span><br><span class="line">	sqlSession.commit();</span><br><span class="line">	sqlSession.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> List&lt;Account&gt; <span class="title function_">findAll</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> MyBatisUtils.openSession();</span><br><span class="line">	<span class="type">AccountMapper</span> <span class="variable">accountMapper</span> <span class="operator">=</span> sqlSession.getMapper(AccountMapper.class);</span><br><span class="line">	<span class="keyword">return</span> accountMapper.findAll();</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写Controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/account&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountService accountService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/save&quot;,produces = &quot;text/html;charset=UTF-8&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">(Account account)</span>&#123;</span><br><span class="line">        accountService.save(account);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;保存成功&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/findAll&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">findAll</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;Account&gt; accountList = accountService.findAll();</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">        modelAndView.addObject(<span class="string">&quot;accountList&quot;</span>,accountList);</span><br><span class="line">        modelAndView.setViewName(<span class="string">&quot;accountList&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写添加页面</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;添加账户信息表单&lt;/h1&gt;</span><br><span class="line">    &lt;form name=<span class="string">&quot;accountForm&quot;</span> action=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/account/save&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">        账户名称:&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;name&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">        账户金额:&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;money&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;保存&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写列表页面</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;c&quot;</span> uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;展示账户数据列表&lt;/h1&gt;</span><br><span class="line">    &lt;table border=<span class="string">&quot;1&quot;</span>&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;th&gt;账户id&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;账户名称&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;账户金额&lt;/th&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line"></span><br><span class="line">        &lt;c:forEach items=<span class="string">&quot;$&#123;accountList&#125;&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;account&quot;</span>&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td&gt;$&#123;account.id&#125;&lt;/td&gt;</span><br><span class="line">                &lt;td&gt;$&#123;account.name&#125;&lt;/td&gt;</span><br><span class="line">                &lt;td&gt;$&#123;account.money&#125;&lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">        &lt;/c:forEach&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/table&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写相应配置文件</p>
<ul>
<li>Spring配置文件：applicationContext.xml</li>
<li>SprngMVC配置文件：spring-mvc.xml</li>
<li>MyBatis映射文件：AccountMapper.xml</li>
<li>MyBatis核心文件：sqlMapConfig.xml</li>
<li>数据库连接信息文件：jdbc.properties</li>
<li>Web.xml文件：web.xml</li>
<li>日志文件：log4j.xml</li>
</ul>
</li>
<li><p>测试添加账户</p>
</li>
<li><p>测试账户列表</p>
</li>
</ul>
<h3 id="Spring整合MyBatis"><a href="#Spring整合MyBatis" class="headerlink" title="Spring整合MyBatis"></a>Spring整合MyBatis</h3><ul>
<li>整合思路</li>
</ul>
<img src="https://pic.imgdb.cn/item/625ecf34239250f7c55baf07.jpg" style="zoom: 50%;" />

<ul>
<li><p>将SqlSessionFactory配置到Spring容器中</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--加载properties文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:property-placeholder</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置数据源信息--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置sessionFactory--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--加载mybatis核心文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:sqlMapConfig-spring.xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>扫描Mapper，让Spring容器产生Mapper实现类</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--扫描mapper所在的包 为mapper创建实现类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.itheima.mapper&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置声明式事务控制</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--声明式事务控制--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--平台事务管理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置事务增强--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--事务的aop织入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* com.itheima.service.impl.*.*(..))&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:advisor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改Service实现类代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;accountService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Account account)</span> &#123;</span><br><span class="line">        accountMapper.save(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Account&gt; <span class="title function_">findAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accountMapper.findAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM07 —— MyBatis的Dao层实现</title>
    <url>/2022/04/19/SSM07/</url>
    <content><![CDATA[<p>本文记录了MyBatis的进阶知识，包括：Dao层（持久层）实现，映射文件的深入知识，核心配置文件的深入知识，多表操作，注解开发</p>
<span id="more"></span>

<h3 id="MyBatis的Dao层实现"><a href="#MyBatis的Dao层实现" class="headerlink" title="MyBatis的Dao层实现"></a>MyBatis的Dao层实现</h3><h4 id="传统开发方式"><a href="#传统开发方式" class="headerlink" title="传统开发方式"></a>传统开发方式</h4><ul>
<li><p>编写UserDao接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">	List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span> <span class="keyword">throws</span> IOException; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写UserDaoImpl实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">	<span class="type">InputStream</span> <span class="variable">resourceAsStream</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;SqlMapConfig.xml&quot;</span>);</span><br><span class="line">	<span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(resourceAsStream);</span><br><span class="line">	<span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">	List&lt;User&gt; userList = sqlSession.selectList(<span class="string">&quot;userMapper.findAll&quot;</span>);</span><br><span class="line">	sqlSession.close();</span><br><span class="line">	<span class="keyword">return</span> userList; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试传统方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTraditionDao</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">	<span class="comment">//当前dao层实现是手动编写的</span></span><br><span class="line">    <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">	List&lt;User&gt; all = userDao.findAll();</span><br><span class="line">	System.out.println(all);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="代理开发方式"><a href="#代理开发方式" class="headerlink" title="代理开发方式"></a>代理开发方式</h4><p>介绍：</p>
<p>采用 Mybatis 的代理开发方式实现 DAO 层的开发，这种方式是企业的主流。</p>
<p>Mapper 接口开发方法只需要程序员编写Mapper 接口（相当于Dao 接口），由Mybatis 框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。</p>
<p>Mapper 接口开发需要遵循以下规范： </p>
<ul>
<li><p>Mapper.xml文件中的namespace与mapper接口的<strong>全限定名</strong>相同</p>
</li>
<li><p>Mapper接口方法名和Mapper.xml中定义的每个statement的id相同</p>
</li>
<li><p>Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql的parameterType的类型相同</p>
</li>
<li><p>Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同</p>
</li>
</ul>
<p>流程：</p>
<ul>
<li><p>编写UserMapper接口</p>
<img src="https://pic.imgdb.cn/item/625daa95239250f7c53ffdc3.jpg" style="zoom:80%;" />
</li>
<li><p>测试代理方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testProxyDao</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">	<span class="type">InputStream</span> <span class="variable">resourceAsStream</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;SqlMapConfig.xml&quot;</span>);</span><br><span class="line">	<span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(resourceAsStream);</span><br><span class="line">	<span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">	<span class="comment">//获得MyBatis框架生成的UserMapper接口的实现类</span></span><br><span class="line">	<span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line">	<span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.findById(<span class="number">1</span>);</span><br><span class="line">	System.out.println(user);</span><br><span class="line">	sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="MyBatis映射文件深入"><a href="#MyBatis映射文件深入" class="headerlink" title="MyBatis映射文件深入"></a>MyBatis映射文件深入</h3><h4 id="动态sql语句"><a href="#动态sql语句" class="headerlink" title="动态sql语句"></a>动态sql语句</h4><p><strong>概述：</strong></p>
<p>Mybatis 的映射文件中，前面我们的 SQL 都是比较简单的，有些时候业务逻辑复杂时，我们的 SQL是动态变化的，此时在前面的学习中我们的 SQL 就不能满足要求了。</p>
<p>参考的官方文档，描述如下：</p>
<p><img src="https://pic.imgdb.cn/item/625dad21239250f7c542fbbe.jpg"></p>
<p><strong>动态SQL之<code>&lt;if&gt;</code></strong></p>
<p>我们根据实体类的不同取值，使用不同的 SQL语句来进行查询。比如在 id如果不为空时可以根据id查询，如果username 不同空时还要加入用户名作为条件。这种情况在我们的多条件组合查询中经常会碰到。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByCondition&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id!=0&quot;</span>&gt;</span></span><br><span class="line">            and id=#&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username!=null&quot;</span>&gt;</span></span><br><span class="line">            and username=#&#123;username&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;password!=null&quot;</span>&gt;</span></span><br><span class="line">            and password=#&#123;password&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>动态SQL之<code>&lt;foreach&gt;</code></strong></p>
<p>循环执行sql的拼接操作，例如：<code>SELECT * FROM USER WHERE id IN (1,2,5)</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByIds&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;list&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">open</span>=<span class="string">&quot;id in(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">            #&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>foreach</code>标签的属性含义如下：</p>
<p><code>&lt;foreach&gt;</code>标签用于遍历集合，它的属性：</p>
<ul>
<li>collection：代表要遍历的集合元素，注意编写时不要写<code>#&#123;&#125;</code></li>
<li>open：代表语句的开始部分</li>
<li>close：代表结束部分</li>
<li>item：代表遍历集合的每个元素，生成的变量名</li>
<li>separator：代表分隔符</li>
</ul>
<p><strong>SQL片段抽取</strong></p>
<p>SQL 中可将重复的 sql 提取出来，使用时用 include 引用即可，最终达到 sql 重用的目的</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--sql语句抽取--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;selectUser&quot;</span>&gt;</span>select * from user<span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByIds&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;list&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;selectUser&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">open</span>=<span class="string">&quot;id in(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">            #&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>MyBatis映射文件配置总结：</strong></p>
<p><code>&lt;select&gt;</code>：查询</p>
<p><code>&lt;insert&gt;</code>：插入</p>
<p><code>&lt;update&gt;</code>：修改</p>
<p><code>&lt;delete&gt;</code>：删除</p>
<p><code>&lt;where&gt;</code>：where条件</p>
<p><code>&lt;if&gt;</code>：if判断</p>
<p><code>&lt;foreach&gt;</code>：循环</p>
<p><code>&lt;sql&gt;</code>：sql片段抽取</p>
<h3 id="MyBatis核心配置文件深入"><a href="#MyBatis核心配置文件深入" class="headerlink" title="MyBatis核心配置文件深入"></a>MyBatis核心配置文件深入</h3><h4 id="typeHandlers标签"><a href="#typeHandlers标签" class="headerlink" title="typeHandlers标签"></a>typeHandlers标签</h4><p>无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用<strong>类型处理器</strong>将获取的值以合适的方式转换成 <strong>Java 类型</strong>。下表描述了一些默认的类型处理器（截取部分）。</p>
<p><img src="https://pic.imgdb.cn/item/625e5c02239250f7c54a513e.jpg"></p>
<p>你可以重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。具体做法为：实现<code>org.apache.ibatis.type.TypeHandler</code> 接口， 或继承一个很便利的类 <code>org.apache.ibatis.type.BaseTypeHandler</code>， 然后可以选择性地将它映射到一个JDBC类型。</p>
<p>例如需求：一个Java中的Date数据类型，我想将之存到数据库的时候存成一个1970年至今的毫秒数，取出来时转换成java的Date，即java的Date与数据库的varchar毫秒值之间转换。</p>
<p><strong>开发步骤：</strong></p>
<ul>
<li><p>定义转换类继承类<code>BaseTypeHandler&lt;T&gt;</code></p>
</li>
<li><p>覆盖4个未实现的方法，其中<code>setNonNullParameter</code>为java程序设置数据到数据库的回调方法，<code>getNullableResult</code>为查询时 MySQL的字符串类型转换成 java的Type类型的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateTypeHandler</span> <span class="keyword">extends</span> <span class="title class_">BaseTypeHandler</span>&lt;Date&gt; &#123;</span><br><span class="line">    <span class="comment">//将java类型 转换成 数据库需要的类型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNonNullParameter</span><span class="params">(PreparedStatement preparedStatement, <span class="type">int</span> i, Date date, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> date.getTime();</span><br><span class="line">        preparedStatement.setLong(i,time);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将数据库中类型 转换成java类型</span></span><br><span class="line">    <span class="comment">//String参数  要转换的字段名称</span></span><br><span class="line">    <span class="comment">//ResultSet 查询出的结果集</span></span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getNullableResult</span><span class="params">(ResultSet resultSet, String s)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="comment">//获得结果集中需要的数据(long) 转换成Date类型 返回</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">aLong</span> <span class="operator">=</span> resultSet.getLong(s);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(aLong);</span><br><span class="line">        <span class="keyword">return</span> date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将数据库中类型 转换成java类型</span></span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getNullableResult</span><span class="params">(ResultSet resultSet, <span class="type">int</span> i)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">aLong</span> <span class="operator">=</span> resultSet.getLong(i);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(aLong);</span><br><span class="line">        <span class="keyword">return</span> date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将数据库中类型 转换成java类型</span></span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getNullableResult</span><span class="params">(CallableStatement callableStatement, <span class="type">int</span> i)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">aLong</span> <span class="operator">=</span> callableStatement.getLong(i);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(aLong);</span><br><span class="line">        <span class="keyword">return</span> date;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在MyBatis核心配置文件中进行注册(sqlMapConfig.xml)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--注册类型处理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeHandlers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeHandler</span> <span class="attr">handler</span>=<span class="string">&quot;com.itheima.handler.DateTypeHandler&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">typeHandler</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeHandlers</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>测试转换是否正确</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">resourceAsStream</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;sqlMapConfig.xml&quot;</span>);</span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(resourceAsStream);</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">    <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建user</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setUsername(<span class="string">&quot;ceshi&quot;</span>);</span><br><span class="line">    user.setPassword(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    user.setBirthday(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    <span class="comment">//执行保存操作</span></span><br><span class="line">    mapper.save(user);</span><br><span class="line"></span><br><span class="line">    sqlSession.commit();</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="plugins标签"><a href="#plugins标签" class="headerlink" title="plugins标签"></a>plugins标签</h4><p>MyBatis可以使用第三方的插件来对功能进行扩展，分页助手PageHelper是将分页的复杂操作进行封装，使用简单的方式即可获得分页的相关数据</p>
<p><strong>开发步骤：</strong></p>
<ul>
<li><p>导入通用PageHelper的坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.jsqlparser<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsqlparser<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在mybatis核心配置文件中配置PageHelper插件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置分页助手插件,注意配置在mapper之前--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.github.pagehelper.PageHelper&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dialect&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>测试分页数据获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">resourceAsStream</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;sqlMapConfig.xml&quot;</span>);</span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(resourceAsStream);</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">    <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置分页相关参数   当前页+每页显示的条数</span></span><br><span class="line">    PageHelper.startPage(<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; userList = mapper.findAll();</span><br><span class="line">    <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得与分页相关参数</span></span><br><span class="line">    PageInfo&lt;User&gt; pageInfo = <span class="keyword">new</span> <span class="title class_">PageInfo</span>&lt;User&gt;(userList);</span><br><span class="line">    System.out.println(<span class="string">&quot;当前页：&quot;</span>+pageInfo.getPageNum());</span><br><span class="line">    System.out.println(<span class="string">&quot;每页显示条数：&quot;</span>+pageInfo.getPageSize());</span><br><span class="line">    System.out.println(<span class="string">&quot;总条数：&quot;</span>+pageInfo.getTotal());</span><br><span class="line">    System.out.println(<span class="string">&quot;总页数：&quot;</span>+pageInfo.getPages());</span><br><span class="line">    System.out.println(<span class="string">&quot;上一页：&quot;</span>+pageInfo.getPrePage());</span><br><span class="line">    System.out.println(<span class="string">&quot;下一页：&quot;</span>+pageInfo.getNextPage());</span><br><span class="line">    System.out.println(<span class="string">&quot;是否是第一个：&quot;</span>+pageInfo.isIsFirstPage());</span><br><span class="line">    System.out.println(<span class="string">&quot;是否是最后一个：&quot;</span>+pageInfo.isIsLastPage());</span><br><span class="line"></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="核心配置文件常用标签总结"><a href="#核心配置文件常用标签总结" class="headerlink" title="核心配置文件常用标签总结"></a>核心配置文件常用标签总结</h4><ul>
<li><p>properties标签：该标签可以加载外部的properties文件</p>
</li>
<li><p>typeAliases标签：设置类型别名</p>
</li>
<li><p>environments标签：数据源环境配置标签</p>
</li>
<li><p>typeHandlers标签：配置自定义类型处理器</p>
</li>
<li><p>plugins标签：配置MyBatis的插件</p>
</li>
</ul>
<h3 id="MyBatis多表操作"><a href="#MyBatis多表操作" class="headerlink" title="MyBatis多表操作"></a>MyBatis多表操作</h3><h4 id="一对一查询"><a href="#一对一查询" class="headerlink" title="一对一查询"></a>一对一查询</h4><p><strong>模型：</strong></p>
<p>用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户</p>
<p>一对一查询的需求：查询一个订单，与此同时查询出该订单所属的用户</p>
<img src="https://pic.imgdb.cn/item/625e8a75239250f7c5c4aca1.jpg" style="zoom: 50%;" />

<p><strong>查询语句</strong>：：<code>select * from orders o,user u where o.uid=u.id;</code></p>
<p>创建Order实体：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> Date ordertime;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> total;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前订单属于哪一个用户</span></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//省略get set方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建User实体：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建OrderMapper接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询全部的方法</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Order&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置OrderMapper.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;orderMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;order&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--手动指定字段与实体属性的映射关系</span></span><br><span class="line"><span class="comment">            column: 数据表的字段名称</span></span><br><span class="line"><span class="comment">            property：实体的属性名称</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;oid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;ordertime&quot;</span> <span class="attr">property</span>=<span class="string">&quot;ordertime&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;total&quot;</span> <span class="attr">property</span>=<span class="string">&quot;total&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;result column=&quot;uid&quot; property=&quot;user.id&quot;&gt;&lt;/result&gt;</span></span><br><span class="line"><span class="comment">    &lt;result column=&quot;username&quot; property=&quot;user.username&quot;&gt;&lt;/result&gt;</span></span><br><span class="line"><span class="comment">    &lt;result column=&quot;password&quot; property=&quot;user.password&quot;&gt;&lt;/result&gt;</span></span><br><span class="line"><span class="comment">    &lt;result column=&quot;birthday&quot; property=&quot;user.birthday&quot;&gt;&lt;/result&gt;--&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            property: 当前实体(order)中的属性名称(private User user)</span></span><br><span class="line"><span class="comment">            javaType: 当前实体(order)中的属性的类型(User)</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;user&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;uid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;password&quot;</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">property</span>=<span class="string">&quot;birthday&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;orderMap&quot;</span>&gt;</span></span><br><span class="line">    SELECT *,o.id oid FROM orders o,USER u WHERE o.uid=u.id</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="一对多查询"><a href="#一对多查询" class="headerlink" title="一对多查询"></a>一对多查询</h4><p><strong>模型：</strong></p>
<p>用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户</p>
<p>一对多查询的需求：查询一个用户，与此同时查询出该用户具有的订单</p>
<p><img src="https://pic.imgdb.cn/item/625ea0ba239250f7c5f3c48d.jpg"></p>
<p>对应的sql语句：<code>select *,o.id oid from user u left join orders o on u.id=o.uid;</code></p>
<p><strong>修改User实体</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//描述的是当前用户存在哪些订单</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Order&gt; orderList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>创建UserMapper接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderMapper</span> &#123;</span><br><span class="line">    <span class="comment">//查询全部的方法</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Order&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>配置UserMapper.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;uid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;password&quot;</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">property</span>=<span class="string">&quot;birthday&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置集合信息</span></span><br><span class="line"><span class="comment">            property:集合名称</span></span><br><span class="line"><span class="comment">            ofType：当前集合中的数据类型</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;orderList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;order&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--封装order的数据--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;oid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;ordertime&quot;</span> <span class="attr">property</span>=<span class="string">&quot;ordertime&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;total&quot;</span> <span class="attr">property</span>=<span class="string">&quot;total&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;userMap&quot;</span>&gt;</span></span><br><span class="line">    SELECT *,o.id oid FROM USER u,orders o WHERE u.id=o.uid</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="多对多查询"><a href="#多对多查询" class="headerlink" title="多对多查询"></a>多对多查询</h4><p>用户表和角色表的关系为，一个用户有多个角色，一个角色被多个用户使用</p>
<p>多对多查询的需求：查询用户同时查询出该用户的所有角色</p>
<p><img src="https://pic.imgdb.cn/item/625ebc68239250f7c52e85d3.jpg"></p>
<p>对应的sql语句：<code>select u.*,r.*,r.id rid from user u left join user_role ur on u.id=ur.user_id inner join role r on ur.role_id=r.id;</code></p>
<p><strong>创建Role实体，修改User实体</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//描述的是当前用户存在哪些订单</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Order&gt; orderList;</span><br><span class="line">    <span class="comment">//代表当前用户具备哪些角色</span></span><br><span class="line">	<span class="keyword">private</span> List&lt;Role&gt; roleList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Role</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String roleName;</span><br><span class="line">    <span class="keyword">private</span> String roleDesc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>添加UserMapper接口方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;User&gt; <span class="title function_">findAllUserAndRole</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p><strong>配置UserMapper.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userRoleMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--user的信息--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;userId&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;password&quot;</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">property</span>=<span class="string">&quot;birthday&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--user内部的roleList信息--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;roleList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;role&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;roleId&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;roleName&quot;</span> <span class="attr">property</span>=<span class="string">&quot;roleName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;roleDesc&quot;</span> <span class="attr">property</span>=<span class="string">&quot;roleDesc&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findUserAndRoleAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;userRoleMap&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM USER u,sys_user_role ur,sys_role r WHERE u.id=ur.userId AND ur.roleId=r.id</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>测试代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">resourceAsStream</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;sqlMapConfig.xml&quot;</span>);</span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(resourceAsStream);</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">    <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line">    List&lt;User&gt; userAndRoleAll = mapper.findUserAndRoleAll();</span><br><span class="line">    <span class="keyword">for</span> (User user : userAndRoleAll) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="MyBatis注解开发"><a href="#MyBatis注解开发" class="headerlink" title="MyBatis注解开发"></a>MyBatis注解开发</h3><h4 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h4><p>这几年来注解开发越来越流行，Mybatis也可以使用注解开发方式，这样我们就可以减少编写Mapper映射文件了。我们先围绕一些基本的CRUD来学习，再学习复杂映射多表操作。</p>
<ul>
<li><p><code>@Insert</code>：实现新增</p>
</li>
<li><p><code>@Update</code>：实现更新</p>
</li>
<li><p><code>@Delete</code>：实现删除</p>
</li>
<li><p><code>@Select</code>：实现查询</p>
</li>
<li><p><code>@Result</code>：实现结果集封装</p>
</li>
<li><p><code>@Results</code>：可以与<code>@Result</code> 一起使用，封装多个结果集</p>
</li>
<li><p><code>@One</code>：实现一对一结果集封装</p>
</li>
<li><p><code>@Many</code>：实现一对多结果集封装</p>
</li>
</ul>
<h4 id="增删改查操作"><a href="#增删改查操作" class="headerlink" title="增删改查操作"></a>增删改查操作</h4><p>UserMapper接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert(&quot;insert into user values(#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;,#&#123;birthday&#125;)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(User user)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update(&quot;update user set username=#&#123;username&#125;,password=#&#123;password&#125; where id=#&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(User user)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delete(&quot;delete from user where id=#&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from user where id=#&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from user&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserMapper mapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">resourceAsStream</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;sqlMapConfig.xml&quot;</span>);</span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(resourceAsStream);</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession(<span class="literal">true</span>);</span><br><span class="line">        mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSave</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setUsername(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        user.setPassword(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        mapper.save(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setId(<span class="number">18</span>);</span><br><span class="line">        user.setUsername(<span class="string">&quot;lucy&quot;</span>);</span><br><span class="line">        user.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        mapper.update(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDelete</span><span class="params">()</span>&#123;</span><br><span class="line">        mapper.delete(<span class="number">18</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFindById</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> mapper.findById(<span class="number">2</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFindAll</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;User&gt; all = mapper.findAll();</span><br><span class="line">        <span class="keyword">for</span> (User user : all) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改MyBatis的核心配置文件，我们使用了注解替代的映射文件，所以我们只需要加载使用了注解的Mapper接口即可</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--扫描使用注解的类--&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.mapper.UserMapper&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>或者指定扫描包含映射关系的接口所在的包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--加载映射关系--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--指定接口所在的包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.itheima.mapper&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="复杂映射开发"><a href="#复杂映射开发" class="headerlink" title="复杂映射开发"></a>复杂映射开发</h4><p>实现复杂关系映射之前我们可以在映射文件中通过配置<code>&lt;resultMap&gt;</code>来实现，使用注解开发后，我们可以使用<code>@Results</code>注解，<code>@Result</code>注解，<code>@One</code>注解，<code>@Many</code>注解组合完成复杂关系的配置</p>
<p><img src="https://pic.imgdb.cn/item/625ec774239250f7c54b8641.jpg"></p>
<p><img src="https://pic.imgdb.cn/item/625ec78b239250f7c54bc182.jpg"></p>
<h4 id="一对一查询-1"><a href="#一对一查询-1" class="headerlink" title="一对一查询"></a>一对一查询</h4><h4 id="一对多查询-1"><a href="#一对多查询-1" class="headerlink" title="一对多查询"></a>一对多查询</h4><h4 id="多对多查询-1"><a href="#多对多查询-1" class="headerlink" title="多对多查询"></a>多对多查询</h4>]]></content>
      <categories>
        <category>SSM</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM06 —— MyBatis基础</title>
    <url>/2022/04/17/SSM06/</url>
    <content><![CDATA[<p>本文记录了MyBatis的基础知识，包括映射文件，增删改查操作，核心配置文件概述和基本的API介绍</p>
<span id="more"></span>

<h3 id="MyBatis简介"><a href="#MyBatis简介" class="headerlink" title="MyBatis简介"></a>MyBatis简介</h3><h4 id="原始JDBC操作的分析"><a href="#原始JDBC操作的分析" class="headerlink" title="原始JDBC操作的分析"></a>原始JDBC操作的分析</h4><p>查询：</p>
<p><img src="https://pic.imgdb.cn/item/625d8be7239250f7c50b0949.jpg"></p>
<p>插入：</p>
<p><img src="https://pic.imgdb.cn/item/625d8c4b239250f7c50bfac1.jpg"></p>
<p>原始JDBC开发存在的问题如下：</p>
<ul>
<li>数据库<strong>连接创建、释放频繁</strong>造成系统资源浪费从而影响系统性能</li>
<li>SQL 语句在代码中硬编码，造成代码不易维护，实际应用 SQL变化的可能较大，SQL变动需要改变java代码。</li>
<li>查询操作时，需要手动将结果集中的数据手动封装到实体中。插入操作时，需要手动将实体的数据设置到SQL语句的占位符位置</li>
</ul>
<p>应对上述问题给出的解决方案：</p>
<ul>
<li>使用数据库连接池初始化连接资源</li>
<li>将SQL语句抽取到xml配置文件中</li>
<li>使用反射、内省等底层技术，自动将实体与表进行属性与字段的自动映射</li>
</ul>
<h4 id="什么是MyBatis"><a href="#什么是MyBatis" class="headerlink" title="什么是MyBatis"></a>什么是MyBatis</h4><p><a href="http://www.mybatis.org/mybatis-3/">官网地址</a> </p>
<ul>
<li>mybatis 是一个优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。</li>
<li>mybatis通过xml或注解的方式将要执行的各种 statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句。</li>
<li>最后mybatis框架执行sql并将结果映射为java对象并返回。采用ORM思想解决了实体和数据库映射的问题，对jdbc 进行了封装，屏蔽了jdbc api 底层访问细节，使我们不用与jdbc api打交道，就可以完成对数据库的持久化操作。</li>
</ul>
<h3 id="MyBatis开发简单演示"><a href="#MyBatis开发简单演示" class="headerlink" title="MyBatis开发简单演示"></a>MyBatis开发简单演示</h3><p>MyBatis开发步骤：</p>
<ul>
<li><p>导入MyBatis的坐标和其他相关坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--mysql驱动坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.32<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mybatis坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--单元测试坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--日志坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建user数据表</p>
<p>包含三个属性：<code>id int， username varchar(32), password varchar(32)</code></p>
</li>
<li><p>编写User实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//省略get set 以及 toString方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写映射文件UserMapper.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;userMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--查询操作--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编写核心文件SqlMapConfig.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--通过properties标签加载外部properties文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--自定义别名，注意要写在前面--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">&quot;com.itheima.domain.User&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;user&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">typeAlias</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--数据源环境--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--事务管理器使用JDBC--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--加载映射文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/itheima/mapper/UserMapper.xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编写测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//查询操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//获得核心配置文件</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">resourceAsStream</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;sqlMapConfig.xml&quot;</span>);</span><br><span class="line">    <span class="comment">//获得session工厂对象</span></span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(resourceAsStream);</span><br><span class="line">    <span class="comment">//获得session会话对象</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">    <span class="comment">//执行操作  参数：namespace+id</span></span><br><span class="line">    List&lt;User&gt; userList = sqlSession.selectList(<span class="string">&quot;userMapper.findAll&quot;</span>);</span><br><span class="line">    <span class="comment">//打印数据</span></span><br><span class="line">    System.out.println(userList);</span><br><span class="line">    <span class="comment">//释放资源</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="MyBatis的映射文件概述"><a href="#MyBatis的映射文件概述" class="headerlink" title="MyBatis的映射文件概述"></a>MyBatis的映射文件概述</h3><p><img src="https://pic.imgdb.cn/item/625da1f5239250f7c534030b.jpg"></p>
<h3 id="MyBatis的增删改查操作"><a href="#MyBatis的增删改查操作" class="headerlink" title="MyBatis的增删改查操作"></a>MyBatis的增删改查操作</h3><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>编写UserMapper映射文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;userMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--插入操作--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;save&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.itheima.domain.User&quot;</span>&gt;</span></span><br><span class="line">        insert into user values(#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>编写插入实体User的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//模拟user对象</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setUsername(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">    user.setPassword(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得核心配置文件</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">resourceAsStream</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;sqlMapConfig.xml&quot;</span>);</span><br><span class="line">    <span class="comment">//获得session工厂对象</span></span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(resourceAsStream);</span><br><span class="line">    <span class="comment">//获得session会话对象</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//执行操作  参数：namespace+id</span></span><br><span class="line">    sqlSession.insert(<span class="string">&quot;userMapper.save&quot;</span>,user);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//mybatis执行更新操作  提交事务</span></span><br><span class="line">    <span class="comment">//sqlSession.commit();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放资源</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>插入操作注意问题</strong></p>
<ul>
<li>插入语句使用insert标签</li>
<li>在映射文件中使用parameterType属性指定要插入的数据类型</li>
<li>Sql语句中使用#{实体属性名}方式引用实体中的属性值</li>
<li>插入操作使用的API是<code>sqlSession.insert(“命名空间.id”,实体对象);</code></li>
<li>插入操作涉及数据库数据变化，所以要使用sqlSession对象显示的提交事务，即<code>sqlSession.commit()</code></li>
</ul>
<h4 id="修改操作"><a href="#修改操作" class="headerlink" title="修改操作"></a>修改操作</h4><p>编写UserMapper映射文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;userMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--修改操作--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.itheima.domain.User&quot;</span>&gt;</span></span><br><span class="line">        update user set username=#&#123;username&#125;,password=#&#123;password&#125; where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>编写修改实体User的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//模拟user对象</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setId(<span class="number">7</span>);</span><br><span class="line">    user.setUsername(<span class="string">&quot;lucy&quot;</span>);</span><br><span class="line">    user.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得核心配置文件</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">resourceAsStream</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;sqlMapConfig.xml&quot;</span>);</span><br><span class="line">    <span class="comment">//获得session工厂对象</span></span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(resourceAsStream);</span><br><span class="line">    <span class="comment">//获得session会话对象</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">    <span class="comment">//执行操作  参数：namespace+id</span></span><br><span class="line">    sqlSession.update(<span class="string">&quot;userMapper.update&quot;</span>,user);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//mybatis执行更新操作  提交事务</span></span><br><span class="line">    sqlSession.commit();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放资源</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>修改操作注意问题</strong></p>
<ul>
<li><p>修改语句使用update标签</p>
</li>
<li><p>修改操作使用的API是<code>sqlSession.update(“命名空间.id”,实体对象);</code></p>
</li>
</ul>
<h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p>编写UserMapper映射文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;userMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--删除操作--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;delete&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">        delete from user where id=#&#123;abc&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>编写删除实体User的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//获得核心配置文件</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">resourceAsStream</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;sqlMapConfig.xml&quot;</span>);</span><br><span class="line">    <span class="comment">//获得session工厂对象</span></span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(resourceAsStream);</span><br><span class="line">    <span class="comment">//获得session会话对象</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">    <span class="comment">//执行操作  参数：namespace+id</span></span><br><span class="line">    sqlSession.delete(<span class="string">&quot;userMapper.delete&quot;</span>,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//mybatis执行更新操作  提交事务</span></span><br><span class="line">    sqlSession.commit();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放资源</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>删除操作注意问题</strong></p>
<ul>
<li>删除语句使用delete标签</li>
<li>Sql语句中使用<code>#&#123;任意字符串&#125;</code>方式引用传递的单个参数</li>
<li>删除操作使用的API是<code>sqlSession.delete(“命名空间.id”,Object);</code></li>
</ul>
<h3 id="MyBatis的核心配置文件概述"><a href="#MyBatis的核心配置文件概述" class="headerlink" title="MyBatis的核心配置文件概述"></a>MyBatis的核心配置文件概述</h3><h4 id="MyBatis核心配置文件层级关系"><a href="#MyBatis核心配置文件层级关系" class="headerlink" title="MyBatis核心配置文件层级关系"></a>MyBatis核心配置文件层级关系</h4><img src="https://pic.imgdb.cn/item/625d9e4a239250f7c52ec15c.jpg" style="zoom:50%;" />

<h4 id="常用配置解析"><a href="#常用配置解析" class="headerlink" title="常用配置解析"></a>常用配置解析</h4><ul>
<li><p><strong>environments标签</strong></p>
<p>数据库环境的配置，支持多环境配置</p>
<img src="https://pic.imgdb.cn/item/625d9ef7239250f7c52fc5da.jpg" style="zoom: 50%;" />

<p>其中，事务管理器（transactionManager）类型有两种：</p>
<ul>
<li><p>JDBC：这个配置就是直接使用了JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域。</p>
</li>
<li><p>MANAGED：这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如JEE 应用服务器的上下文）。 默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将 closeConnection 属性设置为 false 来阻止它默认的关闭行为。</p>
</li>
</ul>
<p>其中，数据源（dataSource）类型有三种：</p>
<ul>
<li><p>UNPOOLED：这个数据源的实现只是每次被请求时打开和关闭连接。</p>
</li>
<li><p>POOLED：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来。（池化思想）</p>
</li>
<li><p>JNDI：这个数据源的实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。</p>
</li>
</ul>
</li>
<li><p><strong>mapper标签</strong></p>
<p>该标签的作用是加载映射的，加载方式有如下几种：</p>
<ul>
<li><p>使用相对于类路径的资源引用，例如：<code>&lt;mapper resource=&quot;org/mybatis/builder/AuthorMapper.xml&quot;/&gt;</code></p>
</li>
<li><p>使用完全限定资源定位符（URL），例如：<code>&lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&gt;</code></p>
</li>
<li><p>使用映射器接口实现类的完全限定类名，例如：<code>&lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&gt;</code></p>
</li>
<li><p>将包内的映射器接口实现全部注册为映射器，例如：<code>&lt;package name=&quot;org.mybatis.builder&quot;/&gt;</code></p>
</li>
</ul>
</li>
<li><p><strong>Properties标签</strong></p>
<p>实际开发中，习惯将数据源的配置信息单独抽取成一个properties文件，该标签可以加载额外配置的properties文件</p>
<img src="https://pic.imgdb.cn/item/625da05d239250f7c531cb4f.jpg" style="zoom: 80%;" />
</li>
<li><p><strong>typeAliases标签</strong></p>
<p>类型别名是为Java 类型设置一个短的名字。原来的类型名称配置如下</p>
<img src="https://pic.imgdb.cn/item/625da0f3239250f7c532a6b7.jpg" style="zoom:80%;" />

<p>MyBatis框架已经为我们设置好的一些常用的类型的别名</p>
<img src="https://pic.imgdb.cn/item/625da137239250f7c53304f3.jpg" style="zoom: 80%;" /></li>
</ul>
<h3 id="MyBatis的相应API"><a href="#MyBatis的相应API" class="headerlink" title="MyBatis的相应API"></a>MyBatis的相应API</h3><p><strong>SqlSession工厂构建器SqlSessionFactoryBuilder</strong></p>
<p>常用API：<code>SqlSessionFactory build(InputStream inputStream)</code></p>
<p>通过加载mybatis的核心文件的输入流的形式构建一个SqlSessionFactory对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;org/mybatis/builder/mybatis-config.xml&quot;</span>;</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line"><span class="type">SqlSessionFactoryBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>();</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> builder.build(inputStream);</span><br></pre></td></tr></table></figure>

<p>其中， Resources 工具类，这个类在 org.apache.ibatis.io 包中。Resources 类帮助你从类路径下、文件系统或一个 web URL 中加载资源文件。</p>
<p><strong>SqlSession工厂对象SqlSessionFactory</strong></p>
<p>SqlSessionFactory 有多个个方法创建 SqlSession 实例。常用的有如下两个：</p>
<img src="https://pic.imgdb.cn/item/625da32c239250f7c535a68d.jpg" style="zoom:85%;" />

<p><strong>SqlSession会话对象</strong></p>
<p>SqlSession 实例在 MyBatis 中是非常强大的一个类。在这里你会看到所有执行语句、提交或回滚事务和获取映射器实例的方法。执行语句的方法主要有：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; T <span class="title function_">selectOne</span><span class="params">(String statement, Object parameter)</span> </span><br><span class="line">&lt;E&gt; List&lt;E&gt; <span class="title function_">selectList</span><span class="params">(String statement, Object parameter)</span> </span><br><span class="line"><span class="type">int</span> <span class="title function_">insert</span><span class="params">(String statement, Object parameter)</span> </span><br><span class="line"><span class="type">int</span> <span class="title function_">update</span><span class="params">(String statement, Object parameter)</span> </span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">(String statement, Object parameter)</span></span><br></pre></td></tr></table></figure>

<p>操作事务的方法主要有：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">commit</span><span class="params">()</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SSM</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM05 —— 事务控制</title>
    <url>/2022/04/17/SSM05/</url>
    <content><![CDATA[<p>本文记录了Spring的事务控制，包含编程式事务控制相关对象、基于XML的声明式事务控制和基于注解的声明式事务控制</p>
<span id="more"></span>

<h3 id="编程式事务控制三大对象"><a href="#编程式事务控制三大对象" class="headerlink" title="编程式事务控制三大对象"></a>编程式事务控制三大对象</h3><h4 id="PlatformTransactionManager"><a href="#PlatformTransactionManager" class="headerlink" title="PlatformTransactionManager"></a>PlatformTransactionManager</h4><p>PlatformTransactionManager 接口是 spring 的<strong>事务管理器</strong>，它里面提供了我们常用的操作事务的方法。</p>
<p><img src="https://pic.imgdb.cn/item/625b10df239250f7c5ca131c.jpg"></p>
<p>注意：<br>PlatformTransactionManager 是接口类型，不同的 Dao 层技术则有不同的实现类，例如：Dao 层技术是Jdbc 或 Mybatis 时：<code>org.springframework.jdbc.datasource.DataSourceTransactionManager</code><br>Dao 层技术是hibernate时：<code>org.springframework.orm.hibernate5.HibernateTransactionManager</code></p>
<h4 id="TransactionDefinition"><a href="#TransactionDefinition" class="headerlink" title="TransactionDefinition"></a>TransactionDefinition</h4><p>TransactionDefinition 是事务的定义信息对象，里面有如下方法：</p>
<p><img src="https://pic.imgdb.cn/item/625b1134239250f7c5ca683c.jpg"></p>
<p><strong>事务隔离级别</strong><br>设置隔离级别，可以解决事务并发产生的问题，如脏读、不可重复读和虚读。</p>
<ul>
<li>ISOLATION_DEFAULT</li>
<li>ISOLATION_READ_UNCOMMITTED</li>
<li>ISOLATION_READ_COMMITTED</li>
<li>ISOLATION_REPEATABLE_READ</li>
<li>ISOLATION_SERIALIZABLE</li>
</ul>
<p><strong>事务传播行为</strong></p>
<ul>
<li>REQUIRED：如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。一般的选择（默认值）</li>
<li>SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行（没有事务）</li>
<li>MANDATORY：使用当前的事务，如果当前没有事务，就抛出异常</li>
<li>REQUERS_NEW：新建事务，如果当前在事务中，把当前事务挂起。</li>
<li>NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起</li>
<li>NEVER：以非事务方式运行，如果当前存在事务，抛出异常</li>
<li>NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行 REQUIRED 类似的操作</li>
<li>超时时间：默认值是-1，没有超时限制。如果有，以秒为单位进行设置</li>
<li>是否只读：建议查询时设置为只读</li>
</ul>
<h4 id="TransactionStatus"><a href="#TransactionStatus" class="headerlink" title="TransactionStatus"></a>TransactionStatus</h4><p>TransactionStatus 接口提供的是事务具体的运行状态，方法介绍如下：</p>
<p><img src="https://pic.imgdb.cn/item/625b1201239250f7c5cb339b.jpg"></p>
<h3 id="基于XML的声明式事务控制"><a href="#基于XML的声明式事务控制" class="headerlink" title="基于XML的声明式事务控制"></a>基于XML的声明式事务控制</h3><p><strong>什么是声明式事务控制</strong></p>
<p>Spring 的声明式事务顾名思义就是采用声明的方式来处理事务。这里所说的声明，就是<strong>指在配置文件中声明</strong>，用在 Spring 配置文件中声明式的处理事务来代替代码式的处理事务。</p>
<p><strong>声明式事务处理的作用</strong></p>
<ul>
<li><strong>事务管理不侵入开发的组件</strong>。具体来说，业务逻辑对象就不会意识到正在事务管理之中，事实上也应该如此，因为事务管理是属于系统层面的服务，而不是业务逻辑的一部分，如果想要改变事务管理策划的话，也只需要在定义文件中重新配置即可。</li>
<li>在不需要事务管理的时候，只要在设定文件上修改一下，即可移去事务管理服务，无需改变代码重新编译，这样维护起来极其方便</li>
</ul>
<p><strong>注意</strong>：Spring 声明式事务控制底层就是AOP。</p>
<h4 id="声明式事务控制的实现"><a href="#声明式事务控制的实现" class="headerlink" title="声明式事务控制的实现"></a>声明式事务控制的实现</h4><p>声明式事务控制明确事项：</p>
<p>（1）谁是切点？</p>
<p>（2）谁是通知？</p>
<p>（3）配置切面？</p>
<ul>
<li><p>引入tx命名空间</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置事务增强</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置平台事务管理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--通知  事务的增强--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置事务的属性信息的--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;transfer&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;REPEATABLE_READ&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;save&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;REPEATABLE_READ&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;REPEATABLE_READ&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;update*&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;REPEATABLE_READ&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置事务 AOP 织入（Spring为事务增强专门有一个advisor）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置事务的aop织入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;txPointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.itheima.service.impl.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;txPointcut&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>测试事务控制转账业务代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String outMan, String inMan, <span class="type">double</span> money)</span> &#123;</span><br><span class="line">    accountDao.out(outMan,money);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">    accountDao.in(inMan,money);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="切点方法的事务参数的配置"><a href="#切点方法的事务参数的配置" class="headerlink" title="切点方法的事务参数的配置"></a>切点方法的事务参数的配置</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--通知  事务的增强--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置事务的属性信息的--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;transfer&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;REPEATABLE_READ&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中，<code>&lt;tx:method&gt;</code> 代表切点方法的事务参数的配置，例如：<br><code>&lt;tx:method name=&quot;transfer&quot; isolation=&quot;REPEATABLE_READ&quot; propagation=&quot;REQUIRED&quot; timeout=&quot;-1&quot; read-only=&quot;false&quot;/&gt;</code></p>
<ul>
<li>name：切点方法名称</li>
<li>isolation:事务的隔离级别</li>
<li>propagation：事务的传播行为</li>
<li>timeout：超时时间</li>
<li>read-only：是否只读</li>
</ul>
<h3 id="基于注解的声明式事务控制"><a href="#基于注解的声明式事务控制" class="headerlink" title="基于注解的声明式事务控制"></a>基于注解的声明式事务控制</h3><ul>
<li><p>编写AccountDao</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository(&quot;accountDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out</span><span class="params">(String outMan, <span class="type">double</span> money)</span> &#123;</span><br><span class="line">        jdbcTemplate.update(<span class="string">&quot;update account set money=money-? where name=?&quot;</span>,money,outMan);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">in</span><span class="params">(String inMan, <span class="type">double</span> money)</span> &#123;</span><br><span class="line">        jdbcTemplate.update(<span class="string">&quot;update account set money=money+? where name=?&quot;</span>,money,inMan);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写AccountService</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;accountService&quot;)</span></span><br><span class="line"><span class="meta">@Transactional(isolation = Isolation.REPEATABLE_READ)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(isolation = Isolation.READ_COMMITTED,propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String outMan, String inMan, <span class="type">double</span> money)</span> &#123;</span><br><span class="line">        accountDao.out(outMan,money);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">        accountDao.in(inMan,money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@Transactional(isolation = Isolation.DEFAULT)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">xxx</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写applicationContext.xml配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--之前省略datsSource、jdbcTemplate、平台事务管理器的配置--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--组件扫描--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.itheima&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--事物的注解驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>解析</p>
<ul>
<li>使用 <code>@Transactional</code> 在需要进行事务控制的类或是方法上修饰，注解可用的属性同 xml 配置方式，例如隔离级别、传播行为等。</li>
<li>注解使用在类上，那么该类下的所有方法都使用同一套注解参数配置。</li>
<li>使用在方法上，不同的方法可以采用不同的事务参数配置。</li>
<li>Xml配置文件中要开启事务的注解驱动<code>&lt;tx:annotation-driven /&gt;</code></li>
</ul>
<p><strong>注解声明式事务控制的配置要点</strong></p>
<ul>
<li>平台事务管理器配置（xml方式）</li>
<li>事务通知的配置（<code>@Transactional</code>注解配置）</li>
<li>事务注解驱动的配置 <code>&lt;tx:annotation-driven/&gt;</code></li>
</ul>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM04 —— AOP</title>
    <url>/2022/04/16/SSM04/</url>
    <content><![CDATA[<p>本文记录了AOP编程的基本概念和在java开发中的底层实现，对动态代理技术作了介绍和演示</p>
<span id="more"></span>

<h3 id="Spring的AOP简介"><a href="#Spring的AOP简介" class="headerlink" title="Spring的AOP简介"></a>Spring的AOP简介</h3><h4 id="AOP及其作用和优势"><a href="#AOP及其作用和优势" class="headerlink" title="AOP及其作用和优势"></a>AOP及其作用和优势</h4><p><strong>AOP</strong> 为 <strong>A</strong>spect <strong>O</strong>riented <strong>P</strong>rogramming 的缩写，意思为<strong>面向切面编程</strong>，是通过预编译方式和<strong>运行期动态代理</strong>实现程序功能的统一维护的一种技术。<br>AOP 是 OOP 的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p>
<p>代码耦合度的三个层面：</p>
<p>（1）重复书写代码。（耦合度最高，想要修改要在每一部分上都要修改）</p>
<p>（2）单独书写重复部分，通过引用的方式使用。（紧耦合）</p>
<p>（3）AOP（松耦合，分隔每一部分的功能，通过配置的方式串联各个部分）</p>
<p>AOP作用：在程序运行期间，在不修改源码的情况下对方法进行功能增强</p>
<p>AOP优势：减少重复代码，提高开发效率，并且便于维护</p>
<h4 id="AOP的底层实现"><a href="#AOP的底层实现" class="headerlink" title="AOP的底层实现"></a>AOP的底层实现</h4><p>实际上，AOP 的底层是通过 Spring 提供的的动态代理技术实现的。在运行期间，Spring通过动态代理技术动态的生成代理对象，代理对象方法执行时进行增强功能的介入，在去调用目标对象的方法，从而完成功能的增强。</p>
<p><strong>AOP的动态代理技术</strong></p>
<p>常用的动态代理技术</p>
<ul>
<li>JDK 代理 : 基于接口的动态代理技术</li>
<li>cglib 代理：基于父类的动态代理技术</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/625abf7d239250f7c532bafd.jpg"></p>
<p><strong>JDK的动态代理</strong></p>
<ul>
<li><p>目标类接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TargetInterface</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>目标类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Target</span> <span class="keyword">implements</span> <span class="title class_">TargetInterface</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;save running.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>动态代理代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Advice</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置增强....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;后置增强....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//目标对象</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Target</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//增强对象</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Advice</span> <span class="variable">advice</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Advice</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值 就是动态生成的代理对象</span></span><br><span class="line"><span class="type">TargetInterface</span> <span class="variable">proxy</span> <span class="operator">=</span> (TargetInterface) Proxy.newProxyInstance(</span><br><span class="line">    target.getClass().getClassLoader(), <span class="comment">//目标对象类加载器</span></span><br><span class="line">    target.getClass().getInterfaces(), <span class="comment">//目标对象相同的接口字节码对象数组</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">        <span class="comment">//调用代理对象的任何方法  实质执行的都是invoke方法</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">            advice.before(); <span class="comment">//前置增强</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">invoke</span> <span class="operator">=</span> method.invoke(target, args);<span class="comment">//执行目标方法</span></span><br><span class="line">            advice.afterReturning(); <span class="comment">//后置增强</span></span><br><span class="line">            <span class="keyword">return</span> invoke;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用代理对象的方法测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用代理对象的方法</span></span><br><span class="line">proxy.save();</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>cglib的动态代理</strong></p>
<ul>
<li><p>目标类(不需要接口)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;save running.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>动态代理代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Advice</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置增强....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;后置增强....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//目标对象</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Target</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//增强对象</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Advice</span> <span class="variable">advice</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Advice</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回值 就是动态生成的代理对象  基于cglib</span></span><br><span class="line">        <span class="comment">//1、创建增强器</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">//2、设置父类（目标）</span></span><br><span class="line">        enhancer.setSuperclass(Target.class);</span><br><span class="line">        <span class="comment">//3、设置回调</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">MethodInterceptor</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                advice.before(); <span class="comment">//执行前置</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">invoke</span> <span class="operator">=</span> method.invoke(target, args);<span class="comment">//执行目标</span></span><br><span class="line">                advice.afterReturning(); <span class="comment">//执行后置</span></span><br><span class="line">                <span class="keyword">return</span> invoke;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//4、创建代理对象</span></span><br><span class="line">        <span class="type">Target</span> <span class="variable">proxy</span> <span class="operator">=</span> (Target) enhancer.create();</span><br><span class="line">        proxy.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用代理对象的方法测试</p>
</li>
</ul>
<h4 id="AOP相关概念"><a href="#AOP相关概念" class="headerlink" title="AOP相关概念"></a>AOP相关概念</h4><p>Spring 的 AOP 实现底层就是对上面的动态代理的代码进行了封装，封装后我们只需要对需要关注的部分进行代码编写，并通过配置的方式完成指定目标的方法增强。</p>
<p>在正式讲解 AOP 的操作之前，我们必须理解 AOP 的相关术语，常用的术语如下：</p>
<ul>
<li>Target（目标对象）：代理的目标对象</li>
<li>Proxy （代理）：一个类被 AOP 织入增强后，就产生一个结果代理类</li>
<li>Joinpoint（连接点）：所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法，因为spring只支持方法类型的连接点（可以被增强的方法叫做连接点）</li>
<li><strong>Pointcut（切入点</strong>）：所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义（真正要被增强的方法）</li>
<li><strong>Advice（通知&#x2F; 增强）</strong>：所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知</li>
<li><strong>Aspect（切面）</strong>：是切入点和通知（引介）的结合</li>
<li><strong>Weaving（织入）</strong>：是指把增强应用到目标对象来创建新的代理对象的过程。spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入</li>
</ul>
<h4 id="AOP开发明确的事项"><a href="#AOP开发明确的事项" class="headerlink" title="AOP开发明确的事项"></a>AOP开发明确的事项</h4><p><strong>需要编写的内容</strong></p>
<ul>
<li>编写核心业务代码（目标类的目标方法）</li>
<li>编写切面类，切面类中有通知(增强功能方法) </li>
<li>在配置文件中，配置织入关系，即将哪些通知与哪些连接点进行结合</li>
</ul>
<p><strong>AOP 技术实现的内容</strong><br>Spring 框架监控切入点方法的执行。<strong>一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行</strong>。</p>
<p><strong>AOP 底层使用哪种代理方式</strong><br>在 Spring 中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式。</p>
<h3 id="基于XML的AOP开发"><a href="#基于XML的AOP开发" class="headerlink" title="基于XML的AOP开发"></a>基于XML的AOP开发</h3><h4 id="快速入门（基础步骤）"><a href="#快速入门（基础步骤）" class="headerlink" title="快速入门（基础步骤）"></a>快速入门（基础步骤）</h4><ul>
<li><p>导入 AOP 相关坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入spring的context坐标，context依赖aop--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- aspectj的织入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建目标接口和目标类（内部有切点）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Target</span> <span class="keyword">implements</span> <span class="title class_">TargetInterface</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;save running.....&quot;</span>);</span><br><span class="line">        <span class="comment">//int i = 1/0;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TargetInterface</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建切面类（内部有增强方法）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置增强..........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;后置增强..........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Proceeding JoinPoint:  正在执行的连接点===切点</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕前增强....&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">proceed</span> <span class="operator">=</span> pjp.proceed();<span class="comment">//切点方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;环绕后增强....&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;异常抛出增强..........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;最终增强..........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将目标类和切面类的对象创建权交给 spring</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--目标对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;target&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.aop.Target&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--切面对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myAspect&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.aop.MyAspect&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>applicationContext.xml</code> 中配置织入关系</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;切面类&quot;</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;通知方法名称&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;切点表达式&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>



<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--目标对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;target&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.aop.Target&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--切面对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myAspect&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.aop.MyAspect&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置织入：告诉spring框架 哪些方法(切点)需要进行哪些增强(前置、后置...)--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--声明切面--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAspect&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--抽取切点表达式--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;myPointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.itheima.aop.*.*(..))&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:pointcut</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--切面：切点+通知--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(public void com.itheima.aop.Target.save())&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;aop:before method=&quot;before&quot; pointcut=&quot;execution(* com.itheima.aop.*.*(..))&quot;/&gt;</span></span><br><span class="line"><span class="comment">            &lt;aop:after-returning method=&quot;afterReturning&quot; pointcut=&quot;execution(* com.itheima.aop.*.*(..))&quot;/&gt;--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;aop:around method=&quot;around&quot; pointcut=&quot;execution(* com.itheima.aop.*.*(..))&quot;/&gt;</span></span><br><span class="line"><span class="comment">            &lt;aop:after-throwing method=&quot;afterThrowing&quot; pointcut=&quot;execution(* com.itheima.aop.*.*(..))&quot;/&gt;</span></span><br><span class="line"><span class="comment">            &lt;aop:after method=&quot;after&quot; pointcut=&quot;execution(* com.itheima.aop.*.*(..))&quot;/&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AopTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TargetInterface target;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        target.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="XML配置AOP详解"><a href="#XML配置AOP详解" class="headerlink" title="XML配置AOP详解"></a>XML配置AOP详解</h4><p><strong>切点表达式的写法</strong></p>
<p>表达式语法：</p>
<p><code>execution([修饰符] 返回值类型 包名.类名.方法名(参数))</code></p>
<ul>
<li>访问修饰符可以省略</li>
<li>返回值类型、包名、类名、方法名可以使用星号<code>*</code> 代表任意</li>
<li>包名与类名之间一个点 <code>.</code> 代表当前包下的类，两个点 <code>..</code> 表示当前包及其子包下的类</li>
<li>参数列表可以使用两个点 <code>..</code> 表示任意个数，任意类型的参数列表</li>
</ul>
<p>例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--execution([修饰符] 返回值类型 包名.类名.方法名(参数))--&gt;</span></span><br><span class="line">execution(public void com.itheima.aop.Target.method())</span><br><span class="line">execution(void com.itheima.aop.Target.*(..))</span><br><span class="line">execution(* com.itheima.aop.*.*(..))</span><br><span class="line">execution(* com.itheima.aop..*.*(..))</span><br><span class="line">execution(* *..*.*(..))</span><br></pre></td></tr></table></figure>



<p><strong>通知的类型</strong></p>
<p>通知的配置语法：</p>
<p><code>&lt;aop:通知类型 method=“切面类中方法名” pointcut=“切点表达式&quot;&gt;&lt;/aop:通知类型&gt;</code></p>
<p>通知的类型：前置通知、后置通知、环绕通知（应用：记录方法所用时间）、异常抛出通知、最终通知</p>
<img src="https://pic.imgdb.cn/item/625b018c239250f7c5b788f2.jpg" style="zoom:55%;" />

<p><strong>切点表达式的抽取</strong></p>
<p>当多个增强的切点表达式相同时，可以将切点表达式进行抽取，在增强中使用 pointcut-ref 属性代替 pointcut 属性来引用抽取后的切点表达式。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--声明切面--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAspect&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--抽取切点表达式--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;myPointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.itheima.aop.*.*(..))&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:pointcut</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--切面：切点+通知--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;around&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointcut&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;after&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointcut&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="基于注解的AOP开发"><a href="#基于注解的AOP开发" class="headerlink" title="基于注解的AOP开发"></a>基于注解的AOP开发</h3><h4 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h4><p>基于注解的aop开发步骤：</p>
<ul>
<li><p>创建目标接口和目标类（内部有切点）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Target</span> <span class="keyword">implements</span> <span class="title class_">TargetInterface</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;save running.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TargetInterface</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建切面类（内部有增强方法）</p>
</li>
<li><p>将目标类和切面类的对象创建权交给 spring（<code>@component(&quot;xxx&quot;)</code>）</p>
</li>
<li><p>在切面类中使用注解配置织入关系（<code>@aspect</code>，<code>@Before</code>，<code>@Around</code>…）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;myAspect&quot;)</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">//标注当前MyAspect是一个切面类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置前置通知</span></span><br><span class="line">    <span class="comment">//@Before(&quot;execution(* com.itheima.anno.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置增强..........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;后置增强..........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Proceeding JoinPoint:  正在执行的连接点===切点</span></span><br><span class="line">    <span class="comment">//@Around(&quot;execution(* com.itheima.anno.*.*(..))&quot;)</span></span><br><span class="line">    <span class="meta">@Around(&quot;pointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕前增强....&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">proceed</span> <span class="operator">=</span> pjp.proceed();<span class="comment">//切点方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;环绕后增强....&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;异常抛出增强..........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@After(&quot;execution(* com.itheima.anno.*.*(..))&quot;)</span></span><br><span class="line">    <span class="meta">@After(&quot;MyAspect.pointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;最终增强..........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义切点表达式</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.itheima.anno.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointcut</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在配置文件中<strong>开启组件扫描和 AOP 的自动代理</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--组件扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.itheima.anno&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--aop自动代理--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;classpath:applicationContext-anno.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnoTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TargetInterface target;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        target.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="注解配置AOP详解"><a href="#注解配置AOP详解" class="headerlink" title="注解配置AOP详解"></a>注解配置AOP详解</h4><p><strong>注解通知的类型</strong></p>
<p>通知的配置语法：<code>@通知注解(“切点表达式&quot;)</code></p>
<p><img src="https://pic.imgdb.cn/item/625b0d63239250f7c5c6694f.jpg"></p>
<p><strong>切点表达式的抽取</strong></p>
<p>同 xml 配置 aop 一样，我们可以将切点表达式抽取。抽取方式是在切面内定义方法，在该方法上使用<code>@Pointcut</code>注解定义切点表达式，然后在在增强注解中进行引用。具体如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;myAspect&quot;)</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">//标注当前MyAspect是一个切面类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line">    <span class="comment">//Proceeding JoinPoint:  正在执行的连接点===切点</span></span><br><span class="line">    <span class="comment">//@Around(&quot;execution(* com.itheima.anno.*.*(..))&quot;)</span></span><br><span class="line">    <span class="meta">@Around(&quot;pointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕前增强....&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">proceed</span> <span class="operator">=</span> pjp.proceed();<span class="comment">//切点方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;环绕后增强....&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@After(&quot;execution(* com.itheima.anno.*.*(..))&quot;)</span></span><br><span class="line">    <span class="meta">@After(&quot;MyAspect.pointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;最终增强..........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义切点表达式</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.itheima.anno.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointcut</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM04 —— Interceptor</title>
    <url>/2022/04/16/Interceptor/</url>
    <content><![CDATA[<p>本文记录了SpringMVC拦截器的相关概念和简单使用方法</p>
<span id="more"></span>

<h3 id="拦截器（interceptor）的作用"><a href="#拦截器（interceptor）的作用" class="headerlink" title="拦截器（interceptor）的作用"></a>拦截器（interceptor）的作用</h3><p>Spring MVC 的拦截器类似于 Servlet 开发中的过滤器 Filter，用于对处理器进行<strong>预处理</strong>和<strong>后处理</strong>。</p>
<p>将拦截器按一定的顺序联结成一条链，这条链称为拦截器链（Interceptor Chain）。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。拦截器也是AOP思想的具体实现。</p>
<h3 id="拦截器和过滤器的区别"><a href="#拦截器和过滤器的区别" class="headerlink" title="拦截器和过滤器的区别"></a>拦截器和过滤器的区别</h3><p><img src="https://pic.imgdb.cn/item/625a7abb239250f7c5b1a25f.jpg"></p>
<h3 id="拦截器简单使用"><a href="#拦截器简单使用" class="headerlink" title="拦截器简单使用"></a>拦截器简单使用</h3><p>自定义拦截器很简单，只有如下三步：</p>
<ul>
<li><p>创建拦截器类实现<code>HandlerInterceptor</code>接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterceptor1</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="comment">//在目标方法执行之前 执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;preHandle.....&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">param</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;param&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;yes&quot;</span>.equals(param))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            request.getRequestDispatcher(<span class="string">&quot;/error.jsp&quot;</span>).forward(request,response);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//返回true代表放行  返回false代表不放行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在目标方法执行之后 视图对象返回之前执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> &#123;</span><br><span class="line">        modelAndView.addObject(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;itheima&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;postHandle...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在流程都执行完毕后 执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterCompletion....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置拦截器（spring-mvc.xml）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置拦截器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--对哪些资源执行拦截操作--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.interceptor.MyInterceptor1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>测试拦截器的拦截效果</p>
</li>
</ul>
<p><strong>多拦截器操作</strong></p>
<p>拦截的顺序与在配置文件（spring-mvc.xml）中配置的顺序有关</p>
<h3 id="拦截器方法说明"><a href="#拦截器方法说明" class="headerlink" title="拦截器方法说明"></a>拦截器方法说明</h3><img src="https://pic.imgdb.cn/item/625a7b7f239250f7c5b32054.jpg" style="zoom: 50%;" />
]]></content>
      <categories>
        <category>SSM</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM03 —— 集成Web,SpringMVC</title>
    <url>/2022/04/15/SSM03/</url>
    <content><![CDATA[<p>概述：本文记录了Spring与Web环境的集成与SpringMVC的简介和组件解析</p>
<span id="more"></span>

<h3 id="Spring集成Web环境"><a href="#Spring集成Web环境" class="headerlink" title="Spring集成Web环境"></a>Spring集成Web环境</h3><h4 id="ApplicationContext应用上下文获取方式"><a href="#ApplicationContext应用上下文获取方式" class="headerlink" title="ApplicationContext应用上下文获取方式"></a>ApplicationContext应用上下文获取方式</h4><p>应用上下文对象是通过<code>new ClasspathXmlApplicationContext(spring配置文件)</code> 方式获取的，但是每次从容器中获得Bean时都要编写<code>new ClasspathXmlApplicationContext(spring配置文件)</code> ，这样的弊端是配置文件加载多次，应用上下文对象创建多次。</p>
<p>在Web项目中，可以使用<code>ServletContextListener</code>监听Web应用的启动，我们可以在Web应用启动时，就加载Spring的配置文件，创建应用上下文对象<code>ApplicationContext</code>，在将其存储到最大的域<code>servletContext</code>域中，这样就可以在任意位置从域中获得应用上下文<code>ApplicationContext</code>对象了。</p>
<h4 id="Spring提供获取应用上下文的工具"><a href="#Spring提供获取应用上下文的工具" class="headerlink" title="Spring提供获取应用上下文的工具"></a>Spring提供获取应用上下文的工具</h4><p>上面的分析不用手动实现，Spring提供了一个监听器<code>ContextLoaderListener</code>就是对上述功能的封装，该监听器内部加载Spring配置文件，创建应用上下文对象，并存储到<code>ServletContext</code>域中，提供了一个客户端工具<code>WebApplicationContextUtils</code>供使用者获得应用上下文对象。<br>所以我们需要做的只有两件事：</p>
<ul>
<li><strong>在web.xml中配置ContextLoaderListener监听器（导入spring-web坐标）</strong></li>
<li><strong>使用WebApplicationContextUtils获得应用上下文对象ApplicationContext</strong></li>
</ul>
<h4 id="导入Spring集成Web的坐标"><a href="#导入Spring集成Web的坐标" class="headerlink" title="导入Spring集成Web的坐标"></a>导入Spring集成Web的坐标</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="配置ContextLoaderListener监听器"><a href="#配置ContextLoaderListener监听器" class="headerlink" title="配置ContextLoaderListener监听器"></a>配置ContextLoaderListener监听器</h4><p>web.xml中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--全局参数--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Spring的监听器--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span></span><br><span class="line">        org.springframework.web.context.ContextLoaderListener</span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="通过工具获得应用上下文对象"><a href="#通过工具获得应用上下文对象" class="headerlink" title="通过工具获得应用上下文对象"></a>通过工具获得应用上下文对象</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> WebApplicationContextUtils.getWebApplicationContext(servletContext);</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;id&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="SpringMVC简介"><a href="#SpringMVC简介" class="headerlink" title="SpringMVC简介"></a>SpringMVC简介</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>SpringMVC 是一种基于 Java 的实现 MVC 设计模型的请求驱动类型的轻量级 Web 框架，属于SpringFrameWork 的后续产品，已经融合在 Spring Web Flow 中。</p>
<p>SpringMVC 已经成为目前最主流的MVC框架之一，并且随着Spring3.0 的发布，全面超越 Struts2，成为最优秀的 MVC 框架。它通过一套注解，让一个简单的 Java 类成为处理请求的控制器，而无须实现任何接口。同时它还支持 RESTful 编程风格的请求。</p>
<h4 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h4><p>需求：客户端发起请求，服务器端接收请求，执行逻辑并进行视图跳转</p>
<p><img src="https://pic.imgdb.cn/item/6259237a239250f7c59923d8.jpg"></p>
<p>步骤：</p>
<ul>
<li><p>导入SpringMVC相关坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Spring坐标--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--SpringMVC坐标--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Servlet坐标--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Jsp坐标--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置SpringMVC核心控制器DispathcerServlet (web.xml中)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置SpringMVC的前端控制器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建Controller类和视图页面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Controller save running....&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>视图页面xxx.jsp</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Success!&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>


</li>
<li><p>使用注解配置Controller类中业务方法的映射地址</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求地址  http://localhost:8080/user/quick</span></span><br><span class="line">    <span class="meta">@RequestMapping(value=&quot;/quick&quot;,method = RequestMethod.GET,params = &#123;&quot;username&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Controller save running....&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置SpringMVC核心文件 spring-mvc.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span> <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.alibaba.com/schema/stat&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.alibaba.com/schema/stat http://www.alibaba.com/schema/stat.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--Controller的组件扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.itheima&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置内部资源视图解析器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--  /jsp/success.jsp  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/jsp/&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>客户端发起请求测试</p>
</li>
</ul>
<h4 id="SpringMVC流程图示"><a href="#SpringMVC流程图示" class="headerlink" title="SpringMVC流程图示"></a>SpringMVC流程图示</h4><p><img src="https://pic.imgdb.cn/item/6259286d239250f7c5a24ad3.jpg"></p>
<h3 id="SpringMVC组件解析"><a href="#SpringMVC组件解析" class="headerlink" title="SpringMVC组件解析"></a>SpringMVC组件解析</h3><h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><p><img src="https://pic.imgdb.cn/item/625928bf239250f7c5a2fd19.jpg"></p>
<ol>
<li>用户发送请求至前端控制器DispatcherServlet。</li>
<li>DispatcherServlet收到请求调用HandlerMapping处理器映射器。</li>
<li>处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。 </li>
<li>DispatcherServlet调用HandlerAdapter处理器适配器。</li>
<li>HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。 </li>
<li>Controller执行完成返回ModelAndView。 </li>
<li>HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。</li>
<li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器。</li>
<li>ViewReslover解析后返回具体View。 </li>
<li>DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。DispatcherServlet响应用户。</li>
</ol>
<h4 id="SpringMVC组件解析-1"><a href="#SpringMVC组件解析-1" class="headerlink" title="SpringMVC组件解析"></a>SpringMVC组件解析</h4><ol>
<li><strong>前端控制器：DispatcherServlet</strong></li>
</ol>
<p>  用户请求到达前端控制器，它就相当于 MVC 模式中的 C，DispatcherServlet 是整个流程控制的中心，由它调用其它组件处理用户的请求，DispatcherServlet 的存在降低了组件之间的耦合性。</p>
<ol start="2">
<li><strong>处理器映射器：HandlerMapping</strong></li>
</ol>
<p>  HandlerMapping 负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</p>
<ol start="3">
<li><strong>处理器适配器：HandlerAdapter</strong></li>
</ol>
<p>  通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。</p>
<ol start="4">
<li><strong>处理器：Handler</strong></li>
</ol>
<p>  它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由Handler 对具体的用户请求进行处理。</p>
<ol start="5">
<li><p><strong>视图解析器：View Resolver</strong><br> View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名，即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。</p>
</li>
<li><p><strong>视图：View</strong><br> SpringMVC 框架提供了很多的 View 视图类型的支持，包括：jstlView、freemarkerView、pdfView等。最常用的视图就是 jsp。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面</p>
</li>
</ol>
<h4 id="SpringMVC注解解析"><a href="#SpringMVC注解解析" class="headerlink" title="SpringMVC注解解析"></a>SpringMVC注解解析</h4><p><code>@RequestMapping</code><br>作用：用于建立请求 URL 和处理请求方法之间的对应关系<br>位置：</p>
<ul>
<li><p>类上，请求URL 的第一级访问目录。此处不写的话，就相当于应用的根目录</p>
</li>
<li><p>方法上，请求 URL 的第二级访问目录，与类上的使用@ReqquestMapping标注的一级目录一起组成访问虚拟路径</p>
</li>
<li><p>属性：</p>
<ul>
<li><code>value</code>：用于指定请求的URL。它和path属性的作用是一样的</li>
<li><code>method</code>：用于指定请求的方式</li>
<li><code>params</code>：用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的key和value必须和配置的一模一样</li>
</ul>
<p>例如：</p>
<ul>
<li><code>params = &#123;&quot;accountName&quot;&#125;</code>，表示请求参数必须有accountName</li>
<li><code>params = &#123;&quot;moeny!100&quot;&#125;</code>，表示请求参数中money不能是100</li>
</ul>
</li>
</ul>
<ol>
<li><p>mvc命名空间引入</p>
<p>命名空间：</p>
<p><code>xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</code><br><code>xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;</code><br>约束地址：</p>
<p><code>http://www.springframework.org/schema/context</code><br><code>http://www.springframework.org/schema/context/spring-context.xsd</code><br><code>http://www.springframework.org/schema/mvc</code><br><code>http://www.springframework.org/schema/mvc/spring-mvc.xsd</code></p>
</li>
<li><p><strong>组件扫描</strong></p>
<p>SpringMVC基于Spring容器，所以在进行SpringMVC操作时，需要将Controller存储到Spring容器中，如果使用<code>@Controller</code>注解标注的话，就需要使用<code>&lt;context:component-scan base-package=&quot;com.itheima.controller&quot;/&gt;</code>进行组件扫描。</p>
</li>
</ol>
<h4 id="SpringMVC的XML配置解析"><a href="#SpringMVC的XML配置解析" class="headerlink" title="SpringMVC的XML配置解析"></a>SpringMVC的XML配置解析</h4><p><strong>视图解析器</strong><br>SpringMVC有默认组件配置，默认组件都是<code>DispatcherServlet.properties</code>配置文件中配置的，该配置文件地址<code>org/springframework/web/servlet/DispatcherServlet.properties</code>，该文件中配置了默认的视图解析器，如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">org.springframework.web.servlet.ViewResolver</span>=<span class="string">org.springframework.web.servlet.view.InternalResourceViewResolver</span></span><br></pre></td></tr></table></figure>

<p>翻看该解析器源码，可以看到该解析器的默认设置，如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REDIRECT_URL_PREFIX = &quot;redirect:&quot; --重定向前缀</span><br><span class="line">FORWARD_URL_PREFIX = &quot;forward:&quot; --转发前缀（默认值）</span><br><span class="line">prefix = &quot;&quot;; --视图名称前缀</span><br><span class="line">suffix = &quot;&quot;; --视图名称后缀</span><br></pre></td></tr></table></figure>

<p>我们可以通过属性注入的方式修改视图的的前后缀</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置内部资源视图解析器--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/views/&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="SpringMVC的数据响应"><a href="#SpringMVC的数据响应" class="headerlink" title="SpringMVC的数据响应"></a>SpringMVC的数据响应</h3><h4 id="数据响应方式1：页面跳转"><a href="#数据响应方式1：页面跳转" class="headerlink" title="数据响应方式1：页面跳转"></a>数据响应方式1：页面跳转</h4><ul>
<li><p><strong>直接返回字符串</strong></p>
<p>此种方式会将返回的字符串与视图解析器的前后缀拼接后跳转</p>
<img src="https://pic.imgdb.cn/item/62596ab9239250f7c51f10d4.jpg" style="zoom:80%;" />

<p>返回带有前缀的字符串：</p>
<p>转发：<code>forward:/WEB-INF/views/index.jsp</code></p>
<p>重定向：<code>redirect:/index.jsp</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原始的形式</span></span><br><span class="line"><span class="comment">// 请求地址  http://localhost:8080/user/quick</span></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/quick&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Controller save running....&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;<span class="comment">//这里返回的字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>通过ModelAndView对象返回</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/quick2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">save2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Model:模型 作用封装数据</span></span><br><span class="line"><span class="comment">        View：视图 作用展示数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">    <span class="comment">//设置模型数据</span></span><br><span class="line">    modelAndView.addObject(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">    <span class="comment">//设置视图名称</span></span><br><span class="line">    modelAndView.setViewName(<span class="string">&quot;success&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/quick3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">save3</span><span class="params">(ModelAndView modelAndView)</span>&#123;</span><br><span class="line">    modelAndView.addObject(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;itheima&quot;</span>);</span><br><span class="line">    modelAndView.setViewName(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/quick4&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">save4</span><span class="params">(Model model)</span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;博学谷&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>向request域存储数据</strong></p>
<p>在进行转发时，往往要向request域中存储数据，在jsp页面中显示，那么Controller中怎样向request域中存储数据呢？</p>
<p>（1）通过SpringMVC框架注入的request对象<code>setAttribute()</code>方法设置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/quick5&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">save5</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">    request.setAttribute(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;酷丁鱼&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）通过ModelAndView的<code>addObject()</code>方法设置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/quick3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">save3</span><span class="params">(ModelAndView modelAndView)</span>&#123;</span><br><span class="line">    modelAndView.addObject(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;itheima&quot;</span>);</span><br><span class="line">    modelAndView.setViewName(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="数据响应方式2：回写数据"><a href="#数据响应方式2：回写数据" class="headerlink" title="数据响应方式2：回写数据"></a>数据响应方式2：回写数据</h4><ul>
<li><p><strong>直接返回字符串</strong></p>
<p>Web基础阶段，客户端访问服务器端，如果想直接回写字符串作为响应体返回的话，只需要使用<code>response.getWriter().print(“hello world”)</code> 即可，那么在Controller中想直接回写字符串该怎样呢？<br>（1） 通过SpringMVC框架注入的response对象，使用<code>response.getWriter().print(“hello world”)</code> 回写数据，此时不需要视图跳转，业务方法返回值为void。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/quick6&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save6</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    response.getWriter().print(<span class="string">&quot;hello itcast&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）将需要回写的字符串直接返回，但此时需要通过<code>@ResponseBody</code>注解告知SpringMVC框架，方法返回的字符串不是跳转是直接在http响应体中返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意跟直接返回字符串的原始字符串很像，但是多了@ResponseBody注解</span></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/quick7&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span>  <span class="comment">//告知SpringMVC框架 不进行视图跳转 直接进行数据响应</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">save7</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello itheima&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在异步项目中，客户端与服务器端往往要进行json格式字符串交互，此时我们可以手动拼接json字符串返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/quick8&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">save8</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;\&quot;username\&quot;:\&quot;zhangsan\&quot;,\&quot;age\&quot;:18&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述方式手动拼接json格式字符串的方式很麻烦，开发中往往要将复杂的java对象转换成json格式的字符串，我们可以使用web阶段学习过的json转换工具jackson进行转换，导入jackson坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过jackson转换json字符串，回写字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/quick9&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">save9</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setUsername(<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">30</span>);</span><br><span class="line">    <span class="comment">//使用json的转换工具将对象转换成json格式字符串在返回</span></span><br><span class="line">    <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> objectMapper.writeValueAsString(user);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> json;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>返回对象或集合</strong></p>
<p>通过SpringMVC帮助我们对对象或集合进行json字符串的转换并回写，为处理器适配器配置消息转换参数，指定使用jackson进行对象或集合的转换，因此需要在spring-mvc.xml中进行如下配置：</p>
<p>（spring-mvc.xml）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;messageConverters&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/quick10&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="comment">//期望SpringMVC自动将User转换成json格式的字符串</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">save10</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setUsername(<span class="string">&quot;lisi2&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在方法上添加<code>@ResponseBody</code>就可以返回json格式的字符串，但是这样配置比较麻烦，配置的代码比较多，因此，我们可以使用mvc的注解驱动代替上述配置。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--mvc的注解驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">&quot;conversionService&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>在 SpringMVC 的各个组件中，<strong>处理器映射器、处理器适配器、视图解析器称</strong>为 SpringMVC 的三大组件。</p>
<p>使用<code>&lt;mvc:annotation-driven&gt;</code>自动加载 <code>RequestMappingHandlerMapping</code>（处理映射器）和<code>RequestMappingHandlerAdapter</code>（处理适配器），可用在Spring-xml.xml配置文件中使用<code>&lt;mvc:annotation-driven&gt;</code>替代注解处理器和适配器的配置。同时使用<code>&lt;mvc:annotation-driven&gt;</code>默认底层就会集成jackson进行对象或集合的json格式字符串的转换</p>
</li>
</ul>
<h4 id="SpringMVC获得请求数据"><a href="#SpringMVC获得请求数据" class="headerlink" title="SpringMVC获得请求数据"></a>SpringMVC获得请求数据</h4><h4 id="获得请求参数"><a href="#获得请求参数" class="headerlink" title="获得请求参数"></a>获得请求参数</h4><p>客户端请求参数的格式是：<code>name=value&amp;name=value… …</code></p>
<p>服务器端要获得请求的参数，有时还需要进行数据的封装，SpringMVC可以接收如下类型的参数：</p>
<ul>
<li>基本类型参数</li>
<li>POJO类型参数</li>
<li>数组类型参数</li>
<li>集合类型参数</li>
</ul>
<h4 id="获得基本类型参数"><a href="#获得基本类型参数" class="headerlink" title="获得基本类型参数"></a>获得基本类型参数</h4><p>Controller中的业务方法的参数名称要与请求参数的name一致，参数值会自动映射匹配。</p>
<p><code>http://localhost:8080/itheima_spring_mvc/user/quick11?username=zhangsan&amp;age=12</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/quick11&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span>	<span class="comment">//代表不进行页面跳转</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save11</span><span class="params">(String username,<span class="type">int</span> age)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    System.out.println(username);</span><br><span class="line">    System.out.println(age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="获得POJO类型参数"><a href="#获得POJO类型参数" class="headerlink" title="获得POJO类型参数"></a>获得POJO类型参数</h4><p>Controller中的业务方法的POJO参数的属性名与请求参数的name一致，参数值会自动映射匹配。</p>
<p><code>http://localhost:8080/itheima_spring_mvc/user/quick12?username=zhangsan&amp;age=12</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/quick12&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save12</span><span class="params">(User user)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获得数组类型参数"><a href="#获得数组类型参数" class="headerlink" title="获得数组类型参数"></a>获得数组类型参数</h4><p>Controller中的业务方法数组名称与请求参数的name一致，参数值会自动映射匹配。</p>
<p><code>http://localhost:8080/itheima_spring_mvc/user/quick13?strs=111&amp;strs=222&amp;strs=333</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/quick13&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save13</span><span class="params">(String[] strs)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    System.out.println(Arrays.asList(strs));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获得集合类型参数"><a href="#获得集合类型参数" class="headerlink" title="获得集合类型参数"></a>获得集合类型参数</h4><p>获得集合参数时，要将集合参数包装到一个POJO中才可以。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/user/quick14&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">        &lt;%--表明是第几个User对象的username age--%&gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;userList[0].username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;userList[0].age&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;userList[1].username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;userList[1].age&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VO</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;User&gt; userList;</span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">getUserList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserList</span><span class="params">(List&lt;User&gt; userList)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userList = userList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;VO&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;userList=&quot;</span> + userList +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/quick14&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save14</span><span class="params">(VO vo)</span> <span class="keyword">throws</span> IOException &#123;<span class="comment">//ViewObject</span></span><br><span class="line">    System.out.println(vo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当使用ajax提交时，可以指定contentType为json形式，那么在方法参数位置使用<code>@RequestBody</code>可以直接接收集合数据而无需使用POJO进行包装。</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">    &lt;script src=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/js/jquery-3.3.1.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="type">var</span> <span class="variable">userList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">        userList.push(&#123;username:<span class="string">&quot;zhangsan&quot;</span>,age:<span class="number">18</span>&#125;);</span><br><span class="line">        userList.push(&#123;username:<span class="string">&quot;lisi&quot;</span>,age:<span class="number">28</span>&#125;);</span><br><span class="line"></span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            type:<span class="string">&quot;POST&quot;</span>,</span><br><span class="line">            url:<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/user/quick15&quot;</span>,</span><br><span class="line">            data:JSON.stringify(userList),</span><br><span class="line">            contentType:<span class="string">&quot;application/json;charset=utf-8&quot;</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/quick15&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save15</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;User&gt; userList)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    System.out.println(userList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：通过谷歌开发者工具抓包发现，没有加载到jquery文件，原因是SpringMVC的前端控制器<br><code>DispatcherServlet</code>的<code>url-pattern</code>配置的是<code>/</code>,代表对所有的资源都进行过滤操作，我们可以通过以下两种方式指定放行静态资源：</p>
<ul>
<li>在spring-mvc.xml配置文件中指定放行的资源<code>&lt;mvc:resources mapping=&quot;/js/**&quot; location=&quot;/js/&quot;/&gt;</code> </li>
<li>使用<code>&lt;mvc:default-servlet-handler/&gt;</code>标签</li>
</ul>
<h4 id="请求数据乱码问题"><a href="#请求数据乱码问题" class="headerlink" title="请求数据乱码问题"></a>请求数据乱码问题</h4><p>当post请求时，数据会出现乱码，我们可以设置一个过滤器来进行编码的过滤。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置全局过滤的filter--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="参数绑定注解-requestParam"><a href="#参数绑定注解-requestParam" class="headerlink" title="参数绑定注解@requestParam"></a>参数绑定注解<code>@requestParam</code></h4><p>当请求的参数名称与Controller的业务方法参数名称不一致时，就需要通过<code>@RequestParam</code>注解显示的绑定。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/quick16&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save16</span><span class="params">(<span class="meta">@RequestParam(value=&quot;name&quot;)</span> String username)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    System.out.println(username);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解@RequestParam还有如下参数可以使用：</p>
<ul>
<li>value：与请求参数名称</li>
<li>required：此在指定的请求参数是否必须包括，默认是true，提交时如果没有此参数则报错</li>
<li>defaultValue：当没有指定请求参数时，则使用指定的默认值赋值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/quick16&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save16</span><span class="params">(<span class="meta">@RequestParam(value=&quot;name&quot;,required = false,defaultValue = &quot;itcast&quot;)</span> String username)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    System.out.println(username);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="获得Rest风格的参数"><a href="#获得Rest风格的参数" class="headerlink" title="获得Rest风格的参数"></a>获得Rest风格的参数</h4><p>REST（Representional State Transfer）,表现形式状态转换</p>
<p><strong>Rest</strong>是一种软件<strong>架构风格</strong>、<strong>设计风格</strong>，而不是标准，只是提供了一组设计原则和约束条件。主要用于客户端和服务器交互类的软件，基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存机制等。</p>
<p>根据Rest风格对资源进行访问称为<strong>Restful</strong></p>
<p>描述模块的名称通常使用复数，也就是加s的格式描述，表示此类资源而非单个资源，例如：users，books，accounts</p>
<p><strong>传统风格资源描述形式：</strong></p>
<p><code>http://localhost/user/getByID?id=1</code></p>
<p><code>http://localhost/user/saveUser</code></p>
<p><strong>Rest风格描述形式：</strong></p>
<p><code>http://localhost/user/1</code></p>
<p><code>http://localhost/user</code></p>
<p><strong>优点：</strong></p>
<ul>
<li>隐藏资源的访问行为，无法通过地址得知对资源是何种操作</li>
<li>书写简化</li>
</ul>
<p><strong>Rest</strong>风格的请求是使用<strong>“url+请求方式”</strong>表示一次请求目的的，HTTP 协议里面四个表示操作方式的动词如下：</p>
<ul>
<li><code>GET</code>：用于获取资源</li>
<li><code>POST</code>：用于新建资源</li>
<li><code>PUT</code>：用于更新资源</li>
<li><code>DELETE</code>：用于删除资源</li>
</ul>
<p>例如：</p>
<ul>
<li><code>/user/1 GET</code> ： 得到 id &#x3D; 1 的 user</li>
<li><code>/user/1 DELETE</code>： 删除 id &#x3D; 1 的 user</li>
<li><code>/user/1 PUT</code>： 更新 id &#x3D; 1 的 user</li>
<li><code>/user POST</code>： 新增 user</li>
</ul>
<p>上述url地址<code>/user/1</code>中的1就是要获得的请求参数，在SpringMVC中可以使用占位符进行参数绑定。地址<code>/user/1</code>可以写成<code>/user/&#123;id&#125;</code>，占位符<code>&#123;id&#125;</code>对应的就是1的值。</p>
<p>在业务方法中我们可以使用<code>@PathVariable</code>注解进行占位符的匹配获取工作。</p>
<p><code>http://localhost:8080/itheima_spring_mvc/user/quick17/zhangsan</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/quick17/&#123;name&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save17</span><span class="params">(<span class="meta">@PathVariable(value=&quot;name&quot;)</span> String username)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    System.out.println(username);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Restful快速开发：</p>
<ul>
<li>名称：<code>@GetMapping</code> <code>@POSTMapping</code> <code>@ PutMapping</code> <code>@DeleteMapping</code></li>
<li>类型：方法注解</li>
<li>位置：基于SpringMVC的Restful开发控制器方法定义上方</li>
<li>作用：设置当前控制器方法请求访问路径与请求动作，每种对应一个请求动作，例如@GetMapping对应GET请求</li>
<li>属性：value(默认)：请求访问路径</li>
</ul>
<h4 id="自定义类型转换器"><a href="#自定义类型转换器" class="headerlink" title="自定义类型转换器"></a>自定义类型转换器</h4><p>SpringMVC 默认已经提供了一些常用的类型转换器，例如客户端提交的字符串转换成int型进行参数设置。</p>
<p>但是不是所有的数据类型都提供了转换器，没有提供的就需要自定义转换器，例如：日期类型的数据就需要自定义转换器。</p>
<p>自定义类型转换器的开发步骤：</p>
<ul>
<li><p>定义转换器类实现Converter接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.core.convert.converter.Converter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateConverter</span> <span class="keyword">implements</span> <span class="title class_">Converter</span>&lt;String, Date&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">convert</span><span class="params">(String dateStr)</span> &#123;</span><br><span class="line">        <span class="comment">//将日期字符串转换成日期对象 返回</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">format</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            date = format.parse(dateStr);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> date;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在配置文件中声明转换器（spring-mvc.xml）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--声明转换器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;conversionService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;converters&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.converter.DateConverter&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>&lt;annotation-driven&gt;</code>中引用转换器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--mvc的注解驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">&quot;conversionService&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/quick18&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save18</span><span class="params">(Date date)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    System.out.println(date);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="获得Servlet相关API"><a href="#获得Servlet相关API" class="headerlink" title="获得Servlet相关API"></a>获得Servlet相关API</h4><p>SpringMVC支持使用原始ServletAPI对象作为控制器方法的参数进行注入，常用的对象如下：</p>
<ul>
<li>HttpServletRequest</li>
<li>HttpServletResponse</li>
<li>HttpSession</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/quick19&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save19</span><span class="params">(HttpServletRequest request, HttpServletResponse response, HttpSession session)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    System.out.println(request);</span><br><span class="line">    System.out.println(response);</span><br><span class="line">    System.out.println(session);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获得请求头"><a href="#获得请求头" class="headerlink" title="获得请求头"></a>获得请求头</h4><p><code>@RequestHeader</code><br>使用<code>@RequestHeader</code>可以获得请求头信息，相当于web阶段学习的<code>request.getHeader(name)</code><br><code>@RequestHeader</code>注解的属性如下：</p>
<ul>
<li>value：请求头的名称</li>
<li>required：是否必须携带此请求头</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/quick20&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save20</span><span class="params">(<span class="meta">@RequestHeader(value = &quot;User-Agent&quot;,required = false)</span> String user_agent)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    System.out.println(user_agent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>@CookieValue</code><br>使用<code>@CookieValue</code>可以获得指定Cookie的值<br><code>@CookieValue</code>注解的属性如下：</p>
<ul>
<li>value：指定cookie的名称</li>
<li>required：是否必须携带此cookie</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/quick21&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save21</span><span class="params">(<span class="meta">@CookieValue(value = &quot;JSESSIONID&quot;)</span> String jsessionId)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    System.out.println(jsessionId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h4><p><strong>文件上传客户端三要素</strong></p>
<ul>
<li>表单项<code>type=“file”</code></li>
<li>表单的提交方式是post</li>
<li>表单的enctype属性是多部分表单形式，及<code>enctype=“multipart/form-data”</code></li>
</ul>
<p>upload.jsp</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">    &lt;form action=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/user/quick23&quot;</span> method=<span class="string">&quot;post&quot;</span> enctype=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span><br><span class="line">        名称&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;username&quot;</span>&gt;&lt;br/&gt;</span><br><span class="line">        文件&lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;uploadFile&quot;</span>&gt;&lt;br/&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><strong>文件上传原理</strong></p>
<ul>
<li>当form表单修改为多部分表单时，<code>request.getParameter()</code>将失效。</li>
<li><code>enctype=&quot;application/x-www-form-urlencoded&quot;</code>时，form表单的正文内容格式是：<br><code>key=value&amp;key=value&amp;key=value</code></li>
<li>当form表单的enctype取值为<code>Mutilpart/form-data</code>时，请求正文内容就变成多部分形式：</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/625987b9239250f7c55f72c1.jpg"></p>
<p><strong>单文件上传步骤</strong></p>
<ul>
<li><p>导入fileupload和io坐标 (pom.xml)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置文件上传解析器 (spring-mvc.xml)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置文件上传解析器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;500000&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>编写文件上传代码 (注意对应路径要有文件夹)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/quick22&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save22</span><span class="params">(String username, MultipartFile uploadFile,MultipartFile uploadFile2)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    System.out.println(username);</span><br><span class="line">    <span class="comment">//获得上传文件的名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> uploadFile.getOriginalFilename();</span><br><span class="line">    uploadFile.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;F:\\test\\&quot;</span>+originalFilename));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>多文件上传实现</strong></p>
<p>多文件上传，只需要将页面修改为多个文件上传项，将方法参数<code>MultipartFile</code>类型修改为<code>MultipartFile[]</code>即可</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/user/quick23&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">        名称<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        文件1<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;uploadFile&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        文件2<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;uploadFile&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/user/quick22&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">        名称<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        文件1<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;uploadFile&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        文件2<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;uploadFile2&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/quick23&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save23</span><span class="params">(String username, MultipartFile[] uploadFile)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    System.out.println(username);</span><br><span class="line">    <span class="keyword">for</span> (MultipartFile multipartFile : uploadFile) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> multipartFile.getOriginalFilename();</span><br><span class="line">        multipartFile.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;F:\\test\\&quot;</span>+originalFilename));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Spring环境搭建步骤"><a href="#Spring环境搭建步骤" class="headerlink" title="Spring环境搭建步骤"></a>Spring环境搭建步骤</h3><ul>
<li>创建工程（Project&amp;Module） </li>
<li>导入静态页面（jsp页面）</li>
<li>导入需要坐标（pom.xml） </li>
<li>创建包结构（controller、service、dao、domain、utils） </li>
<li>导入数据库脚本（见资料test.sql） </li>
<li>创建POJO类（见资料User.java和Role.java） </li>
<li>创建配置文件（applicationContext.xml、spring-mvc.xml、jdbc.properties、log4j.properties）</li>
</ul>
]]></content>
      <categories>
        <category>SSM</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM02 —— 数据源、注解、整合Junit</title>
    <url>/2022/04/14/SSM02/</url>
    <content><![CDATA[<p>概述：本文记录了Spring配置数据源、注解开发、整合Junit部分的基础知识</p>
<span id="more"></span>

<h3 id="Spring配置数据源"><a href="#Spring配置数据源" class="headerlink" title="Spring配置数据源"></a>Spring配置数据源</h3><h4 id="数据源（连接池）的作用"><a href="#数据源（连接池）的作用" class="headerlink" title="数据源（连接池）的作用"></a>数据源（连接池）的作用</h4><ul>
<li>数据源(连接池)是提高程序性能如出现的</li>
<li>事先实例化数据源，初始化部分连接资源</li>
<li>使用连接资源时从数据源中获取</li>
<li>使用完毕后将连接资源归还给数据源</li>
</ul>
<p>常见的数据源(连接池)：<strong>DBCP、C3P0、BoneCP、Druid</strong>等</p>
<h4 id="数据源的开发步骤"><a href="#数据源的开发步骤" class="headerlink" title="数据源的开发步骤"></a>数据源的开发步骤</h4><ul>
<li>导入数据源的坐标和数据库驱动坐标</li>
<li>创建数据源对象</li>
<li>设置数据源的基本连接数据</li>
<li>使用数据源获取连接资源和归还连接资源</li>
</ul>
<h4 id="数据源的手动创建"><a href="#数据源的手动创建" class="headerlink" title="数据源的手动创建"></a>数据源的手动创建</h4><p>需要导入：</p>
<p>（1）导入c3p0和druid的坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）导入MySQL数据库驱动坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.32<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>创建C3P0连接池</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//测试手动创建 c3p0 数据源</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ComboPooledDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>();</span><br><span class="line">    dataSource.setDriverClass(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">    dataSource.setJdbcUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/bjpowernode?useSSL=false&amp;serverTimezone=GMT%2B8&quot;</span>);</span><br><span class="line">    dataSource.setUser(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">    dataSource.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">    System.out.println(connection);</span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建Druid连接池</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//测试手动创建 druid 数据源</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">    dataSource.setDriverClassName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">    dataSource.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/bjpowernode?useSSL=false&amp;serverTimezone=GMT%2B8&quot;</span>);</span><br><span class="line">    dataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">    dataSource.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    <span class="type">DruidPooledConnection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">    System.out.println(connection);</span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提取jdbc.properties配置文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/bjpowernode?useSSL=false&amp;serverTimezone=GMT%2B8</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure>

<p>通过读取jdbc.properties配置文件创建连接池</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//测试手动创建 c3p0 数据源(加载properties配置文件)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//读取配置文件,这里使用资源绑定器ResourceBundle，读取类加载路径下的文件名</span></span><br><span class="line">    <span class="comment">//只需要基本名称，不需要带后缀</span></span><br><span class="line">    <span class="type">ResourceBundle</span> <span class="variable">rb</span> <span class="operator">=</span> ResourceBundle.getBundle(<span class="string">&quot;jdbc&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">driver</span> <span class="operator">=</span> rb.getString(<span class="string">&quot;jdbc.driver&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> rb.getString(<span class="string">&quot;jdbc.url&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> rb.getString(<span class="string">&quot;jdbc.username&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> rb.getString(<span class="string">&quot;jdbc.password&quot;</span>);</span><br><span class="line">    <span class="comment">//创建数据源对象  设置连接参数</span></span><br><span class="line">    <span class="type">ComboPooledDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>();</span><br><span class="line">    dataSource.setDriverClass(driver);</span><br><span class="line">    dataSource.setJdbcUrl(url);</span><br><span class="line">    dataSource.setUser(username);</span><br><span class="line">    dataSource.setPassword(password);</span><br><span class="line"></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">    System.out.println(connection);</span><br><span class="line">    connection.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>可以将DataSource的创建权交由Spring容器去完成</strong></p>
<ul>
<li>DataSource有无参构造方法，而Spring默认就是通过无参构造方法实例化对象的</li>
<li>DataSource要想使用需要通过set方法设置数据库连接信息，而Spring可以通过set方法进行字符串注入</li>
</ul>
<p>pom.xml中添加</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>新建applicationContext.xml在resources目录下，其中添加（依赖注入的set方式）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/bjpowernode?useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=GMT%2B8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试从容器中获取数据源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//测试Spring容器产生数据源对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">    <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> app.getBean(DataSource.class);</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">    System.out.println(connection);</span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>抽取jdbc配置文件</strong></p>
<p>applicationContext.xml加载jdbc.properties配置文件获得连接信息。</p>
<p>首先，需要引入context命名空间和约束路径：</p>
<ul>
<li><p>命名空间：<code>xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</code></p>
</li>
<li><p>约束路径：<code>http://www.springframework.org/schema/context</code></p>
</li>
</ul>
<p>​                        <code>http://www.springframework.org/schema/context/spring-context.xsd</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=</span></span><br><span class="line"><span class="tag">               <span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--加载外部的properties文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>要点：</p>
<p>Spring容器加载properties文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;xx.properties&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;key&#125;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Spring注解开发"><a href="#Spring注解开发" class="headerlink" title="Spring注解开发"></a>Spring注解开发</h3><h4 id="Spring原始注解"><a href="#Spring原始注解" class="headerlink" title="Spring原始注解"></a>Spring原始注解</h4><p>Spring是轻代码而重配置的框架，配置比较繁重，影响开发效率，所以注解开发是一种趋势，注解代替xml配置文件可以简化配置，提高开发效率。</p>
<p>Spring原始注解主要是替代<code>&lt;Bean&gt;</code>的配置</p>
<img src="https://pic.imgdb.cn/item/62585758239250f7c5b11cb3.jpg" style="zoom:50%;" />

<p>使用注解进行开发时，需要在applicationContext.xml中配置组件扫描，作用是指定哪个包及其子包下的Bean需要进行扫描以便识别使用注解配置的类、子段和方法</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--注解的组件扫描--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.itheima&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用<code>@Component</code>或<code>@Repository</code>标识UserDaoImpl需要Spring进行实例化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@Component(&quot;userDao&quot;)</span></span><br><span class="line"><span class="meta">@Repository(&quot;userDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;save running... ...&quot;</span>);</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>@Component</code>或<code>@Service</code>标识UserDaoImpl需要Spring进行实例化</p>
<p>使用<code>@Autowired</code>或者<code>@Autowired+@Qulifier</code>或者<code>@Resource</code>进行userDao的注入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@Component(&quot;userService&quot;)</span></span><br><span class="line"><span class="meta">@Service(&quot;userService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">	<span class="comment">/*@Autowired</span></span><br><span class="line"><span class="comment">	@Qualifier(&quot;userDao&quot;)*/</span></span><br><span class="line">	<span class="meta">@Resource(name=&quot;userDao&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> UserDao userDao;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">		userDao.save();</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>@Value</code>进行字符串注入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository(&quot;userDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">	<span class="meta">@Value(&quot;注入普通数据&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> String str;</span><br><span class="line">	<span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> String driver;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(str);</span><br><span class="line">		System.out.println(driver);</span><br><span class="line">		System.out.println(<span class="string">&quot;save running... ...&quot;</span>);</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>@Scope</code>标注Bean的范围</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="meta">@Scope(&quot;singleton&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">	<span class="comment">//此处省略代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>@PostConstruct</code>标注初始化方法，使用<code>@PreDestroy</code>标注销毁方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;初始化方法....&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@PreDestroy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;销毁方法.....&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Spring新注解"><a href="#Spring新注解" class="headerlink" title="Spring新注解"></a>Spring新注解</h4><p>使用上面的注解还不能全部替代xml配置文件，还需要使用注解替代的配置如下：</p>
<ul>
<li><p>非自定义的Bean的配置：<code>&lt;bean&gt;</code></p>
</li>
<li><p>加载properties文件的配置：<code>context:property-placeholder&gt;</code></p>
</li>
<li><p>组件扫描的配置：&lt;<code>context:component-scan</code>&gt;</p>
</li>
<li><p>引入其他文件：<code>&lt;import&gt;</code></p>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/62586c3d239250f7c5c6e657.jpg"></p>
<ul>
<li><p><code>@Configuration</code></p>
</li>
<li><p><code>@ComponentScan</code></p>
</li>
<li><p><code>@Import</code></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima&quot;)</span></span><br><span class="line"><span class="meta">@Import(&#123;DataSourceConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfiguration</span> &#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>@PropertySource</code></p>
</li>
<li><p><code>@value</code></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceConfiguration</span> &#123;</span><br><span class="line">	<span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> String driver;</span><br><span class="line">	<span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> String url;</span><br><span class="line">	<span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> String username;</span><br><span class="line">	<span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> String password;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>@Bean</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean(name=&quot;dataSource&quot;)</span></span><br><span class="line"><span class="keyword">public</span> DataSource <span class="title function_">getDataSource</span><span class="params">()</span> <span class="keyword">throws</span> PropertyVetoException &#123;</span><br><span class="line">	<span class="type">ComboPooledDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>();</span><br><span class="line">	dataSource.setDriverClass(driver);</span><br><span class="line">	dataSource.setJdbcUrl(url);</span><br><span class="line">	dataSource.setUser(username);</span><br><span class="line">	dataSource.setPassword(password);</span><br><span class="line">	<span class="keyword">return</span> dataSource; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试加载核心配置类创建Spring容器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAnnoConfiguration</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	<span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfiguration.class);</span><br><span class="line">	<span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) </span><br><span class="line">	applicationContext.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">	userService.save();</span><br><span class="line">	<span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> (DataSource) </span><br><span class="line">	applicationContext.getBean(<span class="string">&quot;dataSource&quot;</span>);</span><br><span class="line">	<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">	System.out.println(connection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Spring集成Junit"><a href="#Spring集成Junit" class="headerlink" title="Spring集成Junit"></a>Spring集成Junit</h3><p><strong>原始Junit测试Spring的问题</strong></p>
<p>在测试类中，每个测试方法都有以下两行代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line"><span class="type">IAccountService</span> <span class="variable">as</span> <span class="operator">=</span> ac.getBean(<span class="string">&quot;accountService&quot;</span>,IAccountService.class);</span><br></pre></td></tr></table></figure>

<p>这两行代码的作用是获取容器，如果不写的话，直接会提示空指针异常。所以又不能轻易删掉。</p>
<p><strong>解决思路</strong></p>
<ul>
<li>让SpringJunit负责创建Spring容器，但是需要将配置文件的名称告诉它</li>
<li>将需要进行测试Bean直接在测试类中进行注入</li>
</ul>
<p><strong>步骤：</strong></p>
<ul>
<li><p>导入spring集成Junit的坐标（pom.xml中）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>@Runwith</code>注解替换原来的运行期</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringJunitTest</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>@ContextConfiguration</code>指定配置文件或配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="comment">//加载spring核心配置文件</span></span><br><span class="line"><span class="comment">//@ContextConfiguration(value = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)</span></span><br><span class="line"><span class="comment">//加载spring核心配置类</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = &#123;SpringConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringJunitTest</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>@Autowired</code>注入需要测试的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = &#123;SpringConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringJunitTest</span> &#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> UserService userService; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建测试方法进行测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = &#123;SpringConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringJunitTest</span> &#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> UserService userService;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUserService</span><span class="params">()</span>&#123;</span><br><span class="line">		userService.save();</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>SSM</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM01 —— IoC,DI</title>
    <url>/2022/04/14/SSM01/</url>
    <content><![CDATA[<p>概述：本文记录了Spring的基础概念和基本配置方法</p>
<span id="more"></span>

<h3 id="Spring简介"><a href="#Spring简介" class="headerlink" title="Spring简介"></a>Spring简介</h3><h4 id="Spring是什么"><a href="#Spring是什么" class="headerlink" title="Spring是什么"></a>Spring是什么</h4><p>Spring是分层的Java SE&#x2F;EE 应用full-stack轻量级开源框架，以<strong>IoC</strong>（Inverse Of Control：反转控制）和<strong>AOP</strong>（Aspect Oriented Programming：面向切面编程）为内核</p>
<p>提供了<strong>展现层SpringMVC</strong>和<strong>持久层Spring JDBCTemplate</strong>以及<strong>业务层事务管理</strong>等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java EE企业应用开源框架。</p>
<h4 id="Spring的优势"><a href="#Spring的优势" class="headerlink" title="Spring的优势"></a>Spring的优势</h4><p>（1）方便解耦：简化开发 通过 Spring提供的 loC容器，可以将对象间的依赖关系交由 Spring 进行控制，避免硬编码所造成的过度耦合。用户也不必再为单例模式类、属性文件解析等这文些很底层的需求编写代码.可以更专注干上层的应用。 </p>
<p>（2）AOP编程的支持： 通过 Spring的 AOP 功能，方便进行面向切面编程，许多不容易用传统 OOP 实现的功能可以通过 AOP 轻松实现。 </p>
<p>（3）声明式事务的支持 ：可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活的进行事务管理，提高开发效率和质量。 </p>
<p>（4）方便程序的测试 ：可以用非容器依赖的编程方式进讲行几平所有的测试工作，测试不再是昂贵的操作，而是随手可做的事情。</p>
<p>（5）方便集成各种优秀框架： Spring对各种优秀框架（Struts、 Hibernate、Hessian、Quartz等）的支持。</p>
<p>（ 6）降低 JavaEE API的使用难度： Spring对 JavaEE API（如JDBC、JavaMail、远程调用等）进行了薄薄的封装层，使这些API的使用难度大为降低。 </p>
<p>（7）Java 源码是经典学习范例： Spring的源代码设计精妙、结构清晰、匠心独用，处处体现着大师对Java 设计模式灵活运用以及对 Java技术的高深造诣。它的源代码是 Java技术的最佳实践的范例。 </p>
<h4 id="Spring的体系结构"><a href="#Spring的体系结构" class="headerlink" title="Spring的体系结构"></a>Spring的体系结构</h4><img src="https://pic.imgdb.cn/item/6246961327f86abb2a362a69.jpg" style="zoom: 80%;" />

<h3 id="Spring快速配置"><a href="#Spring快速配置" class="headerlink" title="Spring快速配置"></a>Spring快速配置</h3><h4 id="Spring程序开发步骤"><a href="#Spring程序开发步骤" class="headerlink" title="Spring程序开发步骤"></a>Spring程序开发步骤</h4><p><img src="https://pic.imgdb.cn/item/6246970127f86abb2a37fd13.jpg"></p>
<ul>
<li>导入 Spring 开发的基本包坐标</li>
<li>编写 Dao 接口和实现类</li>
<li>创建 Spring核心配置文件</li>
<li> 在Spring 配置文件中配置 UserDaolmpl </li>
<li>使用 Spring 的API获得 Bean 实例</li>
</ul>
<p> </p>
<h4 id="导入Spring开发的基本包坐标"><a href="#导入Spring开发的基本包坐标" class="headerlink" title="导入Spring开发的基本包坐标"></a>导入Spring开发的基本包坐标</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--导入spring的context坐标，context依赖core、beans、expression--&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="编写Dao接口和实现"><a href="#编写Dao接口和实现" class="headerlink" title="编写Dao接口和实现"></a>编写Dao接口和实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;UserDao save method running....&quot;</span>);</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建Spring核心配置文件"><a href="#创建Spring核心配置文件" class="headerlink" title="创建Spring核心配置文件"></a>创建Spring核心配置文件</h4><p>在类路径下（resources）创建applicationContext.xml配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="在Spring配置文件中配置UserDaoImpl"><a href="#在Spring配置文件中配置UserDaoImpl" class="headerlink" title="在Spring配置文件中配置UserDaoImpl"></a>在Spring配置文件中配置UserDaoImpl</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="使用Spring的API获得Bean实例"><a href="#使用Spring的API获得Bean实例" class="headerlink" title="使用Spring的API获得Bean实例"></a>使用Spring的API获得Bean实例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> (UserDao) app.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="要点总结"><a href="#要点总结" class="headerlink" title="要点总结"></a>要点总结</h4><ul>
<li>导入坐标</li>
<li>创建Bean </li>
<li>创建applicationContext.xml </li>
<li>在配置文件中进行配置 </li>
<li>创建ApplicationContext对象getBean</li>
</ul>
<h3 id="Spring配置文件"><a href="#Spring配置文件" class="headerlink" title="Spring配置文件"></a>Spring配置文件</h3><h4 id="Bean标签基本配置"><a href="#Bean标签基本配置" class="headerlink" title="Bean标签基本配置"></a>Bean标签基本配置</h4><p>用于配置对象交由Spring 来创建。 <strong>默认情况下它调用的是类中的无参构造函数</strong>，如果没有无参构造函数则不能创建成功。</p>
<p> 基本属性∶ </p>
<ul>
<li>id∶Bean实例在Spring容器中的唯一标识（不允许重复）</li>
<li>class∶Bean的全限定名称</li>
</ul>
<p> </p>
<h4 id="Bean标签范围配置"><a href="#Bean标签范围配置" class="headerlink" title="Bean标签范围配置"></a>Bean标签范围配置</h4><p>scope：指对象的作用范围，取值如下：</p>
<p><img src="https://pic.imgdb.cn/item/6246b99d27f86abb2a7d1aa9.jpg"></p>
<p><strong>当scope的取值为singleton时</strong></p>
<p>Bean的实例化个数：1个</p>
<p>Bean的实例化时机：<strong>当Spring核心文件被加载时，实例化配置的Bean实例</strong></p>
<p>Bean的生命周期：</p>
<ul>
<li><p>对象创建：当应用加载，创建容器时，对象就被创建了（注意scope取值不同Bean的创建时机是不同的）</p>
</li>
<li><p>对象运行：只要容器在，对象一直活着</p>
</li>
<li><p>对象销毁：当应用卸载，销毁容器时，对象就被销毁了</p>
</li>
</ul>
<p><strong>当scope的取值为prototype时</strong></p>
<p>Bean的实例化个数：多个</p>
<p>Bean的实例化时机：<strong>当调用getBean()方法时实例化Bean</strong></p>
<ul>
<li><p>对象创建：当使用对象时，创建新的对象实例</p>
</li>
<li><p>对象运行：只要对象在使用中，就一直活着</p>
</li>
<li><p>对象销毁：当对象长时间不用时，被 Java 的垃圾回收器回收了</p>
</li>
</ul>
<h5 id="Bean生命周期配置"><a href="#Bean生命周期配置" class="headerlink" title="Bean生命周期配置"></a>Bean生命周期配置</h5><p><strong>init-method</strong>：指定类中的初始化方法名称</p>
<p><strong>destroy-method</strong>：指定类中销毁方法名称</p>
<h4 id="Bean实例化三种方式"><a href="#Bean实例化三种方式" class="headerlink" title="Bean实例化三种方式"></a>Bean实例化三种方式</h4><p>（1）无参<strong>构造</strong>方法实例化</p>
<p>它会根据默认无参构造方法来创建类对象，如果bean中没有默认无参构造函数，将会创建失败。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>



<p>（2）工厂<strong>静态</strong>方法实例化</p>
<p>工厂的静态方法返回Bean实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticFactoryBean</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> UserDao <span class="title function_">createUserDao</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.factory.StaticFactoryBean&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">factory-method</span>=<span class="string">&quot;createUserDao&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>



<p>（3）工厂<strong>实例</strong>方法实例化</p>
<p>工厂的非静态方法返回Bean实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicFactoryBean</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> UserDao <span class="title function_">createUserDao</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;factoryBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.factory.DynamicFactoryBean&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;factoryBean&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;createUserDao&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="Bean的依赖注入"><a href="#Bean的依赖注入" class="headerlink" title="Bean的依赖注入"></a>Bean的依赖注入</h4><p>（1）创建UserService，UserService内部在调用UserDao的save()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">		<span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> (UserDao) applicationContext.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">		userDao.save();</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）将UserServiceImplement的创建权交给Spring</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.UserServiceImpl&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>（3）从Spring容器中获得UserService进行操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) applicationContext.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">userService.save()</span><br></pre></td></tr></table></figure>



<p>目前UserService实例和UserDao实例都存在与Spring容器中，当前的做法是在容器外部获得UserService实例和UserDao实例，然后在程序中进行结合。</p>
<p><img src="https://pic.imgdb.cn/item/6257e297239250f7c5e6cc69.jpg"></p>
<p>因为UserService和UserDao都在Spring容器中，而最终程序直接使用的是UserService，所以可以在Spring容器中，<strong>将UserDao设置到UserService内部</strong></p>
<p><img src="https://pic.imgdb.cn/item/6257e2e0239250f7c5e76b56.jpg"></p>
<h5 id="Bean的依赖注入概念"><a href="#Bean的依赖注入概念" class="headerlink" title="Bean的依赖注入概念"></a>Bean的依赖注入概念</h5><p>依赖注入（<strong>Dependency Injection</strong>）：它是 Spring 框架核心 IOC 的具体实现。</p>
<p>在编写程序时，通过控制反转，把对象的创建交给了 Spring，但是代码中不可能出现没有依赖的情况。</p>
<p>IOC 解耦只是降低他们的依赖关系，但不会消除。例如：业务层仍会调用持久层的方法。</p>
<p>那这种业务层和持久层的依赖关系，在使用 Spring 之后，就让 Spring 来维护了。</p>
<p>简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取。</p>
<h5 id="Bean的依赖注入方式"><a href="#Bean的依赖注入方式" class="headerlink" title="Bean的依赖注入方式"></a>Bean的依赖注入方式</h5><p><strong>（1）set方法</strong></p>
<p>在UserServiceImpl中添加setUserDao方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> UserDao userDao;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.userDao = userDao; </span><br><span class="line">    &#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">		userDao.save();</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置Spring容器调用set方法进行注入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.UserServiceImpl&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>P命名空间注入本质也是set方法注入，但比起上述的set方法注入更加方便，主要体现在配置文件中，如下：</p>
<p>首先，需要引入P命名空间：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br></pre></td></tr></table></figure>

<p>其次需要修改注入方式</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.UserServiceImpl&quot;</span> <span class="attr">p:userDao-ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>（2）构造方法注入</strong></p>
<p>创建有参构造</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">		<span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> (UserDao) applicationContext.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">		userDao.save();</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置Spring容器调用有参构造时进行注入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="Bean的依赖注入的数据类型"><a href="#Bean的依赖注入的数据类型" class="headerlink" title="Bean的依赖注入的数据类型"></a>Bean的依赖注入的数据类型</h5><p>上面的操作，都是注入的引用Bean，处了对象的引用可以注入，普通数据类型，集合等都可以在容器中进行注入。</p>
<p>注入数据的三种数据类型</p>
<ul>
<li><p><strong>普通数据类型</strong></p>
</li>
<li><p><strong>引用数据类型</strong></p>
</li>
<li><p><strong>集合数据类型</strong></p>
</li>
</ul>
<p>其中引用数据类型，此处就不再赘述了，之前的操作都是对UserDao对象的引用进行注入的，下面将以set方法注入为例，演示普通数据类型和集合数据类型的注入。</p>
<p>（1）普通数据类型的注入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String company;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCompany</span><span class="params">(String company)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.company = company;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(company+<span class="string">&quot;===&quot;</span>+age);</span><br><span class="line">		System.out.println(<span class="string">&quot;UserDao save method running....&quot;</span>);</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;company&quot;</span> <span class="attr">value</span>=<span class="string">&quot;传智播客&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;15&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）集合数据类型（<code>List&lt;String&gt;</code>）的注入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> List&lt;String&gt; strList;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStrList</span><span class="params">(List&lt;String&gt; strList)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.strList = strList;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(strList);</span><br><span class="line">		System.out.println(<span class="string">&quot;UserDao save method running....&quot;</span>);</span><br><span class="line">	&#125; </span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;strList&quot;</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（3）集合数据类型（<code>List&lt;User&gt;</code>）的注入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> List&lt;User&gt; userList;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserList</span><span class="params">(List&lt;User&gt; userList)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.userList = userList;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(userList);</span><br><span class="line">		System.out.println(<span class="string">&quot;UserDao save method running....&quot;</span>);</span><br><span class="line">	&#125; </span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;u1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.domain.User&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;u2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.domain.User&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userList&quot;</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.domain.User&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.domain.User&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;u1&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;u2&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（4）集合数据类型（<code>Map&lt;String,User&gt;</code>）的注入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> Map&lt;String,User&gt; userMap;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserMap</span><span class="params">(Map&lt;String, User&gt; userMap)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.userMap = userMap;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(userMap);</span><br><span class="line">		System.out.println(<span class="string">&quot;UserDao save method running....&quot;</span>);</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;u1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.domain.User&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;u2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.domain.User&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userMap&quot;</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;user1&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;u1&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;user2&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;u2&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（5）集合数据类型（Properties）的注入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> Properties properties;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProperties</span><span class="params">(Properties properties)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.properties = properties;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(properties);</span><br><span class="line">		System.out.println(<span class="string">&quot;UserDao save method running....&quot;</span>);</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;properties&quot;</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;p1&quot;</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">prop</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;p2&quot;</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">prop</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;p3&quot;</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="引入其他配置文件（分模块开发）"><a href="#引入其他配置文件（分模块开发）" class="headerlink" title="引入其他配置文件（分模块开发）"></a>引入其他配置文件（分模块开发）</h5><p>实际开发中，Spring的配置内容非常多，这就导致Spring配置很繁杂且体积很大，所以，可以将部分配置拆解到其他配置文件中，而在Spring主配置文件通过import标签进行加载</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;applicationContext-xxx.xml&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="知识要点"><a href="#知识要点" class="headerlink" title="知识要点"></a>知识要点</h4><p><img src="C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20220414182147790.png" alt="image-20220414182147790"></p>
<h3 id="Spring相关API"><a href="#Spring相关API" class="headerlink" title="Spring相关API"></a>Spring相关API</h3><h4 id="ApplicationContext的继承体系"><a href="#ApplicationContext的继承体系" class="headerlink" title="ApplicationContext的继承体系"></a>ApplicationContext的继承体系</h4><p><strong>applicationContext：</strong>接口类型，代表应用上下文，可以通过其实例获得 Spring 容器中的 Bean 对象</p>
<p><img src="https://pic.imgdb.cn/item/6257f5ef239250f7c5099076.jpg"></p>
<h4 id="ApplicationContext的实现类"><a href="#ApplicationContext的实现类" class="headerlink" title="ApplicationContext的实现类"></a>ApplicationContext的实现类</h4><ul>
<li>ClassPathXmlApplicationContext</li>
</ul>
<p>​        它是从类的根路径下加载配置文件 推荐使用这种</p>
<ul>
<li>FileSystemXmlApplicationContext</li>
</ul>
<p>​        它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置。</p>
<ul>
<li>AnnotationConfigApplicationContext</li>
</ul>
<p>​        当使用注解配置容器对象时，需要使用此类来创建 spring 容器。它用来读取注解。</p>
<h4 id="getBean-方法使用"><a href="#getBean-方法使用" class="headerlink" title="getBean() 方法使用"></a>getBean() 方法使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">	assertBeanFactoryActive();</span><br><span class="line">	<span class="keyword">return</span> getBeanFactory().getBean(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">	assertBeanFactoryActive();</span><br><span class="line">	<span class="keyword">return</span> getBeanFactory().getBean(requiredType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，当参数的数据类型是字符串时，表示根据Bean的id从容器中获得Bean实例，返回是Object，需要强转。</p>
<p>当参数的数据类型是Class类型时，表示根据类型从容器中匹配Bean实例，当容器中相同类型的Bean有多个时，则此方法会报错。</p>
<h4 id="知识要点-1"><a href="#知识要点-1" class="headerlink" title="知识要点"></a>知识要点</h4><p>Spring重点掌握的API</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClasspathXmlApplicationContext</span>(<span class="string">&quot;xml文件&quot;</span>)</span><br><span class="line">app.getBean(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">app.getBean(Class)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SSM</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux</title>
    <url>/2022/04/13/Linux/</url>
    <content><![CDATA[<p>概述：本文记录了Linux的基础知识和常用命令，并且记录了常用软件（JDK，MySQL，Tomcat）的安装步骤和出问题的解决方案。</p>
<span id="more"></span>

<h3 id="Linux概述"><a href="#Linux概述" class="headerlink" title="Linux概述"></a>Linux概述</h3><h4 id="Unix概述"><a href="#Unix概述" class="headerlink" title="Unix概述"></a>Unix概述</h4><p>Unix是一个强大的多用户、多任务操作系统。于1969年在AT&amp;T的贝尔实验室开发。UNIX的商标权由国际开放标准组织（The Open Group）所拥有。UNIX操作系统是商业版，需要收费，价格比Microsoft Windows正版要贵一些。</p>
<h4 id="Linux简介"><a href="#Linux简介" class="headerlink" title="Linux简介"></a>Linux简介</h4><p>Linux是基于Unix的</p>
<p>Linux是一种自由和开放源码的操作系统，存在着许多不同的Linux版本，但它们都使用了Linux内核。Linux可安装在各种计算机硬件设备中，比如手机、平板电脑、路由器、台式计算机</p>
<p>诞生于1991 年10 月5 日。是由芬兰赫尔辛基大学学生Linus Torvalds和后来加入的众多爱好者共同开发完成</p>
<h4 id="Linux系统的应用"><a href="#Linux系统的应用" class="headerlink" title="Linux系统的应用"></a>Linux系统的应用</h4><p>服务器系统Web应用服务器、数据库服务器、接口服务器、DNS、FTP等等； </p>
<p>嵌入式系统路由器、防火墙、手机、PDA、IP 分享器、交换器、家电用品的微电脑控制器等等，</p>
<p>高性能运算、计算密集型应用Linux有强大的运算能力。</p>
<p>桌面应用系统</p>
<p>移动手持系统</p>
<h4 id="Linux的版本"><a href="#Linux的版本" class="headerlink" title="Linux的版本"></a>Linux的版本</h4><p><strong>Linux</strong>的版本分为两种：<strong>内核版本</strong>和<strong>发行版本</strong>；内核版本是指在Linus领导下的内核小组开发维护的系统内核的版本号 ；</p>
<p>Linux的主流版本</p>
<p><img src="https://pic.imgdb.cn/item/62570546239250f7c5ee87ae.jpg"></p>
<h3 id="Linux远程访问"><a href="#Linux远程访问" class="headerlink" title="Linux远程访问"></a>Linux远程访问</h3><p>通过远程访问软件CRT进行连接</p>
<h3 id="Linux的目录结构"><a href="#Linux的目录结构" class="headerlink" title="Linux的目录结构"></a>Linux的目录结构</h3><p><img src="https://pic.imgdb.cn/item/6255c46a239250f7c54d003b.jpg"></p>
<p>root管理员的home目录root</p>
<p>其他用户的home目录home目录中</p>
<h3 id="Linux的常用命令"><a href="#Linux的常用命令" class="headerlink" title="Linux的常用命令"></a>Linux的常用命令</h3><h4 id="切换目录命令cd"><a href="#切换目录命令cd" class="headerlink" title="切换目录命令cd"></a>切换目录命令<code>cd</code></h4><ul>
<li><p><code>cd app</code>    切换到app目录</p>
</li>
<li><p><code>cd ..</code>   切换到上一层目录</p>
</li>
<li><p><code>cd /</code>    切换到系统根目录</p>
</li>
<li><p><code>cd ~</code>   切换到用户主目录</p>
</li>
<li><p><code>cd -</code>    切换到上一个所在目录</p>
</li>
</ul>
<p>使用tab键来补全文件路径</p>
<h4 id="列出文件列表-ls-ll"><a href="#列出文件列表-ls-ll" class="headerlink" title="列出文件列表 ls ll"></a>列出文件列表 <code>ls ll</code></h4><p>ls(list)是一个非常有用的命令，用来显示当前目录下的内容。配合参数的使用，能以不同的方式显示目录内容。  </p>
<p>格式：ls[参数] [路径或文件名]</p>
<p>常用：</p>
<p>在linux中以 . 开头的文件都是隐藏的文件</p>
<ul>
<li><p><code>ls</code></p>
</li>
<li><p><code>ls -a</code>  显示所有文件或目录（包含隐藏的文件）</p>
</li>
<li><p><code>ls -l</code>  缩写成 <code>ll</code></p>
</li>
</ul>
<h4 id="创建目录和移除目录-mkdir-rmdir"><a href="#创建目录和移除目录-mkdir-rmdir" class="headerlink" title="创建目录和移除目录 mkdir rmdir"></a>创建目录和移除目录 <code>mkdir rmdir</code></h4><ul>
<li><p><code>mkdir(make directory)</code>命令可用来创建子目录。</p>
</li>
<li><p><code>mkdir app</code>  在当前目录下创建app目录</p>
</li>
<li><p><code>mkdir -p app2/test</code>  级联创建aap2以及test目录</p>
</li>
<li><p><code>rmdir(remove directory)</code>命令可用来删除“空”的子目录：<code>rmdir app</code> 删除app目录</p>
</li>
</ul>
<h4 id="浏览文件"><a href="#浏览文件" class="headerlink" title="浏览文件"></a>浏览文件</h4><h5 id="cat、more、less"><a href="#cat、more、less" class="headerlink" title="cat、more、less"></a>cat、more、less</h5><p>cat用于显示文件的内容。格式：<code>cat[参数]&lt;文件名&gt;</code></p>
<ul>
<li><code>cat yum.conf</code></li>
</ul>
<p>more一般用于要显示的内容会超过一个画面长度的情况。按空格键显示下一个画面。</p>
<p>​    回车显示下一行内容。</p>
<p>​    按 q 键退出查看。</p>
<ul>
<li><code>more yum.conf</code><ul>
<li>空格显示下一页数据 回车显示下一行的数据</li>
</ul>
</li>
</ul>
<p>less用法和more类似，不同的是less可以通过PgUp、PgDn键来控制。</p>
<ul>
<li><code>less yum.conf</code><ul>
<li>PgUp 和 PgDn 进行上下翻页.</li>
</ul>
</li>
</ul>
<h5 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h5><p>tail命令是在实际使用过程中使用非常多的一个命令，它的功能是：用于显示文件后几行的内容。</p>
<p>用法:</p>
<p><code>tail -10 /etc/passwd</code> 查看后10行数据</p>
<p><code>tail -f catalina.log</code>  动态查看日志(*****)</p>
<p>ctrl+c 结束查看</p>
<h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><h5 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h5><p>rm  删除文件      用法：<code>rm [选项]... 文件...</code></p>
<ul>
<li><code>rm a.txt</code>  删除a.txt文件</li>
</ul>
<p>删除需要用户确认，<code>y/nrm</code> 删除不询问</p>
<ul>
<li><p><code>rm -f a.txt</code>  询问，直接删除rm 删除目录</p>
</li>
<li><p><code>rm -r a</code>  递归删除不询问递归删除（慎用）</p>
</li>
<li><p><code>rm -rf  a</code>  不询问递归删除</p>
</li>
<li><p><code>rm -rf *</code>  删除所有文件</p>
</li>
<li><p><code>rm -rf /*</code> 自杀</p>
</li>
</ul>
<h5 id="cp、mv"><a href="#cp、mv" class="headerlink" title="cp、mv"></a>cp、mv</h5><p>cp(copy)命令可以将文件从一处复制到另一处。一般在使用cp命令时将一个文件复制成另一个文件或复制到某目录时，需要指定源文件名与目标文件名或目录。</p>
<ul>
<li><p><code>cp a.txt b.txt</code>  将a.txt复制为b.txt文件</p>
</li>
<li><p><code>cp a.txt ../</code>   将a.txt文件复制到上一层目录中</p>
</li>
</ul>
<p>mv 移动或者重命名</p>
<ul>
<li><p><code>mv a.txt ../</code>  将a.txt文件移动到上一层目录中</p>
</li>
<li><p><code>mv a.txt b.txt</code>  将a.txt文件重命名为b.txt</p>
</li>
</ul>
<h5 id="tar-（打包或解压）"><a href="#tar-（打包或解压）" class="headerlink" title="tar （打包或解压）"></a>tar （打包或解压）</h5><p>tar命令位于&#x2F;bin目录下，它能够将用户所指定的文件或目录打包成一个文件，但不做压缩。一般Linux上常用的压缩方式是选用tar将许多文件打包成一个文件，再以gzip压缩命令压缩成xxx.tar.gz(或称为xxx.tgz)的文件。常用参数：</p>
<ul>
<li><p><code>-c</code>：创建一个新tar文件</p>
</li>
<li><p><code>-v</code>：显示运行过程的信息</p>
</li>
<li><p><code>-f</code>：指定文件名</p>
</li>
<li><p><code>-z</code>：调用gzip压缩命令进行压缩</p>
</li>
<li><p><code>-t</code>：查看压缩文件的内容</p>
</li>
<li><p><code>-x</code>：解开tar文件</p>
</li>
</ul>
<p>打包：</p>
<ul>
<li><code>tar -cvf xxx.tar ./*</code></li>
</ul>
<p>打包并且压缩：</p>
<ul>
<li><code>tar -zcvf xxx.tar.gz ./*</code></li>
</ul>
<p>解压 </p>
<ul>
<li><code>tar -xvf xxx.tar</code></li>
<li><code>tar -zxvf xxx.tar.gz -C /usr/aaa</code></li>
</ul>
<h5 id="find"><a href="#find" class="headerlink" title="find"></a>find</h5><p>find指令用于查找符合条件的文件</p>
<p>示例：</p>
<ul>
<li><code>find / -name &quot;ins*&quot;</code> 查找文件名称是以ins开头的文件</li>
<li><code>find / -name &quot;ins*&quot; -ls</code> </li>
<li><code>find / -user itcast -ls</code> 查找用户itcast的文件</li>
<li><code>find / -user itcast -type d -ls</code> 查找用户itcast的目录</li>
<li><code>find /-perm -777 -type d-ls</code> 查找权限是777的文件</li>
</ul>
<h5 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h5><p>查找文件里符合条件的字符串。</p>
<p>用法: <code>grep [选项]... PATTERN [FILE]...</code></p>
<p>示例：</p>
<ul>
<li><p><code>grep lang anaconda-ks.cfg</code>  在文件中查找lang</p>
</li>
<li><p><code>grep lang anaconda-ks.cfg -color</code> 高亮显示</p>
</li>
</ul>
<h4 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h4><ul>
<li><code>pwd</code> ：显示当前所在的目录</li>
<li><code>touch</code> ：创建一个空文件 <code>touch a.txt</code></li>
<li><code>clear</code> ：清屏</li>
</ul>
<h3 id="Vi和Vim编辑器"><a href="#Vi和Vim编辑器" class="headerlink" title="Vi和Vim编辑器"></a>Vi和Vim编辑器</h3><h4 id="Vim编辑器"><a href="#Vim编辑器" class="headerlink" title="Vim编辑器"></a>Vim编辑器</h4><p>在Linux下一般使用vi编辑器来编辑文件。vi既可以查看文件也可以编辑文件。三种模式：命令行、插入、底行模式。</p>
<p>切换到命令行模式：按Esc键；</p>
<p>切换到插入模式：按 i 、o、a键；</p>
<ul>
<li>i 在当前位置前插入</li>
<li>I 在当前行首插入</li>
<li>a 在当前位置后插入</li>
<li>A 在当前行尾插入</li>
<li>o 在当前行之后插入一行</li>
<li>O 在当前行之前插入一行</li>
</ul>
<p>切换到底行模式：按 :（冒号）</p>
<p>打开文件：<code>vim file</code></p>
<p>退出：<code>esc : q</code></p>
<p>修改文件：输入 <code>i</code> 进入插入模式</p>
<p>保存并退出：<code>esc : wq</code></p>
<p>不保存退出：<code>esc : q!</code></p>
<p>快捷键：</p>
<ul>
<li><p>dd – 快速删除一行</p>
</li>
<li><p>yy - 复制当前行</p>
</li>
<li><p>nyy - 从当前行向后复制几行</p>
</li>
<li><p>p - 粘贴</p>
</li>
<li><p>R – 替换</p>
</li>
</ul>
<h4 id="重定向输出-gt-和-gt-gt"><a href="#重定向输出-gt-和-gt-gt" class="headerlink" title="重定向输出&gt; 和 &gt;&gt;"></a>重定向输出&gt; 和 &gt;&gt;</h4><p> 重定向输出，覆盖原有内容；&gt;&gt; 重定向输出，又追加功能；示例：</p>
<ul>
<li><p><code>cat /etc/passwd &gt; a.txt</code>  将输出定向到a.txt中</p>
</li>
<li><p><code>cat /etc/passwd &gt;&gt; a.txt</code>  输出并且追加</p>
</li>
<li><p><code>ifconfig &gt; ifconfig.txt</code></p>
</li>
</ul>
<h4 id="系统管理命令"><a href="#系统管理命令" class="headerlink" title="系统管理命令"></a>系统管理命令</h4><ul>
<li><code>ps</code> 正在运行的某个进程的状态</li>
<li><code>ps –ef</code>  查看所有进程</li>
<li><code>ps –ef | grep ssh</code> 查找某一进程</li>
<li><code>kill 2868</code>  杀掉2868编号的进程</li>
<li><code>kill -9 2868</code>  强制杀死进程</li>
</ul>
<h4 id="管道"><a href="#管道" class="headerlink" title="管道 |"></a>管道 |</h4><p>管道是Linux命令中重要的一个概念，其作用是将一个命令的输出用作另一个命令的输入。</p>
<p>示例：</p>
<ul>
<li><code>ls --help | more</code>  分页查询帮助信息</li>
<li><code>ps –ef | grep java</code>  查询名称中包含java的进程 </li>
<li><code>ifconfig | more</code></li>
<li><code>cat index.html | more</code></li>
<li><code>ps –ef | grep aio</code></li>
</ul>
<h3 id="Linux的权限命令"><a href="#Linux的权限命令" class="headerlink" title="Linux的权限命令"></a>Linux的权限命令</h3><h4 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h4><img src="https://pic.imgdb.cn/item/62568f0f239250f7c52b9dc7.jpg" style="zoom:50%;" />

<img src="https://pic.imgdb.cn/item/62568f7e239250f7c52c6f44.jpg" style="zoom:67%;" />

<p>r : 对文件是指可读取内容 对目录是可以ls</p>
<p>w : 对文件是指可修改文件内容，对目录 是指可以在其中创建或删除子节点(目录或文件)</p>
<p>x : 对文件是指是否可以运行这个文件，对目录是指是否可以cd进入这个目录</p>
<h4 id="Linux三种文件类型"><a href="#Linux三种文件类型" class="headerlink" title="Linux三种文件类型"></a>Linux三种文件类型</h4><p>普通文件： 包括文本文件、数据文件、可执行的二进制程序文件等。 </p>
<p>目录文件： Linux系统把目录看成是一种特殊的文件，利用它构成文件系统的树型结构。 </p>
<p>设备文件： Linux系统把每一个设备都看成是一个文件</p>
<h4 id="文件类型标识"><a href="#文件类型标识" class="headerlink" title="文件类型标识"></a>文件类型标识</h4><p>普通文件（-）目录（d）符号链接（l）</p>
<p>进入etc可以查看，相当于快捷方式字符设备文件（c）块设备文件（s）套接字（s）命名管道（p）</p>
<h4 id="文件权限管理"><a href="#文件权限管理" class="headerlink" title="文件权限管理"></a>文件权限管理</h4><p><code>chmod</code> 变更文件或目录的权限。</p>
<p><code>chmod 755 a.txt</code> </p>
<p><code>chmod u=rwx,g=rx,o=rx a.txt</code></p>
<h3 id="Linux上常用网络操作"><a href="#Linux上常用网络操作" class="headerlink" title="Linux上常用网络操作"></a>Linux上常用网络操作</h3><h4 id="主机名配置"><a href="#主机名配置" class="headerlink" title="主机名配置"></a>主机名配置</h4><p><code>hostname</code> 查看主机名</p>
<p><code>hostname xxx</code> 修改主机名 重启后无效</p>
<p>如果想要永久生效，可以修改&#x2F;etc&#x2F;sysconfig&#x2F;network文件</p>
<h4 id="IP地址配置"><a href="#IP地址配置" class="headerlink" title="IP地址配置"></a>IP地址配置</h4><p><code>ifconfig</code> 查看(修改)ip地址(重启后无效)</p>
<p><code>ifconfig eth0 192.168.xxx.xxx</code> 修改ip地址</p>
<p>如果想要永久生效</p>
<p>修改 &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth0文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">DEVICE=eth0 #网卡名称</span><br><span class="line">BOOTPROTO=static #获取ip的方式(static/dhcp/bootp/none)</span><br><span class="line"></span><br><span class="line">HWADDR=00:0C:29:B5:B2:69 #MAC地址</span><br><span class="line">IPADDR=12.168.177.129 #IP地址</span><br><span class="line">NETMASK=255.255.255.0 #子网掩码</span><br><span class="line">NETWORK=192.168.177.0 #网络地址</span><br><span class="line">BROADCAST=192.168.0.255 #广播地址</span><br><span class="line">NBOOT=yes #  系统启动时是否设置此网络接口，设置为yes时，系统启动时激活此设备。</span><br></pre></td></tr></table></figure>

<h4 id="域名映射"><a href="#域名映射" class="headerlink" title="域名映射"></a>域名映射</h4><p>&#x2F;etc&#x2F;hosts文件用于在通过主机名进行访问时做ip地址解析之用,相当于windows系统的C:\Windows\System32\drivers\etc\hosts文件的功能</p>
<h4 id="网络服务管理"><a href="#网络服务管理" class="headerlink" title="网络服务管理"></a>网络服务管理</h4><p><code>service network status</code> 查看指定服务的状态</p>
<p><code>service network stop</code> 停止指定服务</p>
<p><code>service network start</code> 启动指定服务</p>
<p><code>service network restart</code> 重启指定服务</p>
<p><code>service --status–all</code> 查看系统中所有后台服务</p>
<p><code>netstat –nltp</code> 查看系统中网络进程的端口监听情况</p>
<p><strong>防火墙设置</strong></p>
<p>防火墙根据配置文件&#x2F;etc&#x2F;sysconfig&#x2F;iptables来控制本机的”出”、”入”网络访问行为。</p>
<p><code>service iptables status</code> 查看防火墙状态</p>
<p><code>service iptables stop</code> 关闭防火墙</p>
<p><code>service iptables start</code> 启动防火墙</p>
<p><code>chkconfig  iptables off</code> 禁止防火墙自启</p>
<h3 id="Linux上软件安装"><a href="#Linux上软件安装" class="headerlink" title="Linux上软件安装"></a>Linux上软件安装</h3><h4 id="Linux上的软件安装的几种常见方式"><a href="#Linux上的软件安装的几种常见方式" class="headerlink" title="Linux上的软件安装的几种常见方式"></a>Linux上的软件安装的几种常见方式</h4><ol>
<li><p>二进制发布包</p>
<p>软件已经针对具体平台编译打包发布，只要解压，修改配置即可</p>
</li>
<li><p>RPM包</p>
<p>软件已经按照redhat的包管理工具规范RPM进行打包发布，需要获取到相应的软件RPM发布包，然后用RPM命令进行安装</p>
</li>
<li><p>Yum在线安装</p>
<p>软件已经以RPM规范打包，但发布在了网络上的一些服务器上，可用yum在线安装服务器上的rpm软件，并且会自动解决软件安装过程中的库依赖问题</p>
</li>
<li><p>源码编译安装</p>
<p>软件以源码工程的形式发布，需要获取到源码工程后用相应开发工具进行编译打包部署。</p>
</li>
</ol>
<h4 id="上传与下载工具"><a href="#上传与下载工具" class="headerlink" title="上传与下载工具"></a>上传与下载工具</h4><ol>
<li><p><strong>FileZilla</strong></p>
<p>主机名：192.168.18.128    用户名：root   密码：***   端口号：22</p>
<p>一般上传到 &#x2F;usr&#x2F;local 目录下 通过<code>cd /usr/local</code> 查看</p>
</li>
<li><p><strong>Irzsz</strong></p>
<p>使用<code>yum install lrzsz</code>安装</p>
<p>设置目录：</p>
<img src="https://pic.imgdb.cn/item/6257099d239250f7c5f39927.jpg" style="zoom: 67%;" /></li>
</ol>
<p>​    上传文件，放到upload文件夹内，<code>rz</code></p>
<p>​    下载文件：<code>sz 文件名</code>（下载到当前目录）</p>
<ol start="3">
<li><p><strong>sftp</strong></p>
<p>使用 alt + P 打开sftp窗口</p>
<p>上传：<code>put 文件目录</code> </p>
<p>下载：<code>get 文件目录</code></p>
</li>
</ol>
<h4 id="Linux上安装JDK"><a href="#Linux上安装JDK" class="headerlink" title="Linux上安装JDK"></a>Linux上安装JDK</h4><p><a href="https://www.timberkito.com/?p=12">yum安装</a></p>
<ul>
<li>上传JDK到Linux服务器</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(1) 上传JDK</span><br><span class="line">(2) 卸载open-JDK</span><br><span class="line"></span><br><span class="line">java –version</span><br><span class="line">rpm -qa | grep java</span><br><span class="line"></span><br><span class="line">rpm -e --nodeps java-1.6.0-openjdk-1.6.0.35-1.13.7.1.el6_6.i686</span><br><span class="line">rpm -e --nodeps java-1.7.0-openjdk-1.7.0.79-2.5.5.4.el6.i686</span><br></pre></td></tr></table></figure>

<ul>
<li>在Linux服务器上安装JDK</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">* 通常将软件安装到/usr/local</span><br><span class="line">* 直接解压就可以</span><br><span class="line"></span><br><span class="line">tar –xvf  jdk.tar.gz  -C 目标路径</span><br></pre></td></tr></table></figure>

<ul>
<li>配置JDK的环境变量</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> vim /etc/profile</span><br><span class="line"></span><br><span class="line">* 在末尾行添加</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">set</span> java environment</span></span><br><span class="line">JAVA_HOME=/usr/local/jdk1.7.0_71</span><br><span class="line">CLASSPATH=.:$JAVA_HOME/lib.tools.jar</span><br><span class="line">PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">export JAVA_HOME CLASSPATH PATH</span><br><span class="line"></span><br><span class="line">* 保存退出（esc  :wq）</span><br><span class="line">source /etc/profile  使更改的配置立即生效</span><br></pre></td></tr></table></figure>

<h4 id="在Linux上安装MySQL"><a href="#在Linux上安装MySQL" class="headerlink" title="在Linux上安装MySQL"></a>在Linux上安装MySQL</h4><p><a href="https://segmentfault.com/a/1190000022843273">教程</a> （ 重新设置密码为 ‘MyNewPass4!’ ）</p>
<ul>
<li>将MySQL的安装文件上传到Linux的服务器</li>
</ul>
<p>​    （1）将MySQL的tar解压</p>
<p>​    （2）将系统自带的MySQL卸载</p>
<p>​        搜索：<code>rpm -qa | grep mysql</code></p>
<p>​        删除：<code>rpm -e --nodeps 文件名</code></p>
<ul>
<li><p>安装MySQL服务端</p>
<p><code>rpm -ivh MySQL-server-5.6.22-1.el6.i686.rpm</code></p>
</li>
<li><p>安装MySQL客户端</p>
</li>
<li><p>MySQL服务加入到系统服务并自动启动操作</p>
</li>
</ul>
<p>​    <code>chkconfig --add mysql</code></p>
<p>​    自动启动：</p>
<p>​    <code>chkconfig mysql on</code></p>
<p>​    查询列表：</p>
<p>​    <code>chkconfig</code></p>
<ul>
<li><p>关于MySQL远程访问设置</p>
<p>在mysql中设置：</p>
<p><code>grant all privileges on *.* to &#39;root&#39; @&#39;%&#39; identified by &#39;root&#39;;</code></p>
<p><code>finish privileges;</code></p>
<p>在linux中很多软件的端口都被”防火墙”限止，我们需要将防火墙关闭</p>
<p>防火墙打开3306端口</p>
<p><code>/sbin/iptables -I INPUT -p tcp --dport 3306 -j ACCEPT</code></p>
<p><code>/etc/rc.d/init.d/iptables save</code></p>
<p><code>/etc/init.d/iptables status</code></p>
<p>学习阶段我们也可以直接将防火墙关闭</p>
<p><code>service iptables stop;</code></p>
</li>
</ul>
<h4 id="在Linux上安装Tomcat"><a href="#在Linux上安装Tomcat" class="headerlink" title="在Linux上安装Tomcat"></a>在Linux上安装Tomcat</h4><p>1.Tomcat上传到linux上</p>
<p>2.将上传的tomcat解压</p>
<p>3.在tomcat&#x2F;bin目录下执行 startup.sh（注意防火墙）<code>./startup.sh</code></p>
<p>4.查看目标 tomcat&#x2F;logs&#x2F;catalina.out</p>
<p><a href="https://blog.csdn.net/Al_assad/article/details/76383107">出现无法连接的错误</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/2022/04/12/Redis/</url>
    <content><![CDATA[<p>本文简单介绍了Redis这一种非关系型数据库</p>
<span id="more"></span>

<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Redis是一款高性能的NOSQL系列的非关系型数据库</p>
<h4 id="什么是NOSQL"><a href="#什么是NOSQL" class="headerlink" title="什么是NOSQL"></a>什么是NOSQL</h4><p>NoSQL(NoSQL &#x3D; Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。</p>
<p>随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。</p>
<h5 id="NOSQL和关系型数据库比较"><a href="#NOSQL和关系型数据库比较" class="headerlink" title="NOSQL和关系型数据库比较"></a>NOSQL和关系型数据库比较</h5><p><img src="https://pic.imgdb.cn/item/62558c7c239250f7c5009c49.jpg"></p>
<p>优点：</p>
<p>1）成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。</p>
<p>2）查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。                </p>
<p>3）存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。</p>
<p>4）扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。</p>
<p>缺点：</p>
<p>1）维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库十几年的技术同日而语。            </p>
<p>2）不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。</p>
<p>3）不提供关系型数据库对事务的处理。</p>
<h5 id="非关系型数据库的优势："><a href="#非关系型数据库的优势：" class="headerlink" title="非关系型数据库的优势："></a>非关系型数据库的优势：</h5><p>1）性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。</p>
<p>2）可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。</p>
<h5 id="关系型数据库的优势："><a href="#关系型数据库的优势：" class="headerlink" title="关系型数据库的优势："></a>关系型数据库的优势：</h5><p>1）复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。</p>
<p>2）事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库，</p>
<p>让NoSQL数据库对关系型数据库的不足进行弥补。</p>
<p>一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据</p>
<h4 id="主流的NOSQL产品"><a href="#主流的NOSQL产品" class="headerlink" title="主流的NOSQL产品"></a>主流的NOSQL产品</h4><p>​        •    键值(Key-Value)存储数据库<br>​                相关产品： Tokyo Cabinet&#x2F;Tyrant、Redis、Voldemort、Berkeley DB<br>​                典型应用： 内容缓存，主要用于处理大量数据的高访问负载。<br>​                数据模型： 一系列键值对<br>​                优势： 快速查询<br>​                劣势： 存储的数据缺少结构化<br>​        •    列存储数据库<br>​                相关产品：Cassandra, HBase, Riak<br>​                典型应用：分布式的文件系统<br>​                数据模型：以列簇式存储，将同一列数据存在一起<br>​                优势：查找速度快，可扩展性强，更容易进行分布式扩展<br>​                劣势：功能相对局限<br>​        •    文档型数据库<br>​                相关产品：CouchDB、MongoDB<br>​                典型应用：Web应用（与Key-Value类似，Value是结构化的）<br>​                数据模型： 一系列键值对<br>​                优势：数据结构要求不严格<br>​                劣势： 查询性能不高，而且缺乏统一的查询语法<br>​        •    图形(Graph)数据库<br>​                相关数据库：Neo4J、InfoGrid、Infinite Graph<br>​                典型应用：社交网络<br>​                数据模型：图结构<br>​                优势：利用图结构相关算法。<br>​                劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。</p>
<h4 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis"></a>什么是Redis</h4><p>Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次&#x2F;s,写的速度是81000次&#x2F;s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下：</p>
<pre><code>           1) 字符串类型 string
           2) 哈希类型 hash
           3) 列表类型 list
           4) 集合类型 set
           5) 有序集合类型 sortedset
</code></pre>
<h5 id="redis的应用场景"><a href="#redis的应用场景" class="headerlink" title="redis的应用场景"></a>redis的应用场景</h5><p>•    缓存（数据查询、短连接、新闻内容、商品内容等等）<br>•    聊天室的在线好友列表<br>•    任务队列。（秒杀、抢购、12306等等）<br>•    应用排行榜<br>•    网站访问统计<br>•    数据过期处理（可以精确到毫秒<br>•    分布式集群架构中的session分离</p>
<h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><ol>
<li>官网：<a href="https://redis.io/">https://redis.io</a></li>
<li>中文网：<a href="http://www.redis.net.cn/">http://www.redis.net.cn/</a> （可以查询常用命令）</li>
<li>centos安装redis： <a href="https://zhuanlan.zhihu.com/p/34527270">https://zhuanlan.zhihu.com/p/34527270</a></li>
</ol>
<h3 id="命令操作"><a href="#命令操作" class="headerlink" title="命令操作"></a>命令操作</h3><h4 id="redis的数据结构"><a href="#redis的数据结构" class="headerlink" title="redis的数据结构"></a>redis的数据结构</h4><ul>
<li>redis存储的是：key,value格式的数据，其中<strong>key都是字符串</strong>，value有5种不同的数据结构<ul>
<li><strong>value的数据结构</strong>：<ol>
<li>字符串类型 <strong>string</strong></li>
<li>哈希类型 <strong>hash</strong> ： map格式  </li>
<li>列表类型 <strong>list</strong> ： linkedlist格式。支持重复元素</li>
<li>集合类型 <strong>set</strong>  ： 不允许重复元素</li>
<li>有序集合类型 <strong>sortedset</strong>：不允许重复元素，且元素有顺序</li>
</ol>
</li>
</ul>
</li>
</ul>
<ol>
<li><strong>字符串类型 string</strong></li>
</ol>
<ul>
<li><p>存储： <code>set key value</code></p>
</li>
<li><p>获取： <code>get key</code></p>
</li>
<li><p>删除： <code>del key</code></p>
</li>
</ul>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set username zhangsan</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; get username</span><br><span class="line">&quot;zhangsan&quot;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; del age</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>哈希类型 hash</strong></li>
</ol>
<ul>
<li><p>存储： <code>hset key field value</code></p>
</li>
<li><p>获取： </p>
<p>（1）<code>hget key field</code>: 获取指定的field对应的值</p>
<p>（2）<code>hgetall key</code>：获取所有的field和value</p>
</li>
<li><p>删除： <code>hdel key field</code></p>
</li>
</ul>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset myhash username lisi</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hset myhash password 123</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; hget myhash username</span><br><span class="line">&quot;lisi&quot;</span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash</span><br><span class="line">1) &quot;username&quot;</span><br><span class="line">2) &quot;zzq&quot;</span><br><span class="line">3) &quot;password&quot;</span><br><span class="line">4) &quot;123&quot;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; hdel myhash username</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>**列表类型 list:**可以添加一个元素到列表的头部（左边）或者尾部（右边）</li>
</ol>
<ul>
<li><p>添加：</p>
<p>（1）<code>lpush key value</code>: 将元素加入列表左表</p>
<p>（2）<code>rpush key value</code>：将元素加入列表右边</p>
</li>
<li><p>获取：</p>
<p><code>lrange key start end</code> ：范围获取</p>
</li>
<li><p>删除：</p>
<p>（1）<code>lpop key</code>： 删除列表最左边的元素，并将元素返回</p>
<p>（2）<code>rpop key</code>： 删除列表最右边的元素，并将元素返回</p>
</li>
</ul>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush myList a</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; lpush myList b</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; rpush myList c</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; lrange myList 0 -1</span><br><span class="line">1) &quot;b&quot;</span><br><span class="line">2) &quot;a&quot;</span><br><span class="line">3) &quot;c&quot;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p><strong>集合类型 set</strong> ： 不允许重复元素</p>
<ul>
<li><p>存储：<code>sadd key value</code></p>
</li>
<li><p>获取：<code>smembers key</code>：获取set集合中所有元素</p>
</li>
<li><p>删除：<code>srem key value</code>：删除set集合中的某个元素</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd myset a</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset a</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; srem myset a</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>有序集合类型 sortedset</strong>：不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p>
<ul>
<li><p>存储：<code>zadd key score value</code></p>
</li>
<li><p>获取：<code>zrange key start end [withscores]</code></p>
</li>
<li><p>删除：<code>zrem key value</code></p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd mysort 60 zhangsan</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd mysort 50 lisi</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd mysort 80 wangwu</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; zrange mysort 0 -1</span><br><span class="line"></span><br><span class="line">1) &quot;lisi&quot;</span><br><span class="line">2) &quot;zhangsan&quot;</span><br><span class="line">3) &quot;wangwu&quot;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; zrange mysort 0 -1 withscores</span><br><span class="line">1) &quot;zhangsan&quot;</span><br><span class="line">2) &quot;60&quot;</span><br><span class="line">3) &quot;wangwu&quot;</span><br><span class="line">4) &quot;80&quot;</span><br><span class="line">5) &quot;lisi&quot;</span><br><span class="line">6) &quot;500&quot;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; zrem mysort lisi</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>通用命令</p>
</li>
</ol>
<ul>
<li><p><code>keys </code>*  : 查询所有的键</p>
</li>
<li><p><code>type key</code> ： 获取键对应的value的类型</p>
</li>
<li><p><code>del key</code>：删除指定的key value</p>
</li>
</ul>
<h3 id="Redis的持久化"><a href="#Redis的持久化" class="headerlink" title="Redis的持久化"></a>Redis的持久化</h3><p>Redis是一个内存数据库，当Redis服务器重启，获取电脑重启，数据会丢失，我们可以将Redis内存中的数据持久化保存到硬盘的文件中。</p>
<p>如果不进行持久化，那么Redis就相当于一个很大的map集合</p>
<h4 id="Redis持久化机制"><a href="#Redis持久化机制" class="headerlink" title="Redis持久化机制"></a>Redis持久化机制</h4><ol>
<li><p>RDB：默认方式，不需要进行配置，默认就使用这种机制</p>
<ul>
<li>在一定的间隔时间中，检测key的变化情况，然后持久化数据</li>
</ul>
</li>
<li><p>AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据</p>
</li>
</ol>
<p>linux下查看持久化机制命令：<code>info persistence</code></p>
<p><a href="https://blog.csdn.net/weixin_42510262/article/details/112716638">配置方法</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; INFO persistence</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Persistence</span></span><br><span class="line">loading:0</span><br><span class="line">current_cow_size:0</span><br><span class="line">current_cow_size_age:0</span><br><span class="line">current_fork_perc:0.00</span><br><span class="line">current_save_keys_processed:0</span><br><span class="line">current_save_keys_total:0</span><br><span class="line">rdb_changes_since_last_save:7</span><br><span class="line">rdb_bgsave_in_progress:0</span><br><span class="line">rdb_last_save_time:1649782802</span><br><span class="line">rdb_last_bgsave_status:ok</span><br><span class="line">rdb_last_bgsave_time_sec:0</span><br><span class="line">rdb_current_bgsave_time_sec:-1</span><br><span class="line">rdb_last_cow_size:2256896</span><br><span class="line">aof_enabled:0</span><br><span class="line">aof_rewrite_in_progress:0</span><br><span class="line">aof_rewrite_scheduled:0</span><br><span class="line">aof_last_rewrite_time_sec:-1</span><br><span class="line">aof_current_rewrite_time_sec:-1</span><br><span class="line">aof_last_bgrewrite_status:ok</span><br><span class="line">aof_last_write_status:ok</span><br><span class="line">aof_last_cow_size:0</span><br><span class="line">module_fork_in_progress:0</span><br><span class="line">module_fork_last_cow_size:0</span><br></pre></td></tr></table></figure>



<h3 id="Java客户端-Jedis"><a href="#Java客户端-Jedis" class="headerlink" title="Java客户端  Jedis"></a>Java客户端  Jedis</h3><p>Jedis: 一款java操作redis数据库的工具.</p>
<p>使用步骤：</p>
<ol>
<li><p>下载jedis的jar包</p>
</li>
<li><p>使用（注意打开Redis服务器，并要导入相关jar包，如junit, servlet）</p>
</li>
</ol>
<p>  （包含jedis连接池的使用）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.jedis.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.jedis.util.JedisPoolUtils;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPool;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPoolConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jedis的测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisTest</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 快速入门</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1. 获取连接</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;localhost&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        <span class="comment">//2. 操作</span></span><br><span class="line">        jedis.set(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        <span class="comment">//3. 关闭连接</span></span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * string 数据结构操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1. 获取连接</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>();<span class="comment">//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口</span></span><br><span class="line">        <span class="comment">//2. 操作</span></span><br><span class="line">        <span class="comment">//存储</span></span><br><span class="line">        jedis.set(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        <span class="comment">//获取</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        System.out.println(username);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//可以使用setex()方法存储可以指定过期时间的 key value</span></span><br><span class="line">        jedis.setex(<span class="string">&quot;activecode&quot;</span>,<span class="number">20</span>,<span class="string">&quot;hehe&quot;</span>);<span class="comment">//将activecode：hehe键值对存入redis，并且20秒后自动删除该键值对</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 关闭连接</span></span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * hash 数据结构操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1. 获取连接</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>();<span class="comment">//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口</span></span><br><span class="line">        <span class="comment">//2. 操作</span></span><br><span class="line">        <span class="comment">// 存储hash</span></span><br><span class="line">        jedis.hset(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        jedis.hset(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;age&quot;</span>,<span class="string">&quot;23&quot;</span>);</span><br><span class="line">        jedis.hset(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;gender&quot;</span>,<span class="string">&quot;female&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取hash</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> jedis.hget(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取hash的所有map中的数据</span></span><br><span class="line">        Map&lt;String, String&gt; user = jedis.hgetAll(<span class="string">&quot;user&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// keyset</span></span><br><span class="line">        Set&lt;String&gt; keySet = user.keySet();</span><br><span class="line">        <span class="keyword">for</span> (String key : keySet) &#123;</span><br><span class="line">            <span class="comment">//获取value</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> user.get(key);</span><br><span class="line">            System.out.println(key + <span class="string">&quot;:&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 关闭连接</span></span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * list 数据结构操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1. 获取连接</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>();<span class="comment">//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口</span></span><br><span class="line">        <span class="comment">//2. 操作</span></span><br><span class="line">        <span class="comment">// list 存储</span></span><br><span class="line">        jedis.lpush(<span class="string">&quot;mylist&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>);<span class="comment">//从左边存</span></span><br><span class="line">        jedis.rpush(<span class="string">&quot;mylist&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>);<span class="comment">//从右边存</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// list 范围获取</span></span><br><span class="line">        List&lt;String&gt; mylist = jedis.lrange(<span class="string">&quot;mylist&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        System.out.println(mylist);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// list 弹出</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">element1</span> <span class="operator">=</span> jedis.lpop(<span class="string">&quot;mylist&quot;</span>);<span class="comment">//c</span></span><br><span class="line">        System.out.println(element1);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">element2</span> <span class="operator">=</span> jedis.rpop(<span class="string">&quot;mylist&quot;</span>);<span class="comment">//c</span></span><br><span class="line">        System.out.println(element2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// list 范围获取</span></span><br><span class="line">        List&lt;String&gt; mylist2 = jedis.lrange(<span class="string">&quot;mylist&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        System.out.println(mylist2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 关闭连接</span></span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * set 数据结构操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1. 获取连接</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>();<span class="comment">//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口</span></span><br><span class="line">        <span class="comment">//2. 操作</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// set 存储</span></span><br><span class="line">        jedis.sadd(<span class="string">&quot;myset&quot;</span>,<span class="string">&quot;java&quot;</span>,<span class="string">&quot;php&quot;</span>,<span class="string">&quot;c++&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// set 获取</span></span><br><span class="line">        Set&lt;String&gt; myset = jedis.smembers(<span class="string">&quot;myset&quot;</span>);</span><br><span class="line">        System.out.println(myset);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 关闭连接</span></span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * sortedset 数据结构操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1. 获取连接</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>();<span class="comment">//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口</span></span><br><span class="line">        <span class="comment">//2. 操作</span></span><br><span class="line">        <span class="comment">// sortedset 存储</span></span><br><span class="line">        jedis.zadd(<span class="string">&quot;mysortedset&quot;</span>,<span class="number">3</span>,<span class="string">&quot;亚瑟&quot;</span>);</span><br><span class="line">        jedis.zadd(<span class="string">&quot;mysortedset&quot;</span>,<span class="number">30</span>,<span class="string">&quot;后裔&quot;</span>);</span><br><span class="line">        jedis.zadd(<span class="string">&quot;mysortedset&quot;</span>,<span class="number">55</span>,<span class="string">&quot;孙悟空&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// sortedset 获取</span></span><br><span class="line">        Set&lt;String&gt; mysortedset = jedis.zrange(<span class="string">&quot;mysortedset&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(mysortedset);</span><br><span class="line">        <span class="comment">//3. 关闭连接</span></span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * jedis连接池使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test7</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//0.创建一个配置对象</span></span><br><span class="line">        <span class="type">JedisPoolConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">        config.setMaxTotal(<span class="number">50</span>);</span><br><span class="line">        config.setMaxIdle(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//1.创建Jedis连接池对象</span></span><br><span class="line">        <span class="type">JedisPool</span> <span class="variable">jedisPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPool</span>(config,<span class="string">&quot;localhost&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        <span class="comment">//2.获取连接</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> jedisPool.getResource();</span><br><span class="line">        <span class="comment">//3. 使用</span></span><br><span class="line">        jedis.set(<span class="string">&quot;hehe&quot;</span>,<span class="string">&quot;heihei&quot;</span>);</span><br><span class="line">        <span class="comment">//4. 关闭 归还到连接池中</span></span><br><span class="line">        jedis.close();;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * jedis连接池工具类使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test8</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//通过连接池工具类获取</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> JedisPoolUtils.getJedis();</span><br><span class="line">        <span class="comment">//3. 使用</span></span><br><span class="line">        jedis.set(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        <span class="comment">//4. 关闭 归还到连接池中</span></span><br><span class="line">        jedis.close();;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>连接池工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> JedisPool工具类</span></span><br><span class="line"><span class="comment">    加载配置文件，配置连接池的参数</span></span><br><span class="line"><span class="comment">    提供获取连接的方法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisPoolUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//读取配置文件</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> JedisPoolUtils.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jedis.properties&quot;</span>);</span><br><span class="line">        <span class="comment">//创建Properties对象</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">//关联文件</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            pro.load(is);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取数据，设置到JedisPoolConfig中</span></span><br><span class="line">        <span class="type">JedisPoolConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">        config.setMaxTotal(Integer.parseInt(pro.getProperty(<span class="string">&quot;maxTotal&quot;</span>)));</span><br><span class="line">        config.setMaxIdle(Integer.parseInt(pro.getProperty(<span class="string">&quot;maxIdle&quot;</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化JedisPool</span></span><br><span class="line">        jedisPool = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(config,pro.getProperty(<span class="string">&quot;host&quot;</span>),Integer.parseInt(pro.getProperty(<span class="string">&quot;port&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取连接方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getJedis</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>jedis.properties配置设置：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="attr">port</span>=<span class="string">6379</span></span><br><span class="line"><span class="attr">maxTotal</span>=<span class="string">50</span></span><br><span class="line"><span class="attr">maxIdle</span>=<span class="string">10</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet</title>
    <url>/2022/04/12/servlet/</url>
    <content><![CDATA[<p>本文简单介绍了Servlet的相关概念</p>
<span id="more"></span>

<h3 id="Servlet：-server-applet"><a href="#Servlet：-server-applet" class="headerlink" title="Servlet： server applet"></a>Servlet： server applet</h3><ul>
<li><p>概念：运行在服务器端的小程序</p>
<ul>
<li>Servlet就是一个接口，定义了Java类被浏览器访问到(tomcat识别)的规则。</li>
<li>将来我们自定义一个类，实现Servlet接口，复写方法。</li>
</ul>
</li>
<li><p>快速入门：</p>
<ol>
<li><p>创建JavaEE项目</p>
</li>
<li><p>定义一个类，实现Servlet接口</p>
<ul>
<li>public class ServletDemo1 implements Servlet</li>
</ul>
</li>
<li><p>实现接口中的抽象方法</p>
</li>
<li><p>配置Servlet<br>  在web.xml中配置：</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置Servlet --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>cn.itcast.web.servlet.ServletDemo1<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/demo1<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>执行原理：</p>
<ol>
<li>当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径</li>
<li>查找web.xml文件，是否有对应的<code>&lt;url-pattern&gt;</code>标签体内容。</li>
<li>如果有，则在找到对应的<code>&lt;servlet-class&gt;</code>全类名</li>
<li>tomcat会将字节码文件加载进内存，并且创建其对象</li>
<li>调用其方法</li>
</ol>
</li>
<li><p>Servlet中的生命周期方法：</p>
<ol>
<li>被创建：执行init方法，只执行一次<ul>
<li>Servlet什么时候被创建？<ul>
<li>默认情况下，第一次被访问时，Servlet被创建</li>
<li>可以配置执行Servlet的创建时机。<ul>
<li>在<code>&lt;servlet&gt;</code>标签下配置<ol>
<li>第一次被访问时，创建</li>
</ol>
<ul>
<li><code>&lt;load-on-startup&gt;</code>的值为负数</li>
</ul>
</li>
</ul>
<ol start="2">
<li>在服务器启动时，创建<ul>
<li><code>&lt;load-on-startup&gt;</code>的值为0或正整数</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><p>Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的<br>      * 多个用户同时访问时，可能存在线程安全问题。<br>      * 解决：尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要对修改值</p>
<ol start="2">
<li>提供服务：执行service方法，执行多次<ul>
<li>每次访问Servlet时，Service方法都会被调用一次。</li>
</ul>
</li>
<li>被销毁：执行destroy方法，只执行一次<ul>
<li>Servlet被销毁时执行。服务器关闭时，Servlet被销毁</li>
<li>只有服务器正常关闭时，才会执行destroy方法。</li>
<li>destroy方法在Servlet被销毁之前执行，一般用于释放资源</li>
</ul>
</li>
</ol>
</li>
<li><p>Servlet3.0：</p>
<ul>
<li><p>好处：</p>
<ul>
<li>支持注解配置。可以不需要web.xml了。</li>
</ul>
</li>
<li><p>步骤：</p>
<ol>
<li>创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xml</li>
<li>定义一个类，实现Servlet接口</li>
<li>复写方法</li>
<li>在类上使用@WebServlet注解，进行配置</li>
</ol>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat</title>
    <url>/2022/04/12/Tomcat/</url>
    <content><![CDATA[<p>本文中简单介绍了web的相关概念，另外着重介绍了web服务器软件：Tomcat的基础知识</p>
<span id="more"></span>

<h3 id="Web相关概念"><a href="#Web相关概念" class="headerlink" title="Web相关概念"></a>Web相关概念</h3><ol>
<li><p><strong>软件架构</strong></p>
<ul>
<li><p>C&#x2F;S：客户端&#x2F;服务器端</p>
</li>
<li><p>B&#x2F;S：浏览器&#x2F;服务器端</p>
</li>
</ul>
</li>
<li><p><strong>资源分类</strong></p>
<ul>
<li><p><strong>静态资源</strong>：所有用户访问后，得到的结果都是一样的，称为静态资源。静态资源可以直接被浏览器解析</p>
<p>如： html,css,JavaScript</p>
</li>
<li><p><strong>动态资源</strong>：每个用户访问相同资源后，得到的结果可能不一样。称为动态资源。动态资源被访问后，需要先转换为静态资源，在返回给浏览器</p>
<p>如：servlet&#x2F;jsp,php,asp….</p>
<img src="https://pic.imgdb.cn/item/625571df239250f7c5d34f65.jpg" style="zoom: 67%;" /></li>
</ul>
</li>
<li><p><strong>网络通信三要素</strong></p>
<ul>
<li><p><strong>IP</strong>：电子设备(计算机)在网络中的唯一标识。</p>
</li>
<li><p><strong>端口</strong>：应用程序在计算机中的唯一标识。 0~65536</p>
</li>
<li><p><strong>传输协议</strong>：规定了数据传输的规则</p>
</li>
<li><p><strong>基础协议</strong>：</p>
<ul>
<li><p>TCP：安全协议，三次握手。 速度稍慢</p>
</li>
<li><p>UDP：不安全协议。 速度快</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="Web服务器软件"><a href="#Web服务器软件" class="headerlink" title="Web服务器软件"></a>Web服务器软件</h3><ul>
<li><p>服务器：安装了服务器软件的计算机</p>
</li>
<li><p>服务器软件：接收用户的请求，处理请求，做出响应</p>
</li>
<li><p>web服务器软件：接收用户的请求，处理请求，做出响应。</p>
<ul>
<li>在web服务器软件中，可以部署web项目，让用户通过浏览器来访问这些项目</li>
<li>web容器（动态资源必须在web容器中运行）</li>
</ul>
</li>
<li><p>常见的java相关的web服务器软件：</p>
<ul>
<li>webLogic：oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。</li>
<li>webSphere：IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。</li>
<li>JBOSS：JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。</li>
<li><strong>Tomcat</strong>：Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范servlet&#x2F;jsp。开源的，免费的。</li>
</ul>
</li>
<li><p><strong>JavaEE：Java语言在企业级开发中使用的技术规范的总和</strong>，一共规定了13项大的规范</p>
</li>
<li><p>Tomcat：web服务器软件</p>
<ol>
<li><p>下载：<a href="http://tomcat.apache.org/">http://tomcat.apache.org/</a></p>
</li>
<li><p>安装：解压压缩包即可。</p>
<ul>
<li>注意：安装目录建议不要有中文和空格</li>
</ul>
<p> <img src="C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20220412205215019.png" alt="Tomcat目录结构">
 </p>
</li>
<li><p>卸载：删除目录就行了</p>
</li>
<li><p>启动：</p>
<ul>
<li><p>bin&#x2F;startup.bat ,双击运行该文件即可</p>
<p>   （如果出现乱码问题，需要打开conf&#x2F;logging.properties，找到<code>java.util.logging.ConsoleHandler.encoding = UTF-8</code>，将UTF-8修改为GDB，保存后重启）</p>
</li>
<li><p>访问：浏览器输入：<a href="http://localhost:8080/">http://localhost:8080</a> 回车访问自己（我的本地ip为192.168.17.1）<br>            http:&#x2F;&#x2F;别人的ip:8080 访问别人</p>
</li>
<li><p>可能遇到的问题：</p>
<ol>
<li><p>黑窗口一闪而过：</p>
<ul>
<li>原因： 没有正确配置JAVA_HOME环境变量</li>
<li>解决方案：正确配置JAVA_HOME环境变量</li>
</ul>
</li>
<li><p>启动报错（出现403错误，为端口被占用的问题）：</p>
<p> 暴力：找到占用的端口号，并且找到对应的进程，杀死该进程</p>
<ul>
<li>cmd输入 netstat -ano  （或加入端口号搜索更为方便<code>netstat -an0 | findstr 8080</code>）</li>
</ul>
<p> 温柔：修改自身的端口号</p>
</li>
</ol>
<ul>
<li>在tomcat目录下打开：conf&#x2F;server.xml</li>
<li><code>&lt;Connector port=&quot;8888&quot; protocol=&quot;HTTP/1.1&quot;     connectionTimeout=&quot;20000&quot;     redirectPort=&quot;8445&quot; /&gt;</code><ul>
<li>一般会将tomcat的默认端口号修改为80。80端口号是http协议的默认端口号。<ul>
<li>好处：在访问时，就不用输入端口号</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>关闭：</p>
<ol>
<li>正常关闭：<ul>
<li>bin&#x2F;shutdown.bat</li>
<li>ctrl+c</li>
</ul>
</li>
<li>强制关闭：点击启动窗口的×</li>
</ol>
</li>
<li><p>配置:</p>
<p> <strong>部署项目的方式：</strong>（三种方式）</p>
<ol>
<li><p>直接将项目放到webapps目录下即可。</p>
<ul>
<li>&#x2F;hello：项目的访问路径–&gt;虚拟目录</li>
<li>简化部署：将项目打成一个war包（简单起见可以先压缩成zip再改后缀为war），再将war包放置到webapps目录下。<ul>
<li>war包会自动解压缩</li>
</ul>
</li>
</ul>
</li>
<li><p>配置conf&#x2F;server.xml文件<br> 在<code>&lt;Host&gt;</code>标签体中配置<br> <code>&lt;Context docBase=&quot;D:\hello&quot; path=&quot;/hehe&quot; /&gt;</code></p>
<ul>
<li>docBase:项目存放的路径</li>
<li>path：虚拟目录</li>
</ul>
</li>
<li><p>在conf\Catalina\localhost创建任意名称的xml文件。在文件中编写<br> <code>&lt;Context docBase=&quot;D:\hello&quot; /&gt;</code></p>
<ul>
<li>虚拟目录：xml文件的名称</li>
</ul>
</li>
</ol>
<p> <strong>静态项目和动态项目：</strong></p>
<ul>
<li><p>目录结构</p>
<ul>
<li>java动态项目的目录结构：<br>  – 项目的根目录<br>  – WEB-INF目录：<br>      – web.xml：web项目的核心配置文件<br>      – classes目录：放置字节码文件的目录<br>      – lib目录：放置依赖的jar包</li>
</ul>
</li>
<li><p>将Tomcat集成到IDEA中，并且创建JavaEE的项目，部署项目。</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>XML</title>
    <url>/2022/04/12/XML/</url>
    <content><![CDATA[<p>本文中包含XML的基础知识，包含基本概念、语法及解析</p>
<span id="more"></span>

<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Extensible Markup Language 可扩展标记语言</p>
<ul>
<li>可扩展：标签都是自定义的。 <code>&lt;user&gt;  &lt;student&gt;</code></li>
<li>功能：<strong>存储数据</strong><ol>
<li>作为配置文件使用</li>
<li>在网络中传输（与web service有关）</li>
</ol>
</li>
<li>xml与html的区别<ol>
<li>xml标签都是自定义的，html标签是预定义。</li>
<li>xml的语法非常严格，html语法松散</li>
<li>xml是存储数据的，html是展示数据</li>
</ol>
</li>
<li>w3c:万维网联盟</li>
</ul>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ul>
<li><p>基本语法：</p>
<ol>
<li>xml文档的后缀名 .xml</li>
<li>xml第一行必须定义为文档声明</li>
<li>xml文档中有且仅有一个根标签</li>
<li>属性值必须使用引号(单双都可)引起来</li>
<li>标签必须正确关闭</li>
<li>xml标签名称区分大小写（html标签不区分大小写）</li>
</ol>
</li>
<li><p>快速入门：</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&#x27;1.0&#x27; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">users</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">user</span> <span class="attr">id</span>=<span class="string">&#x27;1&#x27;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>zhangsan<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">age</span>&gt;</span>23<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">gender</span>&gt;</span>male<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">user</span> <span class="attr">id</span>=<span class="string">&#x27;2&#x27;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>lisi<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">age</span>&gt;</span>24<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">gender</span>&gt;</span>female<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">users</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>  （XML可以被浏览器解析，因此可以直接拖到浏览器中判断是否写对）</p>
</li>
<li><p>组成部分：</p>
<ol>
<li>文档声明<ol>
<li>格式：<code>&lt;?xml 属性列表 ?&gt;</code></li>
<li>属性列表：</li>
</ol>
<ul>
<li>version：版本号，必须的属性</li>
<li>encoding：编码方式。告知解析引擎当前文档使用的字符集，默认值：ISO-8859-1</li>
<li>standalone：是否独立<ul>
<li>取值：<br>* yes：不依赖其他文件<br>* no：依赖其他文件</li>
</ul>
</li>
</ul>
</li>
<li>指令(了解)：结合css的<ul>
<li><code>&lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;a.css&quot; ?&gt;</code></li>
</ul>
</li>
<li>标签：标签名称自定义的<ul>
<li>规则：<ul>
<li>名称可以包含字母、数字以及其他的字符 </li>
<li>名称不能以数字或者标点符号开始 </li>
<li>名称不能以字母 xml（或者 XML、Xml 等等）开始 </li>
<li>名称不能包含空格</li>
</ul>
</li>
</ul>
</li>
<li>属性：<br> id属性值唯一</li>
<li>文本：<ul>
<li>CDATA区：在该区域中的数据会被原样展示<ul>
<li>格式：  <code>&lt;![CDATA[ 数据 ]]&gt;</code>   (Alt+Enter)</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><p>约束：规定xml文档的书写规则<br>  * 作为框架的使用者(程序员)：<br>      1. 能够在xml中引入约束文档<br>  2. 能够简单的读懂约束文档</p>
<ul>
<li><p>分类：</p>
<ol>
<li>DTD:一种简单的约束技术</li>
<li>Schema:一种复杂的约束技术</li>
</ol>
</li>
<li><p>DTD：<br>      * 引入dtd文档到xml文档中<br>          * 内部dtd：将约束规则定义在xml文档中<br>  * 外部dtd：将约束的规则定义在外部的dtd文件中<br>       * 本地：<code>&lt;!DOCTYPE 根标签名 SYSTEM &quot;dtd文件的位置&quot;&gt;</code><br>       * 网络：<code>&lt;!DOCTYPE 根标签名 PUBLIC &quot;dtd文件名字&quot; &quot;dtd文件的位置URL&quot;&gt;</code></p>
</li>
<li><p>Schema:<br>   * 引入：<br>    1. 填写xml文档的根元素<br>    2. 引入xsi前缀.  xmlns:xsi&#x3D;”<a href="http://www.w3.org/2001/XMLSchema-instance&quot;">http://www.w3.org/2001/XMLSchema-instance&quot;</a><br>    3. 引入xsd文件命名空间.  xsi:schemaLocation&#x3D;”<a href="http://www.itcast.cn/xml">http://www.itcast.cn/xml</a>  student.xsd”<br>    4. 为每一个xsd约束声明一个前缀,作为标识  xmlns&#x3D;”<a href="http://www.itcast.cn/xml&quot;">http://www.itcast.cn/xml&quot;</a> </p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">students</span>   <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">xmlns</span>=<span class="string">&quot;http://www.itcast.cn/xml&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.itcast.cn/xml  student.xsd&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">student</span> <span class="attr">number</span>=<span class="string">&quot;heima_0001&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>tom<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">age</span>&gt;</span>18<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">sex</span>&gt;</span>male<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">students</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>操作xml文档，将文档中的数据读取到内存中</p>
<ul>
<li><p>操作xml文档</p>
<ol>
<li>解析(读取)：将文档中的数据读取到内存中</li>
<li>写入：将内存中的数据保存到xml文档中。持久化的存储</li>
</ol>
</li>
<li><p>解析xml的方式（两种思想）：</p>
<ol>
<li>DOM：将标记语言文档一次性加载进内存，在内存中形成一颗dom树 (一般用于服务端)<ul>
<li>优点：操作方便，可以对文档进行CRUD的所有操作</li>
<li>缺点：占内存</li>
</ul>
</li>
<li>SAX：逐行读取，基于事件驱动的。<ul>
<li>优点：不占内存。</li>
<li>缺点：只能读取，不能增删改</li>
</ul>
</li>
</ol>
</li>
<li><p>xml常见的解析器：<br>  1. JAXP：sun公司提供的解析器，支持dom和sax两种思想<br>  2. DOM4J：一款非常优秀的解析器<br>  3. Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。<br>  4. PULL：Android操作系统内置的解析器，sax方式的。</p>
</li>
<li><p>Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。</p>
<ul>
<li>步骤：<br>        1. 导入jar包<br>          2. 获取Document对象<br>          3. 获取对应的标签Element对象<br>          4. 获取数据</li>
</ul>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.jsoup.Jsoup;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.nodes.Document;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.nodes.Element;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.select.Elements;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URISyntaxException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Jsoup快速入门</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JsoupDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, URISyntaxException &#123;</span><br><span class="line">        <span class="comment">//2.获取Document对象，根据xml文档获取</span></span><br><span class="line">        <span class="comment">//2.1获取student.xml的path</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> JsoupDemo1.class.getClassLoader().getResource(<span class="string">&quot;student.xml&quot;</span>).toURI().getPath();</span><br><span class="line">        <span class="comment">//2.2解析xml文档，加载文档进内存，获取dom树---&gt;Document</span></span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> Jsoup.parse(<span class="keyword">new</span> <span class="title class_">File</span>(path), <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">//3.获取元素对象 Element</span></span><br><span class="line">        <span class="type">Elements</span> <span class="variable">elements</span> <span class="operator">=</span> document.getElementsByTag(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(elements.size());</span><br><span class="line">        <span class="comment">//3.1获取第一个name的Element对象</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">element</span> <span class="operator">=</span> elements.get(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//3.2获取数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> element.text();</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>对象的使用：</p>
<ol>
<li><p>Jsoup：工具类，可以解析html或xml文档，返回Document</p>
<ul>
<li>parse：解析html或xml文档，返回Document<ul>
<li><code>parse(File in, String charsetName)</code>：解析xml或html文件的。</li>
<li><code>parse(String html)</code>：解析xml或html字符串</li>
<li><code>parse(URL url, int timeoutMillis)</code>：通过网络路径获取指定的html或xml的文档对象</li>
</ul>
</li>
</ul>
</li>
<li><p>Document：文档对象。代表内存中的dom树</p>
<ul>
<li>获取Element对象<ul>
<li><code>getElementById(String id)</code>：根据id属性值获取唯一的element对象</li>
<li><code>getElementsByTag(String tagName)</code>：根据标签名称获取元素对象集合</li>
<li><code>getElementsByAttribute(String key)</code>：根据属性名称获取元素对象集合</li>
<li><code>getElementsByAttributeValue(String key, String value)</code>：根据对应的属性名和属性值获取元素对象集合</li>
</ul>
</li>
</ul>
</li>
<li><p>Elements：元素Element对象的集合。可以当做 <code>ArrayList&lt;Element&gt;</code>来使用</p>
</li>
<li><p>Element：元素对象</p>
<ol>
<li><p>获取子元素对象</p>
<ul>
<li><code>getElementById(String id)</code>：根据id属性值获取唯一的element对象</li>
<li><code>getElementsByTag(String tagName)</code>：根据标签名称获取元素对象集合</li>
<li><code>getElementsByAttribute(String key)</code>：根据属性名称获取元素对象集合</li>
<li><code>getElementsByAttributeValue(String key, String value)</code>：根据对应的属性名和属性值获取元素对象集合</li>
</ul>
</li>
<li><p>获取属性值</p>
<ul>
<li><code>String attr(String key)</code>：根据属性名称获取属性值</li>
</ul>
</li>
<li><p>获取文本内容</p>
<ul>
<li><code>String text()</code>:获取文本内容</li>
<li><code>String html()</code>:获取标签体的所有内容(包括字标签的字符串内容)</li>
</ul>
</li>
</ol>
</li>
<li><p>Node：节点对象</p>
<ul>
<li>是Document和Element的父类</li>
</ul>
</li>
</ol>
</li>
<li><p>快捷查询方式：</p>
<ol>
<li>selector:选择器<ul>
<li>使用的方法：<code>Elements select(String cssQuery)</code><ul>
<li>语法：参考Selector类中定义的语法</li>
</ul>
</li>
</ul>
</li>
<li>XPath：XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言<ul>
<li>使用Jsoup的Xpath需要额外导入jar包。</li>
<li>查询w3cshool参考手册，使用xpath的语法完成查询</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *XPath查询</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JsoupDemo6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, XpathSyntaxErrorException &#123;</span><br><span class="line">        <span class="comment">//1.获取student.xml的path</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> JsoupDemo6.class.getClassLoader().getResource(<span class="string">&quot;student.xml&quot;</span>).toURI().getPath();</span><br><span class="line">        <span class="comment">//2.获取Document对象</span></span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> Jsoup.parse(<span class="keyword">new</span> <span class="title class_">File</span>(path), <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.根据document对象，创建JXDocument对象</span></span><br><span class="line">        <span class="type">JXDocument</span> <span class="variable">jxDocument</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JXDocument</span>(document);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.结合xpath语法查询</span></span><br><span class="line">        <span class="comment">//4.1查询所有student标签</span></span><br><span class="line">        List&lt;JXNode&gt; jxNodes = jxDocument.selN(<span class="string">&quot;//student&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (JXNode jxNode : jxNodes) &#123;</span><br><span class="line">            System.out.println(jxNode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.2查询所有student标签下的name标签</span></span><br><span class="line">        List&lt;JXNode&gt; jxNodes2 = jxDocument.selN(<span class="string">&quot;//student/name&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (JXNode jxNode : jxNodes2) &#123;</span><br><span class="line">            System.out.println(jxNode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.3查询student标签下带有id属性的name标签</span></span><br><span class="line">        List&lt;JXNode&gt; jxNodes3 = jxDocument.selN(<span class="string">&quot;//student/name[@id]&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (JXNode jxNode : jxNodes3) &#123;</span><br><span class="line">            System.out.println(jxNode);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//4.4查询student标签下带有id属性的name标签 并且id属性值为itcast</span></span><br><span class="line"></span><br><span class="line">        List&lt;JXNode&gt; jxNodes4 = jxDocument.selN(<span class="string">&quot;//student/name[@id=&#x27;itcast&#x27;]&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (JXNode jxNode : jxNodes4) &#123;</span><br><span class="line">            System.out.println(jxNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC、数据库连接池、JDBCTemplate</title>
    <url>/2022/04/02/JDBC/</url>
    <content><![CDATA[<p>概述：本文记录了JDBC (Java DataBase Connectivity) 的相关知识，JDBC的基本概念级用法，数据库的连接池和JDBCTemplate。</p>
<span id="more"></span>

<h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><h3 id="JDBC的基本概念"><a href="#JDBC的基本概念" class="headerlink" title="JDBC的基本概念"></a>JDBC的基本概念</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>Java DataBase Connectivity   是Java数据库连接， Java语言操作数据库</p>
<p>JDBC本质：其实是官方（sun公司）<strong>定义的一套操作所有关系型数据库的规则，即接口</strong>。</p>
<p>各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。</p>
<p><img src="https://pic.imgdb.cn/item/6247db5a27f86abb2a4748c1.jpg"></p>
<h4 id="完整的连接步骤："><a href="#完整的连接步骤：" class="headerlink" title="完整的连接步骤："></a>完整的连接步骤：</h4><p>步骤：</p>
<p>（注意检查JDK的版本是否对应，另外注意executeUpdate只能用于操作Update语句，不能用于Select等语句）</p>
<ol>
<li><p>导入驱动jar包 如mysql-connector-java-8.0.13.jar（mysql8.0之前的要用另外的版本）<br> （1）复制jar包到项目的libs目录下<br> （2）右键–&gt;Add As Library</p>
</li>
<li><p>注册驱动</p>
</li>
<li><p>获取数据库连接对象 Connection </p>
<p>（注意账号密码对应，数据库名字对应，设置useSSL和serverTimezone）</p>
</li>
<li><p>定义sql</p>
</li>
<li><p>获取执行sql语句的对象 Statement</p>
</li>
<li><p>执行sql，接受返回结果</p>
</li>
<li><p>处理结果</p>
</li>
<li><p>释放资源</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JDBC快速入门</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1. 导入驱动jar包</span></span><br><span class="line">        <span class="comment">//2.注册驱动 mysql 5 之后注册驱动可以省略</span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        <span class="comment">//3.获取数据库连接对象</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/bjpowernode?useSSL=false&amp;serverTimezone=GMT%2B8&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="comment">//4.定义sql语句</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update t_user set name = &#x27;abc&#x27; where id = 2;&quot;</span>;</span><br><span class="line">        <span class="comment">//5.获取执行sql的对象 Statement</span></span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line">        <span class="comment">//6.执行sql</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> stmt.executeUpdate(sql);</span><br><span class="line">        <span class="comment">//7.处理结果</span></span><br><span class="line">        System.out.println(count);</span><br><span class="line">        <span class="comment">//8.释放资源</span></span><br><span class="line">        stmt.close();</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="详解各个对象"><a href="#详解各个对象" class="headerlink" title="详解各个对象"></a>详解各个对象</h4><h5 id="DriverManager：驱动管理对象"><a href="#DriverManager：驱动管理对象" class="headerlink" title="DriverManager：驱动管理对象"></a>DriverManager：驱动管理对象</h5><p>功能：</p>
<ol>
<li>注册驱动：告诉程序该使用哪一个数据库驱动jar<br> static void registerDriver(Driver driver) : 注册与给定的驱动程序 DriverManager 。</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//写代码使用：  Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span></span><br><span class="line"><span class="comment">//通过查看源码发现：在com.mysql.cj.jdbc.Driver类中存在静态代码块</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            java.sql.DriverManager.registerDriver(<span class="keyword">new</span> <span class="title class_">Driver</span>());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException E) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Can&#x27;t register driver!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  注意：mysql5之后的驱动jar包可以省略注册驱动的步骤。</p>
<ol start="2">
<li>获取数据库连接：</li>
</ol>
<ul>
<li><p>方法：static Connection getConnection(String url, String user, String password) </p>
</li>
<li><p>参数：</p>
<ul>
<li><p>url：指定连接的路径<br>    * <strong>语法：jdbc:mysql:&#x2F;&#x2F;ip地址(域名):端口号&#x2F;数据库名称</strong><br>            * 例子：jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;db3<br>            * 细节：<strong>如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:&#x2F;&#x2F;&#x2F;数据库名称</strong></p>
</li>
<li><p>user：用户名</p>
</li>
<li><p>password：密码</p>
</li>
</ul>
</li>
</ul>
<h5 id="Connection：数据库连接对象"><a href="#Connection：数据库连接对象" class="headerlink" title="Connection：数据库连接对象"></a>Connection：数据库连接对象</h5><p>功能：</p>
<ol>
<li>获取执行sql 的对象<ul>
<li>Statement createStatement()</li>
<li>PreparedStatement prepareStatement(String sql)</li>
</ul>
</li>
<li>管理事务：<ul>
<li>开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务</li>
<li>提交事务：commit() </li>
<li>回滚事务：rollback()</li>
</ul>
</li>
</ol>
<h5 id="Statement：执行sql的对象"><a href="#Statement：执行sql的对象" class="headerlink" title="Statement：执行sql的对象"></a>Statement：执行sql的对象</h5><p>执行sql</p>
<ul>
<li><p>boolean execute(String sql) ：可以执行任意的sql </p>
</li>
<li><p>int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句</p>
<p>返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值&gt;0的则执行成功，反之，则失败。</p>
</li>
<li><p>ResultSet executeQuery(String sql)  ：执行DQL（select)语句</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以插入操作为例，更加标准的代码，包括异常的处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1. 注册驱动</span></span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">            <span class="comment">//2. 定义sql</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into t_user(id,name,birth) values(2, &#x27;章齐&#x27;, &#x27;1998-05-28&#x27;);\n&quot;</span>;</span><br><span class="line">            <span class="comment">//3.获取Connection对象</span></span><br><span class="line">            conn = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/bjpowernode?useSSL=false&amp;serverTimezone=GMT%2B8&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">            <span class="comment">//4.获取执行sql的对象 Statement</span></span><br><span class="line">            stmt = conn.createStatement();</span><br><span class="line">            <span class="comment">//5.执行sql</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> stmt.executeUpdate(sql);<span class="comment">//影响的行数</span></span><br><span class="line">            <span class="comment">//6.处理结果</span></span><br><span class="line">            System.out.println(count);</span><br><span class="line">            <span class="keyword">if</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;添加成功！&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;添加失败！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//stmt.close();</span></span><br><span class="line">            <span class="comment">//7. 释放资源</span></span><br><span class="line">            <span class="comment">//避免空指针异常</span></span><br><span class="line">            <span class="keyword">if</span>(stmt != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    stmt.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(conn != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    conn.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="ResultSet：结果集对象-封装查询结果"><a href="#ResultSet：结果集对象-封装查询结果" class="headerlink" title="ResultSet：结果集对象,封装查询结果"></a>ResultSet：结果集对象,封装查询结果</h5><ul>
<li>boolean next(): 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true</li>
<li>getXxx(参数):获取数据<ul>
<li>Xxx：代表数据类型   如： int getInt() ,    String getString()</li>
<li>参数：<ol>
<li>int：代表列的编号,从1开始   如： getString(1)</li>
<li>String：代表列名称。 如： getDouble(“balance”)</li>
</ol>
</li>
</ul>
</li>
</ul>
<h5 id="PreparedStatement：执行sql的对象"><a href="#PreparedStatement：执行sql的对象" class="headerlink" title="PreparedStatement：执行sql的对象"></a>PreparedStatement：执行sql的对象</h5><ol>
<li>SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题<ol>
<li>输入用户随便，输入密码：a’ or ‘a’ &#x3D; ‘a</li>
<li>sql：select * from user where username &#x3D; ‘fhdsjkf’ and password &#x3D; ‘a’ or ‘a’ &#x3D; ‘a’</li>
</ol>
</li>
<li>解决sql注入问题：使用PreparedStatement对象来解决</li>
<li>预编译的SQL：参数使用?作为占位符</li>
<li>步骤：<ol>
<li>导入驱动jar包 mysql-connector-java-5.1.37-bin.jar</li>
<li>注册驱动</li>
<li>获取数据库连接对象 Connection</li>
<li>定义sql<ul>
<li>注意：sql的参数使用？作为占位符。 如：select * from user where username &#x3D; ? and password &#x3D; ?;</li>
</ul>
</li>
<li>获取执行sql语句的对象 PreparedStatement  Connection.prepareStatement(String sql) </li>
<li>给？赋值：<ul>
<li>方法： setXxx(参数1,参数2)<ul>
<li>参数1：？的位置编号 从1 开始</li>
<li>参数2：？的值</li>
</ul>
</li>
</ul>
</li>
<li>执行sql，接受返回结果，不需要传递sql语句</li>
<li>处理结果</li>
<li>释放资源</li>
</ol>
</li>
<li><strong>注意：后期都会使用PreparedStatement来完成增删改查的所有操作</strong><ol>
<li>可以防止SQL注入</li>
<li>效率更高</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.itcast.util.JDBCUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 	* 需求：</span></span><br><span class="line"><span class="comment"> * 		1. 通过键盘录入用户名和密码</span></span><br><span class="line"><span class="comment"> * 		2. 判断用户是否登录成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCDemo9</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.键盘录入，接受用户名和密码</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入用户名：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入密码：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">        <span class="comment">//2.调用方法</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JDBCDemo9</span>().login2(username, password);</span><br><span class="line">        <span class="comment">//3.判断结果，输出不同语句</span></span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="comment">//登录成功</span></span><br><span class="line">            System.out.println(<span class="string">&quot;登录成功！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;用户名或密码错误！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录方法，存在SQL注入的问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">login</span><span class="params">(String username ,String password)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(username == <span class="literal">null</span> || password == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//连接数据库判断是否登录成功</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span>  <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//1.获取连接</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn =  JDBCUtils.getConnection();</span><br><span class="line">            <span class="comment">//2.定义sql</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where username = &#x27;&quot;</span>+username+<span class="string">&quot;&#x27; and password = &#x27;&quot;</span>+password+<span class="string">&quot;&#x27; &quot;</span>;</span><br><span class="line">            System.out.println(sql);</span><br><span class="line">            <span class="comment">//3.获取执行sql的对象</span></span><br><span class="line">            stmt = conn.createStatement();</span><br><span class="line">            <span class="comment">//4.执行查询</span></span><br><span class="line">            rs = stmt.executeQuery(sql);</span><br><span class="line">            <span class="comment">//5.判断</span></span><br><span class="line">           <span class="keyword">return</span> rs.next();<span class="comment">//如果有下一行，则返回true</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtils.close(rs,stmt,conn);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录方法,使用PreparedStatement实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">login2</span><span class="params">(String username ,String password)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(username == <span class="literal">null</span> || password == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//连接数据库判断是否登录成功</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span>  <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//1.获取连接</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn =  JDBCUtils.getConnection();</span><br><span class="line">            <span class="comment">//2.定义sql</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where username = ? and password = ?&quot;</span>;</span><br><span class="line">            <span class="comment">//3.获取执行sql的对象</span></span><br><span class="line">            pstmt = conn.prepareStatement(sql);</span><br><span class="line">            <span class="comment">//4.给?赋值</span></span><br><span class="line">            pstmt.setString(<span class="number">1</span>,username);</span><br><span class="line">            pstmt.setString(<span class="number">2</span>,password);</span><br><span class="line">            <span class="comment">//5.执行查询,不需要传递sql</span></span><br><span class="line">            rs = pstmt.executeQuery();</span><br><span class="line">            <span class="comment">//6.判断</span></span><br><span class="line">            <span class="keyword">return</span> rs.next();<span class="comment">//如果有下一行，则返回true</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtils.close(rs,pstmt,conn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="抽取JDBC工具类-：-JDBCUtils"><a href="#抽取JDBC工具类-：-JDBCUtils" class="headerlink" title="抽取JDBC工具类 ： JDBCUtils"></a>抽取JDBC工具类 ： JDBCUtils</h3><ul>
<li>目的：简化书写（减少重复书写的代码）</li>
<li>分析：<ol>
<li><p>注册驱动也抽取</p>
</li>
<li><p>抽取一个方法获取连接对象</p>
<ul>
<li>需求：不想传递参数（麻烦），还得保证工具类的通用性。</li>
<li>解决：配置文件<br>  jdbc.properties<br>  url&#x3D;<br>  user&#x3D;<br>  password&#x3D;</li>
</ul>
</li>
<li><p>抽取一个方法释放资源</p>
</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JDBC工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCUtils</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String url;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String user;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String password;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String driver;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//读取资源文件，获取值。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1. 创建Properties集合类。</span></span><br><span class="line">            <span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取src路径下的文件的方式---&gt;ClassLoader 类加载器</span></span><br><span class="line">            <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> JDBCUtils.class.getClassLoader();</span><br><span class="line">            <span class="type">URL</span> <span class="variable">res</span>  <span class="operator">=</span> classLoader.getResource(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> res.getPath();</span><br><span class="line">           <span class="comment">// System.out.println(path);///D:/IdeaProjects/itcast/out/production/day04_jdbc/jdbc.properties</span></span><br><span class="line">            <span class="comment">//2. 加载文件</span></span><br><span class="line">           <span class="comment">// pro.load(new FileReader(&quot;D:\\IdeaProjects\\itcast\\day04_jdbc\\src\\jdbc.properties&quot;));</span></span><br><span class="line">            pro.load(<span class="keyword">new</span> <span class="title class_">FileReader</span>(path));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3. 获取数据，赋值</span></span><br><span class="line">            url = pro.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">            user = pro.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">            password = pro.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">            driver = pro.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line">            <span class="comment">//4. 注册驱动</span></span><br><span class="line">            Class.forName(driver);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取连接</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 连接对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放资源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stmt</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(Statement stmt,Connection conn)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( stmt != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stmt.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( conn != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放资源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stmt</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(ResultSet rs,Statement stmt, Connection conn)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( rs != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( stmt != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stmt.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( conn != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JDBC控制事务"><a href="#JDBC控制事务" class="headerlink" title="JDBC控制事务"></a>JDBC控制事务</h3><ol>
<li>事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。</li>
<li>操作：<ol>
<li>开启事务</li>
<li>提交事务</li>
<li>回滚事务</li>
</ol>
</li>
<li>使用Connection对象来管理事务<ul>
<li>开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务<ul>
<li>在执行sql之前开启事务</li>
</ul>
</li>
<li>提交事务：commit() <ul>
<li>当所有sql都执行完提交事务</li>
</ul>
</li>
<li>回滚事务：rollback() <ul>
<li>在catch中回滚事务</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.itcast.util.JDBCUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 事务操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCDemo10</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">pstmt1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">pstmt2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.获取连接</span></span><br><span class="line">            conn = JDBCUtils.getConnection();</span><br><span class="line">            <span class="comment">//开启事务</span></span><br><span class="line">            conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.定义sql</span></span><br><span class="line">            <span class="comment">//2.1 张三 - 500</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql1</span> <span class="operator">=</span> <span class="string">&quot;update account set balance = balance - ? where id = ?&quot;</span>;</span><br><span class="line">            <span class="comment">//2.2 李四 + 500</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql2</span> <span class="operator">=</span> <span class="string">&quot;update account set balance = balance + ? where id = ?&quot;</span>;</span><br><span class="line">            <span class="comment">//3.获取执行sql对象</span></span><br><span class="line">            pstmt1 = conn.prepareStatement(sql1);</span><br><span class="line">            pstmt2 = conn.prepareStatement(sql2);</span><br><span class="line">            <span class="comment">//4. 设置参数</span></span><br><span class="line">            pstmt1.setDouble(<span class="number">1</span>,<span class="number">500</span>);</span><br><span class="line">            pstmt1.setInt(<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            pstmt2.setDouble(<span class="number">1</span>,<span class="number">500</span>);</span><br><span class="line">            pstmt2.setInt(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">            <span class="comment">//5.执行sql</span></span><br><span class="line">            pstmt1.executeUpdate();</span><br><span class="line">            <span class="comment">// 手动制造异常</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>/<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            pstmt2.executeUpdate();</span><br><span class="line">            <span class="comment">//如果没有一场发生，则提交事务</span></span><br><span class="line">            conn.commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//事务回滚</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(conn != <span class="literal">null</span>) &#123;</span><br><span class="line">                    conn.rollback();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e1) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtils.close(pstmt1,conn);</span><br><span class="line">            JDBCUtils.close(pstmt2,<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><ol>
<li><p>概念：其实就是一个容器(集合)，存放数据库连接的容器。<br> 当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，（不会将连接释放掉）会将连接对象归还给容器。</p>
</li>
<li><p>好处：</p>
<ul>
<li><p>节约资源</p>
</li>
<li><p>用户访问高效（避免了多次向底层申请资源（连接对象））</p>
</li>
</ul>
</li>
<li><p>实现：</p>
<p> <strong>标准接口：DataSource</strong>   javax.sql包下的</p>
<p> <strong>方法</strong>：</p>
<ul>
<li><strong>获取连接</strong>：getConnection()</li>
<li><strong>归还连接</strong>：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接</li>
</ul>
<p> 一般我们不去实现它，由数据库厂商来实现</p>
<ul>
<li><p>C3P0：数据库连接池技术</p>
</li>
<li><p>Druid：数据库连接池实现技术，由阿里巴巴提供的</p>
</li>
</ul>
</li>
<li><p>C3P0：数据库连接池技术</p>
<p> 步骤：</p>
<ol>
<li><p>导入jar包 (两个) c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar ，</p>
<ul>
<li>不要忘记导入数据库驱动jar包</li>
</ul>
</li>
<li><p>定义配置文件：</p>
<ul>
<li>名称： c3p0.properties 或者 c3p0-config.xml</li>
<li>路径：直接将文件放在src目录下即可。</li>
</ul>
</li>
<li><p>创建核心对象 数据库连接池对象 ComboPooledDataSource</p>
</li>
<li><p>获取连接： getConnection</p>
</li>
</ol>
<ul>
<li>代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.创建数据库连接池对象</span></span><br><span class="line"><span class="type">DataSource</span> <span class="variable">ds</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>();</span><br><span class="line"><span class="comment">//2. 获取连接对象</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> ds.getConnection();</span><br></pre></td></tr></table></figure>

<p>注意xml文件配置（特别注意在 jdbcUrl 转义&amp;的写法（&amp;amp））</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">c3p0-config</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 使用默认的配置读取连接池对象 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">default-config</span>&gt;</span></span><br><span class="line">  	<span class="comment">&lt;!--  连接参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span>&gt;</span>com.mysql.cj.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span>&gt;</span>jdbc:mysql://localhost:3306/bjpowernode?useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=GMT%2B8<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 连接池参数 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--初始化申请的连接数量--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialPoolSize&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--最大的连接数量--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--超时时间--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;checkoutTimeout&quot;</span>&gt;</span>3000<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">default-config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">named-config</span> <span class="attr">name</span>=<span class="string">&quot;otherc3p0&quot;</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!--  连接参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span>&gt;</span>com.mysql.cj.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span>&gt;</span>jdbc:mysql://localhost:3306/bjpowernode?useSSL=false<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 连接池参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialPoolSize&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span>&gt;</span>8<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;checkoutTimeout&quot;</span>&gt;</span>1000<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">named-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">c3p0-config</span>&gt;</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>Druid：数据库连接池实现技术，由阿里巴巴提供的</p>
<ol>
<li>步骤：<ol>
<li>导入jar包 druid-1.0.9.jar</li>
<li>定义配置文件：<ul>
<li>是properties形式的</li>
<li>可以叫任意名称，可以放在任意目录下</li>
</ul>
</li>
<li>加载配置文件。Properties</li>
<li>获取数据库连接池对象：通过工厂来来获取  DruidDataSourceFactory</li>
<li>获取连接：getConnection</li>
</ol>
</li>
</ol>
<ul>
<li>代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">//3.加载配置文件</span></span><br><span class="line">  <span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">  <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> DruidDemo.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>);</span><br><span class="line">  pro.load(is);</span><br><span class="line">  <span class="comment">//4.获取连接池对象</span></span><br><span class="line">  <span class="type">DataSource</span> <span class="variable">ds</span> <span class="operator">=</span> DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line"><span class="comment">//5.获取连接</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> ds.getConnection();</span><br></pre></td></tr></table></figure>
 <figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/bjpowernode?useSSL=false&amp;serverTimezone=GMT%2B8</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123456</span></span><br><span class="line"><span class="attr">initialSize</span>=<span class="string">5</span></span><br><span class="line"><span class="attr">maxActive</span>=<span class="string">10</span></span><br><span class="line"><span class="attr">maxWait</span>=<span class="string">3000</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>定义工具类<ol>
<li><p>定义一个类 JDBCUtils</p>
</li>
<li><p>提供静态代码块加载配置文件，初始化连接池对象</p>
</li>
<li><p>提供方法</p>
<ul>
<li><p>获取连接方法：通过数据库连接池获取连接</p>
</li>
<li><p>释放资源</p>
</li>
<li><p>获取连接池的方法</p>
</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<ul>
<li><p>代码：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Druid连接池的工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCUtils</span> &#123;</span><br><span class="line">    <span class="comment">//1.定义成员变量 DataSource</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DataSource ds ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.加载配置文件</span></span><br><span class="line">            <span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>));</span><br><span class="line">            <span class="comment">//2.获取DataSource</span></span><br><span class="line">            ds = DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">return</span> ds.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(Statement stmt,Connection conn)</span>&#123;</span><br><span class="line">       close(<span class="literal">null</span>,stmt,conn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(ResultSet rs , Statement stmt, Connection conn)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rs != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(stmt != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stmt.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(conn != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();<span class="comment">//归还连接</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取连接池方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DataSource <span class="title function_">getDataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  ds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>使用工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.datasource.druid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.utils.JDBCUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用新的工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DruidDemo2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 完成添加操作：给account表添加一条记录</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.获取连接</span></span><br><span class="line">            conn = JDBCUtils.getConnection();</span><br><span class="line">            <span class="comment">//2.定义sql</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into t_class values(?,?)&quot;</span>;</span><br><span class="line">            <span class="comment">//3.获取pstmt对象</span></span><br><span class="line">            pstmt = conn.prepareStatement(sql);</span><br><span class="line">            <span class="comment">//4.给？赋值</span></span><br><span class="line">            pstmt.setInt(<span class="number">1</span>,<span class="number">200</span>);</span><br><span class="line">            pstmt.setString(<span class="number">2</span>,<span class="string">&quot;class1&quot;</span>);</span><br><span class="line">            <span class="comment">//5.执行sql</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> pstmt.executeUpdate();</span><br><span class="line">            System.out.println(count);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//6. 释放资源</span></span><br><span class="line">            JDBCUtils.close(pstmt,conn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Spring-JdbcTemplate"><a href="#Spring-JdbcTemplate" class="headerlink" title="Spring  JdbcTemplate"></a>Spring  JdbcTemplate</h2><p>它是spring框架中提供的一个对象，是对原始繁琐的Jdbc API对象的简单封装。spring框架为我们提供了很多的操作模板类。例如：操作关系型数据的JdbcTemplate和HibernateTemplate，操作nosql数据库的RedisTemplate，操作消息队列的JmsTemplate等等。</p>
<ul>
<li><p>Spring框架对JDBC的简单封装。提供了一个<strong>JdbcTemplate</strong>对象简化JDBC的开发</p>
</li>
<li><p><strong>步骤：</strong></p>
<ol>
<li><p>导入jar包</p>
</li>
<li><p>创建JdbcTemplate对象。依赖于数据源DataSource</p>
</li>
</ol>
<pre><code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">JdbcTemplate</span> <span class="variable">template</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(ds);</span><br></pre></td></tr></table></figure>
</code></pre>
<ol start="3">
<li>调用JdbcTemplate的方法来完成CRUD的操作<br>* <code>update()</code>:执行DML语句。增、删、改语句</li>
</ol>
<pre><code>* ```queryForMap()```:查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合

     注意：这个方法查询的结果集长度只能是1

* ```queryForList()```:查询结果将结果集封装为list集合

     ​    注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中

* ```query()```:查询结果，将结果封装为JavaBean对象

 * query的参数：RowMapper
      一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装
                * new BeanPropertyRowMapper&lt;类型&gt;(类型.class)

* ```queryForObject()```：查询结果，将结果封装为对象

 * 一般用于聚合函数的查询

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.jdbctemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.utils.JDBCUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JdbcTemplate入门</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcTemplateDemo1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.导入jar包</span></span><br><span class="line">        <span class="comment">//2.创建JDBCTemplate对象</span></span><br><span class="line">        <span class="type">JdbcTemplate</span> <span class="variable">template</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(JDBCUtils.getDataSource());</span><br><span class="line">        <span class="comment">//3.调用方法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update t_class set classname = &#x27;class2&#x27; where classno = ?&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> template.update(sql, <span class="number">200</span>);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p><strong>使用maven框架的步骤：</strong></p>
<ul>
<li><p>导入spring-jdbc和spring-tx坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建数据库表和实体</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建account表和Account实体</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Account&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, money=&quot;</span> + money +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建JdbcTemplate对象</p>
</li>
<li><p>执行数据库操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcTemplateTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="comment">//测试JdbcTemplate开发步骤</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> PropertyVetoException &#123;</span><br><span class="line">        <span class="comment">//创建数据源对象</span></span><br><span class="line">        <span class="type">ComboPooledDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>();</span><br><span class="line">        dataSource.setDriverClass(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        dataSource.setJdbcUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>);</span><br><span class="line">        dataSource.setUser(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">JdbcTemplate</span> <span class="variable">jdbcTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>();</span><br><span class="line">        <span class="comment">//设置数据源对象  知道数据库在哪</span></span><br><span class="line">        jdbcTemplate.setDataSource(dataSource);</span><br><span class="line">        <span class="comment">//执行操作</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> jdbcTemplate.update(<span class="string">&quot;insert into account values(?,?)&quot;</span>, <span class="string">&quot;tom&quot;</span>, <span class="number">5000</span>);</span><br><span class="line">        System.out.println(row);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>Spring产生JdbcTemplate对象</strong></p>
<p>我们可以将JdbcTemplate的创建权交给Spring，将数据源DataSource的创建权也交给Spring，在Spring容器内部将数据源DataSource注入到JdbcTemplate模版对象中，配置如下：</p>
<p>applicationContext.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--加载jdbc.properties--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--数据源对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--jdbc模板对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//测试Spring产生jdbcTemplate对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> PropertyVetoException &#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">    <span class="type">JdbcTemplate</span> <span class="variable">jdbcTemplate</span> <span class="operator">=</span> app.getBean(JdbcTemplate.class);</span><br><span class="line">    <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> jdbcTemplate.update(<span class="string">&quot;insert into account values(?,?)&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="number">5000</span>);</span><br><span class="line">    System.out.println(row);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用练习：</p>
<p>table emp格式：</p>
<p><img src="https://pic.imgdb.cn/item/62547ea4239250f7c59b6709.jpg"></p>
<ul>
<li>设计一个emp类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Emp</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String ename;</span><br><span class="line">    <span class="keyword">private</span> String job;</span><br><span class="line">    <span class="keyword">private</span> Integer mgr;</span><br><span class="line">    <span class="keyword">private</span> Date joindate;</span><br><span class="line">    <span class="keyword">private</span> Double salary;</span><br><span class="line">    <span class="keyword">private</span> Double bonus;</span><br><span class="line">    <span class="keyword">private</span> Integer dept_id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getEname</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ename;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEname</span><span class="params">(String ename)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.ename = ename;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getJob_id</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> job;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setJob_id</span><span class="params">(String job)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.job = job;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getMgr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mgr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMgr</span><span class="params">(Integer mgr)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mgr = mgr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getJoindate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> joindate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setJoindate</span><span class="params">(Date joindate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.joindate = joindate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Double <span class="title function_">getSalary</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSalary</span><span class="params">(Double salary)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Double <span class="title function_">getBonus</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bonus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBonus</span><span class="params">(Double bonus)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bonus = bonus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getDept_id</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dept_id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDept_id</span><span class="params">(Integer dept_id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dept_id = dept_id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Emp&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, ename=&#x27;&quot;</span> + ename + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, job_id=&quot;</span> + job +</span><br><span class="line">                <span class="string">&quot;, mgr=&quot;</span> + mgr +</span><br><span class="line">                <span class="string">&quot;, joindate=&quot;</span> + joindate +</span><br><span class="line">                <span class="string">&quot;, salary=&quot;</span> + salary +</span><br><span class="line">                <span class="string">&quot;, bonus=&quot;</span> + bonus +</span><br><span class="line">                <span class="string">&quot;, dept_id=&quot;</span> + dept_id +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用Junit进行测试</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.jdbctemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.domain.Emp;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.utils.JDBCUtils;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.BeanPropertyRowMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.RowMapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Date;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcTemplateDemo2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Junit单元测试，可以让方法独立执行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 获取JDBCTemplate对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">JdbcTemplate</span> <span class="variable">template</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(JDBCUtils.getDataSource());</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. 修改1号数据的 salary 为 10000</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 定义sql</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update emp set SAL = 1000 where EMPNO = 7369&quot;</span>;</span><br><span class="line">        <span class="comment">//3. 执行sql</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> template.update(sql);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2. 添加一条记录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into emp(empno,ename,deptno) values(?,?,?)&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> template.update(sql, <span class="number">1015</span>, <span class="string">&quot;郭靖&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        System.out.println(count);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3.删除刚才添加的记录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;delete from emp where empno = ?&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> template.update(sql, <span class="number">1015</span>);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 4.查询id为1001的记录，将其封装为Map集合</span></span><br><span class="line"><span class="comment">     * 注意：这个方法查询的结果集长度只能是1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from emp where empno = ? or empno = ?&quot;</span>;</span><br><span class="line">        Map&lt;String, Object&gt; map = template.queryForMap(sql, <span class="number">1015</span>,<span class="number">7369</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">//&#123;id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20&#125;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 5. 查询所有记录，将其封装为List</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from t_class&quot;</span>;</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map&lt;String, Object&gt; stringObjectMap : list) &#123;</span><br><span class="line">            System.out.println(stringObjectMap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 6. 查询所有记录，将其封装为Emp对象的List集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from emp&quot;</span>;</span><br><span class="line">        List&lt;Emp&gt; list = template.query(sql, <span class="keyword">new</span> <span class="title class_">RowMapper</span>&lt;Emp&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Emp <span class="title function_">mapRow</span><span class="params">(ResultSet rs, <span class="type">int</span> i)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">                <span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Emp</span>();</span><br><span class="line">                <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;EMPNO&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">ename</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;ENAME&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">job</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;JOB&quot;</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">mgr</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;MGR&quot;</span>);</span><br><span class="line">                <span class="type">Date</span> <span class="variable">joindate</span> <span class="operator">=</span> rs.getDate(<span class="string">&quot;HIREDATE&quot;</span>);</span><br><span class="line">                <span class="type">double</span> <span class="variable">salary</span> <span class="operator">=</span> rs.getDouble(<span class="string">&quot;SAL&quot;</span>);</span><br><span class="line">                <span class="type">double</span> <span class="variable">bonus</span> <span class="operator">=</span> rs.getDouble(<span class="string">&quot;COMM&quot;</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">dept_id</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;DEPTNO&quot;</span>);</span><br><span class="line"></span><br><span class="line">                emp.setId(id);</span><br><span class="line">                emp.setEname(ename);</span><br><span class="line">                emp.setJob_id(job);</span><br><span class="line">                emp.setMgr(mgr);</span><br><span class="line">                emp.setJoindate(joindate);</span><br><span class="line">                emp.setSalary(salary);</span><br><span class="line">                emp.setBonus(bonus);</span><br><span class="line">                emp.setDept_id(dept_id);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> emp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Emp emp : list) &#123;</span><br><span class="line">            System.out.println(emp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 6. 查询所有记录，将其封装为Emp对象的List集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6_2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from emp&quot;</span>;</span><br><span class="line">        List&lt;Emp&gt; list = template.query(sql, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;Emp&gt;(Emp.class));</span><br><span class="line">        <span class="keyword">for</span> (Emp emp : list) &#123;</span><br><span class="line">            System.out.println(emp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 7. 查询总记录数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test7</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select count(empno) from emp&quot;</span>;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">total</span> <span class="operator">=</span> template.queryForObject(sql, Long.class);</span><br><span class="line">        System.out.println(total);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>MySQL</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>Junit、反射、注解</title>
    <url>/2022/04/01/javaweb01/</url>
    <content><![CDATA[<p>本系列记录了JavaWeb领域服务端程序开发的基础知识。</p>
<p>本文中包含Junit单元测试，反射，注解</p>
<span id="more"></span>

<h3 id="Web的整体结构"><a href="#Web的整体结构" class="headerlink" title="Web的整体结构"></a>Web的整体结构</h3><p>首先熟悉一下Web的整体结构以及各部分都做些什么</p>
<p><img src="https://pic.imgdb.cn/item/6246c46d27f86abb2a91f1a8.jpg"></p>
<h3 id="Junit单元测试"><a href="#Junit单元测试" class="headerlink" title="Junit单元测试"></a>Junit单元测试</h3><ul>
<li><p>测试分类：</p>
<ol>
<li>黑盒测试：不需要写代码，给输入值，看程序是否能够输出期望的值。</li>
<li>白盒测试：需要写代码的。关注程序具体的执行流程。</li>
</ol>
</li>
<li><p>Junit使用：白盒测试</p>
<ul>
<li><p>步骤：</p>
<ol>
<li><p>定义一个测试类(测试用例)</p>
<ul>
<li>建议：<ul>
<li>测试类名：被测试的类名Test        如CalculatorTest</li>
<li>包名：xxx.xxx.xx.test        cn.itcast.test</li>
</ul>
</li>
</ul>
</li>
<li><p>定义测试方法：可以独立运行</p>
<ul>
<li>建议：<ul>
<li>方法名：test测试的方法名        testAdd()  </li>
<li>返回值：void</li>
<li>参数列表：空参</li>
</ul>
</li>
</ul>
</li>
<li><p>给方法加 @Test</p>
</li>
<li><p>导入junit依赖环境</p>
</li>
</ol>
</li>
<li><p>判定结果：</p>
<ul>
<li>红色：失败</li>
<li>绿色：成功</li>
<li>一般我们会使用断言操作来处理结果<ul>
<li>Assert.assertEquals(期望的结果,运算的结果);</li>
</ul>
</li>
</ul>
</li>
<li><p>补充：</p>
<ul>
<li>@Before:<ul>
<li>修饰的方法会在测试方法之前被自动执行</li>
</ul>
</li>
<li>@After:<ul>
<li>修饰的方法会在测试方法执行之后自动被执行</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="反射：框架设计的灵魂"><a href="#反射：框架设计的灵魂" class="headerlink" title="反射：框架设计的灵魂"></a>反射：框架设计的灵魂</h3><p><img src="https://pic.imgdb.cn/item/6247082127f86abb2a229a6f.jpg"></p>
<ul>
<li><p>框架：半成品软件。可以在框架的基础上进行软件开发，简化编码</p>
</li>
<li><p><strong>反射：将类的各个组成部分封装为其他对象，这就是反射机制</strong></p>
<ul>
<li>好处：<ol>
<li>可以在程序运行过程中，操作这些对象。</li>
<li>可以解耦，提高程序的可扩展性。</li>
</ol>
</li>
</ul>
</li>
<li><p>获取Class类对象的方式（三个阶段有不同的方式）：</p>
<ol>
<li>Class.forName(“全类名”)：将字节码文件加载进内存，返回Class对象<ul>
<li>多用于配置文件，将类名定义在配置文件中。读取文件，加载类</li>
</ul>
</li>
<li>类名.class：通过类名的属性class获取<ul>
<li>多用于参数的传递</li>
</ul>
</li>
<li>对象.getClass()：getClass()方法在Object类中定义着。<ul>
<li>多用于对象的获取字节码的方式</li>
</ul>
</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">       获取Class对象的方式：</span></span><br><span class="line"><span class="comment">           1. Class.forName(&quot;全类名&quot;)：将字节码文件加载进内存，返回Class对象</span></span><br><span class="line"><span class="comment">           2. 类名.class：通过类名的属性class获取</span></span><br><span class="line"><span class="comment">           3. 对象.getClass()：getClass()方法在Object类中定义着。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	</span><br><span class="line">       <span class="comment">//1.Class.forName(&quot;全类名&quot;)</span></span><br><span class="line">       <span class="type">Class</span> <span class="variable">cls1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;cn.itcast.domain.Person&quot;</span>);</span><br><span class="line">       System.out.println(cls1);</span><br><span class="line">       <span class="comment">//2.类名.class</span></span><br><span class="line">       <span class="type">Class</span> <span class="variable">cls2</span> <span class="operator">=</span> Person.class;</span><br><span class="line">       System.out.println(cls2);</span><br><span class="line">       <span class="comment">//3.对象.getClass()</span></span><br><span class="line">       <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">       <span class="type">Class</span> <span class="variable">cls3</span> <span class="operator">=</span> p.getClass();</span><br><span class="line">       System.out.println(cls3);</span><br><span class="line">	</span><br><span class="line">       <span class="comment">//== 比较三个对象</span></span><br><span class="line">       System.out.println(cls1 == cls2);<span class="comment">//true</span></span><br><span class="line">       System.out.println(cls1 == cls3);<span class="comment">//true</span></span><br><span class="line">	</span><br><span class="line">       <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Student.class;</span><br><span class="line">       System.out.println(c == cls1);<span class="comment">//false</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>结论：<br>同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。</li>
</ul>
</li>
<li><p>Class对象功能：</p>
<ul>
<li>获取功能（一共13个方法）：<ol>
<li><p>获取成员变量们</p>
<ul>
<li><p>Field[ ] getFields() ：获取所有<strong>public修饰的</strong>成员变量</p>
</li>
<li><p>Field getField(String name)   获取<strong>指定名称</strong>的 public修饰的成员变量</p>
</li>
<li><p>Field[ ] getDeclaredFields()  获取<strong>所有的</strong>成员变量，不考虑修饰符</p>
</li>
<li><p>Field getDeclaredField(String name)</p>
</li>
</ul>
</li>
<li><p>获取构造方法们</p>
<ul>
<li><p>Constructor&lt;?&gt;[ ] getConstructors()  </p>
</li>
<li><p>Constructor<T> getConstructor(类&lt;?&gt;… parameterTypes)  </p>
</li>
<li><p>Constructor<T> getDeclaredConstructor(类&lt;?&gt;… parameterTypes)  </p>
</li>
<li><p>Constructor&lt;?&gt;[ ] getDeclaredConstructors()</p>
</li>
</ul>
</li>
<li><p>获取成员方法们：</p>
<ul>
<li><p>Method[ ] getMethods()  </p>
</li>
<li><p>Method getMethod(String name, 类&lt;?&gt;… parameterTypes)  </p>
</li>
<li><p>Method[ ] getDeclaredMethods()  </p>
</li>
<li><p>Method getDeclaredMethod(String name, 类&lt;?&gt;… parameterTypes)</p>
</li>
</ul>
</li>
<li><p>获取全类名    </p>
<ul>
<li>String getName()</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>Field：成员变量</p>
<ul>
<li>操作：<ol>
<li><p><strong>设置值</strong></p>
<ul>
<li>void set(Object obj, Object value)</li>
</ul>
</li>
<li><p><strong>获取值</strong></p>
<ul>
<li>get(Object obj)</li>
</ul>
</li>
<li><p>忽略访问权限修饰符的<strong>安全检查</strong></p>
<ul>
<li>setAccessible(true):暴力反射</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>Constructor:构造方法</p>
<ul>
<li><strong>创建</strong>对象：<ul>
<li><p>T newInstance(Object… initargs)  </p>
</li>
<li><p>如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance()方法</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Method：方法对象</p>
<ul>
<li><p><strong>执行</strong>方法：</p>
<ul>
<li>Object invoke(Object obj, Object… args)</li>
</ul>
</li>
<li><p>获取方法名称：</p>
<ul>
<li>String getName(): 获取方法名</li>
</ul>
</li>
</ul>
</li>
<li><p>案例：</p>
<ul>
<li>需求：写一个”框架”，不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中任意方法<ul>
<li>实现：<ol>
<li>配置文件</li>
<li>反射</li>
</ol>
</li>
<li>步骤：<ol>
<li>将需要创建的对象的全类名和需要执行的方法定义在配置文件中</li>
<li>在程序中加载读取配置文件</li>
<li>使用反射技术来加载类文件进内存</li>
<li>创建对象</li>
<li>执行方法</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 框架类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//可以创建任意类的对象，可以执行任意方法</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            前提：不能改变该类的任何代码。可以创建任意类的对象，可以执行任意方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.加载配置文件</span></span><br><span class="line">        <span class="comment">//1.1创建Properties对象</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">//1.2加载配置文件，转换为一个集合</span></span><br><span class="line">        <span class="comment">//1.2.1获取class目录下的配置文件</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ReflectTest.class.getClassLoader();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> classLoader.getResourceAsStream(<span class="string">&quot;pro.properties&quot;</span>);</span><br><span class="line">        pro.load(is);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取配置文件中定义的数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> pro.getProperty(<span class="string">&quot;className&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> pro.getProperty(<span class="string">&quot;methodName&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.加载该类进内存</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line">        <span class="comment">//4.创建对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> cls.newInstance();</span><br><span class="line">        <span class="comment">//5.获取方法对象</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> cls.getMethod(methodName);</span><br><span class="line">        <span class="comment">//6.执行方法</span></span><br><span class="line">        method.invoke(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><ul>
<li><p>概念：说明程序的。给计算机看的</p>
</li>
<li><p>注释：用文字描述程序的。给程序员看的</p>
</li>
<li><p>定义：注解（Annotation），是一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。</p>
</li>
<li><p>概念描述：</p>
<ul>
<li>JDK1.5之后的新特性</li>
<li>说明程序的</li>
<li>使用注解：@注解名称</li>
</ul>
</li>
<li><p>作用分类：</p>
<ul>
<li>编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】</li>
<li>编写文档：通过代码里标识的注解生成文档【生成文档doc文档】</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注解javadoc演示</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> itcat</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnoDemo1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算两数的和</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a 整数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b 整数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 两数的和</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">/**** </span></span><br><span class="line"><span class="comment">       * <span class="doctag">@Description</span>: add </span></span><br><span class="line"><span class="comment">       *   * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> b </span></span><br><span class="line"><span class="comment">       * <span class="doctag">@return</span>: int </span></span><br><span class="line"><span class="comment">       * <span class="doctag">@Author</span>: Mr.Cao</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@Date</span>: 2018/6/18 </span></span><br><span class="line"><span class="comment">       */</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b )</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span>: summ</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Param</span>: [a, b]</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>: int</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: Mr.Cao</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span>: 2018/6/18    tab+a+/</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span>  <span class="type">int</span> <span class="title function_">summ</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>代码分析：通过代码里标识的注解对代码进行分析【使用反射】</li>
</ul>
</li>
<li><p>JDK中预定义的一些注解</p>
<ul>
<li>@Override    ：检测被该注解标注的方法是否是继承自父类&#x2F;父接口的</li>
<li>@Deprecated：该注解标注的内容，表示已过时</li>
<li>@SuppressWarnings：压制警告<ul>
<li>一般传递参数all  @SuppressWarnings(“all”)</li>
</ul>
</li>
</ul>
</li>
<li><p>自定义注解</p>
<ul>
<li>格式：<br>      元注解<br>      public @interface 注解名称{<br>             属性列表;<br>      }</li>
<li>本质：<strong>注解本质上就是一个接口，该接口默认继承Annotation接口</strong><ul>
<li>public interface MyAnno extends java.lang.annotation.Annotation {}</li>
</ul>
</li>
<li><strong>属性：接口中的抽象方法</strong><ul>
<li>要求：<ol>
<li>属性的返回值类型有下列取值<ul>
<li>基本数据类型</li>
<li>String</li>
<li>枚举enum</li>
<li>注解</li>
<li>以上类型的数组</li>
</ul>
</li>
<li>定义了属性，在使用时需要给属性赋值<ol>
<li>如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。</li>
<li>如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可。</li>
<li>数组赋值时，值使用{}包裹。如果数组中只有一个值，则{}可以省略</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
</ul>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnno &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">    Person <span class="title function_">per</span><span class="params">()</span>;<span class="comment">//Person是一个枚举类</span></span><br><span class="line">    MyAnno2 <span class="title function_">anno2</span><span class="params">()</span>;</span><br><span class="line">    String[] strs();</span><br><span class="line">    <span class="comment">/*String name() default &quot;张三&quot;; 设置默认值*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MyAnno(value=12,per = Person.P3,anno2 = @MyAnno2,strs=&#123;&quot;bbb&quot;,&quot;aaa&quot;&#125;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>元注解：用于描述注解的注解<ul>
<li><strong>@Target</strong>：描述注解能够作用的位置<ul>
<li>ElementType取值：<ul>
<li>TYPE：可以作用于类上</li>
<li>METHOD：可以作用于方法上</li>
<li>FIELD：可以作用于成员变量上</li>
</ul>
</li>
</ul>
</li>
<li><strong>@Retention</strong>：描述注解被保留的阶段<ul>
<li>@Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到</li>
</ul>
</li>
<li><strong>@Documented</strong>：描述注解是否被抽取到api文档中</li>
<li><strong>@Inherited</strong>：描述注解是否被子类继承</li>
</ul>
</li>
</ul>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD,ElementType.FIELD&#125;)</span></span><br><span class="line">	<span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line">	<span class="meta">@Documented</span></span><br><span class="line">	<span class="meta">@Inherited</span></span><br><span class="line">	<span class="keyword">public</span> <span class="meta">@interface</span> MyAnno3 &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">* 在程序使用(解析)注解：获取注解中定义的属性值</span><br><span class="line"></span><br><span class="line">  <span class="number">1.</span> 获取注解定义的位置的对象  （Class，Method,Field）</span><br><span class="line">  <span class="number">2.</span> 获取指定的注解</span><br><span class="line">    * getAnnotation(Class)</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  <span class="comment">//其实就是在内存中生成了一个该注解接口的子类实现对象</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProImpl</span> <span class="keyword">implements</span> <span class="title class_">Pro</span>&#123;</span><br><span class="line">  	<span class="keyword">public</span> String <span class="title function_">className</span><span class="params">()</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;cn.itcast.annotation.Demo1&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">public</span> String <span class="title function_">methodName</span><span class="params">()</span>&#123;</span><br><span class="line">      	<span class="keyword">return</span> <span class="string">&quot;show&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>调用注解中的抽象方法获取配置的属性值</li>
</ol>
</li>
<li><p>注解解析图</p>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/62470dba27f86abb2a30d961.jpg"></p>
<ul>
<li><p>案例：简单的测试框架</p>
</li>
<li><p>小结：</p>
<ol>
<li>以后大多数时候，我们会使用注解，而不是自定义注解</li>
<li>注解给谁用？</li>
<li>编译器</li>
<li>给解析程序用</li>
<li>注解不是程序的一部分，可以理解为注解就是一个标签</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 小明定义的计算器类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="comment">//加法</span></span><br><span class="line">    <span class="meta">@Check</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        str.toString();</span><br><span class="line">        System.out.println(<span class="string">&quot;1 + 0 =&quot;</span> + (<span class="number">1</span> + <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//减法</span></span><br><span class="line">    <span class="meta">@Check</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sub</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1 - 0 =&quot;</span> + (<span class="number">1</span> - <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//乘法</span></span><br><span class="line">    <span class="meta">@Check</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mul</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1 * 0 =&quot;</span> + (<span class="number">1</span> * <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//除法</span></span><br><span class="line">    <span class="meta">@Check</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">div</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1 / 0 =&quot;</span> + (<span class="number">1</span> / <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;永无bug...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Check &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单的测试框架</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 当主方法执行后，会自动自行被检测的所有方法(加了Check注解的方法)，判断方法是否有异常，记录到文件中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCheck</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.创建计算器对象</span></span><br><span class="line">        <span class="type">Calculator</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calculator</span>();</span><br><span class="line">        <span class="comment">//2.获取字节码文件对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> c.getClass();</span><br><span class="line">        <span class="comment">//3.获取所有方法</span></span><br><span class="line">        Method[] methods = cls.getMethods();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//出现异常的次数</span></span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;bug.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="comment">//4.判断方法上是否有Check注解</span></span><br><span class="line">            <span class="keyword">if</span>(method.isAnnotationPresent(Check.class))&#123;</span><br><span class="line">                <span class="comment">//5.有，执行</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    method.invoke(c);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="comment">//6.捕获异常</span></span><br><span class="line">                    <span class="comment">//记录到文件中</span></span><br><span class="line">                    number ++;</span><br><span class="line"></span><br><span class="line">                    bw.write(method.getName()+ <span class="string">&quot; 方法出异常了&quot;</span>);</span><br><span class="line">                    bw.newLine();</span><br><span class="line">                    bw.write(<span class="string">&quot;异常的名称:&quot;</span> + e.getCause().getClass().getSimpleName());</span><br><span class="line">                    bw.newLine();</span><br><span class="line">                    bw.write(<span class="string">&quot;异常的原因:&quot;</span>+e.getCause().getMessage());</span><br><span class="line">                    bw.newLine();</span><br><span class="line">                    bw.write(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">                    bw.newLine();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bw.write(<span class="string">&quot;本次测试一共出现 &quot;</span>+number+<span class="string">&quot; 次异常&quot;</span>);</span><br><span class="line"></span><br><span class="line">        bw.flush();</span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEAerror</title>
    <url>/2022/04/01/IDEAerror/</url>
    <content><![CDATA[<p>概述：本文记录了使用IDEA过程中遇到的错误以及解决方案</p>
<span id="more"></span>



<h4 id="IDEA-Java错误：不支持发行版本"><a href="#IDEA-Java错误：不支持发行版本" class="headerlink" title="IDEA Java错误：不支持发行版本"></a>IDEA Java错误：不支持发行版本</h4><p><a href="https://blog.csdn.net/Deeeelete/article/details/104382752?utm_medium=distribute.pc_relevant.none-task-blog-baidulandingword-3&spm=1001.2101.3001.4242"><em>解决方案</em></a></p>
<p>查看几个地方：</p>
<p>（1）项目结构 - 项目 - SDK版本</p>
<p>（2）项目结构 - 模块 - 源 - 语言级别</p>
<p>（3）项目结构 - 模块 - 依赖 - 模块SDK</p>
<p>（4）设置 - Java编译器 - 项目字节码版本和目标字节码版本</p>
<h4 id="Cannot-resolve-symbol-’XXX‘-无法解析的符号-、"><a href="#Cannot-resolve-symbol-’XXX‘-无法解析的符号-、" class="headerlink" title="Cannot resolve symbol ’XXX‘ (无法解析的符号)、"></a>Cannot resolve symbol ’XXX‘ (无法解析的符号)、</h4><p>一般先检查项目结构中是否已经选择了合适的JDK</p>
<p><a href="https://blog.csdn.net/he99774/article/details/78254262"><em>解决方案</em></a></p>
<h4 id="mysql驱动连接-Cannot-load-driver-class-com-mysql-cj-jdbc-Driver"><a href="#mysql驱动连接-Cannot-load-driver-class-com-mysql-cj-jdbc-Driver" class="headerlink" title="mysql驱动连接 Cannot load driver class:com.mysql.cj.jdbc.Driver"></a>mysql驱动连接 Cannot load driver class:com.mysql.cj.jdbc.Driver</h4><p>（1）检查MySQL版本</p>
<p>（2）注意新版本MySQL的写法</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/bjpowernode?useSSL=false&amp;serverTimezone=GMT%2B8</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure>

<p>（3）pom.xml中进行版本修改,在库中删除原来的版本，再重新打开项目</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>      </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="启动Web项目时出现org-apache-catalina-LifecycleException-协议处理程序初始化失败"><a href="#启动Web项目时出现org-apache-catalina-LifecycleException-协议处理程序初始化失败" class="headerlink" title="启动Web项目时出现org.apache.catalina.LifecycleException: 协议处理程序初始化失败"></a>启动Web项目时出现<code>org.apache.catalina.LifecycleException: 协议处理程序初始化失败</code></h4><p>原因：8080端口被占用了</p>
<p>解决方案：cmd中<code>netstat -ano | findstr 8080</code>找到对应进程杀死</p>
<p>补充：</p>
<p><img src="https://pic.imgdb.cn/item/6262e777239250f7c5cb5445.jpg"></p>
<h4 id="使用SpringBoot时出现Failed-to-read-candidate-component-class"><a href="#使用SpringBoot时出现Failed-to-read-candidate-component-class" class="headerlink" title="使用SpringBoot时出现Failed to read candidate component class"></a>使用SpringBoot时出现<code>Failed to read candidate component class</code></h4><p>原因：SpringBoot版本比较低，但是编译器设置版本过高，降低编译环境版本（如降到8）</p>
<h4 id="本机ip记录"><a href="#本机ip记录" class="headerlink" title="本机ip记录"></a>本机ip记录</h4><p>192.168.1.210</p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven-基础</title>
    <url>/2022/03/31/mavenbasic/</url>
    <content><![CDATA[<p>概述：本文主要记录Maven工具的思想和基本用法。包括环境配置，基础概念，项目构建，依赖管理等部分</p>
<span id="more"></span>



<h2 id="Maven简介"><a href="#Maven简介" class="headerlink" title="Maven简介"></a>Maven简介</h2><h3 id="传统项目管理状态分析"><a href="#传统项目管理状态分析" class="headerlink" title="传统项目管理状态分析"></a>传统项目管理状态分析</h3><p>（1）jar包不统一，jar包不兼容</p>
<p>（2）工程升级维护过程繁琐</p>
<h3 id="Maven是什么"><a href="#Maven是什么" class="headerlink" title="Maven是什么"></a>Maven是什么</h3><p>本质是一个项目管理工具，将项目开发和管理过程抽象成一个项目对象模型（POM，Project Object Model）</p>
<h3 id="Maven的作用"><a href="#Maven的作用" class="headerlink" title="Maven的作用"></a>Maven的作用</h3><p>（1）项目构建：提供标准的、跨平台的自动化项目构建方式</p>
<p>（2）依赖管理：方便快捷的管理项目依赖的资源（jar包），避免资源间的版本冲突问题</p>
<p>（3）统一开发结构：提供标准的、统一的项目结构</p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h3><p><a href="https://maven.apache.org/"><em>官网</em></a></p>
<p>解压即安装</p>
<h3 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h3><p>（1）依赖Java，需要配置JAVA_HOME</p>
<p>（2）设置MAVEN自身的运行环境，需要配置MAVEN_HOME（复制所在路径，在系统变量和环境变量中都加以设置）</p>
<p>配置完成后可以在cmd中输入 mvn 检查是否成功</p>
<h2 id="MAVEN基础概念"><a href="#MAVEN基础概念" class="headerlink" title="MAVEN基础概念"></a>MAVEN基础概念</h2><h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><p>仓库用于存储资源，包含各种jar包</p>
<p>仓库分类：</p>
<ol>
<li><p>本地仓库：自己电脑上存储资源的仓库，连接远程仓库获取资源</p>
</li>
<li><p>远程仓库：非本机电脑上的仓库，为本地仓库提供资源</p>
<p>（1）中央仓库：Maven团队维护，存储所有字眼的仓库</p>
<p>（2）私服：部门&#x2F;公司范围内存储资源的仓库，从中央仓库获取资源</p>
</li>
<li><p>私服的作用：</p>
<p>（1）保存具有版权的资源，包含购买或自主研发的jar，中央仓库中的jar都是开源的，不能存储具有版权的资源</p>
<p>（2）一定范围内共享资源，仅对内部开放，不对外共享</p>
</li>
</ol>
<h3 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a>坐标</h3><p>坐标：</p>
<p>用于在Maven中描述仓库中资源的位置。  <a href="https://repo1.maven.org/maven2/">https://repo1.maven.org/maven2/</a></p>
<p>Maven坐标主要组成：</p>
<p>（1）groupID：定义当前Maven项目隶属组织名称</p>
<p>（2）artifactID：定义当前Maven项目名称（通常是模块名称）</p>
<p>（3）version：定义当前项目版本号</p>
<p>（4）packaging：定义该项目的打包方式</p>
<p>Maven坐标的作用：使用唯一标识，唯一性定位资源位置，通过该标识可以将资源的识别与下载工作交由机器完成</p>
<p><a href="https://www.mvnrepository.com/">https://www.mvnrepository.com</a></p>
<h3 id="本地仓库配置"><a href="#本地仓库配置" class="headerlink" title="本地仓库配置"></a>本地仓库配置</h3><p>本地仓库配置决定了资源下载到哪里</p>
<p>命令行中输入mvn 即可在 C:\Users\win10 中生成一个空的 .m2文件夹，为默认的仓库</p>
<p>如果想要将本地仓库设置在别的位置，需要如下配置：</p>
<p>（1）打开Maven目录下（我的电脑在 F:\Tools\apache-maven-3.8.5\conf）的settings.xml</p>
<p>（2）将文件中<code>&lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;</code>复制到下一行未被注释的地方，并将其中路径换成我们自己决定的repository文件夹的位置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>F:\MyDocuments\Maven\repository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="远程仓库的配置"><a href="#远程仓库的配置" class="headerlink" title="远程仓库的配置"></a>远程仓库的配置</h3><p>远程仓库决定了资源从哪里来</p>
<p>默认是从<a href="https://repo1.maven.org/maven2/">https://repo1.maven.org/maven2/</a> 中下载的（不挂梯子会比较慢）</p>
<p>镜像仓库配置（阿里云）</p>
<h3 id="全局setting与用户setting的区别"><a href="#全局setting与用户setting的区别" class="headerlink" title="全局setting与用户setting的区别"></a>全局setting与用户setting的区别</h3><p>全局setting定义了当前计算机中Maven的公共配置</p>
<p>用户setting定义了当前用户的配置</p>
<h2 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h2><h3 id="Maven项目构建命令（手动制作）"><a href="#Maven项目构建命令（手动制作）" class="headerlink" title="Maven项目构建命令（手动制作）"></a>Maven项目构建命令（手动制作）</h3><p>需要在项目目录带有pom.xml层级下进行执行</p>
<p>Maven构建命令使用mvn开头，后面添加功能参数，可以一次执行多个命令，使用空格分隔</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn compile			#编译</span><br><span class="line">mvn clean			#清理</span><br><span class="line">mvn test 			#测试</span><br><span class="line">mvn package			#打包</span><br><span class="line">mvn install			#安装到本地仓库</span><br></pre></td></tr></table></figure>

<h3 id="插件创建工程"><a href="#插件创建工程" class="headerlink" title="插件创建工程"></a>插件创建工程</h3><h3 id="IDEA创建工程"><a href="#IDEA创建工程" class="headerlink" title="IDEA创建工程"></a>IDEA创建工程</h3><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><h3 id="依赖配置"><a href="#依赖配置" class="headerlink" title="依赖配置"></a>依赖配置</h3><p>依赖指当前项目运行所需的jar，一个项目可以设置多个依赖</p>
<p>格式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--指定了当前pom的版本，4.0.0是固定的 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">&lt;!-- 主项目标识，用来定义当前maven属于哪个实际的项目 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>反写的公司网址 + 项目名<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 模块名，maven项目和实际的项目不是一一对应的关系，maven项目提现的是模块化的概念，一个实际项目往往会被划分为很多个模块 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>项目名 + 模块名<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 当前项目版本号，一般有三个数字组成 第一个数字：大版本号 第二个数字：分支版本号 第三个数字：先版本号 snapshot: 快照 alpha： </span></span><br><span class="line"><span class="comment">		内测版本 beta： 公测版本 Release： 稳定版本 GA： 正式发布版本 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1snapshot<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- maven项目打包方式，默认情况为jar，还可打包为war，zip，pom等 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">packaging</span>&gt;</span><span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 项目描述名 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span><span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 项目地址 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">url</span>&gt;</span><span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 项目描述 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">description</span>&gt;</span><span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 开发人员列表 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">developers</span>&gt;</span><span class="tag">&lt;/<span class="name">developers</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 许可证信息 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">licenses</span>&gt;</span><span class="tag">&lt;/<span class="name">licenses</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 组织信息 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">organization</span>&gt;</span><span class="tag">&lt;/<span class="name">organization</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">&lt;!-- 依赖列表 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 依赖项目 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">type</span>&gt;</span><span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 依赖范围，控制依赖与三种依赖范围的关系 --&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 开发中要使用某一个jar，就要将该jar包引入到项目的classpath中 --&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- maven提供了三种classpath： 1.编译 2.测试 3.运行 --&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 下面的test表明junit只存在于测试的classpath中 --&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- maven为scope提供了六个属性：</span></span><br><span class="line"><span class="comment">									compile（默认，编译测试运行都有效）， </span></span><br><span class="line"><span class="comment">									provided（编译和测试）servlet, </span></span><br><span class="line"><span class="comment">									runtime（测试和运行）jdbc, </span></span><br><span class="line"><span class="comment">									test（测试）junit, </span></span><br><span class="line"><span class="comment">									system（编译和测试，与本机系统相关联，可移植性差）, </span></span><br><span class="line"><span class="comment">									import（导入的范围，只使用在dependencyManagerment中，表示从其他的pom中导入dependency的配置） --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 设置依赖是否可选 --&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 有两个值，true和false，默认是false，继承，若为true，子项目必须显式的引用该依赖 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">optional</span>&gt;</span><span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 排除依赖传递的列表 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">&lt;!-- 依赖管理 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 这里定义的依赖不会被运行，即不会被引用为实际的依赖，主要是供子模块集成用 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">dependency</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">&lt;!-- 为构建行为提供相应的支持 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 插件列表 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 插件 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">&lt;!-- 用于子模块中对于父模块的继承 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">parent</span>&gt;</span><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 聚合运行多个maven项目 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">module</span>&gt;</span><span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="依赖传递"><a href="#依赖传递" class="headerlink" title="依赖传递"></a>依赖传递</h3><p>依赖具有传递性：</p>
<p>（1）直接依赖：在当前项目中通过依赖配置建立的依赖关系</p>
<p>（2）间接依赖：被资源的资源如果依赖其他资源，当前项目间接依赖其他资源</p>
<h3 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h3><p>依赖的jar默认情况可以在任何地方使用，可以通过scope标签设定其作用范围</p>
<p>作用范围：</p>
<p>（1）主程序范围有效（main文件夹范围内）</p>
<p>（2）测试程序范围有效（test文件夹范围内）</p>
<p>（3）是否参与打包（package指令范围内）</p>
<img src="https://pic.imgdb.cn/item/6245facd27f86abb2a6cf794.jpg" alt="image1" style="zoom:48%;" />



<h3 id="依赖范围传递性"><a href="#依赖范围传递性" class="headerlink" title="依赖范围传递性"></a>依赖范围传递性</h3><p>带有依赖范围的资源在进行传递时，作用范围将收到影响</p>
<img src="https://pic.imgdb.cn/item/6245fb6d27f86abb2a6d85b3.jpg" alt="image2" style="zoom:45%;" />



<h2 id="生命周期与插件"><a href="#生命周期与插件" class="headerlink" title="生命周期与插件"></a>生命周期与插件</h2><h3 id="项目构建生命周期"><a href="#项目构建生命周期" class="headerlink" title="项目构建生命周期"></a>项目构建生命周期</h3><p>Maven构建生命周期描述的是一次构建过程经历了多少个事件</p>
<p>Maven对项目构建的生命周期划分为三套：</p>
<p>（1）clean：清理工作</p>
<p>（2）default：核心工作，例如编译，测试，打包，部署等</p>
<p>（3）site：产生报告，发布站点等</p>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p><a href="https://maven.apache.org/plugins/index.html"><em>maven官网提供的插件</em></a></p>
<p>插件与生命周期内的阶段绑定，在执行到对应生命周期时执行对应的插件功能</p>
<p>默认maven在各个生命周期上绑定有预设的功能</p>
<p>通过插件可以自定义其他功能</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java与C++的差异</title>
    <url>/2022/03/31/java-basic/</url>
    <content><![CDATA[<p>概述：本文主要记录Java中与C++有明显差异的语言特性</p>
<span id="more"></span>

<h2 id="与C-的差异"><a href="#与C-的差异" class="headerlink" title="与C++的差异"></a>与C++的差异</h2><p>（1）C++ 支持指针，而 Java 没有指针的概念。</p>
<p>（2）C++ 支持多继承，而 Java 不支持多重继承，但允许一个类实现多个接口。</p>
<p>（3）Java 是完全面向对象的语言，并且还取消了 C&#x2F;C++ 中的结构和联合，使编译程序更加简洁</p>
<p>（4）Java 自动进行无用内存回收操作，不再需要程序员进行手动删除，而 C++ 中必须由程序释放内存资源，这就增加了程序员的负担。</p>
<p>（5）Java 不支持操作符重载，而操作符重载则被认为是 C++ 的突出特征。</p>
<p>（6）Java 允许预处理，但不支持预处理器功能，所以为了实现预处理，它提供了引入语句（import），但它与 C++ 预处理器的功能类似。</p>
<p>（7）Java 不支持缺省参数函数，而 C++ 支持 。</p>
<p>（8）C 和 C++ 不支持字符串变量，在 C 和 C++ 程序中使用“Null”终止符代表字符串的结束。在 Java 中字符串是用类对象（String 和 StringBuffer）来实现的</p>
<p>（9）Java 不提供 goto 语句，虽然 Java 指定 goto 作为关键字，但不支持它的使用，这使程序更简洁易读。不过Java中的break&#x2F;continue可以带标签（标签必须放在希望跳出的最外层循环之前，并且必须紧跟一个冒号），用于从内层循环中跳出</p>
<p>（10）Java 不支持 C++ 中的自动强制类型转换，如果需要，必须由程序显式进行强制类型转换。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Good questions —— 数组篇</title>
    <url>/2022/03/31/questions/</url>
    <content><![CDATA[<p>概述：本文记录了我在<a href="https://leetcode-cn.com/"><em>Leetcode</em></a>刷题过程中遇到的与数组相关的优质题目及解题思路</p>
<span id="more"></span>

<h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><p>给定一个不含重复数字的数组 nums ，返回其 <a href="https://leetcode-cn.com/problems/permutations/"><em>所有可能的全排列</em></a> 。可以 <strong>按任意顺序</strong> 返回答案。 </p>
<p>思路：</p>
<p>使用<strong>dfs+回溯</strong>。比较经典的回溯题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dfs(回溯)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vis</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">dfs</span>(nums,vis);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,vector&lt;<span class="type">int</span>&gt;&amp; vis)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>()==nums.<span class="built_in">size</span>())</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i!=nums.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                vis[i]=<span class="number">1</span>;</span><br><span class="line">                path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                <span class="built_in">dfs</span>(nums,vis);</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">                vis[i]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>非递归版本：</p>
<p>思路：</p>
<p>（1）通过实现<a href="https://leetcode-cn.com/problems/next-permutation/">下一个排列</a>函数来实现找到全部排列</p>
<p>（2）下一个排列：<strong>从后往前</strong>搜索数组，找到第一个逆序对。如&lt;3,4,7,6,5&gt;中4是第一个出现逆序的。将4置换为&lt;7,6,5&gt;中比4大且最小的那个数（即5），数组变为&lt;3,5,7,6,4&gt;。再将&lt;7,6,4&gt;部分升序排列（实际上反转就是排序）即可，变为&lt;3,5,4,6,7&gt;即为下一个排列</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=nums.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;=nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(i<span class="number">-1</span>==<span class="number">0</span>)      <span class="comment">//已经为最大的排列（全降序），那么下一个即为最小的排列（全升序）</span></span><br><span class="line">                    <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到第一个逆序发生的索引i-1</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=nums.<span class="built_in">size</span>()<span class="number">-1</span>;j&gt;i<span class="number">-1</span>;--j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[j]&gt;nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                        <span class="built_in">swap</span>(nums[j],nums[i<span class="number">-1</span>]);</span><br><span class="line">                        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>()+i,nums.<span class="built_in">end</span>());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>给定一个可包含重复数字的数组 nums ，返回其 <em>所有可能的</em><a href="https://leetcode-cn.com/problems/permutations-ii/"><em>全排列</em></a> 。你可以 <strong>按任意顺序</strong> 返回答案。 </p>
<p>思路：</p>
<p>（1）相较于上一题，这题需要多考虑去重的问题，即在同一层中，如果可选择的范围（未被访问过的范围）包含重复的数字，那么只能选择第一个，跳过重复的部分。</p>
<p>（2）另外要预先对nums进行排序，保证重复的数字都是相邻的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());<span class="comment">//为了使重复的数都相邻</span></span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vis</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">dfs</span>(nums,vis);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,vector&lt;<span class="type">int</span>&gt;&amp; vis)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>()==nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i!=nums.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="comment">//要保证在同一层中使用的是不同的数</span></span><br><span class="line">            <span class="comment">//对于有重复的数，要找到第一个未被使用过的</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i]==nums[i<span class="number">-1</span>] &amp;&amp; vis[i<span class="number">-1</span>]==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(vis[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                vis[i]=<span class="number">1</span>;</span><br><span class="line">                path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                <span class="built_in">dfs</span>(nums,vis);</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">                vis[i]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="最长递增子序列问题"><a href="#最长递增子序列问题" class="headerlink" title="最长递增子序列问题"></a>最长递增子序列问题</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">最长递增子序列</a>LIS问题及 <a href="https://leetcode-cn.com/problems/minimum-operations-to-make-the-array-k-increasing/submissions/">变体</a></p>
<p>给定一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p>
<p>子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p>
<p>（1）动态规划方法，时间复杂度O(n^2)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动态规划：dp[i]=max(dp[i],dp[j]+1)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(),<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i!=nums.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j!=i;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]&lt;nums[i])</span><br><span class="line">                dp[i]=<span class="built_in">max</span>(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">max_element</span>(dp.<span class="built_in">begin</span>(),dp.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>（2）维护一个记录长度为i时递增子序列末尾元素的最小值，时间复杂度O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//维护一个数组 temp[i]，表示长度为 i 的最长上升子序列的末尾元素的最小值，temp[0] = nums[0]</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">        temp.<span class="built_in">emplace_back</span>(nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i!=nums.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;temp.<span class="built_in">back</span>())</span><br><span class="line">            temp.<span class="built_in">emplace_back</span>(nums[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//注意这里要使用lower_bound</span></span><br><span class="line">                <span class="keyword">auto</span> it=<span class="built_in">lower_bound</span>(temp.<span class="built_in">begin</span>(),temp.<span class="built_in">end</span>(),nums[i]);</span><br><span class="line">                <span class="comment">//if(it==temp.end())</span></span><br><span class="line">                <span class="comment">//continue;</span></span><br><span class="line">                temp[it-temp.<span class="built_in">begin</span>()]=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="原地哈希"><a href="#原地哈希" class="headerlink" title="原地哈希"></a>原地哈希</h2><p>（1）要求在数组中<a href="https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/">找出所有出现两次的整数</a>，时间复杂度O(n)，空间复杂度O(1)</p>
<p>思想：原地哈希</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//思想，将nums[nums[i]-1]位置的数值加上n（由于是出现两次，直接取反也行）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i!=n;++i)&#123;</span><br><span class="line">            nums[(nums[i]<span class="number">-1</span>)%n]+=n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i!=n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>((nums[i]<span class="number">-1</span>)/n==<span class="number">2</span>)</span><br><span class="line">                res.<span class="built_in">push_back</span>(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>（2）要求在长度为n的数组中[找到没有出现在[1,n]<a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/"><em>范围内的数字</em></a></p>
<p>思想：将nums中出现过的数字作为索引，将对应位置取反</p>
<h2 id="打印螺旋矩阵"><a href="#打印螺旋矩阵" class="headerlink" title="打印螺旋矩阵"></a>打印螺旋矩阵</h2><p>题目来源：<a href="https://leetcode-cn.com/problems/spiral-matrix/">打印螺旋矩阵</a>：</p>
<p>思路：</p>
<p>（1）想到按层来遍历可以省去空间复杂度</p>
<p>（2）定义四个变量（left，right，top，bottom）来控制每一层的边界</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Good questions —— 二叉树篇</title>
    <url>/2022/03/31/questions02/</url>
    <content><![CDATA[<p>概述：本文记录了刷题过程中与二叉树相关的优质题目及解题思路</p>
<span id="more"></span>

<h2 id="二叉树的前中后序遍历"><a href="#二叉树的前中后序遍历" class="headerlink" title="二叉树的前中后序遍历"></a>二叉树的前中后序遍历</h2><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><p>（1）递归实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        <span class="built_in">dfs</span>(node-&gt;left);</span><br><span class="line">        <span class="built_in">dfs</span>(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>（2）迭代实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//迭代</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        stk.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            TreeNode* temp=stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();       <span class="comment">//必须先pop出来</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(temp-&gt;val);<span class="comment">//根节点先push到结果数组中</span></span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;right) stk.<span class="built_in">push</span>(temp-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;left)  stk.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>（3）风格统一的迭代写法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//迭代2 用这种写法与中序风格统一</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        TreeNode* cur= root;</span><br><span class="line">        <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>() || cur!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="comment">//前序遍历在节点入栈时即可直接将val放到res中</span></span><br><span class="line">            <span class="keyword">if</span>(cur!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                stk.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur=cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//当访问到最底层时</span></span><br><span class="line">                <span class="comment">//关键步骤，理解cur的改变</span></span><br><span class="line">                cur=stk.<span class="built_in">top</span>()-&gt;right;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>（1）递归实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>（2）迭代实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        TreeNode* cur=root;</span><br><span class="line">        <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>()||cur!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="comment">// 指针来访问节点，访问到最底层</span></span><br><span class="line">            <span class="keyword">if</span>(cur!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="comment">// 将访问的节点放进栈</span></span><br><span class="line">                stk.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur=cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）</span></span><br><span class="line">                res.<span class="built_in">push_back</span>(stk.<span class="built_in">top</span>()-&gt;val);<span class="comment">//中</span></span><br><span class="line">                cur=stk.<span class="built_in">top</span>()-&gt;right;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>（1）递归实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.确定终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">//前中后序遍历只需要改换这三条的顺序</span></span><br><span class="line">        <span class="built_in">postorderTraversal</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">postorderTraversal</span>(root-&gt;right);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>（2）迭代实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//迭代2 可与前中后序相应写法风格相统一，思想是中右左顺序遍历，最后reverse</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        TreeNode* cur= root;</span><br><span class="line">        <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>() || cur!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                stk.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur=cur-&gt;right;  <span class="comment">//注意这里是right,前序是left</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//当访问到最底层时&#123;</span></span><br><span class="line">                <span class="comment">//关键步骤，理解cur的改变</span></span><br><span class="line">                cur=stk.<span class="built_in">top</span>()-&gt;left; <span class="comment">//这里是left，前序是right</span></span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h2><h3 id="从前序和中序遍历序列构造二叉树"><a href="#从前序和中序遍历序列构造二叉树" class="headerlink" title="从前序和中序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">从前序和中序遍历序列构造二叉树</a></h3><p>思路：</p>
<p>（1）明白前序遍历的第一个节点永远是根节点</p>
<p>（2）用哈希表记录中序遍历中每个节点值对应的索引位置</p>
<p>（3）结合（1）（2）可知根节点在中序遍历中的位置，从而可以知道<strong>左子树和右子树的大小</strong></p>
<p>（4）递归地进行左右子树的构建，<strong>函数返回根节点</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;      <span class="comment">//&#123;value, index in inorder array&#125;</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = preorder.<span class="built_in">size</span>();    <span class="comment">//两个数组长度相等</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i!=inorder.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            mp[inorder[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root = <span class="built_in">rebuild</span>(preorder,inorder,<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">rebuild</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; pv,vector&lt;<span class="type">int</span>&gt;&amp; iv,<span class="type">int</span> pl,<span class="type">int</span> pr, <span class="type">int</span> il, <span class="type">int</span> ir)</span></span>&#123;</span><br><span class="line">        <span class="comment">//注意不要落下递归的终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(pr&lt;pl) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//前序遍历的第一个节点即为根节点</span></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(pv[pl]);</span><br><span class="line">        <span class="comment">//在中序遍历中找到对应根节点，即可知道左子树和右子树的大小</span></span><br><span class="line">        <span class="type">int</span> leftsize = mp[pv[pl]] - il;</span><br><span class="line">        root-&gt;left = <span class="built_in">rebuild</span>(pv,iv,pl+<span class="number">1</span>,pl+leftsize,il,il+leftsize<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">rebuild</span>(pv,iv,pl+leftsize+<span class="number">1</span>,pr,il+leftsize+<span class="number">1</span>,ir);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="从中序遍历和后序遍历序列构造二叉树"><a href="#从中序遍历和后序遍历序列构造二叉树" class="headerlink" title="从中序遍历和后序遍历序列构造二叉树"></a>从中序遍历和后序遍历序列构造二叉树</h3><p>思路近似，都是要计算出左右子树的大小，然后进行递归</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;      <span class="comment">//&#123;value, index in inorder array&#125;</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = inorder.<span class="built_in">size</span>();    <span class="comment">//两个数组长度相等</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i!=inorder.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            mp[inorder[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root = <span class="built_in">rebuild</span>(inorder,postorder,<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">rebuild</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; iv,vector&lt;<span class="type">int</span>&gt;&amp; pv,<span class="type">int</span> il,<span class="type">int</span> ir, <span class="type">int</span> pl, <span class="type">int</span> pr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//注意不要落下递归的终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(ir&lt;il) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//后序遍历的最后一个节点即为根节点</span></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(pv[pr]);</span><br><span class="line">        <span class="comment">//在中序遍历中找到对应根节点，即可知道左子树和右子树的大小</span></span><br><span class="line">        <span class="type">int</span> leftsize = mp[pv[pr]] - il;</span><br><span class="line">        root-&gt;left = <span class="built_in">rebuild</span>(iv,pv,il,il+leftsize<span class="number">-1</span>,pl,pl+leftsize<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">rebuild</span>(iv,pv,il+leftsize+<span class="number">1</span>,ir,pl+leftsize,pr<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二叉搜索树中第k小的元素"><a href="#二叉搜索树中第k小的元素" class="headerlink" title="二叉搜索树中第k小的元素"></a>二叉搜索树中第k小的元素</h2><p>给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查<a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/">找其中第 k 个最小元素（从 1 开始计数）</a>。</p>
<p>思路：</p>
<p>（1）要反应过来二叉搜索树的中序遍历即为一个升序数组</p>
<p>（2）取升序数组中的第k个就行</p>
<p>如果要搜索第k大的元素，其实只要调整一下遍历的顺序，先遍历右子树，再遍历左子树即可</p>
<h2 id="二叉树中节点和最大的路径"><a href="#二叉树中节点和最大的路径" class="headerlink" title="二叉树中节点和最大的路径"></a>二叉树中节点和最大的路径</h2><ol>
<li>求二叉树中<a href="https://leetcode-cn.com/problems/jC7MId/"><em>节点之和最大的路径</em></a>，必须至少包含一个节点</li>
</ol>
<p>思路：</p>
<p>（1）关键就是想清楚递归的返回值：应该返回包含当前节点在内的并且最多只包含左右子树其中之一边的最大路径。</p>
<p>（2）在递归的过程中不断更新一个最大路径和，包含当前节点并且可以同时包含左右子树的节点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> maxsum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> lval = <span class="built_in">max</span>(<span class="number">0</span>,<span class="built_in">dfs</span>(root-&gt;left));<span class="comment">//包含根节点root的单条路径的最大值</span></span><br><span class="line">        <span class="type">int</span> rval = <span class="built_in">max</span>(<span class="number">0</span>,<span class="built_in">dfs</span>(root-&gt;right));</span><br><span class="line">        maxsum = <span class="built_in">max</span>(maxsum,root-&gt;val+lval+rval);</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val + <span class="built_in">max</span>(lval,rval);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> maxsum = INT_MIN;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Good questions —— 链表篇</title>
    <url>/2022/03/31/questions03/</url>
    <content><![CDATA[<p>概述：本文记录了刷题过程中与链表相关的优质题目及解题思路</p>
<span id="more"></span>

<h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">反转链表</a></h2><p>（需要完全掌握递归和非递归写法）</p>
<p>（1）迭代</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">迭代方法</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* pre=<span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur=head;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ListNode* temp = cur-&gt;next;  <span class="comment">//暂存后继节点</span></span><br><span class="line">            cur-&gt;next=pre;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;<span class="comment">//注意返回的是pre而不是cur，cur在出循环后是nullptr</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>（2）递归</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">recur</span>(head, <span class="literal">nullptr</span>);           <span class="comment">// 调用递归并返回</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">recur</span><span class="params">(ListNode* cur, ListNode* pre)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) <span class="keyword">return</span> pre;        <span class="comment">// 终止条件</span></span><br><span class="line">        ListNode* res = <span class="built_in">recur</span>(cur-&gt;next, cur); <span class="comment">// 递归后继节点</span></span><br><span class="line">        cur-&gt;next = pre;                       <span class="comment">// 修改节点引用指向</span></span><br><span class="line">        <span class="keyword">return</span> res;                            <span class="comment">// 返回反转链表的头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/">复杂链表的复制</a></h2><p>思路：</p>
<p>（1）哈希表存储所有原节点到新复制的节点的映射</p>
<p>（2）原地复制（在链表每个节点后复制一个新节点），再处理所有的next和random指针，最后断开原链表与新链表之间的连接</p>
<h2 id="重排链表"><a href="#重排链表" class="headerlink" title="重排链表"></a><a href="https://leetcode-cn.com/problems/LGjMqU/">重排链表</a></h2><p>时间O(n), 空间O(1)思想：</p>
<p>（1）找到链表中间节点，并断开</p>
<p>（2）反转后半部分的链表</p>
<p>（3）合并两个链表</p>
<h2 id="k个一组反转链表"><a href="#k个一组反转链表" class="headerlink" title="k个一组反转链表"></a><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/submissions/">k个一组反转链表</a></h2><p>思想：</p>
<p>（1）设计一个反转[head,tail]区间的节点的函数，并<strong>返回反转后的头和尾</strong></p>
<p>（2）注意<strong>保存头结点的前一节点</strong>，用于连接局部反转后的链表</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
